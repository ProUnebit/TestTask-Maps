// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

// eslint-disable-next-line no-global-assign
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  return newRequire;
})({"C:\\Users\\Алексей\\AppData\\Roaming\\npm\\node_modules\\parcel-bundler\\node_modules\\process\\browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};
},{}],"node_modules\\2gis-maps\\dist\\js\\script.full.js":[function(require,module,exports) {
var define;
var global = arguments[3];
var process = require("process");
(function (f) {
    if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f();
    } else if (typeof define === "function" && define.amd) {
        define([], f);
    } else {
        var g;if (typeof window !== "undefined") {
            g = window;
        } else if (typeof global !== "undefined") {
            g = global;
        } else if (typeof self !== "undefined") {
            g = self;
        } else {
            g = this;
        }g.DG = f();
    }
})(function () {
    var define, module, exports;return function () {
        function r(e, n, t) {
            function o(i, f) {
                if (!n[i]) {
                    if (!e[i]) {
                        var c = "function" == typeof require && require;if (!f && c) return c(i, !0);if (u) return u(i, !0);var a = new Error("Cannot find module '" + i + "'");throw a.code = "MODULE_NOT_FOUND", a;
                    }var p = n[i] = { exports: {} };e[i][0].call(p.exports, function (r) {
                        var n = e[i][1][r];return o(n || r);
                    }, p, p.exports, r, e, n, t);
                }return n[i].exports;
            }for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);return o;
        }return r;
    }()({ 1: [function (_dereq_, module, exports) {
            var css = ".leaflet-image-layer,.leaflet-layer,.leaflet-map-pane canvas,.leaflet-map-pane svg,.leaflet-marker-icon,.leaflet-marker-shadow,.leaflet-pane,.leaflet-tile,.leaflet-tile-container,.leaflet-zoom-box{position:absolute;left:0;top:0}.leaflet-container{overflow:hidden}.leaflet-marker-icon,.leaflet-marker-shadow,.leaflet-tile{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none}.leaflet-safari .leaflet-tile{image-rendering:-webkit-optimize-contrast}.leaflet-safari .leaflet-tile-container{width:1600px;height:1600px;-webkit-transform-origin:0 0}.leaflet-marker-icon,.leaflet-marker-shadow{display:block}.leaflet-container .leaflet-marker-pane img,.leaflet-container .leaflet-overlay-pane svg,.leaflet-container .leaflet-tile-pane img,.leaflet-container img.leaflet-image-layer{max-width:none!important}.leaflet-container.leaflet-touch-zoom{-ms-touch-action:pan-x pan-y;touch-action:pan-x pan-y}.leaflet-container.leaflet-touch-drag{-ms-touch-action:pinch-zoom}.leaflet-container.leaflet-touch-drag.leaflet-touch-drag{-ms-touch-action:none;touch-action:none}.leaflet-tile{-webkit-filter:inherit;filter:inherit;visibility:hidden}.leaflet-tile-loaded{visibility:inherit}.leaflet-zoom-box{width:0;height:0;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:800}.leaflet-overlay-pane svg{-moz-user-select:none}.leaflet-pane{z-index:400}.leaflet-tile-pane{z-index:200}.leaflet-overlay-pane{z-index:400}.leaflet-shadow-pane{z-index:500}.leaflet-marker-pane{z-index:600}.leaflet-tooltip-pane{z-index:650}.leaflet-popup-pane{z-index:700}.leaflet-map-pane canvas{z-index:100}.leaflet-map-pane svg{z-index:200}.leaflet-vml-shape{width:1px;height:1px}.lvml{behavior:url(#default#VML);display:inline-block;position:absolute}.leaflet-control{position:relative;z-index:800;pointer-events:visiblePainted;pointer-events:auto}.leaflet-bottom,.leaflet-top{position:absolute;z-index:1000;pointer-events:none}.leaflet-top{top:0}.leaflet-right{right:0}.leaflet-bottom{bottom:0}.leaflet-left{left:0}.leaflet-control{float:left;clear:both}.leaflet-right .leaflet-control{float:right}.leaflet-top .leaflet-control{margin-top:10px}.leaflet-bottom .leaflet-control{margin-bottom:10px}.leaflet-left .leaflet-control{margin-left:10px}.leaflet-right .leaflet-control{margin-right:10px}.leaflet-fade-anim .leaflet-tile{will-change:opacity}.leaflet-fade-anim .leaflet-popup{opacity:0;-webkit-transition:opacity .2s linear;transition:opacity .2s linear}.leaflet-fade-anim .leaflet-map-pane .leaflet-popup{opacity:1}.leaflet-zoom-animated{-webkit-transform-origin:0 0;-ms-transform-origin:0 0;transform-origin:0 0}.leaflet-zoom-anim .leaflet-zoom-animated{will-change:transform;-webkit-transition:-webkit-transform .25s cubic-bezier(0,0,.25,1);transition:-webkit-transform .25s cubic-bezier(0,0,.25,1);transition:transform .25s cubic-bezier(0,0,.25,1);transition:transform .25s cubic-bezier(0,0,.25,1),-webkit-transform .25s cubic-bezier(0,0,.25,1)}.leaflet-pan-anim .leaflet-tile,.leaflet-zoom-anim .leaflet-tile{-webkit-transition:none;transition:none}.leaflet-zoom-anim .leaflet-zoom-hide{visibility:hidden}.leaflet-interactive{cursor:pointer}.leaflet-grab{cursor:-webkit-grab;cursor:-moz-grab}.leaflet-crosshair,.leaflet-crosshair .leaflet-interactive{cursor:crosshair}.leaflet-control,.leaflet-popup-pane{cursor:auto}.leaflet-dragging .leaflet-grab,.leaflet-dragging .leaflet-grab .leaflet-interactive,.leaflet-dragging .leaflet-marker-draggable{cursor:move;cursor:-webkit-grabbing;cursor:-moz-grabbing}.leaflet-image-layer,.leaflet-marker-icon,.leaflet-marker-shadow,.leaflet-pane>svg path,.leaflet-tile-container{pointer-events:none}.leaflet-image-layer.leaflet-interactive,.leaflet-marker-icon.leaflet-interactive,.leaflet-pane>svg path.leaflet-interactive{pointer-events:visiblePainted;pointer-events:auto}.leaflet-container{outline:0}.leaflet-container a{color:#0078A8}.leaflet-container a.leaflet-active{outline:orange solid 2px}.leaflet-zoom-box{border:2px dotted #38f;background:rgba(255,255,255,.5)}.leaflet-container{font:12px/1.5 \"Helvetica Neue\",Arial,Helvetica,sans-serif}.leaflet-bar{-webkit-box-shadow:0 1px 5px rgba(0,0,0,.65);box-shadow:0 1px 5px rgba(0,0,0,.65);border-radius:4px}.leaflet-bar a,.leaflet-bar a:hover{background-color:#fff;border-bottom:1px solid #ccc;width:26px;height:26px;line-height:26px;display:block;text-align:center;text-decoration:none;color:#000}.leaflet-bar a,.leaflet-control-layers-toggle{background-position:50% 50%;background-repeat:no-repeat;display:block}.leaflet-bar a:hover{background-color:#f4f4f4}.leaflet-bar a:first-child{border-top-left-radius:4px;border-top-right-radius:4px}.leaflet-bar a:last-child{border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-bottom:none}.leaflet-bar a.leaflet-disabled{cursor:default;background-color:#f4f4f4;color:#bbb}.leaflet-touch .leaflet-bar a{width:30px;height:30px;line-height:30px}.leaflet-control-zoom-in,.leaflet-control-zoom-out{font:700 18px 'Lucida Console',Monaco,monospace;text-indent:1px}.leaflet-control-zoom-out{font-size:20px}.leaflet-touch .leaflet-control-zoom-in{font-size:22px}.leaflet-touch .leaflet-control-zoom-out{font-size:24px}.leaflet-control-layers{-webkit-box-shadow:0 1px 5px rgba(0,0,0,.4);box-shadow:0 1px 5px rgba(0,0,0,.4);background:#fff;border-radius:5px}.leaflet-control-layers-toggle{background-image:url(dist/css/images/layers.png);width:36px;height:36px}.leaflet-retina .leaflet-control-layers-toggle{background-image:url(dist/css/images/layers-2x.png);background-size:26px 26px}.leaflet-touch .leaflet-control-layers-toggle{width:44px;height:44px}.leaflet-control-layers .leaflet-control-layers-list,.leaflet-control-layers-expanded .leaflet-control-layers-toggle{display:none}.leaflet-control-layers-expanded .leaflet-control-layers-list{display:block;position:relative}.leaflet-control-layers-expanded{padding:6px 10px 6px 6px;color:#333;background:#fff}.leaflet-control-layers-scrollbar{overflow-y:scroll;padding-right:5px}.leaflet-control-layers-selector{margin-top:2px;position:relative;top:1px}.leaflet-control-layers label{display:block}.leaflet-control-layers-separator{height:0;border-top:1px solid #ddd;margin:5px -10px 5px -6px}.leaflet-default-icon-path{background-image:url(dist/css/images/marker-icon.png)}.leaflet-container .leaflet-control-attribution{background:#fff;background:rgba(255,255,255,.7);margin:0}.leaflet-control-attribution,.leaflet-control-scale-line{padding:0 5px;color:#333}.leaflet-control-attribution a{text-decoration:none}.leaflet-control-attribution a:hover{text-decoration:underline}.leaflet-container .leaflet-control-attribution,.leaflet-container .leaflet-control-scale{font-size:11px}.leaflet-left .leaflet-control-scale{margin-left:5px}.leaflet-bottom .leaflet-control-scale{margin-bottom:5px}.leaflet-control-scale-line{border:2px solid #777;border-top:none;line-height:1.1;padding:2px 5px 1px;font-size:11px;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;background:#fff;background:rgba(255,255,255,.5)}.leaflet-control-scale-line:not(:first-child){border-top:2px solid #777;border-bottom:none;margin-top:-2px}.leaflet-control-scale-line:not(:first-child):not(:last-child){border-bottom:2px solid #777}.leaflet-touch .leaflet-bar,.leaflet-touch .leaflet-control-attribution,.leaflet-touch .leaflet-control-layers{-webkit-box-shadow:none;box-shadow:none}.leaflet-touch .leaflet-bar,.leaflet-touch .leaflet-control-layers{border:2px solid rgba(0,0,0,.2);background-clip:padding-box}.leaflet-popup{position:absolute;text-align:center}.leaflet-popup-content-wrapper{text-align:left}.leaflet-popup-tip-container{width:40px;position:absolute;left:50%;margin-left:-20px;overflow:hidden;pointer-events:none}.leaflet-popup-tip{width:17px;height:17px;padding:1px;margin:-10px auto 0;-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);transform:rotate(45deg)}.leaflet-popup-content-wrapper,.leaflet-popup-tip{background:#fff;color:#333;-webkit-box-shadow:0 3px 14px rgba(0,0,0,.4);box-shadow:0 3px 14px rgba(0,0,0,.4)}.leaflet-container a.leaflet-popup-close-button{border:none;font:16px/14px Tahoma,Verdana,sans-serif;color:#c3c3c3;text-decoration:none;background:0 0}.leaflet-container a.leaflet-popup-close-button:hover{color:#999}.leaflet-oldie .leaflet-popup-content-wrapper{zoom:1}.leaflet-oldie .leaflet-popup-tip{width:24px;margin:0 auto;-ms-filter:\"progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)\";filter:progid:DXImageTransform.Microsoft.Matrix(M11=.70710678, M12=.70710678, M21=-.70710678, M22=.70710678)}.leaflet-oldie .leaflet-popup-tip-container{margin-top:-1px}.leaflet-oldie .leaflet-control-layers,.leaflet-oldie .leaflet-control-zoom,.leaflet-oldie .leaflet-popup-content-wrapper,.leaflet-oldie .leaflet-popup-tip{border:1px solid #999}.leaflet-div-icon{background:#fff;border:1px solid #666}.leaflet-tooltip{position:absolute;padding:6px;background-color:#fff;border:1px solid #fff;border-radius:3px;color:#222;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none;-webkit-box-shadow:0 1px 3px rgba(0,0,0,.4);box-shadow:0 1px 3px rgba(0,0,0,.4)}.leaflet-tooltip.leaflet-clickable{cursor:pointer;pointer-events:auto}.leaflet-tooltip-bottom:before,.leaflet-tooltip-left:before,.leaflet-tooltip-right:before,.leaflet-tooltip-top:before{position:absolute;pointer-events:none;border:6px solid transparent;background:0 0;content:\"\"}.leaflet-tooltip-bottom{margin-top:6px}.leaflet-tooltip-top{margin-top:-6px}.leaflet-tooltip-bottom:before,.leaflet-tooltip-top:before{left:50%;margin-left:-6px}.leaflet-tooltip-top:before{bottom:0;margin-bottom:-12px;border-top-color:#fff}.leaflet-tooltip-bottom:before{top:0;margin-top:-12px;margin-left:-6px;border-bottom-color:#fff}.leaflet-tooltip-left{margin-left:-6px}.leaflet-tooltip-right{margin-left:6px}.leaflet-tooltip-left:before,.leaflet-tooltip-right:before{top:50%;margin-top:-6px}.leaflet-tooltip-left:before{right:0;margin-right:-12px;border-left-color:#fff}.leaflet-tooltip-right:before{left:0;margin-left:-12px;border-right-color:#fff}[class^=dg-],[class^=dg-]:after,[class^=dg-]:before{-webkit-box-sizing:content-box;box-sizing:content-box;margin:0;padding:0;vertical-align:baseline;font-weight:inherit;font-style:inherit;font-size:1em;font-family:inherit;line-height:1.2}[class^=dg-]>[class^=dg-]:last-child{margin-bottom:0}[class^=dg-] abbr,[class^=dg-] fieldset,[class^=dg-] img{border:0}[class^=dg-] blockquote,[class^=dg-] q{quotes:none}[class^=dg-] blockquote:after,[class^=dg-] blockquote:before,[class^=dg-] q:after,[class^=dg-] q:before{content:'';content:none}[class^=dg-] ol,[class^=dg-] ul{list-style:none}[class^=dg-] table{border-spacing:0;border-collapse:collapse}[class^=dg-] caption,[class^=dg-] th{text-align:left}[class^=dg-] td,[class^=dg-] th{vertical-align:middle}[class^=dg-] button::-moz-focus-inner,[class^=dg-] input::-moz-focus-inner{padding:0;border:0}.dg-label{position:absolute;top:0;left:0;max-width:none;max-height:none;width:300px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.dg-label__content{display:inline-block;overflow:hidden;padding:3px 7px;min-width:30px;max-width:300px;width:auto;border-width:1px;border-style:solid;border-radius:2px;vertical-align:top;font-size:12px}.leaflet-top .dg-label_name_location-error{top:5px}.leaflet-right .dg-label_name_location-error{right:40px;left:auto;text-align:right}.leaflet-bottom .dg-label_name_location-error{top:4px}.leaflet-left .dg-label_name_location-error{left:40px}.dg-label__content{border-color:#323232;border-color:rgba(50,50,50,.85);background:#323232;background:rgba(50,50,50,.85);color:#ffd26e}.leaflet-popup{margin-bottom:0}.leaflet-popup-tip-container{height:0}.leaflet-popup-content-wrapper{overflow:hidden;padding:0;min-width:60px;min-height:50px;border:0;border-radius:3px;background:0 0;-webkit-box-shadow:none;box-shadow:none;color:#e6e6e6;font-size:14px;-webkit-transition:opacity ease-out .2s,max-height ease-out .2s,height ease-out .2s;transition:opacity ease-out .2s,max-height ease-out .2s,height ease-out .2s;-webkit-transform-origin:50% 100%;-ms-transform-origin:50% 100%;transform-origin:50% 100%}.leaflet-popup-content-wrapper:before{float:right;width:30px;height:17px;content:''}.leaflet-popup-content{position:relative;margin:16px;width:auto;line-height:1.4}.leaflet-popup a{outline:0}.leaflet-popup-content p{margin:0}.leaflet-popup-scrolled{overflow:visible;border:0}.leaflet-popup-inner{position:relative;z-index:0}.leaflet-popup_show_true{-webkit-transition:opacity ease-in-out .2s,height ease-out .2s,-webkit-transform ease-in-out .2s;transition:opacity ease-in-out .2s,height ease-out .2s,-webkit-transform ease-in-out .2s;transition:transform ease-in-out .2s,opacity ease-in-out .2s,height ease-out .2s;transition:transform ease-in-out .2s,opacity ease-in-out .2s,height ease-out .2s,-webkit-transform ease-in-out .2s;-webkit-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}.leaflet-popup_show_false{opacity:0!important;-webkit-transition:all ease-in-out .1s;transition:all ease-in-out .1s;-webkit-transform:scale(0.2);-ms-transform:scale(0.2);transform:scale(0.2)}.leaflet-popup_preloader_true{width:384px;height:52px}.leaflet-map-pane .leaflet-popup-tip-container{position:absolute;top:auto;bottom:0;left:50%;margin-left:-29px;width:58px;height:47px;background-repeat:no-repeat;-webkit-transform:translateY(47px);-ms-transform:translateY(47px);transform:translateY(47px);pointer-events:none}.leaflet-popup-tip{display:none}.leaflet-popup-tip-container_svg{background-repeat:no-repeat;background-image:url(https://maps.api.2gis.ru/2.0/img/DGPopup__popupShadow.png);background-position:50% 95%;background-size:36px 12px}.leaflet-retina .leaflet-popup-tip-container_svg{background-image:url(https://maps.api.2gis.ru/2.0/img/DGPopup__popupShadow@2x.png)}.leaflet-container a.leaflet-popup-close-button{position:absolute;top:3px;right:3px;z-index:1;overflow:hidden;padding:0;width:30px;height:30px;text-align:center;font-weight:400;font-size:18px;line-height:30px;cursor:pointer}.no-touch .leaflet-container a.leaflet-popup-close-button:hover{border-radius:2px;-webkit-transition:all .2s;transition:all .2s}.leaflet-container a.leaflet-popup-close-button:active{color:#777}.leaflet-container a.leaflet-popup-close-button:after{position:absolute;z-index:2;content:''}.leaflet-popup-content-wrapper{background-color:rgba(50,50,50,.9)}.leaflet-popup-tip-container_image{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2258%22%20height%3D%2247%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M0%200c12.643%200%2028%207.115%2028%2044h2c0-36.885%2015.358-44%2028-44h-58z%22%20fill%3D%22rgba(50%2C50%2C50%2C.9)%22%3E%3C%2Fpath%3E%0A%3C%2Fsvg%3E%0A\")}.leaflet-map-pane .leaflet-popup-tip-container_svg{fill:rgba(50,50,50,.9)}.no-touch .leaflet-container a.leaflet-popup-close-button:hover{background-color:#222;-webkit-box-shadow:0 1px 3px rgba(0,0,0,.5);box-shadow:0 1px 3px rgba(0,0,0,.5)}.leaflet-container a.leaflet-popup-close-button:after{top:-3px;right:-5px;width:40px;height:40px}.dg-wrapper{position:relative;overflow:hidden}.dg-scroller{height:100%;overflow-y:scroll;border:0}.dg-scroller__bar{z-index:1;right:0;background:#999}.dg-scroller__bar_h{bottom:2px;height:8px}.dg-header__title{width:100%;margin:0;-webkit-box-sizing:border-box;box-sizing:border-box;background:#999}.dg-header__title_state_fixed{position:absolute;z-index:1}.dg-scroller_hidden_true{overflow:auto}.dg-scroller::-webkit-scrollbar{width:0}.dg-scroller__wrapper{position:relative;overflow:hidden}.dg-scroller__bar-wrapper{position:absolute;top:18px;right:3px;bottom:4px;width:7px;border-radius:5px}.dg-scroller_hidden_true .dg-scroller__bar-wrapper{visibility:hidden}.dg-popup__header+.dg-popup__container-wrapper .dg-scroller__bar-wrapper{top:4px}.dg-scroller__bar{position:absolute;min-height:20px;width:7px;border-radius:3px;pointer-events:auto}.scroller__bar-wrapper .scroller__bar{background-color:#665b4f}.scroller__bar-wrapper:hover .scroller__bar{background-color:#897a6b}.dg-popup__container{margin:0}.leaflet-popup-scrolled .dg-popup__container{padding:8px 14px 8px 0}.dg-popup__header{position:relative;padding-bottom:12px}.leaflet-popup-scrolled .dg-popup__header:after{position:relative;top:12px;display:block;width:100%;height:1px;content:''}.dg-popup__footer{position:relative;bottom:0;overflow:hidden}.leaflet-popup-scrolled .dg-popup__footer:before{display:block;width:100%;height:1px;content:''}.dg-popup_hidden_true{display:none}.leaflet-popup-scrolled .dg-popup__footer:before,.leaflet-popup-scrolled .dg-popup__header:after{border-bottom:1px solid #636363;background-color:#494949}.dg-control-round{position:relative;padding:5px;width:30px;height:30px;border-radius:50%;cursor:default}.dg-control-round__icon{position:relative;display:block;width:30px;height:30px;border-radius:50%;background-color:#f0f0f0;background-image:-webkit-gradient(linear,left top,left bottom,color-stop(0,#fff),to(#e0e0e0));background-image:-webkit-linear-gradient(top,#fff 0,#e0e0e0 100%);background-image:linear-gradient(to bottom,#fff 0,#e0e0e0 100%);color:#2b2a29;text-align:center;text-decoration:none;text-shadow:0 1px 0 #fff;font-size:22px;line-height:30px;cursor:pointer}.no-touch .dg-control-round__icon:hover{background-color:#f5f5f5;background-image:-webkit-gradient(linear,left top,left bottom,color-stop(0,#ebebeb),to(#fff));background-image:-webkit-linear-gradient(top,#ebebeb 0,#fff 100%);background-image:linear-gradient(to bottom,#ebebeb 0,#fff 100%)}.dg-control-round__icon:active,.dg-control-round__icon_state_active,.no-touch .dg-control-round__icon:active{background-color:#ebebeb;background-image:-webkit-gradient(linear,left top,left bottom,color-stop(0,#d6d6d6),to(#fff));background-image:-webkit-linear-gradient(top,#d6d6d6 0,#fff 100%);background-image:linear-gradient(to bottom,#d6d6d6 0,#fff 100%)}.leaflet-disabled .dg-control-round__icon,.leaflet-disabled .dg-control-round__icon:active,.no-touch .leaflet-disabled .dg-control-round__icon:hover{background-image:none;cursor:default}.leaflet-touch .dg-control-round__icon:before{position:absolute;top:-10px;right:-15px;bottom:-10px;left:-15px;content:''}.dg-control-round_is-hidden_true{display:none}.dg-control-round{background-color:#3d3d3d;-webkit-box-shadow:0 3px 5px 0 rgba(0,0,0,.3);box-shadow:0 3px 5px 0 rgba(0,0,0,.3)}.dg-control-round__icon{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,.4);box-shadow:0 2px 2px 0 rgba(0,0,0,.4)}.no-touch .dg-control-round__icon:hover{-webkit-box-shadow:inset 0 1px #fff,0 0 0 1px rgba(0,0,0,.3),0 1px 0 1px rgba(0,0,0,.4);box-shadow:inset 0 1px #fff,0 0 0 1px rgba(0,0,0,.3),0 1px 0 1px rgba(0,0,0,.4)}.dg-control-round__icon:active,.dg-control-round__icon_state_active,.no-touch .dg-control-round__icon:active{-webkit-box-shadow:inset 0 1px 1px 1px rgba(0,0,0,.2),0 0 0 1px rgba(0,0,0,.3),0 -1px 1px 0 #000;box-shadow:inset 0 1px 1px 1px rgba(0,0,0,.2),0 0 0 1px rgba(0,0,0,.3),0 -1px 1px 0 #000}.leaflet-disabled .dg-control-round__icon,.leaflet-disabled .dg-control-round__icon:active,.no-touch .leaflet-disabled .dg-control-round__icon:hover{background-color:#b8b8b8;-webkit-box-shadow:none;box-shadow:none}.dg-museum{position:absolute;top:0;left:0;right:0;z-index:1500;padding:4px 5px 8px;background:#333;color:#fff;opacity:.97;text-align:center}.dg-museum-browser{position:relative;top:4px;display:inline-block;width:16px;height:16px;margin:0 4px;background:url(https://maps.api.2gis.ru/2.0/img/DGMuseum.jpg) left top no-repeat}.dg-museum__chrome{background-position:0 0}.dg-museum__chrome:hover{background-position:0 -16px}.dg-museum__firefox{background-position:-16px 0}.dg-museum__firefox:hover{background-position:-16px -16px}.dg-museum__safari{background-position:-32px 0}.dg-museum__safari:hover{background-position:-32px -16px}.dg-museum__opera{width:15px;background-position:-48px 0}.dg-museum__opera:hover{background-position:-48px -16px}.dg-museum__ie{width:17px;background-position:-63px 0}.dg-museum__ie:hover{background-position:-63px -16px}.dg-museum__close{display:inline-block;margin:0 4px;width:9px;height:9px;background:url(https://maps.api.2gis.ru/2.0/img/DGMuseum_close.gif) top left no-repeat;cursor:pointer}.dg-museum__close:hover{opacity:.6}.leaflet-container{z-index:0;background:#f7f3df;cursor:default}.leaflet-container:-webkit-full-screen{width:100%!important;height:100%!important}.leaflet-container:-moz-full-screen{width:100%!important;height:100%!important}.leaflet-container:-ms-fullscreen{width:100%!important;height:100%!important}.leaflet-container:fullscreen{width:100%!important;height:100%!important}.leaflet-dragging,.leaflet-dragging .leaflet-clickable,.leaflet-dragging .leaflet-container{cursor:move}.leaflet-control a,.leaflet-control a:focus{outline:0!important}.leaflet-container .leaflet-control-attribution{background-color:transparent;-webkit-box-shadow:none;box-shadow:none}.dg-customization__marker{background-repeat:no-repeat}.dg-customization__marker:before{position:absolute;top:0;left:0;width:100%;height:100%;background-image:inherit;background-size:contain;background-repeat:no-repeat;-webkit-transition:opacity ease-in-out .2s,-webkit-transform ease-in-out .2s;transition:opacity ease-in-out .2s,-webkit-transform ease-in-out .2s;transition:opacity ease-in-out .2s,transform ease-in-out .2s;transition:opacity ease-in-out .2s,transform ease-in-out .2s,-webkit-transform ease-in-out .2s;-webkit-transform:scale(1,1);-ms-transform:scale(1,1);transform:scale(1,1);-webkit-transform-origin:50% 100%;-ms-transform-origin:50% 100%;transform-origin:50% 100%}.dg-customization__marker_type_mushroom{background-repeat:no-repeat;background-image:url(https://maps.api.2gis.ru/2.0/img/DGCustomization__marker.png);background-size:22px 34px;width:22px;height:34px;-webkit-transform-origin:50% 100%;-ms-transform-origin:50% 100%;transform-origin:50% 100%;-webkit-animation:dg-customization__show-marker .2s;animation:dg-customization__show-marker .2s}.leaflet-retina .dg-customization__marker_type_mushroom{background-image:url(https://maps.api.2gis.ru/2.0/img/DGCustomization__marker@2x.png)}.dg-customization__marker_type_mushroom:focus{outline:0}.no-touch .dg-customization__marker_type_mushroom:hover{background-repeat:no-repeat;background-image:url(https://maps.api.2gis.ru/2.0/img/DGCustomization__markerHover.png);background-size:22px 34px}.leaflet-retina .no-touch .dg-customization__marker_type_mushroom:hover{background-image:url(https://maps.api.2gis.ru/2.0/img/DGCustomization__markerHover@2x.png)}.dg-customization__marker_type_mushroom:active,.no-touch .dg-customization__marker_type_mushroom:active{background-repeat:no-repeat;background-image:url(https://maps.api.2gis.ru/2.0/img/DGCustomization__markerActive.png);background-size:22px 34px}.leaflet-retina .dg-customization__marker_type_mushroom:active,.leaflet-retina .no-touch .dg-customization__marker_type_mushroom:active{background-image:url(https://maps.api.2gis.ru/2.0/img/DGCustomization__markerActive@2x.png)}@-webkit-keyframes dg-customization__show-marker{from{opacity:0}to{opacity:1}}@keyframes dg-customization__show-marker{from{opacity:0}to{opacity:1}}.dg-customization__marker_appear{background-position:999px}.dg-customization__marker_appear:before{content:''}.dg-customization__marker_disappear{background-position:999px;pointer-events:none}.dg-customization__marker_disappear:before{visibility:hidden;content:'';opacity:0;-webkit-transform:scale(1.2,1.8);-ms-transform:scale(1.2,1.8);transform:scale(1.2,1.8);-webkit-animation:dg-customization__marker-to-callout .2s;animation:dg-customization__marker-to-callout .2s}@-webkit-keyframes dg-customization__marker-to-callout{0%{visibility:visible;opacity:1;-webkit-transform:scale(1,1);transform:scale(1,1)}100%{visibility:visible;opacity:0;-webkit-transform:scale(1.2,1.8);transform:scale(1.2,1.8)}}@keyframes dg-customization__marker-to-callout{0%{visibility:visible;opacity:1;-webkit-transform:scale(1,1);transform:scale(1,1)}100%{visibility:visible;opacity:0;-webkit-transform:scale(1.2,1.8);transform:scale(1.2,1.8)}}.dg-dragging-false{touch-action:auto;-ms-touch-action:auto}.dg-zoom{width:40px;height:74px}.dg-zoom__in{position:absolute;top:0;left:0}.leaflet-touch .dg-zoom__in:before{position:absolute;top:-5px;right:-10px;bottom:0;left:-10px;content:''}.dg-zoom__in:after{position:absolute;right:0;bottom:-1px;left:0;z-index:-1;margin:auto;width:12px;height:2px;-webkit-box-shadow:0 0 3px 2px rgba(0,0,0,.3);box-shadow:0 0 3px 2px rgba(0,0,0,.3);content:''}.dg-zoom__button_type_in:after,.dg-zoom__button_type_in:before,.leaflet-touch .dg-zoom__button_type_in:before{position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;width:14px;height:2px;background-color:#7a7a7a;-webkit-box-shadow:0 1px #fff;box-shadow:0 1px #fff;content:''}.dg-zoom__button_type_in:after{width:2px;height:14px}.no-touch .dg-zoom__button_type_in:hover:after,.no-touch .dg-zoom__button_type_in:hover:before{background-color:#616161}.dg-zoom__button_type_in:active:after,.dg-zoom__button_type_in:active:before,.no-touch .dg-zoom__button_type_in:active:after,.no-touch .dg-zoom__button_type_in:active:before{background-color:#575757}.leaflet-disabled .dg-zoom__button_type_in:active:after,.leaflet-disabled .dg-zoom__button_type_in:active:before,.leaflet-disabled .dg-zoom__button_type_in:after,.leaflet-disabled .dg-zoom__button_type_in:before,.no-touch .leaflet-disabled .dg-zoom__button_type_in:hover:after,.no-touch .leaflet-disabled .dg-zoom__button_type_in:hover:before{-webkit-box-shadow:none;box-shadow:none}.dg-zoom__out{position:absolute;top:40px;right:0;left:0;margin:auto;width:22px;height:22px}.dg-zoom__out:after{position:absolute;top:-1px;right:0;left:0;margin:auto;width:12px;height:2px;content:''}.dg-zoom__button_type_out{width:22px;height:22px}.leaflet-touch .dg-zoom__button_type_out:before{top:-5px;right:-19px;bottom:-19px;left:-19px}.dg-zoom__button_type_out:after{position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;width:10px;height:2px;background:#7a7a7a;-webkit-box-shadow:0 1px #fff;box-shadow:0 1px #fff;content:''}.no-touch .dg-zoom__button_type_out:hover:after{background:#616161}.dg-zoom__button_type_out:active:after,.no-touch .dg-zoom__button_type_out:active:after{background:#575757}.leaflet-disabled .dg-zoom__button_type_out:active:after,.leaflet-disabled .dg-zoom__button_type_out:after,.no-touch .leaflet-disabled .dg-zoom__button_type_out:hover:after{-webkit-box-shadow:none;box-shadow:none}.dg-zoom__out{-webkit-box-shadow:0 2px 3px 0 rgba(0,0,0,.3);box-shadow:0 2px 3px 0 rgba(0,0,0,.3)}.dg-zoom__out:after{background-color:#3d3d3d}.leaflet-disabled .dg-zoom__button_type_in:active:after,.leaflet-disabled .dg-zoom__button_type_in:active:before,.leaflet-disabled .dg-zoom__button_type_in:after,.leaflet-disabled .dg-zoom__button_type_in:before,.leaflet-disabled .dg-zoom__button_type_out:active:after,.leaflet-disabled .dg-zoom__button_type_out:after,.no-touch .leaflet-disabled .dg-zoom__button_type_in:hover:after,.no-touch .leaflet-disabled .dg-zoom__button_type_in:hover:before,.no-touch .leaflet-disabled .dg-zoom__button_type_out:hover:after{background-color:#707070}.dg-attribution{background-color:transparent!important}.dg-attribution__copyright{margin:0 55px 5px 0;text-align:right;white-space:nowrap;font-size:9px;font-family:Helvetica,Arial,sans-serif}.dg-attribution__links{display:inline-block;margin:0;padding:0 5px 0 0}.dg-attribution__link-item{padding:0;list-style-type:none}.leaflet-container .dg-attribution__link{background:-webkit-gradient(linear,left top,right top,from(rgba(8,8,8,.3)),to(rgba(8,8,8,.3))) 0 95%/10px 1px repeat-x;background:-webkit-linear-gradient(left,rgba(8,8,8,.3),rgba(8,8,8,.3) 100%) 0 95%/10px 1px repeat-x;background:linear-gradient(to right,rgba(8,8,8,.3),rgba(8,8,8,.3) 100%) 0 95%/10px 1px repeat-x;color:#333;text-decoration:none;font-size:9px;font-family:Helvetica,Arial,sans-serif;cursor:pointer}.leaflet-container .dg-attribution__link:hover{background-image:-webkit-gradient(linear,left top,right top,from(#080808),to(#080808));background-image:-webkit-linear-gradient(left,#080808,#080808 100%);background-image:linear-gradient(to right,#080808,#080808 100%);color:#333;text-decoration:none}.dg-attribution__logo-url{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20height%3D%2224%22%20width%3D%2255%22%3E%0A%20%3Cpath%20fill%3D%22%23a2c124%22%20d%3D%22m24.395%2012c0-1.4545-0.22177-2.6545-0.66532-4-0.14785%204.2545-4.879%207.8182-7.4664%2010h6.7641c0.70229-2%201.3676-3.9273%201.3676-6m-4.731-9.3455c-2.033-1.6-4.62-2.6545-7.466-2.6545-6.7276%200-12.198%205.4182-12.198%2012s5.4704%2012%2012.198%2012c3.1048%200%205.9509-1.4545%208.1317-3.3455h-8.797v-2.6545c5.3595-4.5455%208.797-7.3455%208.797-10%200-1.1273-0.81317-2.6545-2.6983-2.6545-1.4785%200-2.6983%201.3455-2.6983%204.6545h-3.4005c-0.73925-4.2182%201.8481-7.6727%206.2466-7.6727%200.66532%200%201.2567%200.21818%201.8851%200.32727%22%2F%3E%0A%20%3Cpath%20fill%3D%22%233c4347%22%20d%3D%22m36.593%209.3455h1.3676c0-2-0.66532-5.1273-4.7312-5.2727-4.732-0.2183-6.1%202.6181-6.1%205.9272v5.3455c0%204.4%203.4375%205.3455%206.0988%205.3455%201.5524%200%203.4005-0.87273%204.7312-2v-6.6909h-5.4335v2.6545h2.6983v2.6545c-1.3676%201.3455-5.4335%201.3455-5.4335-2.6545v-5.3091c0-4%205.9509-4.1455%205.6183%200h1.1828zm18.296%206.6545c0-5.8182-6.9859-4.0727-6.9859-7.6%200-1.2%200.81317-2%202.1808-2%201.4415%200%202.2547%201.0182%202.2547%202.9818h2.5874c0-2-0.66532-5.3455-4.7312-5.3455-2.7722%200-4.879%201.4182-4.879%204.3273%200%206.0727%207.1707%204.0727%207.0598%207.6727-0.07392%201.4545-1.1458%202.0727-2.3656%202.0727-1.4415%200-2.6983-0.72727-2.4395-3.3818h-2.6613c-0.25874%203.3455%201.4415%206%205.3595%206%202.699%200%204.732-2.145%204.732-5.345l-0.111%200.618zm-12.198%204h-2.6983v-16h2.6983v16z%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:55px;height:24px;background-size:55px 24px;position:absolute;margin:0 3px 0 0}.dg-location__pin{background-repeat:no-repeat;width:20px;height:20px;background-image:url(https://maps.api.2gis.ru/2.0/img/sprite.basic.png);background-position:-55px 0;background-size:87px 74px}.leaflet-retina .dg-location__pin{background-image:url(https://maps.api.2gis.ru/2.0/img/sprite@2x.basic.png);background-position:-55px 0;background-size:91px 71.5px}.dg-location__pin_state_following{background-repeat:no-repeat;width:20px;height:20px;background-image:url(https://maps.api.2gis.ru/2.0/img/sprite.basic.png);background-position:-22px -24px;background-size:87px 74px}.leaflet-retina .dg-location__pin_state_following{background-image:url(https://maps.api.2gis.ru/2.0/img/sprite@2x.basic.png);background-position:-21px -24px;background-size:91px 71.5px}.dg-control-round__icon_name_locate:after{position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;content:''}.dg-control-round__icon_state_active.dg-control-round__icon_name_locate:active:after,.dg-control-round__icon_state_active.dg-control-round__icon_name_locate:after,.no-touch .dg-control-round__icon_state_active.dg-control-round__icon_name_locate:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2218%22%20height%3D%2218%22%3E%0A%20%20%20%20%3Cg%20fill%3D%22%2323a5d4%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017%2C8%20H%2015.92%20C%2015.48%2C4.937%2013.064%2C2.52%2010%2C2.08%20V%201%20C%2010%2C0.448%209.553%2C0%209%2C0%208.447%2C0%208%2C0.448%208%2C1%20V%202.08%20C%204.936%2C2.52%202.52%2C4.937%202.08%2C8%20H%201%20C%200.447%2C8%200%2C8.448%200%2C9%200%2C9.553%200.447%2C10%201%2C10%20H%202.08%20C%202.52%2C13.063%204.936%2C15.48%208%2C15.92%20V%2017%20c%200%2C0.553%200.447%2C1%201%2C1%200.553%2C0%201%2C-0.447%201%2C-1%20V%2015.92%20C%2013.064%2C15.481%2015.48%2C13.064%2015.92%2C10%20H%2017%20C%2017.553%2C10%2018%2C9.553%2018%2C9%2018%2C8.448%2017.553%2C8%2017%2C8%20z%20M%209%2C14%20C%206.24%2C14%204%2C11.762%204%2C9%204%2C6.238%206.24%2C4%209%2C4%20c%202.761%2C0%205%2C2.238%205%2C5%200%2C2.762%20-2.239%2C5%20-5%2C5%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Ccircle%20cx%3D%229%22%20cy%3D%229%22%20r%3D%223%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2014%2C10.004%20C%2014%2C9.834%2013.991%2C9.667%2013.975%2C9.502%2013.723%2C12.027%2011.592%2C14%209%2C14%206.408%2C14%204.277%2C12.027%204.025%2C9.502%204.009%2C9.667%204%2C9.834%204%2C10.004%20c%200%2C2.762%202.24%2C5%205%2C5%202.761%2C0%205%2C-2.238%205%2C-5%20z%20M%2010%2C3.083%20c%203.064%2C0.439%205.48%2C2.856%205.92%2C5.921%20H%2017%20c%200.369%2C0%200.688%2C0.201%200.86%2C0.498%20C%2017.947%2C9.354%2018%2C9.184%2018%2C9%2018%2C8.448%2017.553%2C8%2017%2C8%20H%2015.92%20C%2015.48%2C4.937%2013.064%2C2.52%2010%2C2.08%20V%203.083%20z%20M%201%2C9.004%20H%202.08%20C%202.52%2C5.939%204.936%2C3.522%208%2C3.083%20V%202.08%20C%204.936%2C2.52%202.52%2C4.937%202.08%2C8%20H%201%20C%200.447%2C8%200%2C8.448%200%2C9%200%2C9.184%200.053%2C9.354%200.14%2C9.502%200.312%2C9.205%200.631%2C9.004%201%2C9.004%20z%20m%208%2C-8%20c%200.553%2C0%201%2C0.447%201%2C1%20V%201%20C%2010%2C0.448%209.553%2C0%209%2C0%208.447%2C0%208%2C0.448%208%2C1%20v%201.004%20c%200%2C-0.553%200.447%2C-1%201%2C-1%20z%22%20fill%3D%22%232685aa%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%209%2C7%20c%201.486%2C0%202.717%2C1.082%202.955%2C2.5%20C%2011.982%2C9.337%2012%2C9.171%2012%2C9%2012%2C7.344%2010.656%2C6%209%2C6%207.344%2C6%206%2C7.344%206%2C9%206%2C9.171%206.018%2C9.337%206.045%2C9.5%206.283%2C8.082%207.514%2C7%209%2C7%20z%22%20fill%3D%22%231c85ab%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}@-webkit-keyframes DGLocation__locateIconRequestingAnim{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes DGLocation__locateIconRequestingAnim{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.dg-control-round__icon_name_locate:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2218%22%20height%3D%2218%22%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23616161%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017%2C8%20H%2015.92%20C%2015.48%2C4.937%2013.064%2C2.52%2010%2C2.08%20V%201%20C%2010%2C0.448%209.553%2C0%209%2C0%208.447%2C0%208%2C0.448%208%2C1%20V%202.08%20C%204.936%2C2.52%202.52%2C4.937%202.08%2C8%20H%201%20C%200.447%2C8%200%2C8.448%200%2C9%200%2C9.553%200.447%2C10%201%2C10%20H%202.08%20C%202.52%2C13.063%204.936%2C15.48%208%2C15.92%20V%2017%20c%200%2C0.553%200.447%2C1%201%2C1%200.553%2C0%201%2C-0.447%201%2C-1%20V%2015.92%20C%2013.064%2C15.481%2015.48%2C13.064%2015.92%2C10%20H%2017%20C%2017.553%2C10%2018%2C9.553%2018%2C9%2018%2C8.448%2017.553%2C8%2017%2C8%20z%20M%209%2C14%20C%206.24%2C14%204%2C11.762%204%2C9%204%2C6.238%206.24%2C4%209%2C4%20c%202.761%2C0%205%2C2.238%205%2C5%200%2C2.762%20-2.239%2C5%20-5%2C5%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Ccircle%20cx%3D%229%22%20cy%3D%229%22%20r%3D%223%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23444%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2014%2C10.004%20C%2014%2C9.834%2013.991%2C9.667%2013.975%2C9.502%2013.723%2C12.027%2011.592%2C14%209%2C14%206.408%2C14%204.277%2C12.027%204.025%2C9.502%204.009%2C9.667%204%2C9.834%204%2C10.004%20c%200%2C2.762%202.24%2C5%205%2C5%202.761%2C0%205%2C-2.238%205%2C-5%20z%20M%2010%2C3.083%20c%203.064%2C0.439%205.48%2C2.856%205.92%2C5.921%20H%2017%20c%200.369%2C0%200.688%2C0.201%200.86%2C0.498%20C%2017.947%2C9.354%2018%2C9.184%2018%2C9%2018%2C8.448%2017.553%2C8%2017%2C8%20H%2015.92%20C%2015.48%2C4.937%2013.064%2C2.52%2010%2C2.08%20V%203.083%20z%20M%201%2C9.004%20H%202.08%20C%202.52%2C5.939%204.936%2C3.522%208%2C3.083%20V%202.08%20C%204.936%2C2.52%202.52%2C4.937%202.08%2C8%20H%201%20C%200.447%2C8%200%2C8.448%200%2C9%200%2C9.184%200.053%2C9.354%200.14%2C9.502%200.312%2C9.205%200.631%2C9.004%201%2C9.004%20z%20m%208%2C-8%20c%200.553%2C0%201%2C0.447%201%2C1%20V%201%20C%2010%2C0.448%209.553%2C0%209%2C0%208.447%2C0%208%2C0.448%208%2C1%20v%201.004%20c%200%2C-0.553%200.447%2C-1%201%2C-1%20z%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%209%2C7%20c%201.486%2C0%202.717%2C1.082%202.955%2C2.5%20C%2011.982%2C9.337%2012%2C9.171%2012%2C9%2012%2C7.344%2010.656%2C6%209%2C6%207.344%2C6%206%2C7.344%206%2C9%206%2C9.171%206.018%2C9.337%206.045%2C9.5%206.283%2C8.082%207.514%2C7%209%2C7%20z%22%20fill%3D%22%23444%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:18px;height:18px;background-size:18px 18px}.dg-control-round__icon_name_locate:active:after,.no-touch .dg-control-round__icon_name_locate:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2218%22%20height%3D%2218%22%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23424242%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017%2C8%20H%2015.92%20C%2015.48%2C4.937%2013.064%2C2.52%2010%2C2.08%20V%201%20C%2010%2C0.448%209.553%2C0%209%2C0%208.447%2C0%208%2C0.448%208%2C1%20V%202.08%20C%204.936%2C2.52%202.52%2C4.937%202.08%2C8%20H%201%20C%200.447%2C8%200%2C8.448%200%2C9%200%2C9.553%200.447%2C10%201%2C10%20H%202.08%20C%202.52%2C13.063%204.936%2C15.48%208%2C15.92%20V%2017%20c%200%2C0.553%200.447%2C1%201%2C1%200.553%2C0%201%2C-0.447%201%2C-1%20V%2015.92%20C%2013.064%2C15.481%2015.48%2C13.064%2015.92%2C10%20H%2017%20C%2017.553%2C10%2018%2C9.553%2018%2C9%2018%2C8.448%2017.553%2C8%2017%2C8%20z%20M%209%2C14%20C%206.24%2C14%204%2C11.762%204%2C9%204%2C6.238%206.24%2C4%209%2C4%20c%202.761%2C0%205%2C2.238%205%2C5%200%2C2.762%20-2.239%2C5%20-5%2C5%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Ccircle%20cx%3D%229%22%20cy%3D%229%22%20r%3D%223%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cg%20fill%3D%22%232e2e2e%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2014%2C10.004%20C%2014%2C9.834%2013.991%2C9.667%2013.975%2C9.502%2013.723%2C12.027%2011.592%2C14%209%2C14%206.408%2C14%204.277%2C12.027%204.025%2C9.502%204.009%2C9.667%204%2C9.834%204%2C10.004%20c%200%2C2.762%202.24%2C5%205%2C5%202.761%2C0%205%2C-2.238%205%2C-5%20z%20M%2010%2C3.083%20c%203.064%2C0.439%205.48%2C2.856%205.92%2C5.921%20H%2017%20c%200.369%2C0%200.688%2C0.201%200.86%2C0.498%20C%2017.947%2C9.354%2018%2C9.184%2018%2C9%2018%2C8.448%2017.553%2C8%2017%2C8%20H%2015.92%20C%2015.48%2C4.937%2013.064%2C2.52%2010%2C2.08%20V%203.083%20z%20M%201%2C9.004%20H%202.08%20C%202.52%2C5.939%204.936%2C3.522%208%2C3.083%20V%202.08%20C%204.936%2C2.52%202.52%2C4.937%202.08%2C8%20H%201%20C%200.447%2C8%200%2C8.448%200%2C9%200%2C9.184%200.053%2C9.354%200.14%2C9.502%200.312%2C9.205%200.631%2C9.004%201%2C9.004%20z%20m%208%2C-8%20c%200.553%2C0%201%2C0.447%201%2C1%20V%201%20C%2010%2C0.448%209.553%2C0%209%2C0%208.447%2C0%208%2C0.448%208%2C1%20v%201.004%20c%200%2C-0.553%200.447%2C-1%201%2C-1%20z%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%209%2C7%20c%201.486%2C0%202.717%2C1.082%202.955%2C2.5%20C%2011.982%2C9.337%2012%2C9.171%2012%2C9%2012%2C7.344%2010.656%2C6%209%2C6%207.344%2C6%206%2C7.344%206%2C9%206%2C9.171%206.018%2C9.337%206.045%2C9.5%206.283%2C8.082%207.514%2C7%209%2C7%20z%22%20fill%3D%22%232e2e2e%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-control-round__icon_state_requesting.dg-control-round__icon_name_locate:active:after,.dg-control-round__icon_state_requesting.dg-control-round__icon_name_locate:after,.no-touch .dg-control-round__icon_state_requesting.dg-control-round__icon_name_locate:hover:after{background-repeat:no-repeat;width:24px;height:24px;background-image:url(https://maps.api.2gis.ru/2.0/img/sprite.dark.png);background-position:0 0;background-size:78px 65px;-webkit-animation:DGLocation__locateIconRequestingAnim 1s linear infinite;animation:DGLocation__locateIconRequestingAnim 1s linear infinite;image-rendering:optimizeQuality}.leaflet-retina .dg-control-round__icon_state_requesting.dg-control-round__icon_name_locate:active:after,.leaflet-retina .dg-control-round__icon_state_requesting.dg-control-round__icon_name_locate:after,.leaflet-retina .no-touch .dg-control-round__icon_state_requesting.dg-control-round__icon_name_locate:hover:after{background-image:url(https://maps.api.2gis.ru/2.0/img/sprite@2x.dark.png);background-position:0 0;background-size:78px 65px}.dg-control-round__icon_name_fullscreen:after{position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;content:''}.dg-control-round__icon_state_active.dg-control-round__icon_name_fullscreen:active:after,.dg-control-round__icon_state_active.dg-control-round__icon_name_fullscreen:after,.no-touch .dg-control-round__icon_state_active.dg-control-round__icon_name_fullscreen:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206%2C1%20H%201%20V%206%20H%203%20V%203%20h%203%20z%20m%204%2C14%20h%205%20v%20-5%20h%20-2%20v%203%20H%2010%20z%20M%2015%2C6%20V%201%20h%20-5%20v%202%20h%203%20V%206%20z%20M%201%2C10%20v%205%20H%206%20V%2013%20H%203%20v%20-3%20z%22%20fill%3D%22%230da4d4%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%201%2C1%20H%206%20V%202%20H%201%20z%20m%209%2C0%20h%205%20v%201%20h%20-5%20z%20m%203%2C9%20h%202%20v%201%20h%20-2%20z%20m%20-3%2C3%20h%203%20v%201%20h%20-3%20z%20m%20-7%2C0%20h%203%20v%201%20H%203%20z%20M%201%2C10%20h%202%20v%201%20H%201%20z%22%20fill%3D%22%230a84ab%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%201%2C6%20H%203%20V%207%20H%201%20z%20m%2012%2C0%20h%202%20V%207%20H%2013%20z%20M%201%2C15%20h%205%20v%201%20H%201%20z%20m%209%2C0%20h%205%20v%201%20h%20-5%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-control-round__icon_name_fullscreen:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%201%2C3%20H%206%20V%204%20H%201%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206%2C1%20H%201%20V%206%20H%203%20V%203%20h%203%20z%20m%204%2C14%20h%205%20v%20-5%20h%20-2%20v%203%20h%20-3%20z%22%20fill%3D%22%236c6c6c%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2010%2C3%20h%205%20v%201%20h%20-5%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2015%2C6%20V%201%20h%20-5%20v%202%20h%203%20V%206%20z%20M%201%2C10%20v%205%20H%206%20V%2013%20H%203%20v%20-3%20z%22%20fill%3D%22%236c6c6c%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%201%2C1%20H%206%20V%202%20H%201%20z%20m%209%2C0%20h%205%20v%201%20h%20-5%20z%20m%203%2C9%20h%202%20v%201%20h%20-2%20z%20m%20-3%2C3%20h%203%20v%201%20h%20-3%20z%20m%20-7%2C0%20h%203%20v%201%20H%203%20z%20M%201%2C10%20h%202%20v%201%20H%201%20z%22%20fill%3D%22%234b4b4b%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%201%2C6%20H%203%20V%207%20H%201%20z%20m%2012%2C0%20h%202%20V%207%20H%2013%20z%20M%201%2C15%20h%205%20v%201%20H%201%20z%20m%209%2C0%20h%205%20v%201%20h%20-5%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:16px;height:16px;background-size:16px 16px}.dg-control-round__icon_name_fullscreen:active:after,.no-touch .dg-control-round__icon_name_fullscreen:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2012%2C9%20h%204%20v%207%20h%20-4%20z%20m%20-3%2C3%20h%205%20v%204%20H%209%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2010%2C15%20h%205%20v%20-5%20h%20-2%20v%203%20h%20-3%20z%22%20fill%3D%22%23282828%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%200%2C9%20h%204%20v%207%20H%200%20z%20m%202%2C3%20h%205%20v%204%20H%202%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%201%2C10%20v%205%20H%206%20V%2013%20H%203%20v%20-3%20z%22%20fill%3D%22%23282828%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C0%20H%204%20V%207%20H%200%20z%20m%209%2C0%20h%205%20V%204%20H%209%20z%20m%203%2C0%20h%204%20v%207%20h%20-4%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2015%2C6%20V%201%20h%20-5%20v%202%20h%203%20v%203%20z%22%20fill%3D%22%23282828%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%202%2C0%20H%207%20V%204%20H%202%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206%2C1%20H%201%20V%206%20H%203%20V%203%20h%203%20z%22%20fill%3D%22%23282828%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-building-callout__body{position:relative}.dg-building-callout__list{margin-bottom:8px;padding-left:24px;color:#ffe6aa;list-style:none}.dg-building-callout__list-item{position:relative;margin-bottom:4px;font-size:12px}.dg-building-callout__list-item:before{position:absolute;top:5px;left:-21px;content:'';background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%226%22%20height%3D%226%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%203%2C-0.002%20C%204.654%2C-0.002%205.994%2C1.342%205.994%2C3%205.994%2C4.658%204.655%2C6.002%203%2C6.002%201.345%2C6.002%200.005%2C4.658%200.005%2C3%200.005%2C1.342%201.346%2C-0.002%203%2C-0.002%20z%22%20fill%3D%22%23aaa%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:6px;height:6px;background-size:6px 6px}.dg-map-geoclicker__address{margin-bottom:10px;font-size:16px}.dg-map-geoclicker__purpose+.dg-map-geoclicker__address{margin-top:-6px}.dg-map-geoclicker__address-header{position:relative;margin-bottom:4px;padding-left:24px}.dg-map-geoclicker__address-header:first-child:before{position:absolute;top:5px;left:1px;content:''}.dg-map-geoclicker__address-drilldown{position:relative;margin-bottom:4px;padding-left:24px;color:#aaa;font-size:12px}.dg-map-geoclicker__address-drilldown:first-child:before{position:absolute;top:2px;left:1px;content:''}.dg-map-geoclicker__purpose{position:relative;margin-bottom:10px;padding-left:24px;font-size:16px}.dg-map-geoclicker__address+.dg-map-geoclicker__purpose{margin-top:-6px}.dg-map-geoclicker__purpose:before{position:absolute;top:4px;left:2px;content:''}.dg-map-geoclicker__purpose_type_street:before{top:4px}.dg-map-geoclicker__sight-description{overflow:hidden;padding:.5em 0 0 24px;max-height:3.6em}a.dg-map-geoclicker__show-more-sights-link{position:relative;margin-left:24px;border-bottom:1px dotted;text-decoration:none}a.dg-map-geoclicker__show-more-sights-link:after{position:absolute;top:4px;margin-left:5px;width:6px;height:10px;content:'';font-weight:700}.dg-map-geoclicker__clamped-line{display:block;white-space:nowrap}.dg-map-geoclicker__clamped-line_last{overflow:hidden;width:100%;text-overflow:ellipsis}.dg-map-geoclicker__preloader-wrapper{display:table-cell;vertical-align:middle;text-align:center}.dg-map-geoclicker__drilldown{margin-bottom:10px}.dg-map-geoclicker__address-drilldown:first-child:before,.dg-map-geoclicker__address-header:first-child:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%229%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%204.958%2C11%20C%204.958%2C9.036%206.756%2C6.751%208.719%2C6.751%208.885%2C6.223%209%2C5.656%209%2C5.063%209%2C2.267%206.985%2C0%204.5%2C0%202.015%2C0%200%2C2.267%200%2C5.063%200%2C5.656%200.114%2C6.222%200.28%2C6.751%202.243%2C6.751%204.018%2C9.012%204.018%2C11%20h%200.94%20z%22%20fill%3D%22%23a0a0a0%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:9px;height:11px;background-size:9px 11px}.dg-map-geoclicker__purpose:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%228%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%203.582%2C8%20c%200.211%2C0%200.798%2C0.035%201%2C0%20v%204%20l%20-2%2C-1%20V%208%20c%200.372%2C0.066%200.861%2C0%201%2C0%20z%20M%200.44%2C5.384%20C%200.163%2C4.866%200%2C4.276%200%2C3.646%200%2C1.633%201.604%2C0.002%203.582%2C0.002%20c%201.978%2C0%203.582%2C1.631%203.582%2C3.644%200%2C0.647%20-0.169%2C1.254%20-0.461%2C1.781%20L%206.641%2C5.495%206.618%2C5.567%20C%205.954%2C6.549%204.844%2C7.192%203.584%2C7.192%202.25%2C7.192%201.084%2C6.467%200.44%2C5.384%20z%20M%202.613%2C1.276%20c%20-0.549%2C0%20-0.995%2C0.453%20-0.995%2C1.013%200%2C0.559%200.446%2C1.013%200.995%2C1.013%200.551%2C0%200.996%2C-0.454%200.996%2C-1.013%200%2C-0.56%20-0.445%2C-1.013%20-0.996%2C-1.013%20z%22%20fill%3D%22%23a0a0a0%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:8px;height:12px;background-size:8px 12px}.dg-map-geoclicker__purpose_type_street:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%208.8%2C0%20H%203.199%20L%200%2C12%20H%2012%20L%208.8%2C0%20z%20M%207%2C12%20H%205%20V%209%20h%202%20v%203%20z%20M%207%2C8%20H%205%20V%206%20H%207%20V%208%20z%20M%207%2C5%20H%205%20V%203%20H%207%20V%205%20z%20M%207%2C2%20H%205%20V%200%20h%202%20v%202%20z%22%20fill%3D%22%23a0a0a0%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:12px;height:12px;background-size:12px 12px}.dg-map-geoclicker__purpose_type_sight:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%228%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%207%2C0%20H%202.547%20C%200.547%2C0%200%2C0.828%200%2C2.5%200%2C3.734%200.5%2C5%202%2C5%203.359%2C5%204%2C3.844%204%2C3%204%2C2.281%202.859%2C2%202%2C2%202%2C2.766%202.234%2C3%203%2C3%203%2C3.69%202.48%2C4%202%2C4%201.234%2C4%201%2C3.329%201%2C2.5%201%2C1.693%201.375%2C1%202.5%2C1%204.391%2C1%205%2C1.656%205%2C3%205%2C4.6%204.338%2C5.119%203%2C6%20v%204%20H%202%20v%202%20H%208%20V%201%20L%207%2C0%20z%20M%204%2C10%20V%206%20l%201%2C1%20v%203%20H%204%20z%20m%202%2C0%20V%206%20l%201%2C1%20v%203%20H%206%20z%22%20fill%3D%22%23aaa%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:8px;height:12px;background-size:8px 12px}.dg-map-geoclicker__purpose_type_settlement:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%209%2C9%20C%208.235%2C9%207.762%2C9.522%207.259%2C10.022%207.795%2C10.38%208.051%2C11.05%207.879%2C12%20H%2012%20C%2012%2C10.46%2010.535%2C9%209%2C9%20z%20m%20-2.868%2C1.248%20c%20-0.965%2C0%20-1.747%2C0.784%20-1.747%2C1.751%20h%203.494%20c%200%2C-0.967%20-0.782%2C-1.751%20-1.747%2C-1.751%20z%20M%2010%2C1%20V%200%20H%207%20V%201%20H%205%20V%206%20L%206%2C7%20V%202%20H%207%20V%207%20L%208%2C8%20V%202%20h%201%20v%206%20h%201%20V%202%20h%201%20v%207%20l%201%2C0.607%20V%201%20H%2010%20z%20M%206.66%2C9.539%206.721%2C9.479%20C%206.903%2C9.297%207.104%2C9.14%207.314%2C9.004%20V%208.414%20L%206.131%2C7.187%203%2C8%20v%204%20H%203.62%20C%203.62%2C10.612%204.747%2C9.483%206.132%2C9.483%206.312%2C9.482%206.49%2C9.502%206.66%2C9.539%20z%20M%202%2C12%20z%20M%201%2C2%200%2C5%20v%207%20H%202%20V%205%20L%201%2C2%20z%20M%201.111%2C6.955%20C%200.804%2C6.955%200.556%2C6.706%200.556%2C6.4%20c%200%2C-0.307%200.248%2C-0.555%200.555%2C-0.555%200.307%2C0%200.554%2C0.248%200.554%2C0.555%200%2C0.306%20-0.247%2C0.555%20-0.554%2C0.555%20z%22%20fill%3D%22%23a0a0a0%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:12px;height:12px;background-size:12px 12px}a.dg-map-geoclicker__show-more-sights-link{color:#ffe6aa}.no-touch a.dg-map-geoclicker__show-more-sights-link:hover{color:#9cd}a.dg-map-geoclicker__show-more-sights-link:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%226%22%20height%3D%2210%22%20viewBox%3D%220%200%206%2010%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206%2C5%20V%205.4%20L%201.4%2C10%20H%200%20L%200%2C8.6%203.6%2C5%200%2C1.4%200%2C0%201.4%2C0%206%2C4.6%20V%205%20l%200%2C0%200%2C0%200%2C0%200%2C0%200%2C0%20z%22%20fill%3D%22%23aaa%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-map-geoclicker__drilldown{color:#aaa}.dg-preloader{position:relative;margin:0 auto;width:200px;height:44px;vertical-align:middle}.dg-preloader_animation_false{background-repeat:no-repeat;background-image:url(https://maps.api.2gis.ru/2.0/img/DGPreloader__preloader.gif);background-size:100px 26px;background-attachment:scroll;background-position:50% 50%}.dg-preloader_animation_true:before{position:absolute;top:50%;left:50%;margin:-22px 0 0 -22px;width:44px;height:44px;outline:transparent solid 1px;content:'';-webkit-animation:dg-preloader__outer 5s linear infinite;animation:dg-preloader__outer 5s linear infinite;image-rendering:optimizeQuality}.dg-preloader_animation_true.dg-preloader_size_small:before{margin:-12px 0 0 -12px;width:24px;height:24px}.dg-preloader_animation_true.dg-preloader_scheme_regular:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2244%22%20height%3D%2244%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2035.68%2C10.32%20C%2038.368%2C13.465%2040%2C17.539%2040%2C22%2040%2C31.941%2031.941%2C40%2022%2C40%2012.059%2C40%204%2C31.941%204%2C22%204%2C17.539%205.632%2C13.465%208.32%2C10.32%20L%205.48%2C7.48%20C%202.07%2C11.354%200%2C16.434%200%2C22%200%2C34.15%209.85%2C44%2022%2C44%2034.15%2C44%2044%2C34.15%2044%2C22%2044%2C16.434%2041.93%2C11.354%2038.52%2C7.48%20l%20-2.84%2C2.84%20z%22%20fill%3D%22%230da5d5%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%209.271%2C9.272%20C%2012.529%2C6.015%2017.029%2C4%2022%2C4%2026.971%2C4%2031.471%2C6.015%2034.729%2C9.272%20L%2037.557%2C6.444%20C%2033.575%2C2.462%2028.075%2C0%2022%2C0%2015.925%2C0%2010.425%2C2.462%206.443%2C6.444%20l%202.828%2C2.828%20z%22%20fill%3D%22%23a6cd2a%22%2F%3E%0A%3C%2Fsvg%3E%0A\");background-size:44px 44px}.dg-preloader_animation_true.dg-preloader_scheme_regular.dg-preloader_size_small:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2224%22%20height%3D%2224%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2018.564%2C7.435%20C%2019.467%2C8.73%2020%2C10.302%2020%2C12%2020%2C16.418%2016.418%2C20%2012%2C20%207.582%2C20%204%2C16.418%204%2C12%204%2C10.302%204.533%2C8.73%205.436%2C7.435%20L%202.581%2C4.581%20C%200.969%2C6.623%200%2C9.195%200%2C12%200%2C18.627%205.373%2C24%2012%2C24%2018.627%2C24%2024%2C18.627%2024%2C12%2024%2C9.195%2023.031%2C6.623%2021.419%2C4.581%20l%20-2.855%2C2.854%20z%22%20fill%3D%22%230da5d5%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2012%2C0%20C%208.686%2C0%205.686%2C1.343%203.516%2C3.515%20L%206.343%2C6.343%20C%207.791%2C4.895%209.791%2C4%2012%2C4%20c%202.209%2C0%204.209%2C0.895%205.657%2C2.343%20L%2020.484%2C3.515%20C%2018.314%2C1.343%2015.314%2C0%2012%2C0%20z%22%20fill%3D%22%23a6cd2a%22%2F%3E%0A%3C%2Fsvg%3E%0A\");background-size:24px 24px}.dg-preloader_animation_true:after{position:absolute;top:50%;left:50%;margin:-16px 0 0 -16px;width:32px;height:32px;outline:transparent solid 1px;content:'';-webkit-animation:dg-preloader__inner 4s linear infinite;animation:dg-preloader__inner 4s linear infinite;image-rendering:optimizeQuality}.dg-preloader_animation_true.dg-preloader_size_small:after{margin:-6px 0 0 -6px;width:12px;height:12px}.dg-preloader_animation_true.dg-preloader_scheme_regular:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2232%22%20height%3D%2232%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206.581%2C23.419%20C%204.969%2C21.377%204%2C18.804%204%2C16%204%2C9.373%209.373%2C4%2016%2C4%20c%206.627%2C0%2012%2C5.373%2012%2C12%200%2C2.804%20-0.969%2C5.377%20-2.581%2C7.419%20l%202.847%2C2.847%20C%2030.594%2C23.487%2032%2C19.909%2032%2C16%2032%2C7.163%2024.837%2C0%2016%2C0%207.163%2C0%200%2C7.163%200%2C16%20c%200%2C3.909%201.406%2C7.487%203.734%2C10.266%20l%202.847%2C-2.847%20z%22%20fill%3D%22%23a6cd2a%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2027.314%2C27.314%2024.486%2C24.486%20C%2022.314%2C26.657%2019.314%2C28%2016%2C28%2012.686%2C28%209.686%2C26.657%207.516%2C24.485%20L%204.688%2C27.313%20C%207.582%2C30.209%2011.582%2C32%2016%2C32%20c%204.418%2C0%208.418%2C-1.791%2011.314%2C-4.686%20z%22%20fill%3D%22%230da5d5%22%2F%3E%0A%3C%2Fsvg%3E%0A\");background-size:32px 32px}.dg-preloader_animation_true.dg-preloader_scheme_regular.dg-preloader_size_small:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%203.141%2C6.86%20C%203.059%2C6.586%203%2C6.301%203%2C6%203%2C4.343%204.343%2C3%206%2C3%207.657%2C3%209%2C4.343%209%2C6%209%2C6.301%208.941%2C6.586%208.859%2C6.86%20l%202.26%2C2.259%20C%2011.674%2C8.209%2012%2C7.144%2012%2C6%2012%2C2.686%209.314%2C0%206%2C0%202.686%2C0%200%2C2.686%200%2C6%200%2C7.144%200.326%2C8.209%200.881%2C9.119%20L%203.141%2C6.86%20z%22%20fill%3D%22%23a6cd2a%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%206%2C12%20c%201.657%2C0%203.157%2C-0.672%204.243%2C-1.757%20L%208.122%2C8.122%20C%207.578%2C8.664%206.828%2C9%206%2C9%205.172%2C9%204.422%2C8.664%203.879%2C8.121%20L%201.758%2C10.242%20C%202.843%2C11.328%204.343%2C12%206%2C12%20z%22%20fill%3D%22%230da5d5%22%2F%3E%0A%3C%2Fsvg%3E%0A\");background-size:12px 12px}@-webkit-keyframes dg-preloader__outer{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes dg-preloader__outer{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes dg-preloader__inner{to{-webkit-transform:rotate(-360deg);transform:rotate(-360deg)}}@keyframes dg-preloader__inner{to{-webkit-transform:rotate(-360deg);transform:rotate(-360deg)}}.dg-popup__footer-buttons{display:table;margin-top:10px;width:100%}.dg-popup__footer-button-wrapper{display:table-cell}.dg-popup__footer-button{position:relative;display:inline-block;-webkit-box-sizing:border-box;box-sizing:border-box;margin-left:5%;width:95%;border-radius:2px;text-align:center;text-decoration:none;font:12px/24px Arial,sans-serif;cursor:pointer;-webkit-transition:all .1s;transition:all .1s}.dg-popup__footer-button-wrapper:first-child .dg-popup__footer-button{margin:0;width:100%}.no-touch .dg-popup__footer-button:hover{-webkit-transition:all .2s;transition:all .2s}.dg-popup__footer-icon-button:before{display:inline-block;margin:-2px 5px 0 0;width:12px;height:12px;background-size:contain;background-repeat:no-repeat;content:'';vertical-align:middle}.dg-popup__button_name_back:before,.dg-popup__button_name_firm-card-back:before,.dg-popup__button_name_firm-list-back:before{width:9px;height:6px}.dg-popup__show-less-house-link{position:relative;top:6px;margin:0 15px 10px;color:#0070c0;text-decoration:none;font-size:12px;line-height:24px}.dg-popup__header-links{margin:8px 18px 0 0}.dg-popup__header-title_for_firmcard{position:relative;overflow:hidden;max-height:3.4em}.dg-popup__header-teaser{display:-webkit-box;height:3.3em;-webkit-line-clamp:3;-webkit-box-orient:vertical}.dg-popup__header-title{display:block;white-space:normal;font:22px/24px 'Arial narrow',Arial,sans-serif}.dg-popup__header-link{display:inline-block;margin-left:2.6em;vertical-align:middle;white-space:nowrap}.dg-popup__header-link:first-child{margin-left:1.2em}.dg-popup__rating{display:inline-block;margin:0 .4em 3px 0;width:70px;height:14px;vertical-align:middle}.dg-popup__rating-stars{background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2214%22%20height%3D%2214%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206.999%2C0%208.748%2C4.989%2013.997%2C4.991%209.83%2C8.708%2011.324%2C14.002%206.999%2C10.871%202.674%2C14.002%204.168%2C8.708%200%2C4.991%205.249%2C4.989%206.999%2C0%20z%22%20fill%3D%22%23ffc84b%22%2F%3E%0A%3C%2Fsvg%3E%0A\");float:left;height:100%}.dg-popup__link{position:relative;background-position:center bottom;background-size:10px 1px;background-repeat:repeat-x;text-decoration:none;-webkit-tap-highlight-color:transparent}.dg-popup__link_type_flamp_reviews{margin-left:.1em}.dg-popup__link_type_photos:before{position:absolute;top:2px;left:-18px;display:inherit;content:''}.dg-popup__link_type_booklet:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2210%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%200%2C8%203%2C2%20V%202%20L%200%2C0%20V%208%20z%20M%204%2C10%208%2C8%20V%200%20L%204%2C2%20v%208%20z%20M%209%2C0%20v%208%20l%203%2C2%20V%202%20L%209%2C0%20z%22%20fill%3D%22%237dc814%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:12px;height:10px;background-size:12px 10px;position:absolute;top:2px;left:-18px;display:inherit;content:''}a.dg-popup__link{background-image:-webkit-gradient(linear,left top,right top,from(rgba(255,230,170,.3)),to(rgba(255,230,170,.3)));background-image:-webkit-linear-gradient(left,rgba(255,230,170,.3),rgba(255,230,170,.3) 100%);background-image:linear-gradient(to right,rgba(255,230,170,.3),rgba(255,230,170,.3) 100%);color:#ffe6aa}.no-touch a.dg-popup__link:hover{background-image:-webkit-gradient(linear,left top,right top,from(rgba(153,204,221,.3)),to(rgba(153,204,221,.3)));background-image:-webkit-linear-gradient(left,rgba(153,204,221,.3),rgba(153,204,221,.3) 100%);background-image:linear-gradient(to right,rgba(153,204,221,.3),rgba(153,204,221,.3) 100%);color:#9cd}.dg-popup__header-title{color:#ffc84b}.dg-popup__footer-button-wrapper .dg-popup__footer-button,.dg-popup__footer-button-wrapper .dg-popup__footer-button:hover{color:#e6e6e6}.dg-popup__footer-button{background:rgba(0,0,0,.2);-webkit-box-shadow:0 1px rgba(0,0,0,.1);box-shadow:0 1px rgba(0,0,0,.1)}.no-touch .dg-popup__footer-button:hover{background:#222;-webkit-box-shadow:0 1px 3px rgba(0,0,0,.5);box-shadow:0 1px 3px rgba(0,0,0,.5)}.dg-popup__rating{background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2214%22%20height%3D%2214%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%207.002%2C0%208.751%2C4.989%2014%2C4.991%209.833%2C8.708%2011.327%2C14.002%207.002%2C10.871%202.677%2C14.002%204.171%2C8.708%200.003%2C4.991%205.252%2C4.989%207.002%2C0%20z%22%20fill%3D%22%23aaa%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-popup__link_type_photos:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2210%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2011%2C1%20H%2010%20L%209%2C0%20H%206%20L%205%2C1%20H%201%20L%200%2C2%20v%207%20l%201%2C1%20H%2011%20L%2012%2C9%20V%202%20L%2011%2C1%20z%20M%203%2C4%20H%202%20V%203%20h%201%20v%201%20z%20m%204.518%2C3.992%20c%20-1.381%2C0%20-2.5%2C-1.119%20-2.5%2C-2.5%200%2C-1.38%201.119%2C-2.5%202.5%2C-2.5%201.38%2C0%202.5%2C1.12%202.5%2C2.5%200%2C1.381%20-1.121%2C2.5%20-2.5%2C2.5%20z%22%20fill%3D%22%2379b0bc%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:12px;height:10px;background-size:12px 10px}.dg-popup__button_name_firm-card-back:before,.dg-popup__button_name_firm-list-back:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%229%22%20height%3D%226%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C3%204%2C6%20V%204%20H%209%20V%202%20H%204%20V%200%20z%22%20fill%3D%22%239f9f9f%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-popup__button_name_back:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%229%22%20height%3D%226%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C3%204%2C6%20V%204%20H%209%20V%202%20H%204%20V%200%20z%22%20fill%3D%22%239f9f9f%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:9px;height:6px;background-size:9px 6px}.dg-popup__button_name_goto:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220%22%20height%3D%227%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2016.5%2C0%20C%2014.738%2C0%2013.295%2C1.306%2013.051%2C3%20H%204.949%20C%204.718%2C1.858%203.71%2C1%202.5%2C1%201.119%2C1%200%2C2.119%200%2C3.5%200%2C4.881%201.119%2C6%202.5%2C6%203.71%2C6%204.718%2C5.142%204.949%2C4%20h%208.102%20C%2013.295%2C5.693%2014.739%2C7%2016.5%2C7%2018.433%2C7%2020%2C5.433%2020%2C3.5%2020%2C1.566%2018.433%2C0%2016.5%2C0%20z%22%20fill%3D%22%239f9f9f%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:20px;height:7px;background-size:20px 7px}.dg-popup__button_name_show-entrance:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205%2C9%209%2C6%205%2C3%20V%205%20H%200%20V%207%20H%205%20V%209%20z%20M%209.6%2C0%20H%202.4%20C%201.074%2C0%200%2C1.074%200%2C2.4%20V%204%20H%202%20V%203.6%20C%202%2C2.716%202.716%2C2%203.6%2C2%20H%208.4%20C%209.283%2C2%2010%2C2.716%2010%2C3.6%20V%208.4%20C%2010%2C9.284%209.283%2C10%208.4%2C10%20H%203.6%20C%202.716%2C10%202%2C9.284%202%2C8.4%20V%208%20H%200%20V%209.6%20C%200%2C10.925%201.074%2C12%202.4%2C12%20H%209.6%20C%2010.926%2C12%2012%2C10.925%2012%2C9.6%20V%202.4%20C%2012%2C1.074%2010.926%2C0%209.6%2C0%20z%22%20fill%3D%22%23a0a0a0%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-firm-card__icon{position:relative;padding-left:24px}.dg-firm-card__icon:before{position:absolute;top:0;left:0;margin:auto;background-position:0 50%;background-repeat:no-repeat;content:''}.dg-firm-card__link{overflow:hidden;margin-bottom:4px;text-overflow:ellipsis;white-space:nowrap;word-wrap:normal;line-height:16px}.dg-firm-card__link a{background-position:center bottom;background-size:10px 1px;background-repeat:repeat-x;text-decoration:none}.dg-firm-card__address{margin-bottom:10px;font-size:16px}.dg-firm-card__address:before{position:absolute;top:5px;left:1px;content:''}.dg-firm-card__comment{position:relative;margin-left:5px;font-size:12px}.dg-firm-card__phone{overflow:hidden;margin-bottom:4px;text-overflow:ellipsis;line-height:16px}.dg-firm-card__phone:before{top:3px;left:1px}.dg-firm-card__site:before{top:3px}.dg-firm-card__email:before{top:5px}.dg-firm-card__rubrics{overflow:hidden;margin-bottom:4px;font-size:12px;line-height:16px}.dg-firm-card__rubrics-list{margin:0;padding:0;list-style:none}.dg-firm-card__rubrics-list-item{display:inline;cursor:default}.dg-firm-card__rubrics-list-item:before{display:inline-block;margin:0 4px;content:'•'}.dg-firm-card__rubrics-list-item:first-child:before{margin:0;content:''}.dg-firm-card__aa{margin:0 0 4px;padding:0 0 0 24px;font-size:12px}.dg-firm-card__aa-list{display:inline;margin:0;padding:0;list-style:none;line-height:16px}.dg-firm-card__aa-list-item{display:inline;-webkit-box-sizing:border-box;box-sizing:border-box;max-width:100%;cursor:default}.dg-firm-card__aa-list-item:before{display:inline-block;margin:0 4px;content:'•'}.dg-firm-card__aa-list-item:first-child:before{margin:0;content:''}.dg-firm-card__aa-list-additional{display:inline;margin:0;padding:0;list-style:none;line-height:16px}.dg-firm-card__schedule{margin-bottom:10px}.dg-firm-card__link a{background-image:-webkit-gradient(linear,left top,right top,from(rgba(255,230,170,.3)),to(rgba(255,230,170,.3)));background-image:-webkit-linear-gradient(left,rgba(255,230,170,.3),rgba(255,230,170,.3) 100%);background-image:linear-gradient(to right,rgba(255,230,170,.3),rgba(255,230,170,.3) 100%);color:#ffe6aa}.no-touch .dg-firm-card__link a:hover{background-image:-webkit-gradient(linear,left top,right top,from(rgba(153,204,221,.3)),to(rgba(153,204,221,.3)));background-image:-webkit-linear-gradient(left,rgba(153,204,221,.3),rgba(153,204,221,.3) 100%);background-image:linear-gradient(to right,rgba(153,204,221,.3),rgba(153,204,221,.3) 100%);color:#9cd}.dg-firm-card__comment,.dg-firm-card__rubrics{color:#aaa}.dg-firm-card__rubrics-list-item:after{color:#6e6964}.dg-firm-card__aa-list-item:after{color:#e6e6e6}.dg-firm-card__address:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%229%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%204.958%2C11%20C%204.958%2C9.036%206.756%2C6.751%208.719%2C6.751%208.885%2C6.223%209%2C5.656%209%2C5.063%209%2C2.267%206.985%2C0%204.5%2C0%202.015%2C0%200%2C2.267%200%2C5.063%200%2C5.656%200.114%2C6.222%200.28%2C6.751%202.243%2C6.751%204.018%2C9.012%204.018%2C11%20h%200.94%20z%22%20fill%3D%22%23a0a0a0%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:9px;height:11px;background-size:9px 11px}.dg-firm-card__phone:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%2210%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%209.181%2C9.05%20C%208.673%2C9.556%208.047%2C9.873%207.391%2C10%206.156%2C9.841%205.008%2C9.417%203.998%2C8.788%20L%201.293%2C6.092%20C%200.639%2C5.053%200.203%2C3.865%200.052%2C2.589%200.19%2C1.964%200.494%2C1.368%200.983%2C0.882%20L%201.803%2C0.065%203.987%2C2.241%20V%202.79%20L%203.441%2C3.332%20c%20-0.452%2C0.451%20-0.453%2C1.183%200%2C1.634%20L%205.082%2C6.6%20c%200.452%2C0.451%201.187%2C0.451%201.639%2C0%20L%207.244%2C6.079%20H%207.838%20L%2010%2C8.233%209.181%2C9.05%20z%22%20fill%3D%22%23a0a0a0%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:10px;height:10px;background-size:10px 10px}.dg-firm-card__site:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2211%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205.5%2C11%20C%202.463%2C11%200%2C8.538%200%2C5.5%200%2C2.462%202.463%2C0%205.5%2C0%208.537%2C0%2011%2C2.462%2011%2C5.5%2011%2C8.538%208.537%2C11%205.5%2C11%20z%20m%200%2C-9%20C%203.566%2C2%202%2C3.567%202%2C5.5%202%2C7.433%203.566%2C9%205.5%2C9%205.655%2C9%205.804%2C8.974%205.954%2C8.954%20L%203%2C6%20V%205%20L%205.571%2C3.286%205.984%2C2.049%20C%205.824%2C2.026%205.666%2C2%205.5%2C2%20z%20M%208.949%2C5%20H%207.375%20C%207.021%2C5.505%206.545%2C6.082%206%2C6.497%20V%208.95%20C%207.693%2C8.705%209%2C7.262%209%2C5.5%209%2C5.329%208.974%2C5.165%208.949%2C5%20z%22%20fill%3D%22%23a0a0a0%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:11px;height:11px;background-size:11px 11px}.dg-firm-card__email:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2211%22%20height%3D%227%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2011%2C1.555%20v%203.89%20C%2011%2C6.303%2010.242%2C7%209.309%2C7%20H%201.692%20C%200.758%2C7%200%2C6.303%200%2C5.444%20V%201.554%20L%205.5%2C4.826%2011%2C1.555%20z%20M%200.191%2C0%20H%2010.808%20L%205.5%2C3.111%200.191%2C0%20z%22%20fill%3D%22%23aaa%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:11px;height:7px;background-size:11px 7px}.dg-schedule__today{position:relative;display:inline-block;margin-left:24px;max-width:84%;background-position:center bottom;background-size:2px 1px;background-repeat:repeat-x;font-size:14px;line-height:16px;cursor:pointer}.dg-schedule__today:before{position:absolute;top:3px;left:-24px;content:''}.dg-schedule__today:after{position:absolute;right:-15px;bottom:4px;content:''}.dg-schedule__today-inner{overflow:hidden;width:100%;text-overflow:ellipsis;white-space:nowrap}.dg-schedule_works-everyday_true .dg-schedule__today{background-image:none;cursor:default}.dg-schedule_works-everyday_true .dg-schedule__today:after{background-image:none}.dg-schedule_open_true .dg-schedule__today:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2211%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205.5%2C11%20C%202.463%2C11%200%2C8.537%200%2C5.5%200%2C2.462%202.463%2C0%205.5%2C0%208.537%2C0%2011%2C2.462%2011%2C5.5%2011%2C8.537%208.537%2C11%205.5%2C11%20z%20M%206%2C5.293%20V%202%20H%205%20V%205.707%20L%207.646%2C8.353%208.353%2C7.646%206%2C5.293%20z%22%20fill%3D%22%2370bf00%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:11px;height:11px;background-size:11px 11px}.dg-schedule__now{margin:2px 7px 0 36px;font-size:12px}.dg-schedule__string{padding:3px 16px 3px 24px;text-align:left;font-size:14px}.dg-schedule__string-time{white-space:nowrap}.dg-schedule__table{display:none;text-align:center;font-size:0}.dg-schedule__table-cell-group{white-space:nowrap}.dg-schedule__tc{display:inline-block;padding:2px 0 15px;width:44px;vertical-align:top;white-space:normal;font-size:14px}.dg-schedule__tc_pre{width:19px}.dg-schedule__day-name{margin:0;color:#8c8782;text-transform:capitalize}.dg-schedule__td{margin:10px 0 0}.dg-schedule_state_expanded .dg-schedule__popup{display:block;visibility:visible;max-height:1000px;opacity:1}.dg-schedule__table-clock{margin:13px 0 0}.dg-schedule__table-lunch{margin:31px 0 0}.dg-schedule__today{background-image:-webkit-gradient(linear,left top,right top,from(rgba(230,230,230,.55)),color-stop(50%,rgba(230,230,230,.55)),color-stop(51%,rgba(0,0,0,0)),to(rgba(0,0,0,0)));background-image:-webkit-linear-gradient(left,rgba(230,230,230,.55),rgba(230,230,230,.55) 50%,rgba(0,0,0,0) 51%,rgba(0,0,0,0) 100%);background-image:linear-gradient(to right,rgba(230,230,230,.55),rgba(230,230,230,.55) 50%,rgba(0,0,0,0) 51%,rgba(0,0,0,0) 100%)}.dg-schedule__now{color:#aaa}.dg-schedule__td{color:#e6e6e6}.dg-schedule__tc_active_true{background:rgba(255,255,255,.1)}.dg-schedule__string-time{color:#e6e6e6}.dg-schedule__table-clock{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2211%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205.5%2C11%20C%202.463%2C11%200%2C8.537%200%2C5.5%200%2C2.462%202.463%2C0%205.5%2C0%208.537%2C0%2011%2C2.462%2011%2C5.5%2011%2C8.537%208.537%2C11%205.5%2C11%20z%20M%206%2C5.293%20V%202%20H%205%20V%205.707%20L%207.646%2C8.353%208.353%2C7.646%206%2C5.293%20z%22%20fill%3D%22%23a0a0a0%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:11px;height:11px;background-size:11px 11px}.dg-schedule__table-lunch{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%204%2C7%20H%208%20C%208.58%2C7%209.461%2C6.084%209.826%2C4.977%20V%205%20C%2011.047%2C5%2012%2C3.453%2012%2C2.031%2012%2C1.453%2011.531%2C1%2011.016%2C1%20H%2010%20C%2010%2C0.188%209.781%2C0%209%2C0%20H%203%20C%202.297%2C0%202%2C0.188%202%2C1%20v%203%20c%200%2C1.49%201.137%2C3%202%2C3%20z%20m%206%2C-5%20h%200.5%20C%2010.875%2C2%2011%2C2.219%2011%2C2.5%2011%2C3.625%2010.562%2C4%2010%2C4%20V%202%20z%20M%200%2C9%20c%200%2C0.448%201.791%2C1%203%2C1%200%2C0.405%200.646%2C1%201%2C1%20h%204%20c%200.354%2C0%201%2C-0.595%201%2C-1%201.208%2C0%203%2C-0.552%203%2C-1%20V%208%20H%200%20v%201%20z%22%20fill%3D%22%23aaa5a0%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:12px;height:11px;background-size:12px 11px}.dg-schedule_open_false .dg-schedule__today:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2211%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205.5%2C11%20C%202.463%2C11%200%2C8.537%200%2C5.5%200%2C2.462%202.463%2C0%205.5%2C0%208.537%2C0%2011%2C2.462%2011%2C5.5%2011%2C8.537%208.537%2C11%205.5%2C11%20z%20M%206%2C5.293%20V%202%20H%205%20V%205.707%20L%207.646%2C8.353%208.353%2C7.646%206%2C5.293%20z%22%20fill%3D%22%23a0a0a0%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:11px;height:11px;background-size:11px 11px}.dg-schedule__today:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%226%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205%2C6%20H%204.586%20L%200%2C1.414%20V%200%20H%201.414%20L%205%2C3.586%208.586%2C0%20H%2010%20V%201.414%20L%205.414%2C6%20H%205%20z%22%20fill%3D%22%23a5a09c%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:10px;height:6px;background-size:10px 6px}.dg-schedule__today_shown_true:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%226%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205%2C0%20H%205.414%20L%2010%2C4.586%20V%206%20H%208.586%20L%205%2C2.414%201.414%2C6%20H%200%20V%204.586%20L%204.586%2C0%20H%205%20z%22%20fill%3D%22%23a5a09c%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:10px;height:6px;background-size:10px 6px}.dg-link,.dg-link:hover{background-position:0 95%;background-size:10px 1px;background-repeat:repeat-x}.dg-link_type_local{background:-webkit-gradient(linear,left top,right top,from(#9cd),color-stop(50%,#9cd),color-stop(50%,transparent));background:-webkit-linear-gradient(left,#9cd,#9cd 50%,transparent 50%);background:linear-gradient(to right,#9cd,#9cd 50%,transparent 50%)}.no-touch .dg-link_type_local:hover{background:-webkit-gradient(linear,left top,right top,from(#9bc),color-stop(50%,#9bc),color-stop(50%,transparent));background:-webkit-linear-gradient(left,#9bc,#9bc 50%,transparent 50%);background:linear-gradient(to right,#9bc,#9bc 50%,transparent 50%)}.dg-link.dg-link_type_local,.dg-link.dg-link_type_local:hover{background-size:6px 1px}.dg-control-round__icon_name_traffic:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220%22%20height%3D%2214%22%20viewBox%3D%220%200%2020%2014%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2018%2C5%20C%2018%2C4%2017%2C1%2015%2C1%20H%2012%2010%20C%208%2C1%207%2C4%207%2C5%20H%205%20v%202%20h%201%20v%204%20c%200%2C0.6%200%2C1%201%2C1%20v%202%20h%202%20v%20-2%20h%207%20v%202%20h%202%20v%20-2%20c%201%2C0%201%2C-0.4%201%2C-1%20V%207%20h%201%20V%205%20H%2018%20z%20M%2010%2C3%20h%202%203%20c%202%2C0%202%2C1%202%2C3%20H%208%20C%208%2C4%208%2C3%2010%2C3%20z%20M%209%2C10%20H%208%20C%207.4%2C10%207%2C9.6%207%2C9%207%2C8.4%207.4%2C8%208%2C8%20h%201%20c%200.6%2C0%201%2C0.4%201%2C1%200%2C0.6%20-0.4%2C1%20-1%2C1%20z%20m%208%2C0%20H%2016%20C%2015.4%2C10%2015%2C9.6%2015%2C9%2015%2C8.4%2015.4%2C8%2016%2C8%20h%201%20c%200.6%2C0%201%2C0.4%201%2C1%200%2C0.6%20-0.4%2C1%20-1%2C1%20z%20M%204%2C4%20H%206%20V%203%20H%204%20C%201%2C3%201%2C6%201%2C7%20H%200%20v%201%20h%201%20v%204%20H%203%20V%2011%20H%205%20V%207%20H%202%20C%202%2C6%202%2C4%204%2C4%20z%20M%203%2C9%204%2C10%20H%202%20V%209%20h%201%20z%22%20fill%3D%22%23616161%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23fff%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22m%2016%2C8%20h%201%20c%200.4%2C0%200.7%2C0.2%200.8%2C0.5%20C%2017.9%2C8.4%2018%2C8.2%2018%2C8%2018%2C7.4%2017.6%2C7%2017%2C7%20h%20-1%20c%20-0.6%2C0%20-1%2C0.4%20-1%2C1%200%2C0.2%200.1%2C0.4%200.2%2C0.5%20C%2015.3%2C8.2%2015.6%2C8%2016%2C8%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%208%2C8%20H%209%20C%209.4%2C8%209.7%2C8.2%209.8%2C8.5%209.9%2C8.4%2010%2C8.2%2010%2C8%2010%2C7.4%209.6%2C7%209%2C7%20H%208%20C%207.4%2C7%207%2C7.4%207%2C8%207%2C8.2%207.1%2C8.4%207.2%2C8.5%207.3%2C8.2%207.6%2C8%208%2C8%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%206%2C3%20H%204%20C%204%2C3%204%2C3%204%2C3%202%2C3%202%2C5%202%2C6%20H%202%20C%202.1%2C5%202.5%2C4%204%2C4%20H%205%206%20V%203%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M0%207H1V8H0z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2015%2C2%20H%2012%2010%20C%208%2C2%208%2C3%208%2C5%20H%208%20C%208%2C3.7%208.3%2C3%2010%2C3%20h%202%203%20c%201.7%2C0%201.9%2C0.7%202%2C2%20h%200%20C%2017%2C3%2017%2C2%2015%2C2%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M3%209L4%209%203%208%202%208%202%209%202%209%202%209%203%209z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%207%2C11%20C%206%2C11%206%2C10.6%206%2C10%20v%201%20c%200%2C0.6%200%2C1%201%2C1%20v%20-1%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22m%2018%2C11%20v%201%20c%201%2C0%201%2C-0.4%201%2C-1%20v%20-1%20c%200%2C0.6%200%2C1%20-1%2C1%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M19%206H20V7H19z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M3%2011L1%2011%201%2012%203%2012%203%2011%205%2011%205%207%205%207%205%2010%203%2010z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M16%2013H18V14H16z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M5%206H6V7H5z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M9%2013L7%2013%207%2014%209%2014%209%2012%2016%2012%2016%2011%209%2011z%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23444%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%202%2C6%20C%202%2C6.4%202%2C6.7%202%2C7%20H%205%20V%206%20H%202%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M2%209L2%2010%204%2010%203%209z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%204%2C3%20H%206%20V%202%20H%204%20C%201%2C2%201%2C5%201%2C6%20H%200%20V%207%20H%201%20C%201%2C6%201%2C3%204%2C3%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2018%2C4%20C%2018%2C3%2017%2C0%2015%2C0%20H%2012%2010%20C%208%2C0%207%2C3%207%2C4%20H%206%205%20V%205%20H%207%20C%207%2C4%208%2C1%2010%2C1%20h%202%203%20c%202%2C0%203%2C3%203%2C4%20h%202%20V%204%20h%20-2%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%208%2C10%20H%209%20C%209.6%2C10%2010%2C9.6%2010%2C9%2010%2C8.8%209.9%2C8.6%209.8%2C8.5%209.7%2C8.8%209.4%2C9%209%2C9%20H%208%20C%207.6%2C9%207.3%2C8.8%207.2%2C8.5%207.1%2C8.6%207%2C8.8%207%2C9%20c%200%2C0.6%200.4%2C1%201%2C1%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017%2C6%20C%2017%2C5.6%2017%2C5.3%2017%2C5%20H%208%20c%200%2C0.3%200%2C0.6%200%2C1%20h%209%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017.8%2C8.5%20C%2017.7%2C8.8%2017.4%2C9%2017%2C9%20H%2016%20C%2015.6%2C9%2015.3%2C8.8%2015.2%2C8.5%2015.1%2C8.6%2015%2C8.8%2015%2C9%20c%200%2C0.6%200.4%2C1%201%2C1%20h%201%20c%200.6%2C0%201%2C-0.4%201%2C-1%200%2C-0.2%20-0.1%2C-0.4%20-0.2%2C-0.5%20z%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%3C%2Fsvg%3E%0A\");width:20px;height:14px;background-size:20px 14px;position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;content:''}.dg-control-round__icon_name_traffic:active:after,.no-touch .dg-control-round__icon_name_traffic:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220%22%20height%3D%2214%22%20viewBox%3D%220%200%2020%2014%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2018%2C5%20C%2018%2C4%2017%2C1%2015%2C1%20H%2012%2010%20C%208%2C1%207%2C4%207%2C5%20H%205%20v%202%20h%201%20v%204%20c%200%2C0.6%200%2C1%201%2C1%20v%202%20h%202%20v%20-2%20h%207%20v%202%20h%202%20v%20-2%20c%201%2C0%201%2C-0.4%201%2C-1%20V%207%20h%201%20V%205%20H%2018%20z%20M%2010%2C3%20h%202%203%20c%202%2C0%202%2C1%202%2C3%20H%208%20C%208%2C4%208%2C3%2010%2C3%20z%20M%209%2C10%20H%208%20C%207.4%2C10%207%2C9.6%207%2C9%207%2C8.4%207.4%2C8%208%2C8%20h%201%20c%200.6%2C0%201%2C0.4%201%2C1%200%2C0.6%20-0.4%2C1%20-1%2C1%20z%20m%208%2C0%20H%2016%20C%2015.4%2C10%2015%2C9.6%2015%2C9%2015%2C8.4%2015.4%2C8%2016%2C8%20h%201%20c%200.6%2C0%201%2C0.4%201%2C1%200%2C0.6%20-0.4%2C1%20-1%2C1%20z%20M%204%2C4%20H%206%20V%203%20H%204%20C%201%2C3%201%2C6%201%2C7%20H%200%20v%201%20h%201%20v%204%20H%203%20V%2011%20H%205%20V%207%20H%202%20C%202%2C6%202%2C4%204%2C4%20z%20M%203%2C9%204%2C10%20H%202%20V%209%20h%201%20z%22%20fill%3D%22%23424242%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23fff%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22m%2016%2C8%20h%201%20c%200.4%2C0%200.7%2C0.2%200.8%2C0.5%20C%2017.9%2C8.4%2018%2C8.2%2018%2C8%2018%2C7.4%2017.6%2C7%2017%2C7%20h%20-1%20c%20-0.6%2C0%20-1%2C0.4%20-1%2C1%200%2C0.2%200.1%2C0.4%200.2%2C0.5%20C%2015.3%2C8.2%2015.6%2C8%2016%2C8%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%208%2C8%20H%209%20C%209.4%2C8%209.7%2C8.2%209.8%2C8.5%209.9%2C8.4%2010%2C8.2%2010%2C8%2010%2C7.4%209.6%2C7%209%2C7%20H%208%20C%207.4%2C7%207%2C7.4%207%2C8%207%2C8.2%207.1%2C8.4%207.2%2C8.5%207.3%2C8.2%207.6%2C8%208%2C8%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%206%2C3%20H%204%20C%204%2C3%204%2C3%204%2C3%202%2C3%202%2C5%202%2C6%20H%202%20C%202.1%2C5%202.5%2C4%204%2C4%20H%205%206%20V%203%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M0%207H1V8H0z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2015%2C2%20H%2012%2010%20C%208%2C2%208%2C3%208%2C5%20H%208%20C%208%2C3.7%208.3%2C3%2010%2C3%20h%202%203%20c%201.7%2C0%201.9%2C0.7%202%2C2%20h%200%20C%2017%2C3%2017%2C2%2015%2C2%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M3%209L4%209%203%208%202%208%202%209%202%209%202%209%203%209z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%207%2C11%20C%206%2C11%206%2C10.6%206%2C10%20v%201%20c%200%2C0.6%200%2C1%201%2C1%20v%20-1%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22m%2018%2C11%20v%201%20c%201%2C0%201%2C-0.4%201%2C-1%20v%20-1%20c%200%2C0.6%200%2C1%20-1%2C1%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M19%206H20V7H19z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M3%2011L1%2011%201%2012%203%2012%203%2011%205%2011%205%207%205%207%205%2010%203%2010z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M16%2013H18V14H16z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M5%206H6V7H5z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M9%2013L7%2013%207%2014%209%2014%209%2012%2016%2012%2016%2011%209%2011z%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cg%20fill%3D%22%232e2e2e%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%202%2C6%20C%202%2C6.4%202%2C6.7%202%2C7%20H%205%20V%206%20H%202%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M2%209L2%2010%204%2010%203%209z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%204%2C3%20H%206%20V%202%20H%204%20C%201%2C2%201%2C5%201%2C6%20H%200%20V%207%20H%201%20C%201%2C6%201%2C3%204%2C3%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2018%2C4%20C%2018%2C3%2017%2C0%2015%2C0%20H%2012%2010%20C%208%2C0%207%2C3%207%2C4%20H%206%205%20V%205%20H%207%20C%207%2C4%208%2C1%2010%2C1%20h%202%203%20c%202%2C0%203%2C3%203%2C4%20h%202%20V%204%20h%20-2%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%208%2C10%20H%209%20C%209.6%2C10%2010%2C9.6%2010%2C9%2010%2C8.8%209.9%2C8.6%209.8%2C8.5%209.7%2C8.8%209.4%2C9%209%2C9%20H%208%20C%207.6%2C9%207.3%2C8.8%207.2%2C8.5%207.1%2C8.6%207%2C8.8%207%2C9%20c%200%2C0.6%200.4%2C1%201%2C1%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017%2C6%20C%2017%2C5.6%2017%2C5.3%2017%2C5%20H%208%20c%200%2C0.3%200%2C0.6%200%2C1%20h%209%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017.8%2C8.5%20C%2017.7%2C8.8%2017.4%2C9%2017%2C9%20H%2016%20C%2015.6%2C9%2015.3%2C8.8%2015.2%2C8.5%2015.1%2C8.6%2015%2C8.8%2015%2C9%20c%200%2C0.6%200.4%2C1%201%2C1%20h%201%20c%200.6%2C0%201%2C-0.4%201%2C-1%200%2C-0.2%20-0.1%2C-0.4%20-0.2%2C-0.5%20z%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%3C%2Fsvg%3E%0A\")}.dg-control-round__icon_state_active.dg-control-round__icon_name_traffic:active:after,.dg-control-round__icon_state_active.dg-control-round__icon_name_traffic:after,.no-touch .dg-control-round__icon_state_active.dg-control-round__icon_name_traffic:hover:after{background-image:none}a.dg-traffic-control{z-index:0;color:#f2f2f2;text-decoration:none;text-shadow:0 1px 2px rgba(0,0,0,.3);font:400 15px/32px 'Arial narrow',Arial,sans-serif}a.dg-traffic-control_color_green:after,a.dg-traffic-control_color_red:after,a.dg-traffic-control_color_yellow:after{position:absolute;top:0;right:0;bottom:0;left:0;z-index:-1;margin:auto;width:22px;height:22px;border-radius:50%;-webkit-box-shadow:inset 0 1px 0 0 rgba(0,0,0,.2),0 1px 0 0 #fff;box-shadow:inset 0 1px 0 0 rgba(0,0,0,.2),0 1px 0 0 #fff}.no-touch a.dg-traffic-control:hover{color:#f2f2f2}.no-touch a.dg-traffic-control_color_green:hover:after,.no-touch a.dg-traffic-control_color_red:hover:after,.no-touch a.dg-traffic-control_color_yellow:hover:after{width:22px;height:22px}a.dg-traffic-control_color_green:after{background:#3fc03b}.no-touch a.dg-traffic-control_color_green:hover:after,a.dg-traffic-control_color_green:active:after{background:-webkit-gradient(linear,left bottom,left top,from(#2aa731),to(#53e13a)) #3ec435;background:-webkit-linear-gradient(bottom,#2aa731,#53e13a) #3ec435;background:linear-gradient(to top,#2aa731,#53e13a) #3ec435}a.dg-traffic-control_color_yellow:after{background:#f3b223}.no-touch a.dg-traffic-control_color_yellow:hover:after,a.dg-traffic-control_color_yellow:active:after{background:-webkit-gradient(linear,left bottom,left top,from(#ef931b),to(#f7be26)) #f4a820;background:-webkit-linear-gradient(bottom,#ef931b,#f7be26) #f4a820;background:linear-gradient(to top,#ef931b,#f7be26) #f4a820}a.dg-traffic-control_color_red:after{background:#eb240c}.no-touch a.dg-traffic-control_color_red:hover:after,a.dg-traffic-control_color_red:active:after{background:-webkit-gradient(linear,left bottom,left top,from(#c01c0a),to(#f73416)) #db2811;background:-webkit-linear-gradient(bottom,#c01c0a,#f73416) #db2811;background:linear-gradient(to top,#c01c0a,#f73416) #db2811}.leaflet-rulerMarker-pane{z-index:600}.dg-ruler__label{position:absolute;top:0;left:0;z-index:200;-webkit-tap-highlight-color:transparent}.dg-ruler__label-spacer{display:block}.dg-ruler__label-container{display:none;padding:2px 4px;border:4px solid #fff;border-radius:13px;background:#0da5d5;background-clip:padding-box;color:#fff;white-space:nowrap;font-size:12px}.dg-ruler__point{display:inline-block;margin:2px 4px 0 0;width:10px;height:10px;border-radius:5px;background:#fff}.dg-ruler__label-remove-link{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206%2C0%20C%202.687%2C0%200%2C2.687%200%2C6%200%2C9.313%202.687%2C12%206%2C12%209.313%2C12%2012%2C9.313%2012%2C6%2012%2C2.687%209.313%2C0%206%2C0%20z%20M%209.401%2C9.398%208.8%2C9.6%206%2C6.8%203.199%2C9.6%202.59%2C9.415%202.375%2C8.774%205.199%2C6%202.399%2C3.175%202.62%2C2.591%203.175%2C2.375%205.949%2C5.225%208.774%2C2.375%209.415%2C2.605%209.566%2C3.196%206.824%2C6%209.6%2C8.8%209.401%2C9.398%20z%22%20fill%3D%22%23fff%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:12px;height:12px;background-size:12px 12px;display:none;margin:1px 0 0 4px;vertical-align:top;-webkit-transition:all .2s ease;transition:all .2s ease}.no-touch .dg-ruler__label-remove-link:hover{-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);transform:rotate(90deg)}.dg-ruler__remove-link-overlay{position:absolute;top:-7px;right:-7px;bottom:-7px;width:40px}.no-touch .dg-ruler__remove-link-overlay{display:none}.dg-control-round__icon_name_ruler:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%229%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2012.999%2C0%20v%204.001%20h%20-1%20V%200%20h%20-2%20v%202%20h%20-1%20V%200%20h%20-2%20V%202%20H%206%20V%200%20H%203.998%20v%204.001%20h%20-1%20V%200%20h%20-3%20V%208%20H%2016%20V%200%20z%22%20fill%3D%22%23616161%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%202.999%2C4%20h%201%20v%201%20h%20-1%20z%20m%203%2C-2%20h%201%20v%201%20h%20-1%20z%20m%203%2C0%20h%201%20v%201%20h%20-1%20z%20m%203%2C2%20h%201%20v%201%20h%20-1%20z%22%20fill%3D%22%23444%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C8%20H%2016%20V%209%20H%200%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C0%20H%203%20V%201%20H%200%20z%20m%2013%2C0%20h%203%20v%201%20h%20-3%20z%20m%20-3%2C0%20h%202%20V%201%20H%2010%20z%20M%207%2C0%20H%209%20V%201%20H%207%20z%20M%204%2C0%20H%206%20V%201%20H%204%20z%22%20fill%3D%22%23444%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:16px;height:9px;background-size:16px 9px;position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;content:''}.dg-control-round__icon_name_ruler:active:after,.no-touch .dg-control-round__icon_name_ruler:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%229%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2012.999%2C0%20v%204.001%20h%20-1%20V%200%20h%20-2%20v%202%20h%20-1%20V%200%20h%20-2%20V%202%20H%206%20V%200%20H%203.998%20v%204.001%20h%20-1%20V%200%20h%20-3%20V%208%20H%2016%20V%200%20z%22%20fill%3D%22%23424242%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%202.999%2C4%20h%201%20v%201%20h%20-1%20z%20m%203%2C-2%20h%201%20v%201%20h%20-1%20z%20m%203%2C0%20h%201%20v%201%20h%20-1%20z%20m%203%2C2%20h%201%20v%201%20h%20-1%20z%22%20fill%3D%22%232e2e2e%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C8%20H%2016%20V%209%20H%200%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C0%20H%203%20V%201%20H%200%20z%20m%2013%2C0%20h%203%20v%201%20h%20-3%20z%20m%20-3%2C0%20h%202%20V%201%20H%2010%20z%20M%207%2C0%20H%209%20V%201%20H%207%20z%20M%204%2C0%20H%206%20V%201%20H%204%20z%22%20fill%3D%22%232e2e2e%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-control-round__icon_state_active.dg-control-round__icon_name_ruler:active:after,.dg-control-round__icon_state_active.dg-control-round__icon_name_ruler:after,.no-touch .dg-control-round__icon_state_active.dg-control-round__icon_name_ruler:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%229%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2012.999%2C0%20v%204.001%20h%20-1%20V%200%20h%20-2%20v%202%20h%20-1%20V%200%20h%20-2%20V%202%20H%206%20V%200%20H%203.999%20v%204.001%20h%20-1%20V%200%20h%20-3%20V%208%20H%2016%20V%200%20z%22%20fill%3D%22%2321a7d6%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%202.999%2C4%20h%201%20v%201%20h%20-1%20z%20m%203%2C-2%20h%201%20v%201%20h%20-1%20z%20m%203%2C0%20h%201%20v%201%20h%20-1%20z%20m%203%2C2%20h%201%20v%201%20h%20-1%20z%22%20fill%3D%22%23147596%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C8%20H%2016%20V%209%20H%200%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C0%20H%203%20V%201%20H%200%20z%20m%2013%2C0%20h%203%20v%201%20h%20-3%20z%20m%20-3%2C0%20h%202%20V%201%20H%2010%20z%20M%207%2C0%20H%209%20V%201%20H%207%20z%20M%204%2C0%20H%206%20V%201%20H%204%20z%22%20fill%3D%22%23147596%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}";_dereq_("browserify-css").createStyle(css, { "href": "dist/css/styles.full.dark.css" }, { "insertAt": "bottom" });module.exports = css;
        }, { "browserify-css": 3 }], 2: [function (_dereq_, module, exports) {
            (function (process) {
                /* reduce implemintation by Mozila https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FReduce*/
                if ('function' !== typeof Array.prototype.reduce) {
                    Array.prototype.reduce = function (callback, opt_initialValue) {
                        'use strict';

                        if (null === this || 'undefined' === typeof this) {
                            // At the moment all modern browsers, that support strict mode, have
                            // native implementation of Array.prototype.reduce. For instance, IE8
                            // does not support strict mode, so this check is actually useless.
                            throw new TypeError('Array.prototype.reduce called on null or undefined');
                        }
                        if ('function' !== typeof callback) {
                            throw new TypeError(callback + ' is not a function');
                        }
                        var index,
                            value,
                            length = this.length >>> 0,
                            isValueSet = false;
                        if (1 < arguments.length) {
                            value = opt_initialValue;
                            isValueSet = true;
                        }
                        for (index = 0; length > index; ++index) {
                            if (this.hasOwnProperty(index)) {
                                if (isValueSet) {
                                    value = callback(value, this[index], index, this);
                                } else {
                                    value = this[index];
                                    isValueSet = true;
                                }
                            }
                        }
                        if (!isValueSet) {
                            throw new TypeError('Reduce of empty array with no initial value');
                        }
                        return value;
                    };
                }

                // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
                // Production steps of ECMA-262, Edition 5, 15.4.4.18
                // Reference: http://es5.github.com/#x15.4.4.18
                if (!Array.prototype.forEach) {

                    Array.prototype.forEach = function forEach(callback, thisArg) {
                        'use strict';

                        var T, k;

                        if (this == null) {
                            throw new TypeError("this is null or not defined");
                        }

                        var kValue,

                        // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
                        O = Object(this),


                        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
                        // 3. Let len be ToUint32(lenValue).
                        len = O.length >>> 0; // Hack to convert O.length to a UInt32

                        // 4. If IsCallable(callback) is false, throw a TypeError exception.
                        // See: http://es5.github.com/#x9.11
                        if ({}.toString.call(callback) !== "[object Function]") {
                            throw new TypeError(callback + " is not a function");
                        }

                        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
                        if (arguments.length >= 2) {
                            T = thisArg;
                        }

                        // 6. Let k be 0
                        k = 0;

                        // 7. Repeat, while k < len
                        while (k < len) {

                            // a. Let Pk be ToString(k).
                            //   This is implicit for LHS operands of the in operator
                            // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
                            //   This step can be combined with c
                            // c. If kPresent is true, then
                            if (k in O) {

                                // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
                                kValue = O[k];

                                // ii. Call the Call internal method of callback with T as the this value and
                                // argument list containing kValue, k, and O.
                                callback.call(T, kValue, k, O);
                            }
                            // d. Increase k by 1.
                            k++;
                        }
                        // 8. return undefined
                    };
                }

                // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
                if (!Object.keys) {
                    Object.keys = function () {
                        'use strict';

                        var hasOwnProperty = Object.prototype.hasOwnProperty,
                            hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString'),
                            dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
                            dontEnumsLength = dontEnums.length;

                        return function (obj) {
                            if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
                                throw new TypeError('Object.keys called on non-object');
                            }

                            var result = [],
                                prop,
                                i;

                            for (prop in obj) {
                                if (hasOwnProperty.call(obj, prop)) {
                                    result.push(prop);
                                }
                            }

                            if (hasDontEnumBug) {
                                for (i = 0; i < dontEnumsLength; i++) {
                                    if (hasOwnProperty.call(obj, dontEnums[i])) {
                                        result.push(dontEnums[i]);
                                    }
                                }
                            }
                            return result;
                        };
                    }();
                }

                // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
                if (!Array.prototype.some) {
                    Array.prototype.some = function (fun /*, thisArg */) {
                        'use strict';

                        if (this === void 0 || this === null) throw new TypeError();

                        var t = Object(this);
                        var len = t.length >>> 0;
                        if (typeof fun !== 'function') throw new TypeError();

                        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
                        for (var i = 0; i < len; i++) {
                            if (i in t && fun.call(thisArg, t[i], i, t)) return true;
                        }

                        return false;
                    };
                }

                // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
                if (!Array.prototype.map) {
                    Array.prototype.map = function (fun /*, thisArg */) {
                        "use strict";

                        if (this === void 0 || this === null) throw new TypeError();

                        var t = Object(this);
                        var len = t.length >>> 0;
                        if (typeof fun !== "function") throw new TypeError();

                        var res = new Array(len);
                        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
                        for (var i = 0; i < len; i++) {
                            // NOTE: Absolute correctness would demand Object.defineProperty
                            //       be used.  But this method is fairly new, and failure is
                            //       possible only if Object.prototype or Array.prototype
                            //       has a property |i| (very unlikely), so use a less-correct
                            //       but more portable alternative.
                            if (i in t) res[i] = fun.call(thisArg, t[i], i, t);
                        }

                        return res;
                    };
                }

                //From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
                if (!Array.prototype.filter) {
                    Array.prototype.filter = function (fun /*, thisArg */) {
                        "use strict";

                        if (this === void 0 || this === null) throw new TypeError();

                        var t = Object(this);
                        var len = t.length >>> 0;
                        if (typeof fun != "function") throw new TypeError();

                        var res = [];
                        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
                        for (var i = 0; i < len; i++) {
                            if (i in t) {
                                var val = t[i];

                                // NOTE: Technically this should Object.defineProperty at
                                //       the next index, as push can be affected by
                                //       properties on Object.prototype and Array.prototype.
                                //       But that method's new, and collisions should be
                                //       rare, so use the more-compatible alternative.
                                if (fun.call(thisArg, val, i, t)) res.push(val);
                            }
                        }

                        return res;
                    };
                }

                //From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
                if (!Function.prototype.bind) {
                    Function.prototype.bind = function (oThis) {
                        if (typeof this !== "function") {
                            // closest thing possible to the ECMAScript 5 internal IsCallable function
                            throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
                        }

                        var aArgs = Array.prototype.slice.call(arguments, 1),
                            fToBind = this,
                            fNOP = function () {},
                            fBound = function () {
                            return fToBind.apply(this instanceof fNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
                        };

                        fNOP.prototype = this.prototype;
                        fBound.prototype = new fNOP();

                        return fBound;
                    };
                }

                //From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf
                if (!Array.prototype.indexOf) {
                    Array.prototype.indexOf = function (searchElement, fromIndex) {
                        if (this === undefined || this === null) {
                            throw new TypeError('"this" is null or not defined');
                        }

                        var length = this.length >>> 0; // Hack to convert object.length to a UInt32

                        fromIndex = +fromIndex || 0;

                        if (Math.abs(fromIndex) === Infinity) {
                            fromIndex = 0;
                        }

                        if (fromIndex < 0) {
                            fromIndex += length;
                            if (fromIndex < 0) {
                                fromIndex = 0;
                            }
                        }

                        for (; fromIndex < length; fromIndex++) {
                            if (this[fromIndex] === searchElement) {
                                return fromIndex;
                            }
                        }

                        return -1;
                    };
                }

                if (typeof Promise !== 'function') {
                    (function () {
                        var define, requireModule, _dereq_, requirejs;

                        (function () {
                            var registry = {},
                                seen = {};

                            define = function (name, deps, callback) {
                                registry[name] = { deps: deps, callback: callback };
                            };

                            requirejs = _dereq_ = requireModule = function (name) {
                                requirejs._eak_seen = registry;

                                if (seen[name]) {
                                    return seen[name];
                                }
                                seen[name] = {};

                                if (!registry[name]) {
                                    throw new Error("Could not find module " + name);
                                }

                                var mod = registry[name],
                                    deps = mod.deps,
                                    callback = mod.callback,
                                    reified = [],
                                    exports;

                                for (var i = 0, l = deps.length; i < l; i++) {
                                    if (deps[i] === 'exports') {
                                        reified.push(exports = {});
                                    } else {
                                        reified.push(requireModule(resolve(deps[i])));
                                    }
                                }

                                var value = callback.apply(this, reified);
                                return seen[name] = exports || value;

                                function resolve(child) {
                                    if (child.charAt(0) !== '.') {
                                        return child;
                                    }
                                    var parts = child.split("/");
                                    var parentBase = name.split("/").slice(0, -1);

                                    for (var i = 0, l = parts.length; i < l; i++) {
                                        var part = parts[i];

                                        if (part === '..') {
                                            parentBase.pop();
                                        } else if (part === '.') {
                                            continue;
                                        } else {
                                            parentBase.push(part);
                                        }
                                    }

                                    return parentBase.join("/");
                                }
                            };
                        })();

                        define("promise/all", ["./utils", "exports"], function (__dependency1__, __exports__) {
                            "use strict";
                            /* global toString */

                            var isArray = __dependency1__.isArray;
                            var isFunction = __dependency1__.isFunction;

                            /**
                              Returns a promise that is fulfilled when all the given promises have been
                              fulfilled, or rejected if any of them become rejected. The return promise
                              is fulfilled with an array that gives all the values in the order they were
                              passed in the `promises` array argument.
                               Example:
                               ```javascript
                              var promise1 = RSVP.resolve(1);
                              var promise2 = RSVP.resolve(2);
                              var promise3 = RSVP.resolve(3);
                              var promises = [ promise1, promise2, promise3 ];
                               RSVP.all(promises).then(function(array){
                                // The array here would be [ 1, 2, 3 ];
                              });
                              ```
                               If any of the `promises` given to `RSVP.all` are rejected, the first promise
                              that is rejected will be given as an argument to the returned promises's
                              rejection handler. For example:
                               Example:
                               ```javascript
                              var promise1 = RSVP.resolve(1);
                              var promise2 = RSVP.reject(new Error("2"));
                              var promise3 = RSVP.reject(new Error("3"));
                              var promises = [ promise1, promise2, promise3 ];
                               RSVP.all(promises).then(function(array){
                                // Code here never runs because there are rejected promises!
                              }, function(error) {
                                // error.message === "2"
                              });
                              ```
                               @method all
                              @for RSVP
                              @param {Array} promises
                              @param {String} label
                              @return {Promise} promise that is fulfilled when all `promises` have been
                              fulfilled, or rejected if any of them become rejected.
                            */
                            function all(promises) {
                                /*jshint validthis:true */
                                var Promise = this;

                                if (!isArray(promises)) {
                                    throw new TypeError('You must pass an array to all.');
                                }

                                return new Promise(function (resolve, reject) {
                                    var results = [],
                                        remaining = promises.length,
                                        promise;

                                    if (remaining === 0) {
                                        resolve([]);
                                    }

                                    function resolver(index) {
                                        return function (value) {
                                            resolveAll(index, value);
                                        };
                                    }

                                    function resolveAll(index, value) {
                                        results[index] = value;
                                        if (--remaining === 0) {
                                            resolve(results);
                                        }
                                    }

                                    for (var i = 0; i < promises.length; i++) {
                                        promise = promises[i];

                                        if (promise && isFunction(promise.then)) {
                                            promise.then(resolver(i), reject);
                                        } else {
                                            resolveAll(i, promise);
                                        }
                                    }
                                });
                            }

                            __exports__.all = all;
                        });
                        define("promise/asap", ["exports"], function (__exports__) {
                            "use strict";

                            var browserGlobal = typeof window !== 'undefined' ? window : {};
                            var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
                            var local = window;

                            // node
                            function useNextTick() {
                                return function () {
                                    process.nextTick(flush);
                                };
                            }

                            function useMutationObserver() {
                                var iterations = 0;
                                var observer = new BrowserMutationObserver(flush);
                                var node = document.createTextNode('');
                                observer.observe(node, { characterData: true });

                                return function () {
                                    node.data = iterations = ++iterations % 2;
                                };
                            }

                            function useSetTimeout() {
                                return function () {
                                    local.setTimeout(flush, 1);
                                };
                            }

                            var queue = [];
                            function flush() {
                                for (var i = 0; i < queue.length; i++) {
                                    var tuple = queue[i];
                                    var callback = tuple[0],
                                        arg = tuple[1];
                                    callback(arg);
                                }
                                queue = [];
                            }

                            var scheduleFlush;

                            // Decide what async method to use to triggering processing of queued callbacks:
                            if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
                                scheduleFlush = useNextTick();
                            } else if (BrowserMutationObserver) {
                                scheduleFlush = useMutationObserver();
                            } else {
                                scheduleFlush = useSetTimeout();
                            }

                            function asap(callback, arg) {
                                var length = queue.push([callback, arg]);
                                if (length === 1) {
                                    // If length is 1, that means that we need to schedule an async flush.
                                    // If additional callbacks are queued before the queue is flushed, they
                                    // will be processed by this flush that we are scheduling.
                                    scheduleFlush();
                                }
                            }

                            __exports__.asap = asap;
                        });
                        define("promise/config", ["exports"], function (__exports__) {
                            "use strict";

                            var config = {
                                instrument: false
                            };

                            function configure(name, value) {
                                if (arguments.length === 2) {
                                    config[name] = value;
                                } else {
                                    return config[name];
                                }
                            }

                            __exports__.config = config;
                            __exports__.configure = configure;
                        });
                        define("promise/polyfill", ["./promise", "./utils", "exports"], function (__dependency1__, __dependency2__, __exports__) {
                            "use strict";
                            /*global self*/

                            var RSVPPromise = __dependency1__.Promise;
                            var isFunction = __dependency2__.isFunction;

                            function polyfill() {
                                var local;

                                if (typeof window !== 'undefined' && window.document) {
                                    local = window;
                                } else {
                                    local = self;
                                }

                                var es6PromiseSupport = "Promise" in local &&
                                // Some of these methods are missing from
                                // Firefox/Chrome experimental implementations
                                "resolve" in local.Promise && "reject" in local.Promise && "all" in local.Promise && "race" in local.Promise &&
                                // Older version of the spec had a resolver object
                                // as the arg rather than a function
                                function () {
                                    var resolve;
                                    new local.Promise(function (r) {
                                        resolve = r;
                                    });
                                    return isFunction(resolve);
                                }();

                                if (!es6PromiseSupport) {
                                    local.Promise = RSVPPromise;
                                }
                            }

                            __exports__.polyfill = polyfill;
                        });
                        define("promise/promise", ["./config", "./utils", "./all", "./race", "./resolve", "./reject", "./asap", "exports"], function (__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __exports__) {
                            "use strict";

                            var config = __dependency1__.config;
                            var configure = __dependency1__.configure;
                            var objectOrFunction = __dependency2__.objectOrFunction;
                            var isFunction = __dependency2__.isFunction;
                            var now = __dependency2__.now;
                            var all = __dependency3__.all;
                            var race = __dependency4__.race;
                            var staticResolve = __dependency5__.resolve;
                            var staticReject = __dependency6__.reject;
                            var asap = __dependency7__.asap;

                            var counter = 0;

                            config.async = asap; // default async is asap;

                            function Promise(resolver) {
                                if (!isFunction(resolver)) {
                                    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
                                }

                                if (!(this instanceof Promise)) {
                                    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
                                }

                                this._subscribers = [];

                                invokeResolver(resolver, this);
                            }

                            function invokeResolver(resolver, promise) {
                                function resolvePromise(value) {
                                    resolve(promise, value);
                                }

                                function rejectPromise(reason) {
                                    reject(promise, reason);
                                }

                                try {
                                    resolver(resolvePromise, rejectPromise);
                                } catch (e) {
                                    rejectPromise(e);
                                }
                            }

                            function invokeCallback(settled, promise, callback, detail) {
                                var hasCallback = isFunction(callback),
                                    value,
                                    error,
                                    succeeded,
                                    failed;

                                if (hasCallback) {
                                    try {
                                        value = callback(detail);
                                        succeeded = true;
                                    } catch (e) {
                                        failed = true;
                                        error = e;
                                    }
                                } else {
                                    value = detail;
                                    succeeded = true;
                                }

                                if (handleThenable(promise, value)) {
                                    return;
                                } else if (hasCallback && succeeded) {
                                    resolve(promise, value);
                                } else if (failed) {
                                    reject(promise, error);
                                } else if (settled === FULFILLED) {
                                    resolve(promise, value);
                                } else if (settled === REJECTED) {
                                    reject(promise, value);
                                }
                            }

                            var PENDING = void 0;
                            var SEALED = 0;
                            var FULFILLED = 1;
                            var REJECTED = 2;

                            function subscribe(parent, child, onFulfillment, onRejection) {
                                var subscribers = parent._subscribers;
                                var length = subscribers.length;

                                subscribers[length] = child;
                                subscribers[length + FULFILLED] = onFulfillment;
                                subscribers[length + REJECTED] = onRejection;
                            }

                            function publish(promise, settled) {
                                var child,
                                    callback,
                                    subscribers = promise._subscribers,
                                    detail = promise._detail;

                                for (var i = 0; i < subscribers.length; i += 3) {
                                    child = subscribers[i];
                                    callback = subscribers[i + settled];

                                    invokeCallback(settled, child, callback, detail);
                                }

                                promise._subscribers = null;
                            }

                            Promise.prototype = {
                                constructor: Promise,

                                _state: undefined,
                                _detail: undefined,
                                _subscribers: undefined,

                                then: function (onFulfillment, onRejection) {
                                    var promise = this;

                                    var thenPromise = new this.constructor(function () {});

                                    if (this._state) {
                                        var callbacks = arguments;
                                        config.async(function invokePromiseCallback() {
                                            invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);
                                        });
                                    } else {
                                        subscribe(this, thenPromise, onFulfillment, onRejection);
                                    }

                                    return thenPromise;
                                },

                                'catch': function (onRejection) {
                                    return this.then(null, onRejection);
                                }
                            };

                            Promise.all = all;
                            Promise.race = race;
                            Promise.resolve = staticResolve;
                            Promise.reject = staticReject;

                            function handleThenable(promise, value) {
                                var then = null,
                                    resolved;

                                try {
                                    if (promise === value) {
                                        throw new TypeError("A promises callback cannot return that same promise.");
                                    }

                                    if (objectOrFunction(value)) {
                                        then = value.then;

                                        if (isFunction(then)) {
                                            then.call(value, function (val) {
                                                if (resolved) {
                                                    return true;
                                                }
                                                resolved = true;

                                                if (value !== val) {
                                                    resolve(promise, val);
                                                } else {
                                                    fulfill(promise, val);
                                                }
                                            }, function (val) {
                                                if (resolved) {
                                                    return true;
                                                }
                                                resolved = true;

                                                reject(promise, val);
                                            });

                                            return true;
                                        }
                                    }
                                } catch (error) {
                                    if (resolved) {
                                        return true;
                                    }
                                    reject(promise, error);
                                    return true;
                                }

                                return false;
                            }

                            function resolve(promise, value) {
                                if (promise === value) {
                                    fulfill(promise, value);
                                } else if (!handleThenable(promise, value)) {
                                    fulfill(promise, value);
                                }
                            }

                            function fulfill(promise, value) {
                                if (promise._state !== PENDING) {
                                    return;
                                }
                                promise._state = SEALED;
                                promise._detail = value;

                                config.async(publishFulfillment, promise);
                            }

                            function reject(promise, reason) {
                                if (promise._state !== PENDING) {
                                    return;
                                }
                                promise._state = SEALED;
                                promise._detail = reason;

                                config.async(publishRejection, promise);
                            }

                            function publishFulfillment(promise) {
                                publish(promise, promise._state = FULFILLED);
                            }

                            function publishRejection(promise) {
                                publish(promise, promise._state = REJECTED);
                            }

                            __exports__.Promise = Promise;
                        });
                        define("promise/race", ["./utils", "exports"], function (__dependency1__, __exports__) {
                            "use strict";
                            /* global toString */

                            var isArray = __dependency1__.isArray;

                            /**
                              `RSVP.race` allows you to watch a series of promises and act as soon as the
                              first promise given to the `promises` argument fulfills or rejects.
                               Example:
                               ```javascript
                              var promise1 = new RSVP.Promise(function(resolve, reject){
                                setTimeout(function(){
                                  resolve("promise 1");
                                }, 200);
                              });
                               var promise2 = new RSVP.Promise(function(resolve, reject){
                                setTimeout(function(){
                                  resolve("promise 2");
                                }, 100);
                              });
                               RSVP.race([promise1, promise2]).then(function(result){
                                // result === "promise 2" because it was resolved before promise1
                                // was resolved.
                              });
                              ```
                               `RSVP.race` is deterministic in that only the state of the first completed
                              promise matters. For example, even if other promises given to the `promises`
                              array argument are resolved, but the first completed promise has become
                              rejected before the other promises became fulfilled, the returned promise
                              will become rejected:
                               ```javascript
                              var promise1 = new RSVP.Promise(function(resolve, reject){
                                setTimeout(function(){
                                  resolve("promise 1");
                                }, 200);
                              });
                               var promise2 = new RSVP.Promise(function(resolve, reject){
                                setTimeout(function(){
                                  reject(new Error("promise 2"));
                                }, 100);
                              });
                               RSVP.race([promise1, promise2]).then(function(result){
                                // Code here never runs because there are rejected promises!
                              }, function(reason){
                                // reason.message === "promise2" because promise 2 became rejected before
                                // promise 1 became fulfilled
                              });
                              ```
                               @method race
                              @for RSVP
                              @param {Array} promises array of promises to observe
                              @param {String} label optional string for describing the promise returned.
                              Useful for tooling.
                              @return {Promise} a promise that becomes fulfilled with the value the first
                              completed promises is resolved with if the first completed promise was
                              fulfilled, or rejected with the reason that the first completed promise
                              was rejected with.
                            */
                            function race(promises) {
                                /*jshint validthis:true */
                                var Promise = this;

                                if (!isArray(promises)) {
                                    throw new TypeError('You must pass an array to race.');
                                }
                                return new Promise(function (resolve, reject) {
                                    var results = [],
                                        promise;

                                    for (var i = 0; i < promises.length; i++) {
                                        promise = promises[i];

                                        if (promise && typeof promise.then === 'function') {
                                            promise.then(resolve, reject);
                                        } else {
                                            resolve(promise);
                                        }
                                    }
                                });
                            }

                            __exports__.race = race;
                        });
                        define("promise/reject", ["exports"], function (__exports__) {
                            "use strict";
                            /**
                              `RSVP.reject` returns a promise that will become rejected with the passed
                              `reason`. `RSVP.reject` is essentially shorthand for the following:
                               ```javascript
                              var promise = new RSVP.Promise(function(resolve, reject){
                                reject(new Error('WHOOPS'));
                              });
                               promise.then(function(value){
                                // Code here doesn't run because the promise is rejected!
                              }, function(reason){
                                // reason.message === 'WHOOPS'
                              });
                              ```
                               Instead of writing the above, your code now simply becomes the following:
                               ```javascript
                              var promise = RSVP.reject(new Error('WHOOPS'));
                               promise.then(function(value){
                                // Code here doesn't run because the promise is rejected!
                              }, function(reason){
                                // reason.message === 'WHOOPS'
                              });
                              ```
                               @method reject
                              @for RSVP
                              @param {Any} reason value that the returned promise will be rejected with.
                              @param {String} label optional string for identifying the returned promise.
                              Useful for tooling.
                              @return {Promise} a promise that will become rejected with the given
                              `reason`.
                            */

                            function reject(reason) {
                                /*jshint validthis:true */
                                var Promise = this;

                                return new Promise(function (resolve, reject) {
                                    reject(reason);
                                });
                            }

                            __exports__.reject = reject;
                        });
                        define("promise/resolve", ["exports"], function (__exports__) {
                            "use strict";

                            function resolve(value) {
                                /*jshint validthis:true */
                                if (value && typeof value === 'object' && value.constructor === this) {
                                    return value;
                                }

                                var Promise = this;

                                return new Promise(function (resolve) {
                                    resolve(value);
                                });
                            }

                            __exports__.resolve = resolve;
                        });
                        define("promise/utils", ["exports"], function (__exports__) {
                            "use strict";

                            function objectOrFunction(x) {
                                return isFunction(x) || typeof x === "object" && x !== null;
                            }

                            function isFunction(x) {
                                return typeof x === "function";
                            }

                            function isArray(x) {
                                return Object.prototype.toString.call(x) === "[object Array]";
                            }

                            // Date.now is not available in browsers < IE9
                            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility
                            var now = Date.now || function () {
                                return new Date().getTime();
                            };

                            __exports__.objectOrFunction = objectOrFunction;
                            __exports__.isFunction = isFunction;
                            __exports__.isArray = isArray;
                            __exports__.now = now;
                        });
                        requireModule('promise/polyfill').polyfill();
                    })();
                }

                _dereq_('leaflet');
                _dereq_('html5shiv');

                // DG inheritance
                var oldDG = window.DG;
                var DG = new (function () {
                    var DgApi = function () {},
                        DgApiCore = function () {};

                    DgApiCore.prototype = L;
                    DgApi.prototype = new DgApiCore();

                    return DgApi;
                }())();

                for (var prop in oldDG) {
                    if (oldDG.hasOwnProperty(prop) && typeof DG[prop] === 'undefined') {
                        DG[prop] = oldDG[prop];
                    }
                }

                window.__dgApi__ = window.__dgApi__ || {};
                DG.version = window.__dgApi__.version;
                DG.Icon.Default.imagePath = '../img/vendors/leaflet';

                DG.Map.addInitHook(function () {
                    var inited = false;

                    // Analytics inited once
                    return function () {
                        if (!inited) {
                            /*eslint-disable */
                            (function (i, s, o, g, r, a, m) {
                                i['GoogleAnalyticsObject'] = r;i[r] = i[r] || function () {
                                    (i[r].q = i[r].q || []).push(arguments);
                                }, i[r].l = 1 * new Date();a = s.createElement(o), m = s.getElementsByTagName(o)[0];a.async = 1;a.src = g;m.parentNode.insertBefore(a, m);
                            })(window, document, 'script', DG.config.googleAnalytics, 'ga');
                            /*eslint-enable */

                            inited = true;
                        }

                        /*eslint-disable */
                        ga('create', DG.config.gaCode, {
                            storage: 'none', // don't store and use cookies thanks GDPR
                            name: DG.config.gaName,
                            sampleRate: 50
                        });
                        ga(DG.config.gaName + '.set', 'anonymizeIp', true);
                        ga(DG.config.gaName + '.send', 'pageview');
                        /*eslint-enable */

                        var newImg = new Image();
                        newImg.src = DG.config.protocol + DG.config.analytics + '?' + 'sr=' + window.screen.width + 'x' + window.screen.height + '&' + 'v=' + DG.version;
                    };
                }());

                // Improve IHandler
                DG.Map.include({
                    addHandler: function (name, HandlerClass) {
                        if (!HandlerClass) {
                            return this;
                        }

                        var options = this.options[name],
                            param = options === Object(options) ? options : null,
                            handler = this[name] = new HandlerClass(this, param);

                        this._handlers.push(handler);

                        if (options) {
                            handler.enable();
                        }

                        return this;
                    }
                });

                // Apply class to map container for detect when we dont need hover effects
                DG.Map.addInitHook(function () {
                    if (!DG.Browser.touchEnabled) {
                        DG.DomUtil.addClass(this._container, 'no-touch');
                    }
                });

                window.DG = DG;
                module.exports = DG;

                var handlers = window.__dgApi__.callbacks || [],
                    chain = Promise.resolve();

                handlers.forEach(function (handlers) {
                    chain = chain.then(handlers[0], handlers[1]);
                });

                DG.then = function (resolve, reject) {
                    return chain.then(resolve, reject);
                };

                // IE8 throw error if `chain.catch`
                /* eslint-disable dot-notation, no-console */
                chain['catch'](function (err) {
                    console.error(err);
                });
                /* eslint-enable dot-notation, no-console */

                DG.plugin = function (plugins) {
                    var count,
                        jsReg = new RegExp(/.js$/i),
                        cssReg = new RegExp(/.css$/i);

                    return new Promise(function (resolve) {
                        function checkLoading() {
                            count--;

                            if (count === 0) {
                                resolve();
                            }
                        }

                        function appendJS(link) {
                            var js = document.createElement('script');
                            js.setAttribute('type', 'text/javascript');
                            js.setAttribute('src', link);
                            js.onload = function () {
                                checkLoading();
                            };
                            js.onerror = function () {
                                checkLoading();
                            };
                            // load/error for IE
                            js.onreadystatechange = function () {
                                if (js.readyState === 'complete' || js.readyState === 'loaded') {
                                    checkLoading();
                                }
                            };

                            document.getElementsByTagName('head')[0].appendChild(js);
                        }

                        function appendCSS(link) {
                            var css = document.createElement('link');
                            css.setAttribute('rel', 'stylesheet');
                            css.setAttribute('type', 'text/css');
                            css.setAttribute('href', link);
                            document.getElementsByTagName('head')[0].appendChild(css);

                            checkLoading();
                        }

                        function isJs(url) {
                            return jsReg.test(url);
                        }

                        function isCss(url) {
                            return cssReg.test(url);
                        }

                        function appendAsset(asset) {
                            if (isJs(asset)) {
                                appendJS(asset);
                            } else if (isCss(asset)) {
                                appendCSS(asset);
                            } else {
                                count--;
                            }
                        }

                        if (DG.Util.isArray(plugins)) {
                            count = plugins.length;
                            plugins.forEach(function (plugin) {
                                appendAsset(plugin);
                            });
                        }

                        if (typeof plugins === 'string') {
                            count = 1;
                            appendAsset(plugins);
                        }
                    });
                };

                DG.ajax = function () {

                    var win = window,
                        doc = document,
                        rurl = /^([\w.+-]+:)?(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
                        twoHundo = /^20\d$/,


                    // Document location
                    ajaxLocParts,
                        ajaxLocation,
                        byTag = 'getElementsByTagName',
                        readyState = 'readyState',
                        contentType = 'Content-Type',
                        requestedWith = 'X-Requested-With',
                        head = doc[byTag]('head')[0],
                        uniqid = 0,
                        callbackPrefix = 'l_dg_ajax_callback_' + +new Date(),
                        lastValue,
                        // data stored by the most recent JSONP callback
                    xmlHttpRequest = 'XMLHttpRequest',
                        xDomainRequest = 'XDomainRequest',
                        // IE 8 and 9 only
                    noop = function () {},
                        defaultHeaders = {
                        contentType: 'application/x-www-form-urlencoded',
                        requestedWith: xmlHttpRequest,
                        accept: {
                            '*': 'text/javascript, text/html, application/xml, text/xml, */*',
                            xml: 'application/xml, text/xml',
                            html: 'text/html',
                            text: 'text/plain',
                            json: 'application/json, text/javascript',
                            js: 'application/javascript, text/javascript'
                        }
                    },

                    /*global XDomainRequest:false */
                    xhr = function (o) {
                        // is it x-domain
                        if (o.crossDomain === true) {
                            var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null;
                            if (xhr && 'withCredentials' in xhr) {
                                return xhr;
                            } else if (win[xDomainRequest]) {
                                return new XDomainRequest();
                            } else {
                                throw new Error('Browser does not support cross-origin requests');
                            }
                        } else {
                            return new XMLHttpRequest();
                        }
                    },
                        globalSetupOptions = {
                        dataFilter: function (data) {
                            return data;
                        }
                    };

                    // IE may throw an exception when accessing
                    // a field from window.location if document.domain has been set
                    try {
                        ajaxLocation = location.href;
                    } catch (e) {
                        // Use the href attribute of an A element
                        // since IE will modify it given document.location
                        ajaxLocation = document.createElement('a');
                        ajaxLocation.href = '';
                        ajaxLocation = ajaxLocation.href;
                    }

                    // Segment location into parts
                    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

                    function handleReadyState(r, success, error) {
                        return function () {
                            // use _aborted to mitigate against IE err c00c023f
                            // (can't read props on aborted request objects)
                            if (r._aborted) {
                                return error(r.request);
                            }
                            if (r.request && r.request[readyState] === 4) {
                                r.request.onreadystatechange = noop;
                                if (twoHundo.test(r.request.status)) {
                                    success(r.request);
                                } else {
                                    error(r.request);
                                }
                            }
                        };
                    }

                    function setHeaders(http, o) {
                        var headers = o.headers || {},
                            h;

                        headers.Accept = headers.Accept || defaultHeaders.accept[o.dataType] || defaultHeaders.accept['*'];

                        // breaks cross-origin requests with legacy browsers
                        if (!o.crossDomain && !headers[requestedWith]) {
                            headers[requestedWith] = defaultHeaders.requestedWith;
                        }
                        if (!headers[contentType]) {
                            headers[contentType] = o.contentType || defaultHeaders.contentType;
                        }
                        for (h in headers) {
                            if (headers.hasOwnProperty(h) && 'setRequestHeader' in http) {
                                http.setRequestHeader(h, headers[h]);
                            }
                        }
                    }

                    function setCredentials(http, o) {
                        if (typeof o.withCredentials !== 'undefined' && typeof http.withCredentials !== 'undefined') {
                            http.withCredentials = !!o.withCredentials;
                        }
                    }

                    function generalCallback(data) {
                        lastValue = data;
                    }

                    function urlappend(url, s) {
                        return url + (/\?/.test(url) ? '&' : '?') + s;
                    }

                    function handleJsonp(o, fn, err, url) {
                        var reqId = uniqid++,
                            cbkey = o.jsonpCallback || 'callback',
                            // the 'callback' key
                        cbval = o.jsonpCallbackName || callbackPrefix,
                            cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)'),
                            match = url.match(cbreg),
                            script = doc.createElement('script'),
                            loaded = 0,
                            isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1;

                        if (match) {
                            if (match[3] === '?') {
                                url = url.replace(cbreg, '$1=' + cbval); // wildcard callback func name
                            } else {
                                cbval = match[3]; // provided callback func name
                            }
                        } else {
                            url = urlappend(url, cbkey + '=' + cbval); // no callback details, add 'em
                        }

                        win[cbval] = generalCallback;

                        script.type = 'text/javascript';
                        script.src = url;
                        script.async = true;
                        if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
                            // need this for IE due to out-of-order onreadystatechange(), binding script
                            // execution to an event listener gives us control over when the script
                            // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
                            //
                            // if this hack is used in IE10 jsonp callback are never called
                            script.event = 'onclick';
                            script.htmlFor = script.id = '_request_' + reqId;
                        }

                        script.onerror = function () {
                            script.onerror = script.onload = script.onreadystatechange = null;
                            err({}, 'Request unknown error', {});
                            lastValue = undefined;
                            head.removeChild(script);
                            loaded = 1;
                        };
                        script.onload = script.onreadystatechange = function () {
                            if (script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded' || loaded) {
                                return false;
                            }
                            script.onerror = script.onload = script.onreadystatechange = null;
                            if (script.onclick) {
                                script.onclick();
                            }
                            // Call the user callback with the last value stored and clean up values and scripts.
                            fn(lastValue);
                            lastValue = undefined;
                            head.removeChild(script);
                            loaded = 1;
                        };

                        // Add the script to the DOM head
                        head.appendChild(script);

                        // Enable JSONP timeout
                        return {
                            abort: function () {
                                script.onerror = script.onload = script.onreadystatechange = null;
                                err({}, 'Request is aborted: timeout', {});
                                lastValue = undefined;
                                head.removeChild(script);
                                loaded = 1;
                            }
                        };
                    }

                    function getRequest(fn, err) {
                        var o = this.options,
                            method = (o.type || 'GET').toUpperCase(),
                            url = typeof o === 'string' ? o : o.url,

                        // convert non-string objects to query-string form unless o.processData is false
                        data = o.processData !== false && o.data && typeof o.data !== 'string' ? Ajax.toQueryString(o.data) : o.data || null,
                            http,
                            sendWait = false;

                        // if we're working on a GET request and we have data then we should append
                        // query string to end of URL and not post data
                        if ((o.type === 'jsonp' || method === 'GET') && data) {
                            url = urlappend(url, data);
                            data = null;
                        }

                        if (o.type === 'jsonp') {
                            return handleJsonp(o, fn, err, url);
                        }

                        http = xhr(o);
                        http.open(method, url, o.async !== false);

                        setHeaders(http, o);
                        setCredentials(http, o);

                        if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
                            http.onload = fn;
                            http.onprogress = function () {};
                            http.ontimeout = function () {};
                            http.onerror = err;
                            sendWait = true;
                        } else {
                            http.onreadystatechange = handleReadyState(this, fn, err);
                        }
                        if (sendWait) {
                            setTimeout(function () {
                                http.send(data);
                            }, 200);
                        } else {
                            http.send(data);
                        }
                        return http;
                    }

                    function buildParams(prefix, obj, traditional, add) {
                        var name,
                            i,
                            v,
                            rbracket = /\[\]$/;

                        if (DG.Util.isArray(obj)) {
                            // Serialize array item.
                            for (i = 0; obj && i < obj.length; i++) {
                                v = obj[i];
                                if (traditional || rbracket.test(prefix)) {
                                    // Treat each array item as a scalar.
                                    add(prefix, v);
                                } else {
                                    buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
                                }
                            }
                        } else if (obj && obj.toString() === '[object Object]') {
                            // Serialize object item.
                            for (name in obj) {
                                if (obj.hasOwnProperty(name)) {
                                    buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
                                }
                            }
                        } else {
                            // Serialize scalar item.
                            add(prefix, obj);
                        }
                    }

                    function setType(url) {
                        var m = url.match(/\.(json|jsonp|html|xml)(\?|$)/);
                        return m ? m[1] : 'js';
                    }

                    function isCrossDomain(url) {
                        var parts = rurl.exec(url.toLowerCase());
                        return !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443'))));
                    }

                    function doRequest(o) {

                        if (!('crossDomain' in o)) {
                            o.crossDomain = isCrossDomain(o.url);
                        }

                        var self = {};
                        self.promise = new Promise(function (resolve, reject) {
                            self.abort = function () {
                                self._aborted = true;
                                reject('aborted');
                            };

                            self.url = o.url;
                            self.timeout = null;
                            self.options = o;

                            self._aborted = false;
                            self._erred = false;
                            self._responseArgs = {};

                            var type = o.type === 'jsonp' ? o.type : o.dataType || setType(self.url);

                            if (o.timeout) {
                                self.timeout = setTimeout(function () {
                                    self.abort();
                                }, o.timeout);
                            }

                            function complete(resp) {
                                if (o.timeout) {
                                    clearTimeout(self.timeout);
                                }
                                self.timeout = null;
                                if (self._erred) {
                                    reject(resp);
                                } else {
                                    resolve(resp);
                                }
                            }

                            function success(resp) {
                                resp = type !== 'jsonp' ? self.request : resp;
                                // use global data filter on response text
                                var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type),
                                    r = filteredResponse;

                                try {
                                    resp.responseText = r;
                                } catch (e) {}
                                // can't assign this in IE<=8, just ignore

                                /* eslint-disable no-eval */
                                if (r) {
                                    switch (type) {
                                        case 'json':
                                            try {
                                                resp = win.JSON.parse(r);
                                            } catch (err) {
                                                return error(resp, 'Could not parse JSON in response', err);
                                            }
                                            break;
                                        case 'js':
                                            resp = eval('(' + r + ')');
                                            break;
                                        case 'html':
                                            resp = r;
                                            break;
                                        case 'xml':
                                            resp = resp.responseXML && resp.responseXML.parseError && resp.responseXML.parseError.errorCode && resp.responseXML.parseError.reason ? null : resp.responseXML;
                                            break;
                                    }
                                }
                                /* eslint-enable no-eval */
                                self._responseArgs.resp = resp;
                                complete(resp);
                            }

                            function error(resp, msg, t) {
                                resp = self.request;
                                self._responseArgs.resp = resp;
                                self._responseArgs.msg = msg;
                                self._responseArgs.t = t;
                                self._erred = true;
                                complete(resp);
                            }

                            self.request = getRequest.call(self, success, error);
                        });

                        return self;
                    }

                    function Ajax(url, options) {

                        if (Object.prototype.toString.call(url) === '[object Object]') {
                            options = url;
                            url = undefined;
                        }
                        options = options || {};
                        options.url = url || options.url;

                        var requestPromise = doRequest(options),
                            resultPromise = requestPromise.promise;

                        if (options.success || options.error || options.complete) {
                            resultPromise.then(options.success, options.error);
                        }

                        resultPromise.abort = requestPromise.abort;

                        return resultPromise;
                    }

                    Ajax.setup = function (options) {
                        options = options || {};
                        for (var k in options) {
                            if (options.hasOwnProperty(k)) {
                                globalSetupOptions[k] = options[k];
                            }
                        }
                    };

                    Ajax.toQueryString = function (o, trad) {
                        var prefix,
                            i,
                            traditional = trad || false,
                            s = [],
                            enc = encodeURIComponent,
                            add = function (key, value) {
                            // If value is a function, invoke it and return its value
                            if (typeof value == 'function') {
                                value = value();
                            } else {
                                value = value || '';
                            }

                            s[s.length] = enc(key) + '=' + enc(value);
                        };

                        // If an array was passed in, assume that it is an array of form elements.
                        if (DG.Util.isArray(o)) {
                            for (i = 0; o && i < o.length; i++) {
                                add(o[i].name, o[i].value);
                            }
                        } else {
                            // If traditional, encode the "old" way (the way 1.3.2 or older
                            // did it), otherwise encode params recursively.
                            for (prefix in o) {
                                if (o.hasOwnProperty(prefix)) {
                                    buildParams(prefix, o[prefix], traditional, add);
                                }
                            }
                        }

                        // spaces should be + according to spec
                        return s.join('&').replace(/%20/g, '+');
                    };

                    var testxhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null;

                    Ajax.corsSupport = !(!(testxhr && 'withCredentials' in testxhr) && !win[xDomainRequest]) &&
                    // cors not available in IE and with cyrillic domain
                    !(DG.Browser.ie && document.location.host.toLowerCase().search(/[а-я]/) != -1);

                    return Ajax;
                }();

                DG.Wkt = {};

                DG.Wkt.toGeoJSON = function (data) {
                    if (DG.Util.isArray(data)) {
                        data = data[0];
                    }
                    var parts = data.split(';');
                    data = parts.pop();

                    var i = 0,
                        srid = (parts.shift() || '').split('=').pop();

                    function $(re) {
                        var match = data.substring(i).match(re);
                        if (!match) {
                            return null;
                        } else {
                            i += match[0].length;
                            return match[0];
                        }
                    }

                    function crs(obj) {
                        if (obj && srid.match(/\d+/)) {
                            obj.crs = {
                                type: 'name',
                                'properties': {
                                    name: 'urn:ogc:def:crs:EPSG::' + srid
                                }
                            };
                        }

                        return obj;
                    }

                    function white() {
                        $(/^\s*/);
                    }

                    function multicoords() {
                        white();
                        var depth = 0,
                            rings = [],
                            stack = [rings],
                            pointer = rings,
                            elem;
                        while (elem = $(/^(\()/) || $(/^(\))/) || $(/^(\,)/) || $(/^[-+]?([0-9]*\.[0-9]+|[0-9]+)/)) {
                            if (elem === '(') {
                                stack.push(pointer);
                                pointer = [];
                                stack[stack.length - 1].push(pointer);
                                depth++;
                            } else if (elem === ')') {
                                pointer = stack.pop();
                                depth--;
                                if (depth === 0) {
                                    break;
                                }
                            } else if (elem === ',') {
                                pointer = [];
                                stack[stack.length - 1].push(pointer);
                            } else {
                                pointer.push(parseFloat(elem));
                            }
                            white();
                        }
                        stack.length = 0;
                        if (depth !== 0) {
                            return null;
                        }
                        return rings;
                    }

                    function coords() {
                        var list = [],
                            item,
                            pt;
                        while (pt = $(/^[-+]?([0-9]*\.[0-9]+|[0-9]+)/) || $(/^(\,)/)) {
                            if (pt === ',') {
                                list.push(item);
                                item = [];
                            } else {
                                if (!item) {
                                    item = [];
                                }
                                item.push(parseFloat(pt));
                            }
                            white();
                        }
                        if (item) {
                            list.push(item);
                        }
                        return list.length ? list : null;
                    }

                    function point() {
                        if (!$(/^(point)/i)) {
                            return null;
                        }
                        white();
                        if (!$(/^(\()/)) {
                            return null;
                        }
                        var c = coords();
                        white();
                        if (!$(/^(\))/)) {
                            return null;
                        }
                        return {
                            type: 'Point',
                            coordinates: c[0]
                        };
                    }

                    function multipoint() {
                        if (!$(/^(multipoint)/i)) {
                            return null;
                        }
                        white();
                        var c = multicoords();
                        white();
                        return {
                            type: 'MultiPoint',
                            coordinates: c
                        };
                    }

                    function multilinestring() {
                        if (!$(/^(multilinestring)/i)) {
                            return null;
                        }
                        white();
                        var c = multicoords();
                        white();
                        return {
                            type: 'MultiLineString',
                            coordinates: c
                        };
                    }

                    function linestring() {
                        if (!$(/^(linestring)/i)) {
                            return null;
                        }
                        white();
                        if (!$(/^(\()/)) {
                            return null;
                        }
                        var c = coords();
                        if (!$(/^(\))/)) {
                            return null;
                        }
                        return {
                            type: 'LineString',
                            coordinates: c
                        };
                    }

                    function polygon() {
                        if (!$(/^(polygon)/i)) {
                            return null;
                        }
                        white();
                        return {
                            type: 'Polygon',
                            coordinates: multicoords()
                        };
                    }

                    function multipolygon() {
                        if (!$(/^(multipolygon)/i)) {
                            return null;
                        }
                        white();
                        return {
                            type: 'MultiPolygon',
                            coordinates: multicoords()
                        };
                    }

                    function geometrycollection() {
                        var geometries = [],
                            geometry;

                        if (!$(/^(geometrycollection)/i)) {
                            return null;
                        }
                        white();

                        if (!$(/^(\()/)) {
                            return null;
                        }
                        while (geometry = root()) {
                            geometries.push(geometry);
                            white();
                            $(/^(\,)/);
                            white();
                        }
                        if (!$(/^(\))/)) {
                            return null;
                        }

                        return {
                            type: 'GeometryCollection',
                            geometries: geometries
                        };
                    }

                    function root() {
                        return point() || linestring() || polygon() || multipoint() || multilinestring() || multipolygon() || geometrycollection();
                    }

                    return crs(root());
                };

                DG.Wkt.geoJsonLayer = function (data, opts) {
                    return DG.geoJson(DG.Wkt.toGeoJSON(data), opts);
                };

                DG.Wkt._coordsToLatLngs = function (coords) {
                    if (DG.Util.isArray(coords) && !DG.Util.isArray(coords[0])) {
                        return [DG.GeoJSON.coordsToLatLng(coords)];
                    }

                    return coords.map(function (el) {
                        return DG.Wkt._coordsToLatLngs(el);
                    }).reduce(function (arr, coord) {
                        return arr.concat(coord);
                    });
                };

                DG.Wkt.toLatLngs = function (data) {
                    if (!DG.Util.isArray(data)) {
                        data = [data];
                    }

                    return data.map(function (el) {
                        var coords = DG.Wkt.toGeoJSON(el).coordinates;

                        return DG.Wkt._coordsToLatLngs(coords);
                    }).reduce(function (arr, coord) {
                        return arr.concat(coord);
                    });
                };

                DG.Wkt.toPoints = function (data) {
                    return DG.Wkt.toGeoJSON(data).coordinates;
                };

                DG.Wkt.pointsToLatLngOnMap = function (wkt, map) {
                    return function parsePoints(points) {
                        return Array.isArray(points) && Array.isArray(points[0]) ? points.map(parsePoints) : map.containerPointToLatLng(points);
                    }(DG.Wkt.toPoints(wkt));
                };

                DG.ProjectDetector = DG.Handler.extend({
                    initialize: function (map) {
                        // (Object)
                        this._map = map;
                        this._osmViewport = false;
                        this._project = undefined;
                        this._loadProjectList();
                    },

                    addHooks: function () {
                        this._projectWatch();
                        this._map.on('move', this._projectWatch, this);
                    },

                    removeHooks: function () {
                        this._map.off('move', this._projectWatch, this);
                    },

                    getProject: function () {
                        if (!this._project) {
                            return false;
                        }

                        return DG.Util.extend({}, this._project);
                    },

                    getProjectsList: function () {
                        return this._projectList.slice(0);
                    },

                    isProjectHere: function (coords, project, checkMethod) {
                        if (!coords) {
                            return null;
                        }

                        if (!(coords instanceof DG.LatLng) && !(coords instanceof DG.LatLngBounds)) {
                            coords = DG.latLng(coords);
                        }

                        coords = coords instanceof DG.LatLngBounds ? DG.latLngBounds(coords.getSouthWest().wrap(), coords.getNorthEast().wrap()) : coords.wrap();

                        checkMethod = checkMethod || (coords instanceof DG.LatLngBounds ? 'intersects' : 'contains');

                        var method = checkMethod == 'intersects' ? this._testProjectIntersects : this._testProjectContains;
                        method = method.bind(this, coords);

                        if (project) {
                            return method(project);
                        } else {
                            return this._projectList.filter(method)[0];
                        }
                    },

                    _projectWatch: function () {
                        if (!this._map._loaded) {
                            return;
                        }

                        if (this._osmViewport === (this._project && this._centerInProject(this._project, 'contains'))) {
                            this._osmViewport = !this._osmViewport;
                            this._map.attributionControl._update(null, this._osmViewport);
                        }

                        if (this._project && this._zoomInProject(this._project) && this._centerInProject(this._project)) {
                            return;
                        }

                        this._searchProject();

                        if (this._project) {
                            if (this._osmViewport === (this._project && this._centerInProject(this._project, 'contains'))) {
                                this._osmViewport = !this._osmViewport;
                            }
                            this._map.attributionControl._update(null, this._osmViewport, this._project.country_code);
                        }
                    },

                    _checkProjectData: function (project) {
                        function check(value) {
                            return value !== undefined && value !== null;
                        }

                        return project && project.bounds && check(project.code) && check(project.domain) && check(project.country_code) && project.zoom_level && check(project.zoom_level.min) && check(project.zoom_level.max) && project.time_zone && check(project.time_zone.offset);
                    },

                    _loadProjectList: function () {
                        DG.fallbackProjectsList = DG.fallbackProjectsList || [];

                        if (!DG.projectsList) {
                            DG.projectsList = DG.fallbackProjectsList;
                        }
                        delete DG.fallbackProjectsList;

                        this._projectList = DG.projectsList.filter(this._checkProjectData).map(function (project) {
                            var bound = DG.Wkt.toGeoJSON(project.bounds);
                            var latLngBounds = DG.geoJSON(bound).getBounds();
                            var defaultPos = project.default_pos ? DG.latLng(project.default_pos.lat, project.default_pos.lon) : null;

                            /* eslint-disable camelcase */
                            return {
                                id: project.id,
                                code: project.code,
                                minZoom: project.zoom_level.min,
                                maxZoom: project.zoom_level.max,
                                timeOffset: project.time_zone.offset,
                                bound: bound,
                                latLngBounds: latLngBounds,
                                traffic: !!project.flags.traffic,
                                transport: !!project.flags.public_transport,
                                roads: !!project.flags.road_network,
                                country_code: project.country_code,
                                domain: project.domain,
                                defaultPos: defaultPos
                            };
                            /* eslint-enable camelcase */
                        });
                    },

                    _searchProject: function () {
                        // Вначале отсеиваем регионы по зуму
                        var filteredByZoom = this._projectList.filter(this._zoomInProject, this);

                        // Находим проект в границы которого попадает центр карты
                        var foundProjects = filteredByZoom.filter(this._centerInProject, this);

                        // Если такой проект не найден, то ищем проекты баунд боксы которых пересекаются с экраном
                        if (foundProjects.length === 0) {
                            var mapBounds = this._map.getBounds();
                            foundProjects = filteredByZoom.filter(DG.bind(this._testProjectIntersects, this, mapBounds));

                            if (foundProjects.length > 1) {
                                var mapCenter = this._map.getCenter();
                                var neareastProject = foundProjects[0];
                                for (var i = 1; i < foundProjects.length; i++) {
                                    var currentProject = foundProjects[i];
                                    if (currentProject.defaultPos && mapCenter.distanceTo(neareastProject.defaultPos) > mapCenter.distanceTo(currentProject.defaultPos)) {
                                        neareastProject = currentProject;
                                    }
                                }
                                foundProjects = [neareastProject];
                            }
                        }

                        var newProject = foundProjects[0] || null;

                        if (this._project === newProject) {
                            return;
                        }

                        var self = this;

                        if (this._project !== null) {
                            this._project = null;
                            setTimeout(function () {
                                self._map.fire('projectleave');
                            }, 1);
                        }

                        if (newProject) {
                            this._project = newProject;
                            setTimeout(function () {
                                self._map.fire('projectchange', { getProject: self.getProject.bind(self) });
                            }, 1);
                        }
                    },

                    _testProjectIntersects: function (bounds, project) {
                        return project.latLngBounds.intersects(bounds);
                    },

                    _testProjectContains: function (latlng, project) {
                        return DG.PolyUtil.inside([latlng.lng, latlng.lat], project.bound);
                    },

                    _centerInProject: function (project, checkMethod) {
                        return this.isProjectHere(this._map.getCenter(), project, checkMethod);
                    },

                    _zoomInProject: function (project) {
                        return this._map.getZoom() >= project.minZoom;
                    }
                });

                DG.Map.mergeOptions({
                    projectDetector: true
                });

                DG.Map.addInitHook('addHandler', 'projectDetector', DG.ProjectDetector);

                /*
                 * Utility functions
                 */

                DG.Metric = function () {};

                /*
                 * DG.Metric.Segments class can calculate total pushed segments length and used to shortcut
                 * 'get Something by provided Length' calculations (segment's Index, segment's Length, etc...)
                 */
                DG.Metric.Segments = function () {
                    this.length = 0;
                };

                DG.Metric.Segments.prototype = {
                    push: function (len) {
                        this[this.length] = this.length > 0 ? this[this.length - 1] + len : len;
                        this.length += 1;

                        return this;
                    },

                    getLength: function () {
                        return this[this.length - 1];
                    },

                    getReverse: function () {
                        var segments = new DG.Metric.Segments();
                        var i = this.length - 1;

                        if (i < 0) {
                            return segments;
                        }

                        while (i--) {
                            segments.push(this[i + 1] - this[i]);
                        }

                        return segments.push(this[0]);
                    },

                    getIndex: function (len) {
                        var i = this.length - 1;

                        if (i < 0) {
                            return i;
                        }

                        while (i--) {
                            if (this[i] <= len) {
                                break;
                            }
                        }

                        return i + 1;
                    },

                    getSegRatio: function (len) {
                        var i = this.getIndex(len);
                        var sub = i > 0 ? this[i - 1] : 0;

                        return (len - sub) / (this[i] - sub);
                    },

                    getSegLength: function (len) {
                        var i = this.getIndex(len);
                        var sub = i > 0 ? this[i - 1] : 0;

                        return len - sub;
                    }
                };

                /*
                 * DG.VertexTransform is a classic 2D matrix transformation class
                 *
                 * Prototype methods can scale/rotate/translate vertices
                 *
                 * Static methods do the same but return simple array instances with attached
                 * .clone() method which can reconstruct full DG.VertexTransform object
                 */

                DG.VertexTransform = DG.Class.extend({
                    initialize: function (vertices) {
                        this._vertices = vertices;

                        this._scale = null;
                        this._angle = null;
                        this._trans = null;
                        this._matrix = null;

                        this.load();
                    },

                    load: function () {
                        this.vertices = this._vertices.map(function (vertex) {
                            return vertex.clone();
                        });
                        this.vertices.clone = DG.VertexTransform.clone;

                        return this;
                    },

                    save: function () {
                        this._vertices = this.vertices.map(function (vertex) {
                            return vertex.clone();
                        });

                        return this;
                    },

                    setScale: function (scale) {
                        this._scale = scale;
                        return this;
                    },

                    getScale: function () {
                        return this._scale;
                    },

                    setAngle: function (angle) {
                        this._angle = angle;
                        return this;
                    },

                    getAngle: function () {
                        return this._angle;
                    },

                    setTranslation: function (trans) {
                        this._trans = trans;
                        return this;
                    },

                    getTranslation: function () {
                        return this._trans;
                    },

                    setMatrix: function (matrix) {
                        this._matrix = matrix;
                        return this;
                    },

                    getMatrix: function () {
                        return this._matrix;
                    },

                    scale: function (scale) {
                        var v = this.vertices;
                        var i = v.length;

                        scale = scale || this._scale || 1;
                        while (i--) {
                            v[i].x *= scale;
                            v[i].y *= scale;
                        }

                        return this;
                    },

                    unScale: function (scale) {
                        scale = scale || this._scale || 1; //  Also safeguard against zero scale
                        return this.scale(1 / scale);
                    },

                    rotate: function (angle) {
                        var cos = angle ? angle.cos : this._angle ? this._angle.cos : 1;
                        var sin = angle ? angle.sin : this._angle ? this._angle.sin : 0;
                        var v = this.vertices;
                        var i = v.length;
                        var x, y;

                        while (i--) {
                            x = v[i].x;
                            y = v[i].y;
                            v[i].x = x * cos - y * sin;
                            v[i].y = x * sin + y * cos;
                        }

                        return this;
                    },

                    unRotate: function (angle) {
                        var cos = angle ? angle.cos : this._angle ? this._angle.cos : 1;
                        var sin = angle ? angle.sin : this._angle ? this._angle.sin : 0;

                        return this.rotate({ cos: cos, sin: -sin });
                    },

                    translate: function (trans) {
                        var dx = trans ? trans.x : this._trans ? this._trans.x : 0;
                        var dy = trans ? trans.y : this._trans ? this._trans.y : 0;
                        var v = this.vertices;
                        var i = v.length;

                        while (i--) {
                            v[i].x += dx;
                            v[i].y += dy;
                        }

                        return this;
                    },

                    unTranslate: function (trans) {
                        var dx = trans ? trans.x : this._trans ? this._trans.x : 0;
                        var dy = trans ? trans.y : this._trans ? this._trans.y : 0;

                        return this.translate({ x: -dx, y: -dy });
                    },

                    transform: function (matrix) {
                        var a, b, c, d, dx, dy;
                        var v = this.vertices;
                        var i = v.length;
                        var x, y;

                        if (matrix) {
                            a = matrix[0];b = matrix[1];dx = matrix[2];
                            c = matrix[3];d = matrix[4];dy = matrix[5];
                        } else if (this._matrix) {
                            a = this._matrix[0];b = this._matrix[1];dx = this._matrix[2];
                            c = this._matrix[3];d = this._matrix[4];dy = this._matrix[5];
                        } else {
                            a = 1;b = 0;dx = 0;
                            c = 0;d = 1;dy = 0;
                        }

                        while (i--) {
                            x = v[i].x;
                            y = v[i].y;
                            v[i].x = x * a + y * b + dx;
                            v[i].y = x * c + y * d + dy;
                        }

                        return this;
                    },

                    statics: {
                        scale: function (vt, scale) {
                            var v = vt.vertices;
                            var result = [];
                            var x, y;

                            scale = scale || 1;
                            for (var i = 0; i < v.length; i++) {
                                x = v[i].x * scale;
                                y = v[i].y * scale;
                                result.push(new DG.Point(x, y));
                            }
                            result.clone = DG.VertexTransform.clone;

                            return result;
                        },

                        unScale: function (vt, scale) {
                            scale = scale || 1; //  Also safeguard against zero scale
                            return DG.VertexTransform.scale(vt, 1 / scale);
                        },

                        rotate: function (vt, angle) {
                            var cos = angle ? angle.cos : 1;
                            var sin = angle ? angle.sin : 0;
                            var v = vt.vertices;
                            var x, y, rx, ry;
                            var result = [];

                            for (var i = 0; i < v.length; i++) {
                                rx = v[i].x;
                                ry = v[i].y;
                                x = rx * cos - ry * sin;
                                y = rx * sin + ry * cos;
                                result.push(new DG.Point(x, y));
                            }
                            result.clone = DG.VertexTransform.clone;

                            return result;
                        },

                        unRotate: function (vt, angle) {
                            var cos = angle ? angle.cos : 1;
                            var sin = angle ? angle.sin : 0;

                            return DG.VertexTransform.rotate(vt, { cos: cos, sin: -sin });
                        },

                        translate: function (vt, trans) {
                            var dx = trans ? trans.x : 0;
                            var dy = trans ? trans.y : 0;
                            var v = vt.vertices;
                            var result = [];
                            var x, y;

                            for (var i = 0; i < v.length; i++) {
                                x = v[i].x + dx;
                                y = v[i].y + dy;
                                result.push(new DG.Point(x, y));
                            }
                            result.clone = DG.VertexTransform.clone;

                            return result;
                        },

                        unTranslate: function (vt, trans) {
                            var dx = trans ? trans.x : 0;
                            var dy = trans ? trans.y : 0;

                            return DG.VertexTransform.translate(vt, { x: -dx, y: -dy });
                        },

                        clone: function () {
                            //  'this' is an array
                            return new DG.VertexTransform(this).save();
                        },

                        getLength: function (vec1, vec2) {
                            var dx, dy;

                            if (typeof vec1 === 'number') {
                                //  'vec1' and 'vec2' are absolute coordinates of vector
                                return Math.sqrt(vec1 * vec1 + vec2 * vec2);
                            } else {
                                //  'vec1' and 'vec2' are vector objects
                                dx = vec2.x - vec1.x;
                                dy = vec2.y - vec1.y;
                                return Math.sqrt(dx * dx + dy * dy);
                            }
                        },

                        getScaled: function (vec1, vec2, scale) {
                            var dx, dy;

                            if (typeof vec1 === 'number') {
                                //  'vec1' and 'vec2' are absolute coordinates of vector
                                return new DG.Point(vec1 * scale, vec2 * scale);
                            } else {
                                //  'vec1' and 'vec2' are vector objects
                                dx = (vec2.x - vec1.x) * scale;
                                dy = (vec2.y - vec1.y) * scale;
                                return new DG.Point(vec1.x + dx, vec1.y + dy);
                            }
                        },

                        getAngle: function (vec1, vec2, origin) {
                            var l, sp, x1, y1, x2, y2;

                            if (typeof vec1 === 'number') {
                                //  'vec1' and 'vec2' are absolute coordinates of vector
                                l = Math.sqrt(vec1 * vec1 + vec2 * vec2);
                                if (l > 0) {
                                    return { cos: vec1 / l, sin: vec2 / l };
                                } else {
                                    return { cos: 1, sin: 0 };
                                }
                            } else {
                                //  'vec1' and 'vec2' are vector objects
                                x1 = vec1.x;y1 = vec1.y;
                                x2 = vec2.x;y2 = vec2.y;
                                if (origin) {
                                    x1 -= origin.x;y1 -= origin.y;
                                    x2 -= origin.x;y2 -= origin.y;
                                }
                                sp = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2);
                                return {
                                    cos: (x1 * x2 + y1 * y2) / sp,
                                    sin: (x1 * y2 - x2 * y1) / sp
                                };
                            }
                        },

                        getAnglesSum: function (angle1, angle2) {
                            return {
                                cos: angle1.cos * angle2.cos - angle1.sin * angle2.sin,
                                sin: angle1.sin * angle2.cos + angle1.cos * angle2.sin
                            };
                        },

                        getAnglesDif: function (angle1, angle2) {
                            return {
                                cos: angle1.cos * angle2.cos + angle1.sin * angle2.sin,
                                sin: angle1.sin * angle2.cos - angle1.cos * angle2.sin
                            };
                        }
                    }
                });

                /*
                 * DG.ArrowPathTransform class is a core of arrow's body calculations
                 *
                 * General ideas are:
                 *      We construct arrow body with stroke points making arcs on outer path turns
                 *      Processing is done segment by segment around {0, 0} virtual point
                 *          and resulting 'path' finally rotated to it's original map's angle (.fullAngle)
                 *      Subset of this vertices lately used in .subPath() calculations which can be used
                 *          in animations for ex.
                 *
                 *  Final translation (see DG.Entrance.Arrow) moves arrow objects to their original positions
                 */

                DG.ArrowPathTransform = DG.VertexTransform.extend({
                    initialize: function (path) {
                        //  'path.offset' is initial points offset (-x / +x) to compensate arrow tip length

                        //  Skip super initialization as we need only subset of DG.VertexTransform power
                        this._lengths = new DG.Metric.Segments();
                        this._vertices = [[], []];
                        this._drawings = [[], []];
                        //  this._arcs = [];    //  initialized in _setPath()

                        this._setPath(path);
                        this.subPath(1);
                    },

                    load: function () {
                        return this.subPath(1);
                    },

                    save: function () {
                        return this; //  NoOp
                    },

                    //  Method constructs new path points with some displacement from original 'path'
                    //  Outer corners will be smoothed by arcs (cubic Bézier curves)
                    _setPath: function (path) {
                        var transform = DG.ArrowPathTransform.transform;
                        var vertices = this._vertices;
                        var drawings = this._drawings;
                        var Point = DG.Point;
                        var width = path.width;
                        var arcs = [[], [], []];
                        var lengths = [];

                        var i, x, ax, bx, cx, angles, angle;

                        vertices.push(path.vertices); //  expect .pop() in final transform
                        vertices[0].push(new DG.Point(path.offset, +width));
                        vertices[1].push(new DG.Point(path.offset, -width));
                        angles = DG.ArrowPathTransform.getAngles(path);

                        cx = -path.offset;
                        for (i = 0; i < angles.length; i++) {
                            x = path.vertices[i + 1].x;
                            ax = width * angles[i].cot;

                            //  http://pomax.github.io/bezierinfo/#circles_cubic
                            //  actual equation is (4/3 * tan(α/4) * radius)
                            bx = angles[i].tan * width * 8 / 3;

                            //  Next code can be combined by -/+ inversion but for simplicity it is left as is
                            if (ax > 0) {
                                vertices[0].push(new Point(x + ax, +width));
                                drawings[0].push('L');

                                arcs[2].push(1);
                                arcs[1].push(vertices[1].length);
                                vertices[1].push(new Point(x + ax, -width));
                                vertices[1].push(new Point(x + ax - bx, -width));

                                transform(vertices, angles[i], { x: x, y: 0 });

                                vertices[1].push(new Point(0 - ax + bx, -width));
                                vertices[1].push(new Point(0 - ax, -width));
                                drawings[1].push('L', 'C');

                                lengths.push(Math.abs(x + ax) - cx);cx = +ax;
                            } else {
                                vertices[1].push(new Point(x - ax, -width));
                                drawings[1].push('L');

                                arcs[2].push(0);
                                arcs[0].push(vertices[0].length);
                                vertices[0].push(new Point(x - ax, +width));
                                vertices[0].push(new Point(x - ax + bx, +width));

                                transform(vertices, angles[i], { x: x, y: 0 });

                                vertices[0].push(new Point(0 + ax - bx, +width));
                                vertices[0].push(new Point(0 + ax, +width));
                                drawings[0].push('L', 'C');

                                lengths.push(Math.abs(x - ax) - cx);cx = -ax;
                            }
                        }

                        //  Final segments and tail arc
                        ax = path.vertices[i + 1].x;
                        bx = width * 4 / 3; // tan(PI/4) = 1

                        vertices[0].push(new Point(ax, +width));
                        vertices[1].push(new Point(ax, -width));

                        vertices[0].push(new Point(ax - bx, +width));
                        vertices[1].push(new Point(ax - bx, -width));

                        drawings[0].push('L');
                        drawings[1].push('L');

                        lengths.push(Math.abs(ax) - cx);

                        //  Reverse right path
                        vertices[1].reverse();
                        drawings[1].reverse();

                        //  Move vertices into original position (before last translation)
                        angle = DG.VertexTransform.getAnglesSum(angles.fullAngle, path.getAngle());
                        transform(vertices, angle, vertices.pop()[0]); //  path.vertices[0]

                        //  We need to reconstruct arc's indexes but too many variables already touched, reuse some of them
                        ax = vertices[0].length;
                        bx = vertices[1].length;
                        this._arcs = arcs[2].map(function (i) {
                            cx = arcs[i].shift();
                            if (i > 0) {
                                return new DG.ArcBezier(vertices[1].slice(bx - cx - 4, bx - cx));
                            } else {
                                return new DG.ArcBezier(vertices[0].slice(cx, cx + 4).reverse());
                            }
                        }).reverse();

                        this._lengths.push(lengths.pop());
                        lengths.reverse().forEach(function (l, i) {
                            this._lengths.push(this._arcs[i].getLength()).push(l);
                        }, this);

                        //  Shortcut border cases (0%-length sub-path and full-path)
                        this[0] = {
                            vertices: [vertices[0][ax - 2], vertices[0][ax - 1], vertices[1][0], vertices[1][1]],
                            drawings: ['M', 'C']
                        };
                        this[1] = {
                            vertices: vertices[0].concat(vertices[1]),
                            drawings: ['M'].concat(drawings[0], 'C', drawings[1])
                        };
                    },

                    _setAngleAndDisplacement: function (vL, vR) {
                        // Used in DG.ArrowTipTransform.subShape()
                        this.angle = DG.VertexTransform.getAngle({ x: vL.x - vR.x, y: vL.y - vR.y }, { x: 0, y: 1 });
                        this.displ = vR.clone();
                    },

                    subPath: function (pathRatio) {
                        pathRatio = pathRatio > 1 ? 1 : pathRatio;

                        //  Shortcut border cases (0%-length sub-path and full-path)
                        if (pathRatio === 0 || pathRatio === 1) {
                            this.vertices = this[pathRatio].vertices.map(function (vertex) {
                                return vertex.clone();
                            });
                            this.drawings = this[pathRatio].drawings;
                            this._setAngleAndDisplacement(this.vertices[0], this.vertices[this.vertices.length - 1]);
                            return this;
                        }

                        var getScaled = DG.VertexTransform.getScaled;
                        var vertices = this._vertices;
                        var drawings = this._drawings;
                        var lengths = this._lengths;
                        var len = lengths.getLength() * pathRatio;
                        var segIndex = lengths.getIndex(len);
                        var segRatio = lengths.getSegRatio(len);
                        var vertexIndexLeft = vertices[0].length - 2;
                        var vertexIndexRight = 1;
                        var drawingIndexLeft = drawings[0].length - 1;
                        var drawingIndexRight = 0;
                        var vertexLeft, vertexRight;
                        var arc = 0,
                            aed = 0;

                        while (aed++ < segIndex) {
                            if (aed % 2 == 1) {
                                vertexIndexLeft--;
                                drawingIndexLeft--;
                                vertexIndexRight++;
                                drawingIndexRight++;
                            } else {
                                if (drawings[0][drawingIndexLeft] === 'C') {
                                    vertexIndexLeft -= 3;
                                    drawingIndexLeft -= 1;
                                } else {
                                    vertexIndexRight += 3;
                                    drawingIndexRight += 1;
                                }
                                arc++;
                            }
                        }

                        if (segIndex % 2 == 1) {
                            //  One path ends with an arc
                            arc = this._arcs[arc];
                            if (drawings[0][drawingIndexLeft] === 'C') {
                                arc = arc.getCurveBefore(arc.getTbyL(lengths.getSegLength(len)));
                                vertexLeft = arc.points[3];
                                vertexRight = vertices[1][vertexIndexRight];
                                this.vertices = arc.points.slice(1).reverse().concat(vertices[0].slice(vertexIndexLeft), vertices[1].slice(0, vertexIndexRight + 1)).map(function (vertex) {
                                    return vertex.clone();
                                });
                                this.drawings = ['M'].concat(drawings[0].slice(drawingIndexLeft), 'C', drawings[1].slice(0, drawingIndexRight));
                            } else {
                                arc = arc.getCurveBefore(arc.getTbyL(lengths.getSegLength(len)));
                                vertexLeft = vertices[0][vertexIndexLeft];
                                vertexRight = arc.points[3];
                                this.vertices = vertices[0].slice(vertexIndexLeft).concat(vertices[1].slice(0, vertexIndexRight + 1), arc.points.slice(1)).map(function (vertex) {
                                    return vertex.clone();
                                });
                                this.drawings = ['M'].concat(drawings[0].slice(drawingIndexLeft + 1), 'C', drawings[1].slice(0, drawingIndexRight + 1));
                            }
                        } else {
                            //  Both paths end with lines
                            vertexLeft = getScaled(vertices[0][vertexIndexLeft], vertices[0][vertexIndexLeft - 1], segRatio);
                            vertexRight = getScaled(vertices[1][vertexIndexRight], vertices[1][vertexIndexRight + 1], segRatio);
                            this.vertices = [vertexLeft].concat(vertices[0].slice(vertexIndexLeft), vertices[1].slice(0, vertexIndexRight + 1), vertexRight).map(function (vertex) {
                                return vertex.clone();
                            });
                            this.drawings = ['M'].concat(drawings[0].slice(drawingIndexLeft), 'C', drawings[1].slice(0, drawingIndexRight + 1));
                        }

                        this._setAngleAndDisplacement(vertexLeft, vertexRight);
                        return this;
                    },

                    statics: {
                        getAngles: function (path) {
                            var getAngle = DG.VertexTransform.getAngle;
                            var fullAngle = { cos: 1, sin: 0 };
                            var vertices = path.vertices;
                            var angles = [];

                            var absSin, angle, cos, sin, cot, temp, sign;

                            for (var i = 1, len = vertices.length - 1; i < len; i++) {
                                angle = getAngle(vertices[i - 1], vertices[i + 1], vertices[i]);

                                absSin = Math.abs(angle.sin);
                                if (absSin < 0.000001) {
                                    //  Exclude 180° angle from vertices array
                                    vertices.splice(vertices.length - i - 1, 1);
                                    len--;
                                    i--;
                                } else {
                                    //  This is half ∢α cotangent, sign describes angle direction and used to shortcut stroke calculations
                                    //  '-1' - right angle is inner angle, '1' - left angle is inner angle (if seen from [0, 0] to [-1, 0])
                                    angle.cot = (1 + angle.cos) / angle.sin;

                                    //  We need to rotate next segment to [-1, 0] axis, so we need complementary angle actually
                                    angle.cos = -angle.cos;

                                    //  Complimentary angle also used to calculate it's quaternary ∢β tangent
                                    //  ∢β tangent used in approximation of outer arc segment by Bézier curve
                                    cot = (1 + angle.cos) / angle.sin;
                                    sign = cot < 0 ? -1 : 1;
                                    temp = sign * Math.sqrt(4 * cot * cot + 4);
                                    angle.tan = -0.5 * (cot + cot - temp);

                                    angles.push(angle);

                                    cos = fullAngle.cos * angle.cos - fullAngle.sin * angle.sin;
                                    sin = fullAngle.sin * angle.cos + fullAngle.cos * angle.sin;

                                    fullAngle = { cos: cos, sin: sin };
                                }
                            }

                            //  Used in final stroke points translation
                            angles.fullAngle = { cos: fullAngle.cos, sin: -fullAngle.sin };
                            return angles;
                        },

                        //  TODO - if length of 'latlngs' array is less than 2 or it is undefined next function produces exception
                        //  check this condition in outer routines?!
                        getTranslatedPath: function (map, latlngs) {
                            var path = new DG.VertexTransform([]);
                            var i = latlngs.length - 1;
                            var v = map.project(latlngs[i]);
                            var dx = v.x,
                                dy = v.y;

                            path.vertices.push(new DG.Point(0, 0));
                            while (i--) {
                                v = map.project(latlngs[i]);
                                path.vertices.push(new DG.Point(v.x - dx, v.y - dy));
                            }
                            return path.setAngle(DG.VertexTransform.getAngle(-path.vertices[1].x, -path.vertices[1].y)).unRotate();
                        },

                        transform: function (rings, angle, vector) {
                            var i = rings.length;
                            var cos = angle.cos;
                            var sin = angle.sin;
                            var dx = vector.x;
                            var dy = vector.y;
                            var ring, x, y, j;

                            while (i--) {
                                ring = rings[i];
                                j = ring.length;
                                while (j--) {
                                    x = ring[j].x - dx;
                                    y = ring[j].y - dy;
                                    ring[j].x = x * cos - y * sin;
                                    ring[j].y = x * sin + y * cos;
                                }
                            }
                        }
                    }
                });

                /*
                 * DG.ArrowTipTransform class is a core of arrow's tip calculations
                 *
                 * .subShape() routine 'bound' arrow's tip to the ending points of .subPath()
                 * calculated separately in DG.ArrowPathTransform
                 *
                 *  Final translation (see DG.Entrance.Arrow) moves arrow objects to their original positions
                 */

                DG.ArrowTipTransform = DG.VertexTransform.extend({
                    initialize: function (path, shape) {
                        this.drawings = shape.drawings; //  static mapping
                        this._vertices = shape.vertices;

                        this._setShape(path, shape);
                    },

                    _setShape: function (path, shape) {
                        var sp = shape.vertices[0];
                        var width = Math.abs(sp.y);
                        var pl = path.vertices[1].x; //  negative value
                        var length = sp.x; //  negative value
                        var offset = pl - length + width + width;

                        path.width = width;
                        path.offset = length + (offset > 0 ? offset : 0);
                        if (path.vertices.length < 3 && length > -10) {
                            path.offset += 2.5;
                        }

                        this._vertices = this.load().unTranslate(sp).vertices;
                    },

                    subShape: function (transform) {
                        this.load().unRotate(transform.angle).translate(transform.displ);
                        return this;
                    }
                });

                /*
                 * DG.ComplexPath is a simple vector layer class with empty .getEvents() object(!)
                 * It's drawing logic is maintained in DG.Entrance.Arrow class
                 *
                 * _pxBounds is a pixel bounds of this drawings and they are used in L.Canvas
                 */

                DG.ComplexPath = DG.Path.extend({
                    options: {
                        fill: true,
                        fillOpacity: 1,
                        interactive: false
                    },

                    initialize: function (options) {
                        DG.setOptions(this, options);

                        this._empty = [];

                        this._pxEmpty = DG.bounds(DG.point(0, 0), DG.point(0, 0));
                        this._pxBounds = this._pxEmpty;

                        this._vertices = [this._empty];
                        this._drawings = [this._empty];
                    },

                    getEvents: function () {
                        return {};
                    },

                    _project: function () {
                        var opts = this.options,
                            zoom,
                            weight;

                        if (this._map) {
                            zoom = this._map.getZoom();
                        } else {
                            return;
                        }

                        if (opts.visibility.isShown && opts.transform[zoom]) {
                            //  Next numbers was empirically selected in order to provide visual compliance
                            //  to the original arrow's implementation
                            weight = 2.2 - (19 - zoom) * 0.2;
                            if (opts.weight !== weight) {
                                this.setStyle({ weight: +weight.toFixed(2) });
                            }

                            this._vertices[0] = opts.transform[zoom].vertices;
                            this._drawings[0] = opts.transform[zoom].drawings;

                            this._pxBounds = opts.transform[zoom]._pxBounds;
                        } else {
                            this._vertices[0] = this._empty;
                            this._drawings[0] = this._empty;

                            this._pxBounds = this._pxEmpty;
                        }
                    },

                    _update: function () {
                        if (this._map) {
                            this._updatePath();
                        }
                    },

                    _updatePath: function () {
                        //  used in Canvas renderer
                        this._renderer._updateComplexPath(this);
                    }
                });

                /*
                 * Actual painting methods that can draw complex objects with curves
                 *
                 * Point coordinates must be provided in layer._vertices object
                 * And types of line must be provided in layer._drawings object
                 */

                DG.extend(L.Canvas.prototype, {
                    _updateComplexPath: function (layer, closed) {
                        var i, j, k, d, x, y, _x, _y, $x, $y, points;
                        var drawings = layer._drawings;
                        var vertices = layer._vertices;
                        var ctx = this._ctx;

                        this._drawnLayers[layer._leaflet_id] = layer;

                        //  TODO: Do we need to do a 'beginPath()' and possible 'closePath()' per ring?!
                        ctx.beginPath();

                        for (i = 0; i < vertices.length; i++) {
                            points = vertices[i];
                            x = y = 0;
                            j = k = 0;
                            while (j < points.length) {
                                d = drawings[i][k++];
                                switch (d) {
                                    case 'M':
                                        x = points[j].x;
                                        y = points[j].y;
                                        j += 1;
                                        ctx.moveTo(x, y);
                                        break;

                                    case 'm':
                                        x += points[j].x;
                                        y += points[j].y;
                                        j += 1;
                                        ctx.moveTo(x, y);
                                        break;

                                    case 'L':
                                        x = points[j].x;
                                        y = points[j].y;
                                        j += 1;
                                        ctx.lineTo(x, y);
                                        break;

                                    case 'l':
                                        x += points[j].x;
                                        y += points[j].y;
                                        j += 1;
                                        ctx.lineTo(x, y);
                                        break;

                                    case 'C':
                                        _x = points[j].x;
                                        _y = points[j].y;
                                        j += 1;
                                        $x = points[j].x;
                                        $y = points[j].y;
                                        j += 1;
                                        x = points[j].x;
                                        y = points[j].y;
                                        j += 1;
                                        ctx.bezierCurveTo(_x, _y, $x, $y, x, y);
                                        break;

                                    case 'c':
                                        _x = x + points[j].x;
                                        _y = y + points[j].y;
                                        j += 1;
                                        $x = x + points[j].x;
                                        $y = y + points[j].y;
                                        j += 1;
                                        x = x + points[j].x;
                                        y = y + points[j].y;
                                        j += 1;
                                        ctx.bezierCurveTo(_x, _y, $x, $y, x, y);
                                        break;

                                    case 'Q':
                                        _x = points[j].x;
                                        _y = points[j].y;
                                        j += 1;
                                        x = points[j].x;
                                        y = points[j].y;
                                        j += 1;
                                        ctx.quadraticCurveTo(_x, _y, x, y);
                                        break;

                                    case 'q':
                                        _x = x + points[j].x;
                                        _y = y + points[j].y;
                                        j += 1;
                                        x = x + points[j].x;
                                        y = y + points[j].y;
                                        j += 1;
                                        ctx.quadraticCurveTo(_x, _y, x, y);
                                        break;
                                }
                            }
                            if (closed) {
                                ctx.closePath();
                            }
                        }

                        this._fillStroke(ctx, layer);
                    }
                });

                DG.extend(L.SVG.prototype, {
                    _updateComplexPath: function (layer, closed) {
                        this._setPath(layer, L.SVG.complexPointsToPath(layer._vertices, layer._drawings, closed));
                    }
                });

                DG.extend(L.SVG, {
                    complexPointsToPath: function (vertices, drawings, closed) {
                        var str = '';
                        var svg = DG.Browser.svg;
                        var i, j, k, n, d, points;

                        for (i = 0; i < vertices.length; i++) {
                            points = vertices[i];

                            //  Speedup hot path by removing if/ternary condition checks but duplicating loops
                            if (svg) {
                                j = k = 0;
                                while (j < points.length) {
                                    d = drawings[i][k++];
                                    switch (d) {
                                        case 'C':
                                        case 'c':
                                            n = 3;break;
                                        case 'Q':
                                        case 'q':
                                            n = 2;break;

                                        default:
                                            n = 1; //  'M', 'm', 'L', 'l', ...
                                    }
                                    str += d;
                                    while (n--) {
                                        str += points[j].x.toFixed(4) + ',' + points[j].y.toFixed(4) + ' ';
                                        j += 1;
                                    }
                                }
                            } else {
                                //  vml in IE8 can support only integer values in 'path', sorry about loss of precision
                                j = k = 0;
                                while (j < points.length) {
                                    d = drawings[i][k++];
                                    switch (d) {
                                        case 'M':
                                            d = 'm';n = 1;break;
                                        case 'm':
                                            d = 't';n = 1;break;
                                        case 'L':
                                            d = 'l';n = 1;break;
                                        case 'l':
                                            d = 'r';n = 1;break;
                                        case 'C':
                                            d = 'c';n = 3;break;
                                        case 'c':
                                            d = 'v';n = 3;break;
                                        case 'Q':
                                            //  VML spec has 'qb' command in 'v' attribute string but no 'relativeTo' compliment
                                            //  So we'll emulate Cubic Bézier curve by applying Quadratic variant in both cases
                                            //  TODO: Both control points will use the same value but this is not true solution
                                            str += 'C' + points[j].x.toFixed(0) + ',' + points[j].y.toFixed(0) + ' ' + points[j].x.toFixed(0) + ',' + points[j].y.toFixed(0) + ' ' + points[j + 1].x.toFixed(0) + ',' + points[j + 1].y.toFixed(0) + ' ';
                                            j += 2;
                                            d = '';
                                            n = 0;
                                            break;
                                        case 'q':
                                            str += 'c' + points[j].x.toFixed(0) + ',' + points[j].y.toFixed(0) + ' ' + points[j].x.toFixed(0) + ',' + points[j].y.toFixed(0) + ' ' + points[j + 1].x.toFixed(0) + ',' + points[j + 1].y.toFixed(0) + ' ';
                                            j += 2;
                                            d = '';
                                            n = 0;
                                            break;

                                        default:
                                            n = 1;
                                    }
                                    str += d;
                                    while (n--) {
                                        str += points[j].x.toFixed(0) + ',' + points[j].y.toFixed(0) + ' ';
                                        j += 1;
                                    }
                                }
                            }

                            str += closed ? svg ? 'z' : 'x' : '';
                        }

                        // SVG complains about empty path strings
                        return str || 'm0,0';
                    }
                });

                /*
                 * DGBezierCurves is a collection of three classes:
                 * Original DG.Bezier class provides basic math for Cubic and Quadratic Bézier curves
                 * DG.TimeBezier used in animation effects it can return 'Distance' (Y) by Time (X) value
                 * DG.ArcBezier can return 't' value by curve's segment length
                 * Actual calculations can be very hard (in math terms) so we use LUT's to optimize them
                 *
                 * Original ideas come from this source:   https://pomax.github.io/bezierinfo/
                 */

                DG.Bezier = DG.Class.extend({
                    /**
                     * Initialize curve object by provided control points
                     * @param {Array<DG.Point>} coords Curve's control points in DG.Point format (up to four control points supported)
                     * @param {boolean} [clone] Clone original points or not (Default)
                     */
                    initialize: function (coords, clone) {
                        if (clone) {
                            this.points = coords.map(function (coord) {
                                return coord.clone();
                            });
                        } else {
                            this.points = coords;
                        }
                        this.dpoints = this._getDerivatives();
                        this.order = this.points.length - 1;
                        this._lut = [];
                    },

                    getPoint: function (t) {
                        var p = this.points;
                        var mt, mt2, t2;
                        var a, b, c, d;

                        if (t === 0) {
                            return p[0];
                        }
                        if (t === 1) {
                            return p[this.order];
                        }

                        mt = 1 - t;
                        mt2 = mt * mt;
                        t2 = t * t;

                        if (this.order > 2) {
                            a = mt2 * mt;
                            b = mt2 * t * 3;
                            c = mt * t2 * 3;
                            d = t * t2;
                        } else {
                            p = [p[0], p[1], p[2], { x: 0, y: 0 }];
                            a = mt2;
                            b = mt * t * 2;
                            c = t2;
                            d = 0;
                        }

                        return new DG.Point(a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x, a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y);
                    },

                    derivative: function (t) {
                        var p = this.dpoints[0];
                        var mt = 1 - t;
                        var a, b, c;

                        if (this.order > 2) {
                            a = mt * mt;
                            b = mt * t * 2;
                            c = t * t;
                        } else {
                            p = [p[0], p[1], { x: 0, y: 0 }];
                            a = mt;b = t;c = 0;
                        }

                        return new DG.Point(a * p[0].x + b * p[1].x + c * p[2].x, a * p[0].y + b * p[1].y + c * p[2].y);
                    },

                    getLength: function () {
                        /* eslint-disable camelcase */
                        var w_i = DG.Bezier.WEIGHT;
                        var x_i = DG.Bezier.ABSCISSA;
                        var z = 0.5;
                        var sum = 0;
                        var d, l, t;

                        for (var i = 0; i < x_i.length; i++) {
                            t = z * x_i[i] + z;
                            d = this.derivative(t);
                            l = d.x * d.x + d.y * d.y;
                            sum += w_i[i] * Math.sqrt(l);
                        }
                        /* eslint-enable camelcase */

                        return z * sum;
                    },

                    getCurveBefore: function (z) {
                        var p = this.points;
                        var z2, z3, mz, mz2, mz3;
                        var b$3, b$4, c$4;
                        var curve;

                        if (z === 1) {
                            return this.clone();
                        }

                        curve = [];
                        z2 = z * z;
                        mz = z - 1;
                        mz2 = mz * mz;

                        curve[0] = new DG.Point(p[0].x, p[0].y);

                        curve[1] = new DG.Point(z * p[1].x - mz * p[0].x, z * p[1].y - mz * p[0].y);

                        b$3 = z * mz * 2;
                        curve[2] = new DG.Point(z2 * p[2].x - b$3 * p[1].x + mz2 * p[0].x, z2 * p[2].y - b$3 * p[1].y + mz2 * p[0].y);

                        if (this.order > 2) {
                            z3 = z2 * z;
                            mz3 = mz2 * mz;
                            b$4 = z2 * mz * 3;
                            c$4 = z * mz2 * 3;
                            curve[3] = new DG.Point(z3 * p[3].x - b$4 * p[2].x + c$4 * p[1].x - mz3 * p[0].x, z3 * p[3].y - b$4 * p[2].y + c$4 * p[1].y - mz3 * p[0].y);
                        }

                        return new DG.Bezier(curve);
                    },

                    getCurveAfter: function (z) {
                        var p = this.points;
                        var n = this.order;
                        var z2, z3, mz, mz2, mz3;
                        var b$3, b$4, c$4;
                        var curve;

                        if (z === 1) {
                            return this.clone();
                        }

                        curve = [];
                        z2 = z * z;
                        mz = z - 1;
                        mz2 = mz * mz;

                        curve[n] = new DG.Point(p[n].x, p[n].y);

                        curve[--n] = new DG.Point(z * p[n + 1].x - mz * p[n].x, z * p[n + 1].y - mz * p[n].y);

                        b$3 = z * mz * 2;
                        curve[--n] = new DG.Point(z2 * p[n + 2].x - b$3 * p[n + 1].x + mz2 * p[n].x, z2 * p[n + 2].y - b$3 * p[n + 1].y + mz2 * p[n].y);

                        if (this.order > 2) {
                            z3 = z2 * z;
                            mz3 = mz2 * mz;
                            b$4 = z2 * mz * 3;
                            c$4 = z * mz2 * 3;
                            curve[--n] = new DG.Point(z3 * p[n + 3].x - b$4 * p[n + 2].x + c$4 * p[n + 1].x - mz3 * p[n].x, z3 * p[n + 3].y - b$4 * p[n + 2].y + c$4 * p[n + 1].y - mz3 * p[n].y);
                        }

                        return new DG.Bezier(curve);
                    },

                    _getDerivatives: function () {
                        var p = this.points;
                        var d, c, j, list;
                        var result = [];

                        for (d = p.length, c = d - 1; d > 1; d--, c--) {
                            list = [];
                            for (j = 0; j < c; j++) {
                                list.push(new DG.Point(c * (p[j + 1].x - p[j].x), c * (p[j + 1].y - p[j].y)));
                            }
                            result.push(list);
                            p = list;
                        }

                        return result;
                    },

                    getLUT: function (steps) {
                        steps = steps || 125;

                        if (this._lut.length !== steps + 1) {
                            if (this.order > 2) {
                                this._setLUT3(steps);
                            } else {
                                this._setLUT2(steps);
                            }
                        }

                        return this._lut;
                    },

                    _setLUT2: function (steps) {
                        var lut = this._lut = [];
                        var p = this.points;
                        var t, mt;
                        var a, b, c;

                        lut.push({ x: p[0].x, y: p[0].y, l: 0 });
                        for (var s = 1; s < steps; s++) {
                            t = s / steps;
                            mt = 1 - t;
                            a = mt * mt;
                            b = mt * t * 2;
                            c = t * t;
                            lut.push({
                                x: a * p[0].x + b * p[1].x + c * p[2].x,
                                y: a * p[0].y + b * p[1].y + c * p[2].y
                            });
                        }
                        lut.push({ x: p[2].x, y: p[2].y, l: 0 });
                    },

                    _setLUT3: function (steps) {
                        var lut = this._lut = [];
                        var p = this.points;
                        var t, t2, mt, mt2;
                        var a, b, c, d;

                        lut.push({ x: p[0].x, y: p[0].y, l: 0 });
                        for (var s = 1; s < steps; s++) {
                            t = s / steps;
                            mt = 1 - t;
                            mt2 = mt * mt;
                            t2 = t * t;
                            a = mt2 * mt;
                            b = mt2 * t * 3;
                            c = mt * t2 * 3;
                            d = t * t2;
                            lut.push({
                                x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,
                                y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y
                            });
                        }
                        lut.push({ x: p[3].x, y: p[3].y, l: 0 });
                    },

                    clone: function () {
                        return new DG.Bezier(this.points, true);
                    }
                });

                DG.bezier = function (coords) {
                    if (typeof coords === 'number' || coords instanceof DG.Point) {
                        coords = Array.prototype.slice.call(arguments);
                    }

                    if (typeof coords[0] === 'number') {
                        if (coords.length < 7) {
                            coords = [new DG.Point(coords[0], coords[1]), new DG.Point(coords[2], coords[3]), new DG.Point(coords[4], coords[5])];
                        } else {
                            coords = [new DG.Point(coords[0], coords[1]), new DG.Point(coords[2], coords[3]), new DG.Point(coords[4], coords[5]), new DG.Point(coords[6], coords[7])];
                        }
                        return new DG.Bezier(coords);
                    } else {
                        return new DG.Bezier(coords, true);
                    }
                };

                /* eslint-disable indent */
                DG.Bezier.WEIGHT = [0.3626837833783620, 0.3626837833783620, 0.3137066458778873, 0.3137066458778873, 0.2223810344533745, 0.2223810344533745, 0.1012285362903763, 0.1012285362903763];
                DG.Bezier.ABSCISSA = [-0.1834346424956498, 0.1834346424956498, -0.5255324099163290, 0.5255324099163290, -0.7966664774136267, 0.7966664774136267, -0.9602898564975363, 0.9602898564975363];
                /* eslint-enable indent */

                //  This curve is monotonically ordered by 'X' coordinate and has P[0] = {0, 0} and P[3] = {1, 1}
                //  We can utilize this facts to shortcut calculations
                DG.TimeBezier = DG.Bezier.extend({
                    initialize: function (controlPoint1, controlPoint2, clone) {
                        DG.Bezier.prototype.initialize.call(this, [DG.TimeBezier.START, controlPoint1, controlPoint2, DG.TimeBezier.END], clone);
                    },

                    getYbyX: function (x) {
                        var lut = this.getLUT();
                        var max = lut.length - 1;
                        var min = 0;
                        var mid;

                        if (x <= 0) {
                            return 0;
                        }
                        if (x >= 1) {
                            return 1;
                        }

                        //  'X' is monotonically increasing so we can do a simple binary search (LUT)
                        //  and then fine-tune the result by linear interpolation assuming 'Y' is not changed so radically
                        while (true) {
                            mid = min + (max - min >> 1);
                            if (x < lut[mid].x) {
                                max = mid;
                            } else {
                                min = mid;
                            }
                            if (max - min < 2) {
                                break;
                            }
                        }
                        x = (x - lut[min].x) / (lut[max].x - lut[min].x);

                        return lut[min].y + (lut[max].y - lut[min].y) * x;
                    },

                    getLUT: function (steps) {
                        var p = this.points;
                        var t, t2, mt;
                        var b, c, d;
                        var lut;

                        steps = steps || 240;
                        if (this._lut.length === steps + 1) {
                            return this._lut;
                        } else {
                            this._lut = lut = [];
                        }

                        lut.push({ x: 0, y: 0 });
                        for (var s = 1; s < steps; s++) {
                            t = s / steps;
                            mt = 1 - t;
                            t2 = t * t;
                            //  We don't need 'a' coefficient because p[0] is {0, 0}
                            b = mt * mt * t * 3;
                            c = mt * t2 * 3;
                            d = t * t2;
                            lut.push({
                                x: b * p[1].x + c * p[2].x + d,
                                y: b * p[1].y + c * p[2].y + d
                            });
                        }
                        lut.push({ x: 1, y: 1 });

                        return lut;
                    },

                    clone: function () {
                        return new DG.TimeBezier(this.points, true);
                    }
                });

                DG.TimeBezier.START = DG.point(0, 0);
                DG.TimeBezier.END = DG.point(1, 1);

                //  This is cubic Bezier describing circular arc
                DG.ArcBezier = DG.Bezier.extend({
                    initialize: function (coords, clone) {
                        DG.Bezier.prototype.initialize.call(this, coords, clone);
                        this.getLUT();
                        this._setLutLengths();
                    },

                    getTbyL: function (l) {
                        var lut = this.getLUT();
                        var max = lut.length - 1;
                        var min = 0;
                        var mid;
                        var x, y;

                        if (l <= 0) {
                            return 0;
                        }
                        if (l >= lut[max].l) {
                            return 1;
                        }

                        //  'L' is monotonically increasing so we can do a binary search (LUT)
                        //  and then fine-tune the result by linear interpolation
                        while (true) {
                            mid = min + (max - min >> 1);
                            if (l < lut[mid].l) {
                                max = mid;
                            } else {
                                min = mid;
                            }
                            if (max - min < 2) {
                                break;
                            }
                        }
                        l = (l - lut[min].l) / (lut[max].l - lut[min].l);

                        x = lut[min].x + (lut[max].x - lut[min].x) * l;
                        y = lut[min].y + (lut[max].y - lut[min].y) * l;

                        //  BUT this is a part of story, we need a projection of this point to the actual curve and it's reverse 't' val
                        var p, dx, dy, t;
                        var et = max / lut.length;
                        var dt = min / lut.length;
                        var s = 1 / lut.length / 10; //  TODO
                        var d = Math.pow(2, 53) - 1;

                        for (t = dt; dt < et; dt += s) {
                            p = this.getPoint(dt);
                            dx = p.x - x;dy = p.y - y;
                            l = Math.sqrt(dx * dx + dy * dy);
                            if (l < d) {
                                d = l;
                                t = dt;
                            }
                        }

                        return t;
                    },

                    _setLutLengths: function () {
                        var lut = this._lut;
                        var dx, dy;

                        lut[0].l = 0;
                        for (var i = 1; i < lut.length; i++) {
                            dx = lut[i].x - lut[i - 1].x;
                            dy = lut[i].y - lut[i - 1].y;
                            lut[i].l = lut[i - 1].l + Math.sqrt(dx * dx + dy * dy);
                        }
                    },

                    getLength: function () {
                        return this._lut[this._lut.length - 1].l;
                    },

                    clone: function () {
                        return new DG.ArcBezier(this.points, true);
                    }
                });

                /*
                 * DG.Animation provides tick (step) logic returning progression values
                 * calculated over provided or custom Bézier curves
                 * Original input can be array object btw...
                 */

                DG.Animation = DG.Evented.extend({
                    options: {
                        // animation: {    //  Or array of objects
                        //     function: DG.Animation.EASE,
                        //     duration: 2000,
                        //     frames: null
                        // }

                        //offset: 0
                        //repeat: 0
                    },

                    initialize: function (options) {
                        DG.setOptions(this, options);

                        this._animID = -1;
                        this._startTime = 0;
                        this._running = false;
                        this._animation = null;
                        this._durations = null;
                    },

                    start: function () {
                        this.stop();
                        this._prepare();

                        this._running = true;

                        this.fire('start');

                        //  Date.now(), but... IE9+
                        this._startTime = new Date().getTime();

                        this._animate();
                    },

                    stop: function () {
                        if (this._running) {
                            this._run(this._durations.getLength());
                        }
                    },

                    _prepare: function () {
                        this._animation = DG.Util.isArray(this.options.animation) ? this.options.animation : [this.options.animation];

                        this._durations = new DG.Metric.Segments();
                        this._animation.forEach(function (animation) {
                            this.push(animation.duration);
                        }, this._durations);
                    },

                    _animate: function () {
                        this._animID = DG.Util.requestAnimFrame(this._animate, this);
                        this._run();
                    },

                    _run: function (elapsed) {
                        var el, index, progress;
                        //  Possible skip zero delta time but who cares?!
                        elapsed = elapsed ? elapsed : new Date().getTime() - this._startTime;

                        if (elapsed < this._durations.getLength()) {
                            index = this._durations.getIndex(elapsed);
                            el = this._durations.getSegRatio(elapsed);
                            progress = this._animation[index]['function'].getYbyX(el);
                            this._step(this._getFrameValues(index, progress));
                        } else {
                            index = this._durations.length - 1;
                            this._step(this._getFrameValues(index, 1));
                            this._complete();
                        }
                    },

                    _step: function (obj) {
                        this.fire('step', obj);
                    },

                    _complete: function () {
                        DG.Util.cancelAnimFrame(this._animID);

                        this._durations = null;
                        this._animation = null;
                        this._running = false;
                        this.fire('end');
                    },

                    _getFrameValues: function (index, progress) {
                        var frames = this._animation[index].frames;
                        var obj = { progress: progress };
                        var fr, to;

                        if (frames) {
                            for (var key in frames) {
                                if (frames[key].progress) {
                                    obj[key] = frames[key].progress(progress);
                                } else {
                                    fr = frames[key].from;
                                    to = frames[key].to;
                                    obj[key] = fr + (to - fr) * progress;
                                }
                            }
                        }
                        return obj;
                    }
                });

                DG.animation = function (options) {
                    return new DG.Animation(options);
                };

                DG.Animation.LINEAR = new DG.TimeBezier(DG.point(0.00, 0.0), DG.point(1.00, 1.0));
                DG.Animation.EASE = new DG.TimeBezier(DG.point(0.25, 0.1), DG.point(0.25, 1.0));
                DG.Animation.EASE_IN = new DG.TimeBezier(DG.point(0.42, 0.0), DG.point(1.00, 1.0));
                DG.Animation.EASE_IN_OUT = new DG.TimeBezier(DG.point(0.42, 0.0), DG.point(0.58, 1.0));
                DG.Animation.EASE_OUT = new DG.TimeBezier(DG.point(0.00, 0.0), DG.point(0.58, 1.0));

                /*
                 * DG.Entrance is a main class that hosts actual arrow layers
                 * It orchestrates animation and provides user space methods like .show() and .hide()
                 */

                DG.Entrance = DG.FeatureGroup.extend({

                    options: {
                        vectors: [],

                        fillColor: '#0085a0',
                        strokeColor: '#fff',

                        enableAnimation: true,
                        interactive: false,

                        autoClose: true
                    },

                    initialize: function (options) {
                        DG.LayerGroup.prototype.initialize.call(this);

                        DG.setOptions(this, options);

                        this._bounds = new DG.LatLngBounds();
                        this._animations = {
                            bounce: DG.animation(DG.Entrance.BOUNCE_ANIMATION),
                            path: DG.animation(DG.Entrance.PATH_ANIMATION)
                        };

                        this._initArrows();

                        this._isShown = false;
                    },

                    onAdd: function (map) {
                        DG.LayerGroup.prototype.onAdd.call(this, map);
                        this.show();
                    },

                    onRemove: function (map) {
                        this.hide();
                        DG.LayerGroup.prototype.onRemove.call(this, map);
                    },

                    getEvents: function () {
                        var events = {};

                        if (this.options.autoClose) {
                            events['layeradd'] = this._removeEntrance; //  eslint-disable-line dot-notation
                        }
                        if (this.options.enableAnimation) {
                            events['zoomend'] = this._animate; //  eslint-disable-line dot-notation
                        }

                        return events;
                    },

                    show: function (fitBounds) {
                        if (this._layers) {
                            if (fitBounds) {
                                this.fitBounds();
                            }
                            if (!this._isShown) {
                                this._isShown = true;
                                this.eachLayer(function (arrow) {
                                    arrow.setVisibility(true);
                                });
                                if (this.options.enableAnimation) {
                                    this._animate();
                                }
                                this._map.fire('entranceshow');
                            }
                        }

                        return this;
                    },

                    hide: function () {
                        if (this._layers && this._isShown) {
                            this._isShown = false;
                            this.eachLayer(function (arrow) {
                                arrow.setVisibility(false);
                            });
                            this._map.fire('entrancehide');
                        }

                        return this;
                    },

                    isShown: function () {
                        return this._isShown;
                    },

                    getBounds: function () {
                        return this._bounds;
                    },

                    setFillColor: function (color) {
                        this.eachLayer(function (arrow) {
                            arrow.setStyle({ fillColor: color });
                        });
                    },

                    setStrokeColor: function (color) {
                        this.eachLayer(function (arrow) {
                            arrow.setStyle({ color: color });
                        });
                    },

                    _initArrows: function () {
                        var base = {
                            color: this.options.strokeColor,
                            fillColor: this.options.fillColor,
                            interactive: this.options.interactive
                        };

                        this.options.vectors.map(function (vector) {
                            return DG.Wkt.toLatLngs(vector);
                        }).forEach(function (latlngs) {
                            var options = DG.Util.create(base),
                                bounds = DG.latLngBounds(latlngs);

                            this._bounds.extend(bounds);

                            options.latlngs = latlngs;
                            options.bounds = bounds;
                            if (this.options.enableAnimation) {
                                if (latlngs.length > 2) {
                                    options.animation = this._animations.path;
                                } else {
                                    options.animation = this._animations.bounce;
                                    options.distance = true;
                                }
                            }

                            this.addLayer(DG.entrance.arrow(options));
                        }, this);
                    },

                    _animate: function () {
                        if (this._isShown) {
                            this._animations.bounce.start();
                            this._animations.path.start();
                        }
                    },

                    //  Current logic of next four methods extracted from original arrow's implementation
                    fitBounds: function () {
                        var map = this._map,
                            fitZoom,
                            bounds = this.getBounds();

                        if (!map.getBounds().contains(bounds) || !this._isAllowedZoom()) {
                            fitZoom = this._getFitZoom();
                            if (!map.projectDetector.getProject()) {
                                map.once('moveend', function () {
                                    map.setZoom(this._getFitZoom());
                                }, this);
                            }
                            map.setView(bounds.getCenter(), fitZoom, { animate: true });
                        }

                        return this;
                    },

                    _getFitZoom: function () {
                        return this._map.projectDetector.getProject().maxZoom || DG.Entrance.SHOW_FROM_ZOOM;
                    },

                    _isAllowedZoom: function () {
                        return this._map.getZoom() >= DG.Entrance.SHOW_FROM_ZOOM;
                    },

                    _removeEntrance: function (e) {
                        if (e.layer instanceof DG.Popup || e.layer instanceof DG.Entrance && e.layer !== this) {

                            this.remove();
                        }
                    }
                });

                DG.entrance = function (options) {
                    return new DG.Entrance(options);
                };

                DG.Entrance.SHOW_FROM_ZOOM = 16;
                DG.Entrance.PATH_ANIMATION = {
                    animation: {
                        'function': DG.Animation.EASE_IN_OUT,
                        'duration': 750
                    }
                };
                DG.Entrance.BOUNCE_ANIMATION = {
                    animation: [{ 'function': DG.Animation.EASE_IN_OUT, 'duration': 250, 'frames': { 'distance': { 'from': 0, 'to': 0.6 } } }, { 'function': DG.Animation.EASE_IN, 'duration': 135, 'frames': { 'distance': { 'from': 0.6, 'to': 0 } } }, { 'function': DG.Animation.EASE_OUT, 'duration': 135, 'frames': { 'distance': { 'from': 0, 'to': 0.16 } } }, { 'function': DG.Animation.EASE_IN, 'duration': 90, 'frames': { 'distance': { 'from': 0.16, 'to': 0 } } }, { 'function': DG.Animation.EASE_OUT, 'duration': 90, 'frames': { 'distance': { 'from': 0, 'to': 0.06 } } }, { 'function': DG.Animation.EASE_IN, 'duration': 50, 'frames': { 'distance': { 'from': 0.06, 'to': 0 } } }]
                };

                /*
                 * DG.Entrance.Arrow class hosts two layers, one for arrow body (path) and one for arrow tip
                 * It overrides projection events from hosted layers to minimize total overhead
                 * Actual calculations produced in DG.ArrowPathTransform and DG.ArrowTipTransform classes
                 */

                DG.Entrance.Arrow = DG.FeatureGroup.extend({
                    initialize: function (options) {
                        DG.LayerGroup.prototype.initialize.call(this);

                        DG.setOptions(this, options);

                        this._progress = 1;
                        this._distance = 0;
                        this._visibility = {
                            isShown: false
                        };
                        this._position = options.latlngs[options.latlngs.length - 1];
                        this._shape = this.options.shape || DG.Entrance.Arrow.SHAPE;

                        this._apt = {}; // DG.ArrowPathTransform objects by zoom levels
                        this._att = {}; // DG.ArrowTipTransform objects by zoom levels
                    },

                    beforeAdd: function (map) {
                        //  this._map is not initialized yet, so we can freely addLayer(s)
                        var opts = this.options;

                        //  TODO: Check Canvas processing order
                        //  Additional logic to DISABLE animation on Canvas for now!
                        if (opts.animation && !map.options.preferCanvas && !DG.Browser.ielt9) {
                            opts.animation.on('step', this._animation, this);
                        } else {
                            opts.animation = null;
                        }

                        this.projection();

                        this.addLayer(new DG.ComplexPath({
                            lineCap: 'butt',
                            color: opts.color,
                            fillColor: opts.fillColor,
                            interactive: opts.interactive,
                            visibility: this._visibility,
                            transform: this._apt
                        }));

                        this.addLayer(new DG.ComplexPath({
                            lineJoin: 'miter',
                            color: opts.color,
                            fillColor: opts.fillColor,
                            interactive: opts.interactive,
                            visibility: this._visibility,
                            transform: this._att
                        }));
                    },

                    getEvents: function () {
                        return {
                            zoomend: this._project,
                            moveend: this._update,
                            viewreset: this._reset
                        };
                    },

                    setVisibility: function (isShown) {
                        if (this._visibility.isShown !== isShown) {
                            this._visibility.isShown = isShown;
                            if (isShown) {
                                if (!this.options.animation) {
                                    this._reset();
                                }
                            } else {
                                this._reset();
                            }
                        }
                    },

                    getBounds: function () {
                        return this.options.bounds;
                    },

                    projection: function () {
                        var map = this._map || this._mapToAdd;
                        var zoom = map ? map.getZoom() : 0;
                        var vertices = this._shape.vertices[zoom];
                        var drawings = this._shape.drawings[zoom];
                        var latlngs = this.options.latlngs;
                        var shape, path, lastPoint, prevPoint;

                        if (zoom && vertices && drawings) {
                            if (!this._att[zoom]) {
                                path = DG.ArrowPathTransform.getTranslatedPath(map, latlngs);
                                shape = { vertices: vertices, drawings: drawings };
                                this._att[zoom] = new DG.ArrowTipTransform(path, shape);
                                this._apt[zoom] = new DG.ArrowPathTransform(path);
                            }

                            lastPoint = map.latLngToLayerPoint(this._position);
                            prevPoint = map.latLngToLayerPoint(latlngs[latlngs.length - 2]);
                            if (!this._apt[zoom]._pxBounds) {
                                //  One-time action per 'viewreset' event
                                //  Caching _pxBounds for using with Canvas renderer
                                this._setBounds(lastPoint, prevPoint, this._apt[zoom], this._att[zoom]);
                            }
                            if (this.options.distance) {
                                //  Arrow position recalculated for Bounce animation effect
                                lastPoint = DG.VertexTransform.getScaled(lastPoint, prevPoint, this._distance);
                            }

                            //  Main calculations
                            //  Get part of the arrow path and move (bound) arrow tip to it
                            this._apt[zoom].subPath(this._progress).translate(lastPoint);
                            this._att[zoom].subShape(this._apt[zoom]).translate(lastPoint);
                        }

                        return this;
                    },

                    _animation: function (e) {
                        if (e.distance != undefined) {
                            this._distance = e.distance; //  bounce animation effect
                        } else {
                            this._progress = e.progress; //  path animation effect
                        }
                        if (this._visibility.isShown) {
                            //  TODO: Additional logic for animation on Canvas
                            // this.projection().invoke('redraw');

                            this._project();
                            this._update();
                        }
                    },

                    _project: function () {
                        this.projection().invoke('_project');
                    },

                    _update: function () {
                        this.invoke('_update');
                    },

                    _reset: function () {
                        this._resetBounds();

                        this._project();
                        this._update();
                    },

                    _resetBounds: function () {
                        //  Canvas renderer specific
                        var z;

                        for (z in this._apt) {
                            this._apt[z]._pxBounds = null;
                        }

                        for (z in this._att) {
                            this._att[z]._pxBounds = null;
                        }
                    },

                    _setBounds: function (pl, pp, apt, att) {
                        var _apt = apt.subPath(1).translate(pl).vertices,
                            _att = att.subShape(apt).translate(pl).vertices;

                        /*
                                //  TODO: Additional logic for animation on Canvas
                                if (this.options.distance) {
                                    pl = DG.VertexTransform.getScaled(pl, pp, 1);
                                    _apt = _apt.concat(apt.subPath(1).translate(pl).vertices);
                                    _att = _att.concat(att.subShape(apt).translate(pl).vertices);
                                }
                        */
                        apt._pxBounds = new DG.Bounds(_apt);
                        att._pxBounds = new DG.Bounds(_att);
                    }
                });

                DG.entrance.arrow = function (options) {
                    return new DG.Entrance.Arrow(options);
                };

                /*
                 * Predefined arrow tips
                 */

                /* eslint-disable array-bracket-spacing */
                DG.Entrance.Arrow.SHAPE = {
                    vertices: {
                        16: [[-6.5000, -1.8000], [-6.0522, -1.8000], [-7.0975, -5.2537], [-6.6619, -6.2565], [-6.5980, -6.3550], [-6.1757, -6.1470], [0.8371, -0.3552], [0.9275, -0.1764], [0.9275, 0.1764], [0.8371, 0.3552], [-6.1757, 6.1470], [-6.5980, 6.3550], [-6.6619, 6.2565], [-7.0975, 5.2537], [-6.0522, 1.8000], [-6.5000, 1.8000]],
                        17: [[-9.0000, -2.4000], [-7.8890, -2.4000], [-9.9245, -7.2548], [-9.3363, -8.6404], [-9.3448, -8.6448], [-8.8717, -8.3508], [1.0285, -0.3552], [1.1190, -0.1764], [1.1190, 0.1764], [1.0285, 0.3552], [-8.8717, 8.3508], [-9.3448, 8.6448], [-9.3363, 8.6404], [-9.9245, 7.2548], [-7.8890, 2.4000], [-9.0000, 2.4000]],
                        18: [[-11.5000, -3.0000], [-10.0795, -3.0000], [-12.4909, -9.3173], [-11.8402, -10.7654], [-11.5986, -10.7073], [-10.9380, -10.2258], [1.1497, -0.3552], [1.2402, -0.1764], [1.2402, 0.1764], [1.1497, 0.3552], [-10.9380, 10.2258], [-11.5986, 10.7073], [-11.8402, 10.7654], [-12.4909, 9.3173], [-10.0795, 3.0000], [-11.5000, 3.0000]],
                        19: [[-13.0000, -3.6000], [-11.6600, -3.6000], [-14.1696, -10.8351], [-13.5189, -12.2832], [-13.2773, -12.2251], [-12.6167, -11.7436], [1.3061, -0.3552], [1.3966, -0.1764], [1.3966, 0.1764], [1.3061, 0.3552], [-12.6167, 11.7436], [-13.2773, 12.2251], [-13.5189, 12.2832], [-14.1696, 10.8351], [-11.6600, 3.6000], [-13.0000, 3.6000]]
                    },
                    drawings: {
                        16: ['M', 'L', 'L', 'C', 'L', 'C', 'L', 'C', 'L', 'L'],
                        17: ['M', 'L', 'L', 'C', 'L', 'C', 'L', 'C', 'L', 'L'],
                        18: ['M', 'L', 'L', 'C', 'L', 'C', 'L', 'C', 'L', 'L'],
                        19: ['M', 'L', 'L', 'C', 'L', 'C', 'L', 'C', 'L', 'L']
                    }
                };
                /* eslint-enable array-bracket-spacing */

                (function (vertices) {
                    for (var i in vertices) {
                        vertices[i] = vertices[i].map(function (vertex) {
                            return DG.point(vertex);
                        });
                    }
                })(DG.Entrance.Arrow.SHAPE.vertices);

                DG.Label = DG.Layer.extend({

                    options: {
                        offset: new DG.Point(12, 15),
                        className: 'dg-label',
                        zIndexOffset: 0,
                        textDirection: 'auto' // 'auto' | 'ltr' | 'rtl
                    },

                    _typeOfString: Object.prototype.toString.call('s'),
                    _defaultZIndex: 100,

                    initialize: function (content, options) {
                        DG.Util.setOptions(this, options);

                        this._animated = DG.Browser.any3d;
                        this._content = content;
                    },

                    onAdd: function (map) {
                        this._map = map;

                        if (!this._el) {
                            this._initDOM();
                        }

                        this._visible = true;

                        this.setContent(this._content)._onViewReset();

                        map.on('viewreset', this._onViewReset, this).on('zoomanim', this._onZoomAnimation, this);
                    },

                    onRemove: function (map) {
                        map.off('viewreset', this._onViewReset, this).off('zoomanim', this._onZoomAnimation, this);

                        this._visible = false;

                        this._el.removeChild(this._container);
                        DG.Util.falseFn(this._container.offsetWidth); // we need reflow here
                        this._container = null;

                        map.getPanes().tooltipPane.removeChild(this._el);
                        this._el = null;
                    },

                    _initDOM: function () {
                        this._el = DG.DomUtil.create('div', this.options.className + ' leaflet-zoom-' + (this._animated ? 'animated' : 'hide'), this._map.getPanes().tooltipPane);
                        this._el.style.zIndex = this._defaultZIndex + this.options.zIndexOffset;

                        this._container = DG.DomUtil.create('div', this.options.className + '__content', this._el);
                        this._container.setAttribute('dir', this.options.textDirection);

                        DG.DomEvent.disableClickPropagation(this._el).on(this._container, 'mousewheel', DG.DomEvent.stopPropagation).on(this._container, 'contextmenu', DG.DomEvent.stopPropagation);
                    },

                    _onViewReset: function () {
                        if (this._visible && this._latlng) {
                            DG.DomUtil.setPosition(this._el, this._map.latLngToLayerPoint(this._latlng).add(this.options.offset), DG.Browser.ie);
                        }
                    },

                    _onZoomAnimation: function (opt) {
                        if (this._latlng) {
                            DG.DomUtil.setPosition(this._el, this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).add(this.options.offset));
                        }
                    },

                    setOffset: function (point) {
                        if (point instanceof DG.Point) {
                            this.options.offset = point;
                            this._onViewReset();
                        }
                        return this;
                    },

                    setZIndexOffset: function (zIndex) {
                        if (!isNaN(+zIndex)) {
                            this.options.zIndexOffset = +zIndex;
                            if (this._visible) {
                                this._el.style.zIndex = this._defaultZIndex + this.options.zIndexOffset;
                            }
                        }
                        return this;
                    },

                    setContent: function (content) {
                        if (Object.prototype.toString.call(content) !== this._typeOfString) {
                            return this;
                        }
                        this._content = content;
                        if (this._visible) {
                            this._container.innerHTML = content;
                        }
                        return this;
                    },

                    setPosition: function (latlng) {
                        if (!(latlng instanceof DG.LatLng)) {
                            return this;
                        }

                        this._latlng = latlng;
                        this._onViewReset();
                        return this;
                    }
                });

                DG.label = function (content, options) {
                    return new DG.Label(content, options);
                };

                DG.Marker.include({

                    bindLabel: function (content, options) {
                        if (this._label) {
                            this._label.setContent(content);
                            if (options) {
                                if (this.options.offset !== options.offset) {
                                    this._label.setOffset(this.options.offset = options.offset);
                                }
                                if (this.options.static !== options.static) {
                                    this.unbindLabel().bindLabel(content, options);
                                }
                            }
                        } else {
                            options = DG.extend({
                                offset: new DG.Point(5, 5)
                            }, options);

                            this._label = DG.label(content, options);

                            this.once('remove', this._onMarkerRemove);

                            if (options.static) {
                                this.showLabel();
                            } else {
                                this.on('mouseover', this._mouseOverLabel).on('mouseout', this._mouseOutLabel).on('dragstart', this._dragStartLabel).on('dragend', this._dragEndLabel);
                            }

                            if (typeof this._map !== 'undefined') {
                                this._updateLabelZIndex();
                            } else {
                                this.once('add', this._updateLabelZIndex);
                            }
                        }
                        return this;
                    },

                    unbindLabel: function () {
                        if (this._label) {
                            this.hideLabel().off('remove', this.unbindLabel).off('mouseover', this._mouseOverLabel).off('mouseout', this._mouseOutLabel).off('dragstart', this._dragStartLabel).off('dragend', this._dragEndLabel).off('move', this._updatePosition).off('add', this._updateLabelZIndex);

                            this._label = null;
                        }
                        return this;
                    },

                    _onMarkerRemove: function () {
                        if (this._label) {
                            var content = this._label._content;
                            this.once('add', function () {
                                if (this._label) {
                                    return;
                                } // new label added after removing marker
                                this.bindLabel(content);
                            });
                            this.unbindLabel();
                        }
                    },

                    getLabel: function () {
                        return this._label ? this._label : null;
                    },

                    _originalUpdateZIndex: DG.Marker.prototype._updateZIndex,
                    _updateZIndex: function (offset) {
                        if (!this._zIndex) {
                            this._zIndex = 0;
                        }
                        this._originalUpdateZIndex(offset);
                        this._updateLabelZIndex();
                        return this;
                    },

                    _updateLabelZIndex: function () {
                        if (this._label && this._icon) {
                            this._label.setZIndexOffset(this._icon.style.zIndex);
                        }
                        return this;
                    },

                    showLabel: function () {
                        if (this._label) {
                            this.on('move', this._updatePosition)._map.addLayer(this._label.setPosition(this.getLatLng()));
                        }

                        return this;
                    },

                    hideLabel: function () {
                        if (this._label) {
                            this.off('move', this._updatePosition)._map.removeLayer(this._label);
                        }
                        return this;
                    },

                    _updatePosition: function () {
                        this._label.setPosition(this.getLatLng());
                    },

                    _dragStartLabel: function () {
                        this._label.isMarkerDragging = true;

                        this.hideLabel();
                    },

                    _dragEndLabel: function () {
                        this._label.isMarkerDragging = false;

                        if (this._label.isMouseOverMarker) {
                            this.showLabel();
                        }
                    },

                    _mouseOverLabel: function () {
                        this._label.isMouseOverMarker = true;

                        if (!this._label.isMarkerDragging) {
                            this.showLabel();
                        }
                    },

                    _mouseOutLabel: function () {
                        this._label.isMouseOverMarker = false;

                        this.hideLabel();
                    }
                });

                DG.Marker.addInitHook(function () {
                    if (typeof this.options.label !== 'undefined') {
                        this.bindLabel(this.options.label);
                    }
                });

                DG.Path.include({
                    bindLabel: function (content, options) {

                        if (!this._label) {
                            this._label = DG.label(content, options);
                            this.on(this._labelEvents, this);
                        } else {
                            this._label.setContent(content);

                            if (this._label.options.offset !== options.offset) {
                                this._label.setOffset(options.offset);
                            }
                        }
                        return this;
                    },

                    unbindLabel: function () {
                        if (this._label) {
                            this.off(this._labelEvents, this);
                            this._map.removeLayer(this._label);
                            this._label = null;
                        }
                        return this;
                    },

                    getLabel: function () {
                        return this._label ? this._label : null;
                    },

                    _labelEvents: {
                        mouseover: function (event) {
                            this._map.addLayer(this._label.setPosition(event.latlng));
                            DG.DomEvent.stop(event);
                        },
                        mousemove: function (event) {
                            this._label.setPosition(event.latlng);
                            DG.DomEvent.stop(event);
                        },
                        mouseout: function (event) {
                            this._map.removeLayer(this._label);
                            DG.DomEvent.stop(event);
                        },
                        remove: function () {
                            this._map.removeLayer(this._label);
                        }
                    }
                });

                DG.Path.addInitHook(function () {
                    if (typeof this.options.label !== 'undefined') {
                        this.bindLabel(this.options.label);
                    }
                });

                DG.Entrance.include({
                    bindLabel: function (content, options) {

                        if (!this._label) {
                            this._label = DG.label(content, options);
                            this.on(this._labelEvents, this);
                        } else {
                            this._label.setContent(content);

                            if (this._label.options.offset !== options.offset) {
                                this._label.setOffset(options.offset);
                            }
                        }
                        return this;
                    },

                    unbindLabel: function () {
                        if (this._label) {
                            this.off(this._labelEvents, this);
                            this._map.removeLayer(this._label);
                            this._label = null;
                        }
                        return this;
                    },

                    getLabel: function () {
                        return this._label ? this._label : null;
                    },

                    _labelEvents: {
                        mouseover: function (event) {
                            this._map.addLayer(this._label.setPosition(event.latlng));
                            DG.DomEvent.stop(event);
                        },
                        mousemove: function (event) {
                            this._label.setPosition(event.latlng);
                            DG.DomEvent.stop(event);
                        },
                        mouseout: function () {
                            this._label.remove();
                        },
                        remove: function () {
                            this._label.remove();
                        }
                    }
                });

                DG.Entrance.addInitHook(function () {
                    if (typeof this.options.label !== 'undefined') {
                        this.bindLabel(this.options.label);
                    }
                });

                DG.configTheme = DG.configTheme || {};

                DG.configTheme.balloonOptions = {
                    offset: {
                        x: 1,
                        y: -43
                    }
                };

                _dereq_('../../../vendors/baron');

                // 2GIS-related popup content wrapper and offset
                (function () {
                    var offsetX = DG.configTheme.balloonOptions.offset.x,
                        offsetY = DG.configTheme.balloonOptions.offset.y,
                        originalInitialize = DG.Popup.prototype.initialize,
                        originalInitLayout = DG.Popup.prototype._initLayout,
                        originalOnAdd = DG.Popup.prototype.onAdd,
                        graf = baron.noConflict();

                    var BaronDomHelper = function (element) {
                        this[0] = element;
                        this.length = 1;
                    };
                    BaronDomHelper.prototype = {
                        setAttribute: function (name, value) {
                            this[0].setAttribute(name, value);
                            return this;
                        },
                        getAttribute: function (name) {
                            return this[0].getAttribute(name);
                        },
                        removeAttribute: function (name) {
                            this[0].removeAttribute(name);
                            return this;
                        },
                        css: function (style, value) {
                            if (value) {
                                this[0].style[style] = value;
                                return this;
                            } else {
                                return DG.DomUtil.getStyle(this[0], style);
                            }
                        }
                    };

                    DG.Popup.prototype.options.offset = DG.point(offsetX, offsetY);

                    DG.Popup.mergeOptions({
                        border: 16,
                        mapControlsWidth: 60,
                        textDirection: 'auto' // 'auto' | 'ltr' | 'rtl
                    });

                    DG.Popup.include({
                        _headerContent: null,
                        _footerContent: null,

                        //baron elements references
                        _scroller: null,
                        _scrollerBar: null,
                        _barWrapper: null,
                        _baron: null,
                        _isBaronExist: false,

                        _popupShowClass: 'leaflet-popup_show_true',
                        _popupHideClass: 'leaflet-popup_show_false',

                        _popupTipClass: 'leaflet-popup-tip-container',
                        _tipSVGPath: 'M0 0c12.643 0 28 7.115 28 44h2c0-36.885 15.358-44 28-44h-58z',

                        _isAutoPanPaddingUserDefined: false,

                        initialize: function (options, source) {
                            // (Object, Object)
                            this._popupStructure = {};
                            this._isAutoPanPaddingUserDefined = options && options.hasOwnProperty('autoPanPadding');
                            originalInitialize.call(this, options, source);
                        },

                        onAdd: function (map) {
                            // (Map)
                            map.on({
                                entranceshow: this._closePopup,
                                resize: this.resize
                            }, this);
                            originalOnAdd.call(this, map);
                            this._animateOpening();
                        },

                        onRemove: function (map) {
                            // (Map)
                            this._animateClosing();
                            map.off({
                                entranceshow: this._closePopup,
                                resize: this.resize
                            }, this);

                            if (DG.DomUtil.TRANSITION) {
                                this._removeTimeout = setTimeout(L.bind(L.DomUtil.remove, L.DomUtil, this._container), 200);
                            } else {
                                L.DomUtil.remove(this._container);
                            }

                            map.fire('popupclose', { popup: this });

                            if (this._source) {
                                this._source.fire('popupclose', { popup: this }, true);
                            }
                        },

                        setContent: function (content) {
                            // (DOMElement | Object | HTML) -> Popup
                            if (!this._isNode(content) && typeof content === 'object') {
                                Object.keys(content).forEach(function (item) {
                                    this['_' + item + 'Content'] = content[item];
                                }, this);
                            } else {
                                this._bodyContent = content;
                            }

                            this.update();

                            return this;
                        },

                        setHeaderContent: function (content) {
                            // (HTML) -> Popup
                            this._headerContent = content;
                            this.update();

                            return this;
                        },

                        setFooterContent: function (content) {
                            // (HTML) -> Popup
                            this._footerContent = content;
                            this.update();

                            return this;
                        },

                        getContent: function () {
                            // () -> HTML
                            return this._bodyContent;
                        },

                        getHeaderContent: function () {
                            // () -> HTML
                            return this._headerContent;
                        },

                        getFooterContent: function () {
                            // () -> HTML
                            return this._footerContent;
                        },

                        clear: function () {
                            // () -> Popup
                            Object.keys(this._popupStructure).forEach(this._clearElement, this);

                            // think about move this set to another public method
                            this._isBaronExist = false;
                            return this;
                        },

                        clearHeader: function () {
                            // () -> Popup
                            return this._clearElement('header');
                        },

                        clearFooter: function () {
                            // () -> Popup
                            return this._clearElement('footer');
                        },

                        findElement: function (element) {
                            // (String) -> DOMElement
                            return this._contentNode.querySelector(element);
                        },

                        _animateOpening: function () {
                            DG.DomUtil.addClass(this._innerContainer, this._popupShowClass);
                            DG.DomUtil.removeClass(this._innerContainer, this._popupHideClass);
                        },

                        _animateClosing: function () {
                            DG.DomUtil.addClass(this._innerContainer, this._popupHideClass);
                            DG.DomUtil.removeClass(this._innerContainer, this._popupShowClass);
                        },

                        _closePopup: function () {
                            this._map.closePopup(this);
                        },

                        _isNode: function (o) {
                            // (Object) -> Boolean
                            return o.nodeName ? true : false;
                        },

                        _onCloseButtonClick: function (e) {
                            if (this._map) {
                                this._map.closePopup(this);
                            }
                            L.DomEvent.stop(e);
                        },

                        _close: function () {
                            if (this._map) {
                                if (DG.Browser.mobile && this._map.geoclicker && (this.options.closeOnClick || this._map.options.closePopupOnClick)) {
                                    //  We need to signal geoclicker that popup was open before 'click' event
                                    //  But by time it will get it's event the popup will be already closed
                                    //  See 'DGGeoclicker' for '_mapEventsListeners' and '_singleClick' method
                                    this._map.geoclicker.popupWasOpen = true;
                                }

                                this._map.closePopup(this);
                            }
                        },

                        _initLayout: function () {
                            originalInitLayout.call(this);
                            this._innerContainer = DG.DomUtil.create('div', 'leaflet-popup-inner ' + this._popupHideClass, this._container);

                            // Prevents mouse events from leaking through close button
                            // See https://github.com/2gis/mapsapi/pull/153/
                            DG.DomEvent.disableClickPropagation(this._innerContainer);

                            if (this.options.closeButton) {
                                this._innerContainer.appendChild(this._detachEl(this._closeButton));
                            }

                            this._innerContainer.appendChild(this._detachEl(this._wrapper));

                            var tip = this._detachEl(this._tipContainer);

                            if (DG.Browser.svg) {
                                var path = DG.SVG.create('path');
                                var svgClass = this._popupTipClass + ' ' + this._popupTipClass + '_svg';

                                path.setAttribute('d', this._tipSVGPath);

                                tip = DG.SVG.create('svg');
                                tip.setAttribute('class', svgClass);

                                tip.appendChild(path);
                                DG.DomEvent.disableClickPropagation(path);
                            } else {
                                DG.DomUtil.addClass(tip, this._popupTipClass + '_image');
                                DG.DomEvent.disableClickPropagation(tip);
                            }

                            this._innerContainer.appendChild(tip);
                        },

                        _clearElement: function (elem) {
                            // (DOMElement) -> Popup
                            this['_' + elem + 'Content'] = null;
                            this._detachEl(this._popupStructure[elem]);
                            delete this._popupStructure[elem];
                            return this;
                        },

                        _updateScrollPosition: function () {
                            if (this._baron) {
                                this._baron.update();
                            }
                        },

                        resize: function () {
                            var scrolled = this._updateLayout();
                            this._updatePosition();

                            if (!scrolled) {
                                if (this._isBaronExist) {
                                    this._scrollerWrapper.style.height = '';
                                    DG.DomUtil.removeClass(this._scroller, 'dg-scroller');

                                    DG.DomUtil.addClass(this._scroller, 'dg-scroller_hidden_true');
                                    DG.DomUtil.removeClass(this._scroller, 'dg-scroller');
                                    DG.DomEvent.off(this._scroller, 'scroll', this._onScroll);
                                }
                            } else if (this._isBaronExist) {
                                DG.DomUtil.removeClass(this._scroller, 'dg-scroller_hidden_true');
                                DG.DomUtil.addClass(this._scroller, 'dg-scroller');

                                var scrollTop = this._isBaronExist ? this._scroller.scrollTop : false;

                                if (scrollTop) {
                                    this._scroller.scrollTop = scrollTop;
                                }

                                var innerHeight = this.options.maxHeight - this.options.border * 2 - this._getDelta();
                                this._scrollerWrapper.style.height = innerHeight + 'px';

                                this._updateScrollPosition();
                            } else if (!this._isContentHeightEnough()) {
                                this._initBaronScroller();
                                this._initBaron();
                            }

                            this._adjustPan();
                            this._bindAdjustPanOnTransitionEnd();
                        },

                        _adjustPan: function (e) {
                            if (!this._map) {
                                return;
                            }

                            if (e) {
                                // animated popup is opening (height from 0 to max)
                                if (e.propertyName === 'max-height') {
                                    // when it's finished we are here
                                    DG.DomEvent.off(this._wrapper, DG.DomUtil.TRANSITION_END, this._adjustPan);
                                } else {
                                    // here's intermediate steps - we don't need to process them
                                    return;
                                }
                            }

                            var options = this.options;

                            if (!options.autoPan) {
                                return;
                            }

                            var map = this._map,
                                containerHeight = this._container.offsetHeight,
                                containerWidth = this._containerWidth,
                                layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

                            if (this._zoomAnimated) {
                                layerPos._add(L.DomUtil.getPosition(this._container));
                            }

                            var autoPanPadding = [options.autoPanPadding[0], options.autoPanPadding[1]];

                            // if width of map is more then width of popup and controls
                            // set default autoPanPadding to width controls
                            if (!this._isAutoPanPaddingUserDefined && this._map._container.offsetWidth >= options.maxWidth + options.mapControlsWidth * 2) {
                                autoPanPadding[0] = options.mapControlsWidth;
                            }

                            var containerPos = map.layerPointToContainerPoint(layerPos),
                                padding = L.point(autoPanPadding),
                                paddingTL = L.point(options.autoPanPaddingTopLeft || padding),
                                paddingBR = L.point(options.autoPanPaddingBottomRight || padding),
                                size = map.getSize(),
                                dx = 0,
                                dy = 0;

                            if (size.x === 0 || size.y === 0) {
                                // map isn't visible
                                return;
                            }

                            if (containerPos.x + containerWidth + paddingBR.x > size.x) {
                                // right
                                dx = containerPos.x + containerWidth - size.x + paddingBR.x;
                            }
                            if (containerPos.x - dx - paddingTL.x < 0) {
                                // left
                                dx = containerPos.x - paddingTL.x;
                            }
                            if (containerPos.y + containerHeight + paddingBR.y > size.y) {
                                // bottom
                                dy = containerPos.y + containerHeight - size.y + paddingBR.y;
                            }
                            if (containerPos.y - dy - paddingTL.y < 0) {
                                // top
                                dy = containerPos.y - paddingTL.y;
                            }

                            if (dx || dy) {
                                map.fire('autopanstart').panBy([dx, dy]);
                            }
                        },

                        _bindAdjustPanOnTransitionEnd: function () {
                            if (DG.DomUtil.TRANSITION) {
                                DG.DomEvent.on(this._wrapper, DG.DomUtil.TRANSITION_END, this._adjustPan, this);
                            } else {
                                this._adjustPan();
                            }
                        },

                        _isContentHeightEnough: function () {
                            // () -> Boolean
                            var options = this.options;

                            if (!options.maxHeight) {
                                return true;
                            }

                            var popupHeight = this._popupStructure.body ? this._popupStructure.body.offsetHeight + this._getDelta() : this._contentNode.offsetHeight;

                            popupHeight += options.border * 2;

                            return popupHeight <= options.maxHeight;
                        },

                        _initBaronScroller: function () {
                            var contentNode = this._popupStructure.body.parentNode,
                                scrollerWrapper = this._scrollerWrapper = DG.DomUtil.create('div', 'dg-scroller__wrapper', contentNode),
                                scroller = this._scroller = DG.DomUtil.create('div', 'dg-scroller', scrollerWrapper),
                                barWrapper = this._barWrapper = DG.DomUtil.create('div', 'dg-scroller__bar-wrapper', scroller),
                                innerHeight = this.options.maxHeight - this.options.border * 2;

                            this._scrollerBar = DG.DomUtil.create('div', 'dg-scroller__bar', barWrapper);
                            scroller.appendChild(this._detachEl(this._popupStructure.body));

                            innerHeight -= this._getDelta();
                            scrollerWrapper.style.height = Math.max(18, innerHeight) + 'px';
                            scrollerWrapper.style.width = contentNode.offsetWidth + 5 + 'px'; //TODO

                            this._isBaronExist = true;

                            this._switchEvents();
                        },

                        _onScroll: function (e) {
                            this.fire('scroll', { originalEvent: e });
                        },

                        _onClick: function (e) {
                            e.target = e.target || e.srcElement;

                            if (!this._moving) {
                                this.fire('click', { originalEvent: e });
                            }
                        },

                        _onStart: function (e) {
                            this._moved = false;

                            if (this._moving) {
                                return;
                            }

                            var first = e.touches ? e.touches[0] : e;

                            this._startPoint = new DG.Point(first.clientX, first.clientY);

                            this._toggleTouchEvents();
                        },

                        _onEnd: function (e) {
                            this._toggleTouchEvents(true);

                            this._onClick(e);

                            this._moving = false;
                        },

                        _onMove: function (e) {

                            if (e.touches && e.touches.length > 1) {
                                this._moved = true;
                                return;
                            }

                            var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,
                                newPoint = DG.point(first.clientX, first.clientY),
                                offset = Math.abs(newPoint.subtract(this._startPoint).y);

                            if (!offset || offset < 10) {
                                return;
                            }

                            this._moving = this._moved = true;
                        },

                        _initBaron: function () {
                            var context = this._scrollerWrapper;
                            this._baron = graf({
                                scroller: '.dg-scroller',
                                bar: '.dg-scroller__bar',
                                track: '.dg-scroller__bar-wrapper',
                                $: function (selector) {
                                    var node = {}.toString.call(selector) === '[object String]' ? context.querySelector(selector) : selector;

                                    return new BaronDomHelper(node);
                                },
                                event: function (elem, event, func, mode) {
                                    event.split(' ').forEach(function (type) {
                                        DG.DomEvent[mode || 'on'](elem, type, func);
                                    });
                                }
                            });
                        },

                        _initHeader: function () {
                            this._popupStructure.header = DG.DomUtil.create('header', 'dg-popup__header', this._contentNode);
                            this._popupStructure.header.setAttribute('dir', this.options.textDirection);
                        },

                        _initFooter: function () {
                            this._popupStructure.footer = DG.DomUtil.create('footer', 'dg-popup__footer', this._contentNode);
                            this._popupStructure.footer.setAttribute('dir', this.options.textDirection);
                        },

                        _initBodyContainer: function () {
                            this._popupStructure.wrapper = DG.DomUtil.create('div', 'dg-popup__container-wrapper', this._contentNode);
                            this._popupStructure.body = DG.DomUtil.create('div', 'dg-popup__container', this._popupStructure.wrapper);
                            this._popupStructure.body.setAttribute('dir', this.options.textDirection);
                        },

                        update: function () {
                            if (!this._map) {
                                return;
                            }

                            if (!DG.Browser.ielt9) {
                                this._container.style.visibility = 'hidden';
                            }
                            this._switchEvents(true);

                            this._clearNode(this._contentNode);
                            this._isBaronExist = false;

                            // init popup content dom structure
                            if (this._headerContent) {
                                this._initHeader();
                            }
                            if (this._bodyContent) {
                                this._initBodyContainer();
                            }
                            if (this._footerContent) {
                                this._initFooter();
                            }

                            this._updatePopupStructure();
                            this.resize();

                            DG.DomEvent.on(this._wrapper, 'click', DG.DomEvent.stopPropagation);
                            this._switchEvents();

                            if (DG.Browser.ielt9) {
                                var elem = this._popupStructure.footer;
                                if (elem) {
                                    elem.className += ' ie8';
                                }
                            }

                            if (!DG.Browser.ielt9) {
                                this._container.style.visibility = '';
                            }
                        },

                        _getDelta: function () {
                            // () -> Number
                            var delta = 0,
                                popup = this._popupStructure;

                            if (popup.header) {
                                delta += popup.header.offsetHeight;
                            }
                            if (popup.footer) {
                                delta += popup.footer.offsetHeight;
                            }

                            return delta;
                        },

                        _updateLayout: function () {
                            var opts = this.options,
                                content = this._contentNode,
                                // leaflet-popup-content
                            wrapper = this._wrapper,
                                // leaflet-popup-content-wrapper
                            style = content.style,
                                wrapperStyle = wrapper.style,
                                width,
                                scrolledClass = 'leaflet-popup-scrolled',
                                result = false;

                            style.margin = opts.border + 'px';

                            DG.DomUtil.removeClass(content, scrolledClass);

                            if (this._isContentHeightEnough()) {
                                wrapperStyle.maxHeight = content.offsetHeight + opts.border * 2 + 'px';
                            } else {
                                wrapperStyle.maxHeight = opts.maxHeight + 'px';
                                DG.DomUtil.addClass(content, scrolledClass);
                                result = true;
                            }

                            var availableWidth = opts.autoPanPadding[0] * 2;

                            if (opts.sprawling) {
                                width = opts.maxWidth;

                                width = Math.min(width, this._map._container.offsetWidth - availableWidth);
                                width = Math.max(width, opts.minWidth);
                            } else {
                                wrapperStyle.width = '';

                                style.whiteSpace = 'nowrap';
                                width = wrapper.offsetWidth;
                                style.whiteSpace = '';

                                width = Math.min(width, this._map._container.offsetWidth - availableWidth);
                                width = Math.min(Math.max(width, opts.minWidth), opts.maxWidth);
                            }

                            wrapperStyle.width = width + 'px';

                            this._containerWidth = this._container.offsetWidth;

                            return result;
                        },

                        _updatePopupStructure: function () {
                            Object.keys(this._popupStructure).forEach(function (item) {
                                this._insertContent(this['_' + item + 'Content'], this._popupStructure[item]);
                            }, this);

                            this.fire('contentupdate');
                        },

                        _insertContent: function (content, node) {
                            // (String | DOMElement, DOMElement)
                            if (!content || !node) {
                                return;
                            }

                            content = typeof content === 'function' ? content(this._source || this) : content;

                            if (typeof content === 'string') {
                                node.innerHTML = content;
                            } else {
                                this._clearNode(node);
                                node.appendChild(content);
                            }
                        },

                        _clearNode: function (node) {
                            // (DOMElement)
                            while (node.hasChildNodes()) {
                                node.removeChild(node.firstChild);
                            }
                        },

                        _detachEl: function (elem) {
                            // (DOMElement) -> DOMElement
                            if (elem.parentNode) {
                                elem.parentNode.removeChild(elem);
                            }
                            return elem;
                        },

                        _switchEvents: function (on) {
                            // (Boolean)
                            var switcher = on ? 'off' : 'on';

                            if (!DG.Browser.touch) {
                                DG.DomEvent[switcher](this._contentNode, 'click', this._onClick, this);
                            } else {
                                DG.DomEvent[switcher](this._contentNode, 'touchstart mousedown mousemove', this._onStart, this);
                            }

                            if (this._isBaronExist) {
                                DG.DomEvent[switcher](this._scroller, 'scroll', this._onScroll, this);
                            }
                        },

                        _toggleTouchEvents: function (on) {
                            var switcher = on ? 'off' : 'on';

                            DG.DomEvent[switcher](this._contentNode, 'touchmove', this._onMove, this);
                            DG.DomEvent[switcher](this._contentNode, 'touchend', this._onEnd, this);
                        }

                    });
                })();

                DG.Map.include({
                    _markerClass: 'dg-customization__marker_type_mushroom',
                    _markerShowClass: 'dg-customization__marker_appear',
                    _markerHideClass: 'dg-customization__marker_disappear',
                    _dgHideClass: 'dg-popup_hidden_true',
                    openPopup: function (popup, latlng, options) {
                        // (Popup) or (String || HTMLElement, LatLng[, Object])
                        if (!(popup instanceof L.Popup)) {
                            var content = popup;

                            popup = new L.Popup(options).setContent(content);
                        }

                        if (latlng) {
                            popup.setLatLng(latlng);
                        }

                        if (this.hasLayer(popup)) {
                            return this;
                        }

                        if (this._popup && this._popup.options.autoClose) {
                            this.closePopup();
                        }

                        this._popup = popup;

                        if (popup._source && popup._source._icon) {
                            if (popup._source._icon.className.indexOf(this._markerClass) !== -1) {
                                DG.DomUtil.removeClass(popup._source._icon, this._markerShowClass);
                                DG.DomUtil.addClass(popup._source._icon, this._markerHideClass);
                            } else {
                                DG.DomUtil.addClass(popup._source._icon, this._dgHideClass);
                                if (popup._source._shadow) {
                                    DG.DomUtil.addClass(popup._source._shadow, this._dgHideClass);
                                }
                            }
                        }

                        return this.addLayer(popup);
                    },

                    closePopup: function (popup) {
                        // (Popup) -> Popup
                        if (!popup || popup === this._popup) {
                            popup = this._popup;
                            this._popup = null;
                        }
                        if (popup) {
                            if (popup._source && popup._source._icon) {
                                if (popup._source._icon.className.indexOf(this._markerClass) !== -1) {
                                    DG.DomUtil.removeClass(popup._source._icon, this._markerHideClass);
                                    DG.DomUtil.addClass(popup._source._icon, this._markerShowClass);
                                } else {
                                    DG.DomUtil.removeClass(popup._source._icon, this._dgHideClass);
                                    if (popup._source._shadow) {
                                        DG.DomUtil.removeClass(popup._source._shadow, this._dgHideClass);
                                    }
                                }
                            }
                            this.removeLayer(popup);
                        }

                        return this;
                    }
                });

                DG.Dictionary = {};

                DG.Dictionary.ru = {
                    pluralRules: function (n) {
                        // (Number)
                        if (n % 10 === 1 && n % 100 !== 11) {
                            // 1, 21
                            return 0;
                        }
                        if (n % 10 >= 2 && n % 10 <= 4 && n % 10 % 1 === 0 && (n % 100 < 12 || n % 100 > 14)) {
                            // 2, 3
                            return 1;
                        }

                        if (n % 10 === 0 || n % 10 >= 5 && n % 10 <= 9 && n % 10 % 1 === 0 || n % 100 >= 11 && n % 100 <= 14 && n % 100 % 1 === 0) {
                            // 13, 17
                            return 2;
                        }
                    }
                };

                DG.Dictionary.en = {
                    pluralRules: function (n) {
                        // (Number)
                        if (n === 1) {
                            // 1
                            return 0;
                        } else {
                            return 1; //0, 2, 3, 4 ..
                        }
                    }
                };

                DG.Dictionary.it = {
                    pluralRules: function (n) {
                        // (Number)
                        if (n === 1) {
                            // 1
                            return 0;
                        } else {
                            return 1; //0, 2, 3, 4 ..
                        }
                    }
                };

                DG.Dictionary.cs = {
                    pluralRules: function (n) {
                        // (Number)
                        return n === 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2;
                    }
                };

                DG.Dictionary.es = {
                    pluralRules: function (n) {
                        // (Number)
                        return n >= 2 ? 1 : 0;
                    }
                };

                // Stub for Arabic language, we don't have cases with plural form usage
                // Actually Arabic has 6 plural forms
                DG.Dictionary.ar = {
                    pluralRules: function () {
                        return 0;
                    }
                };

                DG.Locale = {
                    t: function (msg, argument) {
                        // (String, Number) -> String
                        var result,
                            lang = this._map.getLang(),
                            msgIsset = false,
                            dictionaryMsg,
                            exp;

                        if (typeof this.constructor.Dictionary[lang] === 'undefined') {
                            if (lang === 'ar') {
                                lang = 'en';
                            } else {
                                lang = DG.config.defaultLang;
                            }
                        }
                        dictionaryMsg = this.constructor.Dictionary[lang][msg];
                        msgIsset = typeof dictionaryMsg !== 'undefined';
                        if (!msgIsset) {
                            return msg;
                        }
                        result = msgIsset ? dictionaryMsg : msg;

                        if (argument !== undefined) {
                            argument = parseInt(argument, 10);
                            argument = isNaN(argument) ? 0 : argument;
                            exp = this.constructor.Dictionary[lang].pluralRules(argument);
                            result = dictionaryMsg[exp];
                        }

                        result = DG.Util.template(result, { n: argument });
                        return result;
                    }
                };

                DG.Map.include({
                    setLang: function (lang) {
                        // (String)
                        if (lang && Object.prototype.toString.call(lang) === '[object String]') {
                            this.options.currentLang = lang;
                            this.fire('langchange', { 'lang': lang });
                        }
                    },

                    getLang: function () {
                        // () -> String
                        // If the language hasn't been set before, set it to page language or
                        // default language from config
                        if (!this.options.currentLang) {
                            var root = document.documentElement;
                            var lang = root.lang || root.getAttributeNS && root.getAttributeNS('http://www.w3.org/XML/1998/namespace', 'lang') || DG.config.defaultLang;

                            this.options.currentLang = lang;
                        }

                        return this.options.currentLang;
                    }
                });

                DG.RoundControl = DG.Control.extend({
                    includes: DG.Mixin.Events,

                    options: {
                        position: 'topright',
                        iconClass: 'default'
                    },

                    onAdd: function (map) {
                        var controlClass = this._controlCLass = 'dg-control-round',
                            controlIconClass = this._controlIconCLass = this._controlCLass + '__icon',
                            container = DG.DomUtil.create('div', '');

                        if (this._disable) {
                            return container;
                        }
                        DG.DomUtil.addClass(container, controlClass);

                        var link = this._link = DG.DomUtil.create('a', controlIconClass + ' ' + controlIconClass + '_name_' + this.options.iconClass, container);

                        link.href = '#';

                        this._renderTranslation();

                        this._map = map;

                        DG.DomEvent.on(container, 'click', this._toggleControl, this).on(container, 'dblclick', DG.DomEvent.stopPropagation).on(link, 'mousedown', DG.DomEvent.stopPropagation);

                        this.fireEvent('add');

                        return container;
                    },

                    onRemove: function () {
                        this.fireEvent('remove');
                        DG.DomEvent.off(this._link, 'click', this._toggleControl);
                    },

                    setState: function (state) {
                        if (!this._link || !this._container) {
                            return this;
                        }

                        if (this._state) {
                            DG.DomUtil.removeClass(this._container, this._controlCLass + '_state_' + this._state);
                            DG.DomUtil.removeClass(this._link, this._controlIconCLass + '_state_' + this._state);

                            this._state = null;
                        }

                        if (state) {
                            this._state = state;

                            DG.DomUtil.addClass(this._container, this._controlCLass + '_state_' + this._state);
                            DG.DomUtil.addClass(this._link, this._controlIconCLass + '_state_' + this._state);
                        }

                        return this;
                    },

                    _toggleControl: function (e) {
                        DG.DomEvent.stop(e);
                        this.fireEvent('click');
                    }
                });

                DG.RoundControl.include(DG.Locale);

                DG.roundControl = function (options) {
                    return new DG.RoundControl(options);
                };

                var ie9 = function () {
                    var div = document.createElement('div');
                    var all = div.getElementsByTagName('i');
                    div.innerHTML = '<!--[if IE 9]><i></i><![endif]-->';
                    return Boolean(all[0]);
                }();

                var safari51 = DG.Browser.safari && navigator.userAgent.indexOf('Version/5.1') !== -1;

                var wasPreviouslyDisabled = false;

                // Old Safari throws error when localStorage.getItem is called in private mode
                try {
                    wasPreviouslyDisabled = localStorage.getItem('DGMuseum') === 'false';
                } catch (err) {
                    // do nothing
                }

                DG.Map.mergeOptions({
                    museum: !wasPreviouslyDisabled && (DG.Browser.ielt9 || ie9 || DG.Browser.opera12 || safari51)
                });

                DG.Map.Museum = DG.Handler.extend({
                    statics: {
                        Dictionary: {
                            ar: {
                                wearesorry: 'لا نضمن لك تشغيل ثابت للتطبيق على متصفحك. حاول التحديث:'
                            },
                            cs: {
                                wearesorry: 'Nezaručujeme stabilní fungování aplikace ve Vašem prohlížeči. Zkuste provést aktualizaci:'
                            },
                            en: {
                                wearesorry: 'We do not guarantee stable operation of the application in your browser. Try updating:'
                            },
                            es: {
                                wearesorry: 'No garantizamos un funcionamiento estable de la aplicación en su buscador. Intente actualizarlo:'
                            },
                            it: {
                                wearesorry: 'Non garantiamo il funzionamento stabile dell\'applicazione nel tuo browser. Prova ad aggiornare:'
                            },
                            ru: {
                                wearesorry: 'Мы не гарантируем стабильную работу приложения в вашем браузере. Попробуйте обновиться:'
                            }
                        }
                    },

                    includes: [DG.Locale],

                    initialize: function (map) {
                        this._map = map;

                        this._element = document.createElement('div');
                        this._element.className = 'dg-museum';
                        this._element.innerHTML = '<span></span>' + '<a class="dg-museum-browser dg-museum__chrome" target="_blank" href="https://www.google.com/chrome/"></a>' + '<a class="dg-museum-browser dg-museum__firefox" target="_blank" href="https://www.mozilla.org/firefox/new/"></a>' + '<a class="dg-museum-browser dg-museum__safari" target="_blank" href="https://support.apple.com/downloads/safari"></a>' + '<a class="dg-museum-browser dg-museum__opera" target="_blank" href="https://www.opera.com/"></a>' + '<a class="dg-museum-browser dg-museum__ie" target="_blank" href="https://windows.microsoft.com/internet-explorer/download-ie"></a>';

                        this._text = this._element.children[0];

                        this._closeButton = document.createElement('span');
                        this._closeButton.className = 'dg-museum__close';
                        this._element.appendChild(this._closeButton);

                        this._renderTranslation();
                    },

                    addHooks: function () {
                        this._map.getContainer().appendChild(this._element);
                        this._map.on('langchange', this._renderTranslation, this);
                        DG.DomEvent.on(this._closeButton, 'click', this._onCloseButtonClick, this);
                    },

                    removeHooks: function () {
                        this._map.getContainer().removeChild(this._element);
                        this._map.off('langchange', this._renderTranslation, this);
                        DG.DomEvent.off(this._closeButton, 'click', this._onCloseButtonClick, this);
                    },

                    _onCloseButtonClick: function (e) {
                        DG.DomEvent.stop(e);

                        // Old Safari throws error when localStorage.getItem is called in private mode
                        try {
                            localStorage.setItem('DGMuseum', 'false');
                        } catch (err) {
                            // do nothing
                        }

                        this.disable();
                    },

                    _renderTranslation: function () {
                        var lang = this._map.getLang();
                        this._text.innerHTML = this.t('wearesorry');
                        this._element.setAttribute('dir', lang === 'ar' ? 'rtl' : 'ltr');
                    }
                });

                DG.Map.addInitHook('addHandler', 'museum', DG.Map.Museum);

                DG.configTheme = DG.configTheme || {};

                DG.configTheme.markersData = {
                    iconSize: [22, 34],
                    className: 'dg-customization__marker dg-customization__marker_type_mushroom',
                    iconAnchor: [10, 32]
                };

                // Fix a lot of bugs with pinch-zooming
                // See https://github.com/2gis/mapsapi/issues/327
                DG.Map.mergeOptions({
                    bounceAtZoomLimits: false
                });

                //Inject observing localization change
                var controlAddTo = DG.Control.prototype.addTo;

                DG.Control.include({
                    addTo: function (map) {
                        map.on('langchange', this._renderTranslation, this);

                        return controlAddTo.call(this, map);
                    },
                    _renderTranslation: function () {}
                });

                // Add some browser detection
                DG.Browser.safari51 = DG.Browser.safari && navigator.userAgent.indexOf('Version/5.1') !== -1;

                // DG.Browser.touch checks whether touch events supported or not; touchEnabled checks if it's a touch device
                var msPointer = navigator.msPointerEnabled && navigator.msMaxTouchPoints && !window.PointerEvent;
                var pointer = window.PointerEvent && navigator.pointerEnabled && navigator.maxTouchPoints || msPointer;
                var documentTouch = window.DocumentTouch && document instanceof window.DocumentTouch;
                DG.Browser.touchEnabled = pointer || 'ontouchstart' in window || documentTouch;

                // Applies 2GIS divIcon to marker
                DG.Marker.prototype.options.icon = DG.divIcon(DG.configTheme.markersData);

                // support old option clickable
                var utilSetOptions = DG.Util.setOptions;

                DG.setOptions = L.setOptions = DG.Util.setOptions = function (obj, options) {
                    if (options && typeof options.clickable !== 'undefined') {
                        options.interactive = options.clickable;
                    }

                    return utilSetOptions.call(this, obj, options);
                };

                DG.Layer.mergeOptions({
                    nonBubblingEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu']
                });

                L.Canvas.include({
                    // overwrite the function without mousemove debounce as it breaks metalayers events
                    _initContainer: function () {
                        var container = this._container = document.createElement('canvas');

                        L.DomEvent.on(container, 'mousemove', this._onMouseMove, this).on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this).on(container, 'mouseout', this._handleMouseOut, this);

                        this._ctx = container.getContext('2d');
                    }
                });

                var initMap = DG.Map.prototype.initialize,
                    panBy = DG.Map.prototype.panBy,
                    getBoundsZoom = DG.Map.prototype.getBoundsZoom,
                    setMaxZoom = DG.Map.prototype.setMaxZoom;

                // Restrict zoom level according to 2gis projects, in case if dgTileLayer is only one
                DG.Map.include({

                    // number of tileLayers without 2gis layers
                    _tileLayersNumber: 0,

                    _mapMaxZoomCache: null,

                    //TODO try refactor it after up on new leaflet (> 0.7)
                    initialize: function (id, options) {
                        // (HTMLElement or String, Object)
                        // Override default wheelPxPerZoomLevel value to avoid zooming too fast
                        // on mouse wheel rotation
                        // See https://github.com/2gis/mapsapi/issues/343
                        options = DG.extend({ wheelPxPerZoomLevel: 10000 }, options);

                        this.metaLayers = [];

                        initMap.call(this, id, options);

                        //  Project must be checked after BaseLayer init which occurs in InitHook (see orig method definition)
                        if (this.options.center && this.options.zoom !== undefined) {
                            this.setView(DG.latLng(this.options.center), this.options.zoom, { reset: true });
                        }

                        this._lastMetalayer = {
                            layer: undefined,
                            entity: undefined
                        };
                    },

                    setView: function (center, zoom, options) {
                        this._restrictZoom(center, zoom);

                        zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
                        center = this._limitCenter(DG.latLng(center), zoom, this.options.maxBounds);
                        options = options || {};

                        if (options.animate) {
                            options.animate = this._testAnimation(center);
                        }

                        this._stop();

                        if (this._loaded && !options.reset && options !== true) {

                            if (options.animate !== undefined) {
                                options.zoom = DG.extend({
                                    animate: options.animate,
                                    duration: options.duration
                                }, options.zoom);
                                options.pan = DG.extend({
                                    animate: options.animate,
                                    duration: options.duration
                                }, options.pan);
                            }

                            // try animating pan or zoom
                            var animated = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);

                            if (animated) {
                                // prevent resize handler call, the view will refresh after animation anyway
                                clearTimeout(this._sizeTimer);
                                return this;
                            }
                        }

                        // animation didn't start, just reset the map view
                        this._resetView(center, zoom);

                        return this;
                    },

                    panBy: function (offset, options) {
                        var map = panBy.call(this, offset, options);

                        var zoom = this._restrictZoom(this.getCenter());
                        if (this.getZoom() > zoom) {
                            this.setZoom(zoom);
                        }

                        return map;
                    },

                    getBoundsZoom: function (bounds, inside, padding) {
                        bounds = DG.latLngBounds(bounds);
                        this._restrictZoom(bounds);
                        return getBoundsZoom.call(this, bounds, inside, padding);
                    },

                    getTileLayersNumber: function () {
                        return this._tileLayersNumber;
                    },

                    setMaxZoom: function (zoom) {
                        this._mapMaxZoomCache = null;
                        return setMaxZoom.call(this, zoom);
                    },

                    _testAnimation: function (coords) {
                        //if we jump to other project - disable animation
                        if (this.projectDetector.enabled()) {
                            var projectFrom = this.projectDetector.getProject(),
                                projectTo = this.projectDetector.isProjectHere(coords);

                            if (projectFrom && projectTo) {
                                return projectFrom.code === projectTo.code;
                            }
                        }

                        return true;
                    },

                    _updateTileLayers: function (e) {
                        if (!(e.layer instanceof DG.TileLayer) || e.layer._isDg) {
                            return;
                        }

                        if (e.type === 'layeradd') {
                            this._tileLayersNumber++;
                        } else {
                            this._tileLayersNumber--;
                        }
                    },

                    _getNewBounds: function (coords, zoom) {
                        if (coords instanceof DG.LatLngBounds) {
                            return coords;
                        }

                        var point = this.project(coords, zoom);
                        var screenSize = this.getSize().divideBy(2);

                        var sw = this.unproject(point.subtract(screenSize), zoom);
                        var ne = this.unproject(point.add(screenSize), zoom);

                        return DG.latLngBounds(sw, ne);
                    },

                    _restrictZoom: function (coords, zoom) {
                        if (this._layers && this.projectDetector.enabled() && this._tileLayersNumber === 0) {

                            var mapOptions = this.options,
                                isMapMaxZoom = !!mapOptions.maxZoom,
                                dgTileLayer = this.baseLayer,
                                bounds = this._getNewBounds(coords, zoom),
                                project = this.projectDetector.isProjectHere(bounds);

                            if (isMapMaxZoom) {
                                if (!this._mapMaxZoomCache) {
                                    if (this.baseLayer.options.detectRetina && DG.Browser.retina && mapOptions.maxZoom > 0) {
                                        mapOptions.maxZoom--;
                                    }

                                    this._mapMaxZoomCache = mapOptions.maxZoom;
                                }
                                mapOptions.maxZoom = this._mapMaxZoomCache && project ? this._mapMaxZoomCache : DG.config.projectLeaveMaxZoom;
                                if (project) {
                                    this._mapMaxZoomCache = mapOptions.maxZoom;
                                }

                                return mapOptions.maxZoom;
                            } else {
                                if (project) {
                                    if (dgTileLayer.options.detectRetina && DG.Browser.retina && project.maxZoom > 0) {
                                        dgTileLayer.options.maxZoom = project.maxZoom - 1;
                                    } else {
                                        dgTileLayer.options.maxZoom = project.maxZoom;
                                    }
                                } else {
                                    dgTileLayer.options.maxZoom = DG.config.projectLeaveMaxZoom;
                                }

                                dgTileLayer.options.maxNativeZoom = dgTileLayer.options.maxZoom;
                                this._updateZoomLevels();

                                return dgTileLayer.options.maxZoom;
                            }
                        }
                    },

                    // Added meta layers events processing before map events
                    _fireDOMEvent: function (e, type, targets) {
                        if (e.keyCode === 13) {
                            // https://github.com/Leaflet/Leaflet/issues/5499
                            return;
                        }
                        if (e.type === 'click') {
                            // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
                            // @event preclick: MouseEvent
                            // Fired before mouse click on the map (sometimes useful when you
                            // want something to happen on click before any existing click
                            // handlers start running).
                            var synth = L.Util.extend({}, e);
                            synth.type = 'preclick';
                            this._fireDOMEvent(synth, synth.type, targets);
                        }

                        if (e._stopped) {
                            return;
                        }

                        // Find the layer the event is propagating from and its parents.
                        targets = (targets || []).concat(this._findEventTargets(e, type));

                        if (!targets.length) {
                            return;
                        }

                        var target = targets[0];
                        if (type === 'contextmenu' && target.listens(type, true)) {
                            L.DomEvent.preventDefault(e);
                        }

                        var data = {
                            originalEvent: e
                        };

                        if (e.type !== 'keypress') {
                            var isMarker = target instanceof L.Marker;
                            data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
                            data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
                            data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
                        }

                        for (var i = 0; i < targets.length; i++) {
                            // Check metalayers before dispatch the event to the map
                            if (targets[i] === this) {
                                var metalayer = this._getCurrentMetaLayer(data);

                                if (type === 'mousemove') {
                                    if (this._lastMetalayer.entity && metalayer.entity && this._lastMetalayer.entity.id === metalayer.entity.id) {
                                        this._fireMetalayerEvent('mousemove', metalayer, data);
                                    } else {
                                        this._fireMetalayerEvent('mouseout', this._lastMetalayer, data);
                                        this._fireMetalayerEvent('mouseover', metalayer, data);
                                        this._fireMetalayerEvent('mousemove', metalayer, data);
                                        this._lastMetalayer = metalayer;
                                    }
                                } else {
                                    this._fireMetalayerEvent(type, metalayer, data);
                                }

                                // If the event wasn't stopped in metalayers, dispatch it to the map
                                if (!data.originalEvent._stopped) {
                                    targets[i].fire(type, data, true);
                                }
                            } else {
                                targets[i].fire(type, data, true);
                                if (this._lastMetalayer.entity && data.originalEvent._stopped) {
                                    // fixes L.circle([54.983136831455, 82.897440725094], 200).addTo(map);
                                    this._fireMetalayerEvent('mouseout', this._lastMetalayer, data);
                                    this._lastMetalayer = {
                                        layer: undefined,
                                        entity: undefined
                                    };
                                }
                            }

                            if (data.originalEvent._stopped || targets[i].options.nonBubblingEvents && L.Util.indexOf(targets[i].options.nonBubblingEvents, type) !== -1) {
                                return;
                            }
                        }
                    },

                    _getCurrentMetaLayer: function (data) {
                        // Not forget for IE8 with srcElement
                        var eventTarget = data.originalEvent.target || data.originalEvent.srcElement;

                        // Suppose that user can interact with the metalayer only if there are no layers between cursor and map
                        if (
                        // For all browsers which support pointer-events: none on tiles
                        eventTarget === this._container ||
                        // And for IE10 or less where targets are tiles
                        DG.Browser.ie && eventTarget.className === 'leaflet-tile leaflet-tile-loaded' ||
                        // The only exception is canvas, because a canvas layer occupies the whole screen
                        eventTarget.tagName === 'CANVAS') {
                            for (var j = this.metaLayers.length - 1; j >= 0; j--) {
                                var metaEntity = this.metaLayers[j].getHoveredObject(data);
                                if (metaEntity) {
                                    return {
                                        layer: this.metaLayers[j],
                                        entity: metaEntity
                                    };
                                }
                            }
                        }
                        return {
                            layer: undefined,
                            entity: undefined
                        };
                    },

                    _fireMetalayerEvent: function (type, metalayer, data) {
                        if (!metalayer.entity) {
                            return;
                        }
                        var listener = metalayer.layer.mapEvents[type];
                        if (!listener) {
                            return;
                        }
                        data.entity = metalayer.entity;
                        listener.call(metalayer.layer, data);
                    }
                });

                DG.Map.addInitHook(function () {
                    this.on('layeradd layerremove', this._updateTileLayers);
                });

                // Set css property touch-action to auto if dragging is false.
                // Need for scrolling page in mobile using our map dom element.
                // todo: I made issue in leaflet https://github.com/Leaflet/Leaflet/issues/4415
                DG.Map.addInitHook(function () {
                    if (this.options.dragging == false && this.options.tap == false) {
                        DG.DomUtil.addClass(this._container, 'dg-dragging-false');
                    }
                });

                DG.Map.addInitHook(function () {
                    var errorUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAAA1BMVEX28t5R0k5UAAAAH0lEQVR4Xu3AAQkAAADCMPunNsdhWxwAAAAAAAAAwAEhAAABg2UP5AAAAABJRU5ErkJggg==';
                    var errorRuUrl = DG.config.protocol + DG.config.baseUrl + '/img/nomap_ru.png';

                    var TileLayer = DG.Browser.mobile ? DG.MobileTileLayer : DG.TileLayer;

                    var BaseLayer = TileLayer.extend({
                        initialize: function (url, options) {
                            this._isDg = true;
                            TileLayer.prototype.initialize.call(this, url, options);
                        },

                        getTiles: function () {
                            return this._tiles;
                        }
                    });

                    var tileUrl = DG.config.protocol + (DG.Browser.retina ? DG.config.retinaTileServer : DG.config.tileServer);
                    var arabicTileUrl = DG.config.protocol + (DG.Browser.retina ? DG.config.arabicRetinaTileServer : DG.config.arabicTileServer);

                    var previewTileUrl = DG.config.protocol + (DG.Browser.retina ? DG.config.previewRetinaTileServer : DG.config.previewTileServer);
                    var arabicPreviewTileUrl = DG.config.protocol + (DG.Browser.retina ? DG.config.arabicPreviewRetinaTileServer : DG.config.arabicPreviewTileServer);

                    this.baseLayer = new BaseLayer(tileUrl, {
                        subdomains: '0123',
                        errorTileUrl: this.getLang() === 'ru' ? errorRuUrl : errorUrl,
                        detectRetina: DG.config.detectRetina,
                        maxZoom: 19,
                        maxNativeZoom: 19,
                        zIndex: 0,
                        updateWhenIdle: false, // it's okay with preview tiles
                        previewUrl: previewTileUrl
                    });

                    var currentTilesLang = ''; // 'ar' | ''

                    function updateTileUrl() {
                        var lang = this.getLang();
                        var project = this.projectDetector && this.projectDetector.getProject();

                        if (lang === 'ru' && !project) {
                            this.baseLayer.options.errorTileUrl = errorRuUrl;
                        } else {
                            this.baseLayer.options.errorTileUrl = errorUrl;
                        }

                        // Change 2GIS tiles for Arabic language in Dubai project
                        if (currentTilesLang === '' && lang === 'ar' && project && project.country_code === 'ae') {
                            currentTilesLang = 'ar';
                            this.baseLayer.setUrl(arabicTileUrl);
                            if (this.baseLayer.setPreviewUrl) {
                                this.baseLayer.setPreviewUrl(arabicPreviewTileUrl);
                            }
                        } else if (currentTilesLang === 'ar' && (lang !== 'ar' || !project || project.country_code !== 'ae')) {
                            currentTilesLang = '';
                            this.baseLayer.setUrl(tileUrl);
                            if (this.baseLayer.setPreviewUrl) {
                                this.baseLayer.setPreviewUrl(previewTileUrl);
                            }
                        }
                    }

                    updateTileUrl.call(this);

                    this.baseLayer.addTo(this);

                    this.on({
                        langchange: updateTileUrl,
                        projectchange: updateTileUrl,
                        projectleave: updateTileUrl
                    }, this);
                });

                DG.Map.mergeOptions({
                    tilesCheck: true
                });

                DG.Map.TilesCheck = DG.Handler.extend({
                    initialize: function (map) {
                        this._map = map;
                        this._layer = map.baseLayer;

                        this._moveStartEventCounter = 0;
                        this._moveEndEventCounter = 0;

                        this._loadingEventCounter = 0;
                        this._loadEventCounter = 0;
                    },

                    addHooks: function () {
                        this._map.on(this._mapEvents, this);
                        this._layer.on(this._layerEvents, this);
                    },

                    removeHooks: function () {
                        this._map.off(this._mapEvents, this);
                        this._layer.off(this._layerEvents, this);
                    },

                    _mapEvents: {
                        layeradd: function (e) {
                            if (e.layer == this._layer) {
                                this.enable();
                            }
                        },

                        layerremove: function (e) {
                            if (e.layer == this._layer) {
                                this.disable();
                            }
                        },

                        movestart: function () {
                            this._stopWaiting();

                            this._moveStartEventCounter++;
                            this._isWaiting = true;
                        },

                        moveend: function () {
                            this._moveEndEventCounter++;

                            if (!this._isWaiting && this._moveStartEventCounter !== this._moveEndEventCounter) {
                                return;
                            }

                            this._isMoveEnd = true;

                            this._checkWaiting();
                        }
                    },

                    _layerEvents: {
                        loading: function () {
                            this._loadingEventCounter++;
                        },

                        load: function () {
                            this._loadEventCounter++;

                            if (!this._isWaiting && this._loadingEventCounter !== this._loadEventCounter) {
                                return;
                            }

                            this._isLoad = true;

                            this._checkWaiting();
                        }
                    },

                    _stopWaiting: function () {
                        this._isWaiting = false;
                        this._isMoveEnd = false;
                        this._isLoad = false;
                    },

                    _checkWaiting: function () {
                        if (this._isWaiting && this._isLoad && this._isMoveEnd) {
                            this._stopWaiting();
                            this._resetCounters();
                            this._checkTiles();
                        }
                    },

                    _checkTiles: function () {
                        if (this._map.getTileLayersNumber() !== 0 || !this._map._loaded) {
                            return;
                        }

                        var zoom = this._map.getZoom();
                        var errorUrl = this._layer.options.errorTileUrl;
                        var tiles = this._layer.getTiles();

                        for (var i in tiles) {
                            if (tiles[i].coords.z === zoom && tiles[i].el.src !== errorUrl) {
                                return;
                            }
                        }

                        this._map.zoomOut();
                    },

                    _resetCounters: function () {
                        this._moveStartEventCounter = 0;
                        this._moveEndEventCounter = 0;

                        this._loadingEventCounter = 0;
                        this._loadEventCounter = 0;
                    }
                });

                DG.Map.addInitHook('addHandler', 'tilesCheck', DG.Map.TilesCheck);

                /**
                 * This customization fixes unwanted inertia movement after sudden drag stops
                 * See https://github.com/Leaflet/Leaflet/pull/4048.
                 * If this PR ever gets merged, this file can be removed.
                 */
                var onDragEnd = DG.Map.Drag.prototype._onDragEnd;

                DG.Map.Drag.include({
                    _rememberTimeAndPosition: function () {
                        var time = this._lastTime = +new Date(),
                            pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

                        this._positions.push(pos);
                        this._times.push(time);

                        // Remove all data points older than 50 ms
                        while (time - this._times[0] > 50) {
                            this._positions.shift();
                            this._times.shift();
                        }
                    },

                    _onDrag: function (e) {
                        if (this._map.options.inertia) {
                            this._rememberTimeAndPosition();
                        }

                        this._map.fire('move', e).fire('drag', e);
                    },

                    _onDragEnd: function () {
                        if (this._map.options.inertia && !DG.Browser.touch) {
                            this._rememberTimeAndPosition();
                        }

                        onDragEnd.call(this);
                    }
                });

                // from https://github.com/Turfjs/turf-inside/blob/master/index.js
                DG.PolyUtil.inside = function (point, polygon, pointReduce) {
                    pointReduce = pointReduce || DG.PolyUtil._defaultPointReduce;
                    var polys = polygon.coordinates;
                    var pt = pointReduce(point);

                    // normalize to multipolygon
                    if (polygon.type === 'Polygon') {
                        polys = [polys];
                    }

                    var insidePoly = false;
                    var i = 0;
                    while (i < polys.length && !insidePoly) {
                        // check if it is in the outer ring first
                        if (this._inRing(pt, polys[i][0], pointReduce)) {
                            var inHole = false;
                            var k = 1;
                            // check for the point in any of the holes
                            while (k < polys[i].length && !inHole) {
                                if (this._inRing(pt, polys[i][k], pointReduce)) {
                                    inHole = true;
                                }
                                k++;
                            }
                            if (!inHole) {
                                insidePoly = true;
                            }
                        }
                        i++;
                    }
                    return insidePoly;
                };

                // pt is [x,y] and ring is [[x,y], [x,y],..]
                DG.PolyUtil._inRing = function (pt, ring, pointReduce) {
                    var isInside = false;
                    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
                        var pi = pointReduce(ring[i]);
                        var pj = pointReduce(ring[j]);
                        var xi = pi[0],
                            yi = pi[1];
                        var xj = pj[0],
                            yj = pj[1];
                        var intersect = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;

                        if (intersect) {
                            isInside = !isInside;
                        }
                    }
                    return isInside;
                };

                DG.PolyUtil._defaultPointReduce = function (point) {
                    return point;
                };

                /**
                 * В файле содежатся изменения для ускорения лифлета на мобильных девайсах
                 */

                if (DG.Browser.mobile) {
                    (function () {
                        /**
                         * Хакаем addClass и removeClass, чтобы они не работали для определённых классов
                         * Сделано так, чтобы не менять кучу методов в кишках лифлета
                         *
                         * leaflet-dragging и leaflet-drag-target вызывает длинный recalculate style
                         */
                        var addClass = L.DomUtil.addClass;
                        L.DomUtil.addClass = function (el, name) {
                            if (name === 'leaflet-dragging' || name === 'leaflet-drag-target') {
                                return;
                            }

                            addClass(el, name);
                        };

                        var removeClass = L.DomUtil.removeClass;
                        L.DomUtil.removeClass = function (el, name) {
                            if (name === 'leaflet-dragging' || name === 'leaflet-drag-target') {
                                return;
                            }

                            removeClass(el, name);
                        };

                        L.Draggable.include({
                            /**
                             * Добавлено округление позиции this._startPos.add(offset)._round()
                             * И сравнение с предудыщей if (this._newPos && this._newPos.x == pos.x && this._newPos.y == pos.y) {
                             * Чтобы обновление dom происходило только при реальном изменении
                             * Убраны классы leaflet-dragging и leaflet-drag-target
                             */
                            _onMove: function (e) {
                                // Ignore simulated events, since we handle both touch and
                                // mouse explicitly; otherwise we risk getting duplicates of
                                // touch events, see #4315.
                                // Also ignore the event if disabled; this happens in IE11
                                // under some circumstances, see #3666.
                                if (e._simulated || !this._enabled) {
                                    return;
                                }

                                if (e.touches && e.touches.length > 1) {
                                    this._moved = true;
                                    return;
                                }

                                var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,
                                    newPoint = new L.Point(first.clientX, first.clientY),
                                    offset = newPoint.subtract(this._startPoint);

                                if (!offset.x && !offset.y) {
                                    return;
                                }
                                if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
                                    return;
                                }

                                L.DomEvent.preventDefault(e);

                                if (!this._moved) {
                                    // @event dragstart: Event
                                    // Fired when a drag starts
                                    this.fire('dragstart');

                                    this._moved = true;
                                    this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

                                    this._lastTarget = e.target || e.srcElement;
                                    // IE and Edge do not give the <use> element, so fetch it
                                    // if necessary
                                    if (window.SVGElementInstance && this._lastTarget instanceof SVGElementInstance) {
                                        this._lastTarget = this._lastTarget.correspondingUseElement;
                                    }
                                }

                                var pos = this._startPos.add(offset)._round();
                                this._moving = true;

                                L.Util.cancelAnimFrame(this._animRequest);
                                this._lastEvent = e;

                                if (this._newPos && this._newPos.x == pos.x && this._newPos.y == pos.y) {
                                    return;
                                }

                                this._newPos = pos;
                                this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true);
                            }
                        });

                        /**
                         * Длительность всех инерций при движении карты теперь 1 секунда
                         */
                        L.Map.Drag.include({
                            _onDragEnd: function (e) {
                                var map = this._map,
                                    options = map.options,
                                    noInertia = !options.inertia || this._times.length < 2;

                                map.fire('dragend', e);

                                if (noInertia) {
                                    map.fire('moveend');
                                } else {

                                    var direction = this._lastPos.subtract(this._positions[0]),
                                        duration = (this._lastTime - this._times[0]) / 1000,
                                        ease = options.easeLinearity,
                                        speedVector = direction.multiplyBy(ease / duration),
                                        speed = speedVector.distanceTo([0, 0]),
                                        limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
                                        limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),
                                        decelerationDuration = 1,
                                        // limitedSpeed / (options.inertiaDeceleration * ease),
                                    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

                                    if (!offset.x && !offset.y) {
                                        map.fire('moveend');
                                    } else {
                                        offset = map._limitOffset(offset, map.options.maxBounds);

                                        L.Util.requestAnimFrame(function () {
                                            map.panBy(offset, {
                                                duration: decelerationDuration,
                                                easeLinearity: ease,
                                                noMoveStart: true,
                                                animate: true
                                            });
                                        });
                                    }
                                }
                            }
                        });
                    })();
                }

                L.MobileTileLayer = L.TileLayer.extend({
                    initialize: function (url, options) {
                        L.TileLayer.prototype.initialize.call(this, url, options);

                        this._previewUrl = options.previewUrl;
                    },

                    setPreviewUrl: function (url) {
                        this._previewUrl = url;
                        this.redraw();
                    },

                    /**
                     * Быстрое навешивание событий, вместо L.DomUtil.on используем простое присваивание
                     */
                    createTile: function (coords, done, url) {
                        var tile = document.createElement('img');
                        tile.onload = L.bind(this._tileOnLoad, this, done, tile);
                        tile.onerror = L.bind(this._tileOnError, this, done, tile);

                        if (this.options.crossOrigin) {
                            tile.crossOrigin = '';
                        }

                        /*
                         Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
                         http://www.w3.org/TR/WCAG20-TECHS/H67
                        */
                        tile.alt = '';
                        tile.src = this.getTileUrl(coords, url);

                        return tile;
                    },

                    /**
                     * Убран класс leaflet-tile
                     * Добавлен хак для превью тайлов
                     */
                    _initTile: function (tile) {
                        tile.style.position = 'absolute';

                        var tileSize = this.getTileSize();
                        tile.style.width = tileSize.x + 'px';
                        tile.style.height = tileSize.y + 'px';

                        tile.style.visibility = 'hidden';
                        tile.style.pointerEvents = 'none';

                        tile.onselectstart = L.Util.falseFn;
                        tile.onmousemove = L.Util.falseFn;

                        // without this hack, tiles disappear after zoom on Chrome for Android
                        // https://github.com/Leaflet/Leaflet/issues/2078
                        if (L.Browser.android && !L.Browser.android23) {
                            tile.style.WebkitBackfaceVisibility = 'hidden';
                        }

                        return tile;
                    },

                    /**
                     * Убран класс leaflet-tile-container
                     */
                    _updateLevels: function () {

                        var zoom = this._tileZoom,
                            maxZoom = this.options.maxZoom;

                        if (zoom === undefined) {
                            return undefined;
                        }

                        for (var z in this._levels) {
                            if (this._levels[z].el.children.length || z === zoom) {
                                this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
                            } else {
                                L.DomUtil.remove(this._levels[z].el);
                                this._removeTilesAtZoom(z);
                                delete this._levels[z];
                            }
                        }

                        var level = this._levels[zoom],
                            map = this._map;

                        if (!level) {
                            level = this._levels[zoom] = {};

                            level.el = L.DomUtil.create('div', 'leaflet-zoom-animated', this._container);

                            level.el.style.zIndex = maxZoom;

                            level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
                            level.zoom = zoom;

                            this._setZoomTransform(level, map.getCenter(), map.getZoom());

                            // force the browser to consider the newly added element for transition
                            L.Util.falseFn(level.el.offsetWidth);
                        }

                        this._level = level;

                        return level;
                    },

                    /**
                     * Убрано добавление тайлов через documentFragment
                     */
                    _update: function (center) {
                        var map = this._map;
                        if (!map) {
                            return;
                        }
                        var zoom = map.getZoom();

                        if (center === undefined) {
                            center = map.getCenter();
                        }
                        if (this._tileZoom === undefined) {
                            return;
                        } // if out of minzoom/maxzoom

                        var pixelBounds = this._getTiledPixelBounds(center),
                            tileRange = this._pxBoundsToTileRange(pixelBounds),
                            tileCenter = tileRange.getCenter(),
                            queue = [],
                            margin = this.options.keepBuffer,
                            noPruneRange = new L.Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));

                        for (var key in this._tiles) {
                            var c = this._tiles[key].coords;
                            if (c.z !== this._tileZoom || !noPruneRange.contains(L.point(c.x, c.y))) {
                                this._tiles[key].current = false;
                            }
                        }

                        // _update just loads more tiles. If the tile zoom level differs too much
                        // from the map's, let _setView reset levels and prune old tiles.
                        if (Math.abs(zoom - this._tileZoom) > 1) {
                            this._setView(center, zoom);return;
                        }

                        // create a queue of coordinates to load tiles from
                        for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
                            for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
                                var coords = new L.Point(i, j);
                                coords.z = this._tileZoom;

                                if (!this._isValidTile(coords)) {
                                    continue;
                                }

                                var tile = this._tiles[this._tileCoordsToKey(coords)];
                                if (tile) {
                                    tile.current = true;
                                } else {
                                    queue.push(coords);
                                }
                            }
                        }

                        // sort tile queue to load tiles in order of their distance to center
                        queue.sort(function (a, b) {
                            return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
                        });

                        if (queue.length !== 0) {
                            // if it's the first batch of tiles to load
                            if (!this._loading) {
                                this._loading = true;
                                // @event loading: Event
                                // Fired when the grid layer starts loading tiles.
                                this.fire('loading');
                            }

                            for (i = 0; i < queue.length; i++) {
                                this._addTile(queue[i], this._level.el);
                            }
                        }
                    },

                    /**
                     * We don't load preview tile:
                     * - after zoom-in if a tile from a lower zoom is already shown
                     * - after zoom-out if four tiles from a higher zoom is already shown
                     */
                    _needPreviewTile: function (coords) {
                        if (this._tileZoom - this._map.getZoom() > 0) {
                            // zoom in
                            return !this._existTileFromLowerZoom(coords);
                        } else {
                            // zoom out
                            return !this._existTilesFromHigherZoom(coords);
                        }
                    },

                    _existTileFromLowerZoom: function (coords) {
                        var coords2 = L.point(coords.x / 2, coords.y / 2)._floor();

                        coords2.z = coords.z - 1;

                        var key = this._tileCoordsToKey(coords2);
                        var tile = this._tiles[key];
                        return tile && !tile.preview;
                    },

                    _existTilesFromHigherZoom: function (coords) {
                        var x = coords.x;
                        var y = coords.y;

                        for (var i = 2 * x; i < 2 * x + 2; i++) {
                            for (var j = 2 * y; j < 2 * y + 2; j++) {
                                var c = new L.Point(i, j);
                                c.z = coords.z + 1;
                                var key = this._tileCoordsToKey(c);
                                if (!this._tiles[key]) {
                                    return false;
                                }
                            }
                        }

                        return true;
                    },

                    /**
                     * Добавлена логика с превью тайлами
                     */
                    _addTile: function (coords, container) {
                        var tilePos = this._getTilePos(coords),
                            key = this._tileCoordsToKey(coords);

                        var wrapCoords = this._wrapCoords(coords);
                        var needPreview = this._needPreviewTile(wrapCoords);

                        var url = needPreview ? this._previewUrl : this._url;
                        var tile = this.createTile(wrapCoords, L.bind(this._tileReady, this, coords), url);

                        this._initTile(tile);

                        L.DomUtil.setPosition(tile, tilePos);

                        // save tile in cache
                        this._tiles[key] = {
                            el: tile,
                            preview: needPreview,
                            coords: coords,
                            current: true
                        };

                        container.appendChild(tile);
                        // @event tileloadstart: TileEvent
                        // Fired when a tile is requested and starts loading.
                        this.fire('tileloadstart', {
                            tile: tile,
                            coords: coords
                        });
                    },

                    /**
                     * Убран fadeAnimated и класс leaflet-tile-loaded
                     */
                    _tileReady: function (coords, err, tile) {
                        if (!this._map) {
                            return;
                        }

                        if (err) {
                            // @event tileerror: TileErrorEvent
                            // Fired when there is an error loading a tile.
                            this.fire('tileerror', {
                                error: err,
                                tile: tile,
                                coords: coords
                            });
                        }

                        var key = this._tileCoordsToKey(coords);

                        tile = this._tiles[key];
                        if (!tile) {
                            return;
                        }

                        // Если у тайла уже есть оригинальная (не пожатая) картинка,
                        // то заменим превью на нее
                        if (tile.originalEl && tile.el.parentNode) {
                            tile.el.parentNode.replaceChild(tile.originalEl, tile.el);
                            tile.el = tile.originalEl;

                            tile.originalEl = null;
                            tile.preview = false;

                            // Если у тайла есть только превью, то добавим его на карту
                            // И начнем грузить оригинальный
                        } else if (tile.preview) {
                            tile.originalEl = this.createTile(this._wrapCoords(coords), L.bind(this._tileReady, this, coords), this._url);
                            this._initTile(tile.originalEl);
                            L.DomUtil.setPosition(tile.originalEl, this._getTilePos(coords));
                        }

                        tile.loaded = +new Date();
                        tile.active = true;
                        this._pruneTiles();

                        if (!err) {
                            tile.el.style.visibility = '';

                            // @event tileload: TileEvent
                            // Fired when a tile loads.
                            this.fire('tileload', {
                                tile: tile.el,
                                preview: tile.preview,
                                coords: coords
                            });
                        }

                        if (this._noTilesToLoad()) {
                            this._loading = false;
                            // @event load: Event
                            // Fired when the grid layer loaded all visible tiles.
                            this.fire('load');

                            if (L.Browser.ielt9 || !this._map._fadeAnimated) {
                                L.Util.requestAnimFrame(this._pruneTiles, this);
                            } else {
                                // Wait a bit more than 0.2 secs (the duration of the tile fade-in)
                                // to trigger a pruning.
                                setTimeout(L.bind(this._pruneTiles, this), 250);
                            }
                        }
                    },

                    /**
                     * В отличие от оригинального метода, здесь url прокидывается параметром
                     */
                    getTileUrl: function (coords, url) {
                        var data = {
                            r: L.Browser.retina ? '@2x' : '',
                            s: this._getSubdomain(coords),
                            x: coords.x,
                            y: coords.y,
                            z: this._getZoomForUrl()
                        };
                        if (this._map && !this._map.options.crs.infinite) {
                            var invertedY = this._globalTileRange.max.y - coords.y;
                            if (this.options.tms) {
                                data['y'] = invertedY;
                            }
                            data['-y'] = invertedY;
                        }

                        return L.Util.template(url, L.extend(data, this.options));
                    }
                });

                DG.Control.Zoom.include(DG.Locale);
                DG.Control.Zoom.Dictionary = {};

                DG.Control.Zoom.include({
                    onAdd: function (map) {
                        var zoomName = 'dg-zoom',
                            buttonTemplate = '<div class="dg-control-round__icon ' + zoomName + '__control ' + zoomName + '__button ' + zoomName + '__button_type_{type}"></div>',
                            container = DG.DomUtil.create('div', zoomName);

                        this._map = map;

                        this._zoomInButton = this._createButton(DG.Util.template(buttonTemplate, { type: 'in' }), this.t('zoom_in'), 'dg-control-round ' + zoomName + '__in', container, this._zoomIn, this);
                        this._zoomOutButton = this._createButton(DG.Util.template(buttonTemplate, { type: 'out' }), this.t('zoom_out'), 'dg-control-round ' + zoomName + '__out', container, this._zoomOut, this);

                        this._updateDisabled();
                        map.on('zoomend zoomlevelschange', this._updateDisabled, this);

                        return container;
                    },

                    _originalCreateButton: DG.Control.Zoom.prototype._createButton,

                    // set active state control on mobile devices
                    _createButton: function () {
                        var args = Array.prototype.slice.call(arguments);
                        var link = this._originalCreateButton.apply(this, args);

                        var icon = link.children[0];
                        var linkActiveClass = 'dg-control-round_state_active';
                        var iconActiveClass = 'dg-control-round__icon_state_active';

                        DG.DomEvent.on(link, 'touchstart', function () {
                            DG.DomUtil.addClass(link, linkActiveClass);
                            DG.DomUtil.addClass(icon, iconActiveClass);
                        }).on(link, 'touchend touchcancel', function () {
                            DG.DomUtil.removeClass(link, linkActiveClass);
                            DG.DomUtil.removeClass(icon, iconActiveClass);
                        });

                        return link;
                    },

                    _renderTranslation: function () {
                        if (!this._zoomInButton || !this._zoomOutButton) {
                            return;
                        }

                        this._zoomInButton.title = this.t('zoom_in');
                        this._zoomOutButton.title = this.t('zoom_out');
                    }
                });

                DG.Control.Zoom.Dictionary.ru = {
                    zoom_in: 'Приблизить',
                    zoom_out: 'Отдалить'
                };

                DG.Control.Zoom.Dictionary.it = {
                    zoom_in: 'Zoom avanti',
                    zoom_out: 'Zoom indietro'
                };

                DG.Control.Zoom.Dictionary.cs = {
                    zoom_in: 'Přiblížit',
                    zoom_out: 'Oddálit'
                };

                DG.Control.Zoom.Dictionary.en = {
                    zoom_in: 'Zoom in',
                    zoom_out: 'Zoom out'
                };

                DG.Control.Zoom.Dictionary.es = {
                    zoom_in: 'Acercar',
                    zoom_out: 'Alejar'
                };

                DG.Control.Zoom.Dictionary.ar = {
                    zoom_in: '',
                    zoom_out: ''
                };

                var dust = _dereq_('dustjs-linkedin');
                _dereq_('dustjs-helpers');

                DG.dust = function (name, data) {
                    var result;

                    // The callback is called synchronously, so this works
                    dust.render(name, data, function (err, html) {
                        result = html;
                    });

                    return result;
                };

                DG.Control.Attribution.include(DG.Locale);
                DG.Control.Attribution.Dictionary = {};
                DG.Control.Attribution.include({
                    options: {
                        position: 'bottomright'
                    },

                    _getLink: function (linkType) {
                        /* eslint-disable camelcase */
                        var dictionary = {
                            ru: {
                                copyright_logo: 'http://info.2gis.ru/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                                copyright_apilink: 'http://api.2gis.ru/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                                copyright_license: 'http://law.2gis.ru/api-rules/'
                            },

                            it: {
                                copyright_logo: 'http://2gis.it/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                                copyright_apilink: 'http://2gis.it/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                                copyright_license: 'http://law.2gis.it/licensing-agreement/'
                            },

                            cz: {
                                copyright_logo: 'http://praha.2gis.cz/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                                copyright_apilink: 'http://praha.2gis.cz/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                                copyright_license: 'http://law.2gis.cz/api-rules/'
                            },

                            cl: {
                                copyright_logo: 'http://santiago.2gis.cl/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                                copyright_apilink: 'http://santiago.2gis.cl/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                                copyright_license: 'http://law.2gis.cl/api-rules/'
                            },

                            cy: {
                                copyright_logo: 'http://info.2gis.com.cy/lemesos?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                                copyright_apilink: 'http://info.2gis.com.cy/lemesos?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                                copyright_license: 'http://law.2gis.com.cy/api-rules/'
                            },

                            ae: {
                                copyright_logo: 'http://info.2gis.ae/dubai?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                                copyright_apilink: 'http://info.2gis.ae/dubai?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                                copyright_license: 'http://law.2gis.ae/api-rules/'
                            }
                        };
                        /* eslint-enable camelcase */

                        var countryCode = this._countryCode in dictionary ? this._countryCode : 'ru';

                        return dictionary[countryCode][linkType];
                    },

                    onAdd: function (map) {
                        if (!map._copyright) {
                            map._copyright = true;
                            this._first = true;
                        }

                        map.attributionControl = this;
                        this._container = DG.DomUtil.create('div', 'dg-attribution');
                        DG.DomEvent.disableClickPropagation(this._container);

                        for (var i in map._layers) {
                            if (map._layers[i].getAttribution) {
                                this.addAttribution(map._layers[i].getAttribution());
                            }
                        }

                        this._update();

                        return this._container;
                    },

                    _update: function (lang, osm, countryCode) {
                        if (!this._map) {
                            return;
                        }

                        if (typeof osm !== 'undefined') {
                            this._osm = osm;
                        }

                        if (typeof countryCode !== 'undefined') {
                            this._countryCode = countryCode;
                        }

                        var attribs = [];

                        for (var i in this._attributions) {
                            if (this._attributions[i]) {
                                attribs.push(i);
                            }
                        }

                        var prefixAndAttribs = [],
                            copyright = '';

                        if (this._first) {
                            copyright = this._getAttributionHTML(lang);
                        }

                        if (this.options.prefix) {
                            prefixAndAttribs.push(this.options.prefix);
                        }
                        if (attribs.length) {
                            prefixAndAttribs.push(attribs.join(', '));
                        }

                        this._container.innerHTML = copyright + prefixAndAttribs.join(' | ');
                    },
                    _getData: function (lang) {
                        lang = lang || this._map.getLang();

                        return {
                            'osm': this._osm,
                            'work_on': this.t('work_on'),
                            'work_on_with_osm': this.t('work_on_with_osm'),
                            'lang': lang,
                            'copyright_apilink': this._getLink('copyright_apilink'),
                            'copyright_license': this._getLink('copyright_license'),
                            'copyright_logo': this._getLink('copyright_logo'),
                            'license_agreement': this.t('license_agreement'),
                            'dir': lang !== 'ar' ? 'ltr' : 'rtl'
                        };
                    },
                    _getAttributionHTML: function (lang) {
                        return DG.dust('DGAttribution/copyright', this._getData(lang));
                    },
                    _renderTranslation: function (e) {
                        this._update(e.lang);
                    }
                });

                DG.Map.addInitHook(function () {
                    if (!this._copyright) {
                        DG.control.attribution().addTo(this);
                    }
                });

                DG.Control.Attribution.Dictionary.ru = {
                    license_agreement: 'Лицензионное соглашение',
                    work_on: 'Работает на API 2ГИС',
                    work_on_with_osm: 'API 2ГИС'
                };

                DG.Control.Attribution.Dictionary.it = {
                    license_agreement: 'Accordo di licenza',
                    work_on: '2GIS API',
                    work_on_with_osm: '2GIS API'
                };

                DG.Control.Attribution.Dictionary.cs = {
                    license_agreement: 'Licenční smlouva',
                    work_on: 'Pracuje na API 2GIS',
                    work_on_with_osm: 'API 2GIS'
                };

                DG.Control.Attribution.Dictionary.en = {
                    license_agreement: 'License agreement',
                    work_on: 'Uses 2GIS API',
                    work_on_with_osm: '2GIS API'
                };

                DG.Control.Attribution.Dictionary.es = {
                    license_agreement: 'Acuerdo de licencia',
                    work_on: '2GIS API',
                    work_on_with_osm: '2GIS API'
                };

                DG.Control.Attribution.Dictionary.ar = {
                    license_agreement: 'إتفاقية ترخيص',
                    work_on: 'يعمل بتطبيق 2GIS',
                    work_on_with_osm: 'API 2GIS'
                };

                DG.Control.Location = DG.RoundControl.extend({

                    statics: {
                        Dictionary: {}
                    },

                    options: {
                        iconClass: 'locate',
                        position: DG.Browser.mobile ? 'bottomright' : 'topleft',
                        drawCircle: true,
                        follow: true, // follow with zoom and pan the user's location
                        stopFollowingOnDrag: false, // if follow is true, stop following when map is dragged
                        metric: true,
                        onLocationError: function () /*err*/{
                            // this event is called in case of any location error
                            // that is not a time out error.
                            // console.log(err.message);
                        },
                        onLocationOutsideMapBounds: function () /*context*/{
                            // this event is repeatedly called when the location changes
                            // console.log(context.t('outsideMapBoundsMsg'));
                        },
                        locateOptions: {}
                    },

                    initialize: function (options) {
                        DG.Util.setOptions(this, options);

                        if (!navigator.geolocation) {
                            this._disable = true;
                            return;
                        }

                        this._event = undefined;

                        this._locateOptions = {
                            watch: true, // if you overwrite this, visualization cannot be updated
                            setView: true,
                            maximumAge: Infinity,
                            maxZoom: Infinity
                        };
                        DG.extend(this._locateOptions, this.options.locateOptions);

                        this._resetVariables();

                        this.on({
                            'click': this._handleLocate,
                            'add': this._initLocate
                        });
                    },

                    _initLocate: function () {
                        this._layer = new DG.LayerGroup();
                        this._layer.addTo(this._map);

                        // event hooks
                        this._map.on({
                            'locationfound': this._onLocationFound,
                            'locationerror': this._onLocationError
                        }, this);
                    },

                    _handleLocate: function () {
                        if (this._active && (!this._event || this._map.getBounds().contains(this._event.latlng) || this._isOutsideMapBounds())) {
                            this._stopLocate();
                        } else {
                            this._locateOnNextLocationFound = true;

                            if (!this._active) {
                                this._map.locate(this._locateOptions);
                            }

                            this._active = true;

                            if (this.options.follow) {
                                this._startFollowing();
                            }

                            this._clearError();

                            if (this._event) {
                                this._visualizeLocation();
                            } else {
                                this.setState('requesting');
                            }
                        }
                    },

                    _onLocationFound: function (e) {
                        // no need to do anything if the location has not changed
                        if (this._event && this._event.latlng.lat === e.latlng.lat && this._event.latlng.lng === e.latlng.lng && this._event.accuracy === e.accuracy) {
                            return;
                        }

                        if (!this._active) {
                            return;
                        }

                        this._event = e;

                        if (this.options.follow && this._following) {
                            this._locateOnNextLocationFound = true;
                        }

                        this._visualizeLocation();
                    },

                    _startFollowing: function () {
                        this._following = true;
                        if (this.options.stopFollowingOnDrag) {
                            this._map.on('dragstart', this._stopFollowing);
                        }
                    },

                    _stopFollowing: function () {
                        this._following = false;
                        if (this.options.stopFollowingOnDrag) {
                            this._map.off('dragstart', this._stopFollowing);
                        }
                        this._visualizeLocation();
                    },

                    _isOutsideMapBounds: function () {
                        if (this._event === undefined) {
                            return false;
                        }
                        return this._map.options.maxBounds && !this._map.options.maxBounds.contains(this._event.latlng);
                    },

                    _visualizeLocation: function () {
                        if (this._event.accuracy === undefined) {
                            this._event.accuracy = 0;
                        }

                        var radius = this._event.accuracy;

                        if (this._locateOnNextLocationFound) {
                            if (this._isOutsideMapBounds()) {
                                this.options.onLocationOutsideMapBounds(this);
                            } else if (this._locateOptions.setView) {
                                var zoom = this._map.projectDetector.getProject().maxZoom || DG.config.projectLeaveMaxZoom;
                                zoom = Math.min(this._locateOptions.maxZoom, zoom);
                                this._map.setView(this._event.latlng, zoom);
                            }
                            this._locateOnNextLocationFound = false;
                        }

                        // circle with the radius of the location's accuracy
                        var style = {
                            clickable: false,
                            color: '#FFF',
                            fillColor: '#FFF',
                            fillOpacity: 0.4,
                            weight: 0,
                            opacity: 0.3
                        };
                        if (this.options.drawCircle) {
                            if (!this._circle) {
                                this._circle = DG.circle(this._event.latlng, radius, style).addTo(this._layer);
                            } else {
                                this._circle.setLatLng(this._event.latlng).setRadius(radius);
                            }
                        }

                        var markerClass = 'dg-location__pin';

                        markerClass += this._following ? ' ' + markerClass + 'state_following' : '';
                        // small inner marker
                        var m = {
                            icon: DG.divIcon({
                                className: markerClass,
                                iconSize: [20, 20]
                            })
                        };

                        if (!this._marker) {
                            this._marker = DG.marker(this._event.latlng, m).bindLabel(this.t('you_are_here')).addTo(this._layer);
                        } else {
                            this._marker.setLatLng(this._event.latlng);
                        }

                        DG.DomEvent.on(this._marker, 'click', function () {
                            this._map.fireEvent('dgLocateClick');
                        }, this);

                        if (!this._container) {
                            return;
                        }

                        this.setState('active');
                    },

                    _resetVariables: function () {
                        this._active = false;
                        this._following = false;
                    },

                    _stopLocate: function () {
                        this._map.stopLocate();
                        this._map.off('dragstart', this._stopFollowing);

                        this.setState();
                        this._resetVariables();

                        this._layer.clearLayers();
                        this._marker = undefined;
                        this._circle = undefined;
                        this._event = undefined;
                    },

                    _onLocationError: function (err) {
                        // ignore time out error if the location is watched
                        if (err.code === 3 && this._locateOptions.watch) {
                            return;
                        }

                        this._stopLocate();
                        this._error = DG.DomUtil.create('div', 'dg-label dg-label_name_location-error', this._container);
                        this._errorText = DG.DomUtil.create('div', 'dg-label__content', this._error);
                        this._errorText.innerHTML = this.t('cant_find');

                        var self = this;
                        setTimeout(function () {
                            self._clearError();
                        }, 3000);

                        //show location error
                        this.options.onLocationError(err);
                    },

                    _clearError: function () {
                        if (this._error) {
                            this._container.removeChild(this._error);
                            this._error = undefined;
                            this._errorText = undefined;
                        }
                    },

                    _renderTranslation: function () {
                        if (this._link) {
                            this._link.title = this.t('button_title');
                        }
                        if (this._marker) {
                            this._marker.bindLabel(this.t('you_are_here'));
                        }
                    }
                });

                DG.control.location = function (options) {
                    return new DG.Control.Location(options);
                };

                DG.Map.addInitHook(function () {
                    if (this.options.locationControl) {
                        this.locationControl = DG.control.location(this.options.locationControl);
                        this.addControl(this.locationControl);
                    }
                });

                DG.Control.Location.Dictionary.ru = {
                    cant_find: 'Мы не смогли Вас найти',
                    you_are_here: 'Вы здесь',
                    button_title: 'Найти Вас на карте'
                };

                DG.Control.Location.Dictionary.it = {
                    cant_find: 'Non siamo riusciti a localizzarti',
                    you_are_here: 'Voi siete qui',
                    button_title: 'Trova la tua posizione sulla mappa'
                };

                DG.Control.Location.Dictionary.cs = {
                    cant_find: 'Nepodařilo se nám určit Vaši polohu',
                    you_are_here: 'Jste tady',
                    button_title: 'Určit Vaši polohu na mapě'
                };

                DG.Control.Location.Dictionary.en = {
                    cant_find: 'We can\'t find you',
                    you_are_here: 'You are here',
                    button_title: 'Show your location'
                };

                DG.Control.Location.Dictionary.es = {
                    cant_find: 'No pudimos encontrarte',
                    you_are_here: 'Tú estás aquí',
                    button_title: 'Encontrarte en el mapa'
                };

                DG.Control.Location.Dictionary.ar = {
                    cant_find: 'لم نستطع تحديد موقعك',
                    you_are_here: 'أنت هنا',
                    button_title: 'موقعي'
                };

                // Inspired by Sindre Sorhus screenfull
                /*global Element */
                DG.Screenfull = DG.Class.extend({
                    _apiMap: [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'], ['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'], ['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'], ['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']],

                    initialize: function () {
                        this.api = this._api();
                    },

                    request: function (elem) {
                        var request = this.api.requestFullscreen;

                        elem = elem || document.documentElement;
                        elem[request](Element.ALLOW_KEYBOARD_INPUT);
                    },

                    exit: function () {
                        document[this.api.exitFullscreen]();
                    },

                    isFullscreen: function () {
                        return !!document[this.api.fullscreenElement];
                    },

                    isAvailable: function () {
                        return Boolean(this.api);
                    },

                    _api: function () {
                        var api = {},
                            apiMap = this._apiMap;

                        apiMap.forEach(function (val) {
                            if (val && val[1] in document) {
                                val.forEach(function (method, i) {
                                    api[apiMap[0][i]] = method;
                                });
                            }
                        });

                        return api.requestFullscreen ? api : false;
                    }
                });

                DG.screenfull = new DG.Screenfull();

                DG.Control.Fullscreen = DG.RoundControl.extend({

                    statics: {
                        Dictionary: {}
                    },

                    options: {
                        position: 'topright',
                        iconClass: 'fullscreen'
                    },

                    initialize: function (options) {
                        DG.Util.setOptions(this, options);
                        this._isFullscreen = false;
                        this.on('click', this._toggleFullscreen);
                    },

                    _toggleFullscreen: function () {
                        if (!this._isFullscreen) {
                            this._toggle(true, 'request', 'on', 'requestfullscreen');
                        } else {
                            this._toggle(false, 'exit', 'on', 'cancelfullscreen');
                        }

                        this._renderTranslation();
                        this._map.invalidateSize();
                    },

                    _renderTranslation: function () {
                        this._link.title = this.t(this._isFullscreen ? 'title_min' : 'title_max');
                    },

                    _toggle: function (isEnabled, method, list, event) {
                        var container = this._map._container;

                        this._isFullscreen = isEnabled;
                        this.setState(isEnabled ? 'active' : '');

                        DG.screenfull[method](container);
                        DG.DomEvent[list](document, DG.screenfull.api.fullscreenchange, this._onFullScreenStateChange, this);
                        this._map.fire(event);
                    },

                    _onFullScreenStateChange: function () {
                        if (!DG.screenfull.isFullscreen()) {
                            this._toggle(false, 'exit', 'on', 'cancelfullscreen');
                        }
                    }
                });

                DG.control.fullscreen = function (options) {
                    return new DG.Control.Fullscreen(options);
                };

                DG.Map.mergeOptions({
                    fullscreenControl: true
                });

                DG.Map.addInitHook(function () {
                    if (this.options.fullscreenControl) {
                        this.fullscreenControl = DG.control.fullscreen(this.options.fullscreenControl);

                        if (DG.screenfull.isAvailable()) {
                            this.addControl(this.fullscreenControl);
                        }
                    }
                });

                DG.Control.Fullscreen.Dictionary.ru = {
                    title_max: 'Развернуть',
                    title_min: 'Восстановить'
                };

                DG.Control.Fullscreen.Dictionary.it = {
                    title_max: 'Espandi',
                    title_min: 'Ripristina'
                };

                DG.Control.Fullscreen.Dictionary.cs = {
                    title_max: 'Rozbalit',
                    title_min: 'Obnovit'
                };

                DG.Control.Fullscreen.Dictionary.en = {
                    title_max: 'Expand',
                    title_min: 'Restore'
                };

                DG.Control.Fullscreen.Dictionary.es = {
                    title_max: 'Maximizar',
                    title_min: 'Restaurar'
                };

                DG.Control.Fullscreen.Dictionary.ar = {
                    title_max: '',
                    title_min: ''
                };

                DG.Meta = {};

                DG.Meta.Layer = DG.Layer.extend({

                    options: {
                        tileSize: 256,

                        minZoom: 0,
                        maxZoom: 19,
                        zoomOffset: 0,
                        eventBubbling: 'transparent'
                        // maxNativeZoom: <Number>,
                        // detectRetina: <Number>,
                        // zoomReverse: <Number>
                        // attribution: <String>,
                        // zIndex: <Number>,
                        // bounds: <LatLngBounds>
                    },

                    initialize: function (source, options) {
                        // (String, Object)
                        DG.TileLayer.prototype.initialize.call(this, null, options);
                        delete this._url;

                        this._currentTileKey = '';
                        this._currentTileData = [];
                        this._lastEntity = undefined;
                        this._dispatchMouseEvents = true;

                        this._origin = DG.Meta.origin(source, {
                            dataFilter: this.options.dataFilter
                        });
                    },

                    getOrigin: function () {
                        // () -> Object
                        return this._origin;
                    },

                    onAdd: function (map) {
                        this._resetView();

                        map.metaLayers.push(this);

                        map.on('rulerstart', this._disableDispatchMouseEvents, this);
                        map.on('rulerend', this._enableDispatchMouseEvents, this);

                        var self = this;

                        if (DG.Browser.touchEnabled && this.options.isPoi) {
                            map.eachLayer(function (layer) {
                                if (layer instanceof L.TileLayer) {
                                    // On every tile will be load meta tile.
                                    layer.on('tileloadstart', self._onTileLoadStart, self);
                                    // Load metatiles for already loaded tiles.
                                    for (var tile in layer._tiles) {
                                        self._onTileLoadStart({
                                            coords: layer._tiles[tile].coords
                                        });
                                    }
                                }
                            });
                        }
                    },

                    onRemove: function (map) {
                        var self = this;

                        if (DG.Browser.touchEnabled && this.options.isPoi) {
                            map.eachLayer(function (layer) {
                                if (layer instanceof L.TileLayer) {
                                    // On every tile will be load meta tile.
                                    layer.off('tileloadstart', self._onTileLoadStart);
                                }
                            });
                        }

                        this._tileZoom = null;

                        var index = map.metaLayers.indexOf(this);
                        if (index !== -1) {
                            map.metaLayers.splice(index, 1);
                        }

                        map.off('rulerstart', this._disableDispatchMouseEvents, this);
                        map.off('rulerend', this._enableDispatchMouseEvents, this);
                    },

                    getEvents: function () {
                        return {
                            viewprereset: this._invalidateAll,
                            viewreset: this._resetView,
                            zoom: this._resetView,
                            moveend: this._onMoveEnd
                        };
                    },

                    setUrl: function (url) {
                        this._currentTileKey = '';
                        this._currentTileData = [];
                        this._lastEntity = undefined;
                        this._dispatchMouseEvents = true;
                        this._origin.setURL(url, true);
                    },

                    getHoveredObject: function (event) {
                        var tileSize = this.getTileSize(),
                            layerPoint = this._map.mouseEventToLayerPoint(event.originalEvent),
                            tileOriginPoint = this._map.getPixelOrigin().add(layerPoint),
                            tileCoord = tileOriginPoint.unscaleBy(tileSize).floor(),
                            mouseTileOffset = DG.point(tileOriginPoint.x % tileSize.x, tileOriginPoint.y % tileSize.y),
                            tileKey,
                            zoom = this._map.getZoom(),
                            self = this;

                        if (zoom > this.options.maxZoom + this.options.zoomOffset || zoom < this.options.minZoom - this.options.zoomOffset || !this._isValidTile(tileCoord)) {
                            return;
                        }

                        this._wrapCoords(tileCoord);

                        tileCoord.z = this._getZoomForUrl();
                        tileCoord.key = tileSize.x + 'x' + tileSize.y;
                        tileKey = this._origin.getTileKey(tileCoord);

                        if (tileKey === this._currentTileKey) {
                            self._lastEntity = self._getHoveredObject(mouseTileOffset);
                        } else {
                            this._origin.getTileData(tileCoord, function (tileData) {
                                self._currentTileKey = tileKey;
                                self._currentTileData = tileData;
                                self._lastEntity = self._getHoveredObject(mouseTileOffset);
                            });
                        }

                        return this._lastEntity;
                    },

                    _removeAllTiles: DG.GridLayer.prototype._removeAllTiles,
                    _getZoomForUrl: DG.TileLayer.prototype._getZoomForUrl,
                    getTileSize: DG.TileLayer.prototype.getTileSize,
                    _isValidTile: DG.GridLayer.prototype._isValidTile,
                    _wrapCoords: DG.GridLayer.prototype._wrapCoords,
                    _resetView: DG.GridLayer.prototype._resetView,
                    _resetGrid: DG.GridLayer.prototype._resetGrid,
                    _invalidateAll: DG.GridLayer.prototype._invalidateAll,
                    _pxBoundsToTileRange: DG.GridLayer.prototype._pxBoundsToTileRange,

                    // Fix for https://github.com/Leaflet/Leaflet/compare/0726f12bbf33fcb18fe8bb541d5e3212bb1f5ab2...c263f2d8b1bd962b60474376cc4816a688052513#diff-f1e6be67599c594731fff6191c710420L579
                    _onMoveEnd: function () {
                        if (!this._map || this._map._animatingZoom) {
                            return;
                        }

                        this._resetView();
                    },

                    _onTileLoadStart: function (e) {
                        var tileSize = this.getTileSize();
                        e.coords.key = tileSize.x + 'x' + tileSize.y;
                        this._origin.getTileData(e.coords);
                    },

                    _enableDispatchMouseEvents: function () {
                        this._dispatchMouseEvents = true;
                    },

                    _disableDispatchMouseEvents: function () {
                        this._dispatchMouseEvents = false;
                    },

                    mapEvents: {
                        mousemove: function (event) {
                            this._fireMetalayerEvent('mousemove', event);
                        },

                        mouseover: function (event) {
                            this._fireMetalayerEvent('mouseover', event);
                        },

                        mouseout: function (event) {
                            this._fireMetalayerEvent('mouseout', event);
                            this._currentTileKey = '';
                        },

                        click: function (event) {
                            var tileSize = this.getTileSize(),
                                layerPoint = this._map.mouseEventToLayerPoint(event.originalEvent),
                                tileOriginPoint = this._map.getPixelOrigin().add(layerPoint),
                                tileCoord = tileOriginPoint.unscaleBy(tileSize).floor(),
                                mouseTileOffset = DG.point(tileOriginPoint.x % tileSize.x, tileOriginPoint.y % tileSize.y),
                                tileKey = this._origin.getTileKey(tileCoord);
                            tileCoord.z = this._getZoomForUrl();
                            tileCoord.key = tileSize.x + 'x' + tileSize.y;
                            var self = this;
                            this._origin.getTileData(tileCoord, function (tileData) {
                                self._currentTileData = tileData;
                                self._currentTileKey = tileKey;
                                self._lastEntity = self._getHoveredObject(mouseTileOffset);
                                self._mouseDown = false;

                                event.entity = self._lastEntity;
                                self._fireMetalayerEvent('click', event);
                            });
                        },

                        dblclick: function (event) {
                            this._fireMetalayerEvent('dblclick', event);
                        },

                        mousedown: function (event) {
                            this._mouseDown = true;
                            this._fireMetalayerEvent('mousedown', event);
                        },

                        contextmenu: function (event) {
                            this._fireMetalayerEvent('contextmenu', event);
                        }
                    },

                    _fireMetalayerEvent: function (type, mouseEvent) {
                        if (!mouseEvent.entity || !this._dispatchMouseEvents) {
                            return;
                        }
                        this.fire(type, {
                            meta: mouseEvent.entity,
                            latlng: this._map.mouseEventToLatLng(mouseEvent.originalEvent)
                        });
                        var isDragging = type === 'mousedown' || this._mouseDown && type === 'mousemove';
                        if (this.options.eventBubbling === 'layer' && !isDragging) {
                            DG.DomEvent.stop(mouseEvent);
                        }
                    },

                    _getHoveredObject: function (mouseTileOffset) {
                        if (!this._currentTileData) {
                            return;
                        }

                        for (var i = 0; i < this._currentTileData.length; i++) {
                            if (DG.PolyUtil.inside(mouseTileOffset, this._currentTileData[i].geometry, this._pointReduceHelper)) {
                                return this._currentTileData[i];
                            }
                        }
                    },

                    _pointReduceHelper: function (point) {
                        return [point.x, point.y];
                    },

                    _setView: function (center, zoom, noPrune, noUpdate) {
                        var tileZoom = Math.round(zoom),
                            tileZoomChanged = this._tileZoom !== tileZoom;

                        if (!noUpdate && tileZoomChanged) {
                            this._tileZoom = tileZoom;
                            this._resetGrid();
                        }
                    }
                });

                DG.Meta.layer = function (source, options) {
                    return new DG.Meta.Layer(source, options);
                };

                DG.Meta.Origin = DG.Class.extend({

                    options: {
                        subdomains: '0123',
                        dataFilter: null
                    },

                    _url: false,

                    initialize: function (url, options) {
                        // (String, Object)
                        this._url = url;
                        this._requests = {};

                        this._tileStorage = {};

                        options = DG.setOptions(this, options);

                        if (typeof options.subdomains === 'string') {
                            options.subdomains = options.subdomains.split('');
                        }
                    },

                    getTileData: function (coord, clb) {
                        // (Object) -> Object
                        var tileKey = this.getTileKey(coord),
                            self = this,
                            callback = typeof clb === 'function' ? clb : function () {};

                        if (typeof this._tileStorage[tileKey] === 'undefined' && typeof this._requests[tileKey] === 'undefined') {
                            this._tileStorage[tileKey] = false;
                            var currentRequest = this._requests[tileKey] = this._requestData(coord).then(function (data) {
                                if (self._requests[tileKey] !== currentRequest) {
                                    callback(false);
                                    return;
                                }
                                self.setTileData(tileKey, self.options.dataFilter ? self.options.dataFilter(data, coord) : data);
                                delete self._requests[tileKey];
                                callback(self._tileStorage[tileKey]);
                            });
                        } else {
                            callback(this._tileStorage[tileKey]);
                        }
                    },

                    setTileData: function (key, data) {
                        // (Object/String, Object) -> Object
                        if (typeof key !== 'string') {
                            key = this.getTileKey(key);
                        }

                        data.forEach(function (entity) {
                            if (entity.geometry.constructor !== Object) {
                                entity.geometry = DG.Wkt.toGeoJSON(entity.geometry);
                            }
                            if (!this._tileStorage[key]) {
                                this._tileStorage[key] = [];
                            }
                            this._tileStorage[key].push(entity);
                        }, this);

                        return this;
                    },

                    flush: function () {
                        // () -> Object
                        this._tileStorage = {};
                        Object.keys(this._requests).forEach(function (tileKey) {
                            if (this[tileKey].abort) {
                                this[tileKey].abort();
                            }
                        }, this._requests);
                        this._requests = {};

                        return this;
                    },

                    setURL: function (url, flush) {
                        // (String, Boolean) -> Object
                        this._url = url;
                        if (flush) {
                            this.flush();
                        }

                        return this;
                    },

                    getTileKey: function (coord) {
                        // (Object)-> String
                        return [coord.x, coord.y, coord.z, coord.key].join(':');
                    },

                    _requestData: function (key) {
                        // (String)
                        if (this._url) {
                            return this._performRequest(key);
                        } else {
                            return Promise.resolve([]);
                        }
                    },

                    _performRequest: function (coords) {
                        // (Object) -> Promise
                        return DG.ajax(this._prepareURL(coords), {
                            type: 'get',
                            dataType: 'json'
                        });
                    },

                    _prepareURL: function (coords) {
                        // (Object) -> String
                        return DG.Util.template(this._url, {
                            x: coords.x,
                            y: coords.y,
                            z: coords.z,
                            s: this._getSubdomain(coords)
                        });
                    },

                    _getSubdomain: DG.TileLayer.prototype._getSubdomain

                });

                DG.Meta.origin = function (source, options) {
                    return new DG.Meta.Origin(source, options);
                };

                DG.Map.mergeOptions({
                    poi: true
                });

                DG.Poi = DG.Handler.extend({

                    options: {
                        disableLabel: false
                    },

                    initialize: function (map, options) {
                        // (Object)
                        this._map = map;
                        DG.Util.setOptions(this, options);

                        var url = DG.config.protocol + (DG.Browser.retina ? DG.config.retinaPoiMetaServer : DG.config.poiMetaServer);

                        this._metaLayer = DG.Meta.layer(url, {
                            minZoom: DG.config.poiLayerMinZoom,
                            maxNativeZoom: 19,
                            detectRetina: DG.config.detectRetina,
                            eventBubbling: 'layer',
                            dataFilter: DG.bind(this._processData, this),
                            isPoi: true
                        });

                        this._currentTilesLang = ''; // 'ar' | ''
                    },

                    addHooks: function () {
                        this._map.addLayer(this._metaLayer);
                        if (!this.options.disableLabel) {
                            this._labelHelper = DG.label();
                        }
                        this._metaLayer.on(this._layerEventsListeners, this);
                        this._map.on('langchange', this._updateUrl, this);
                        this._map.on('projectchange', this._updateUrl, this);
                        this._map.on('projectleave', this._updateUrl, this);
                    },

                    removeHooks: function () {
                        this._map.removeLayer(this._metaLayer);
                        if (!this.options.disableLabel) {
                            this._map.removeLayer(this._labelHelper);
                            this._labelHelper = null;
                        }
                        this._metaLayer.off(this._layerEventsListeners, this);
                        this._map.off('langchange', this._updateUrl, this);
                        this._map.off('projectchange', this._updateUrl, this);
                        this._map.off('projectleave', this._updateUrl, this);
                    },

                    getMetaLayer: function () {
                        return this._metaLayer;
                    },

                    _updateUrl: function () {
                        var url = DG.config.protocol + (DG.Browser.retina ? DG.config.retinaPoiMetaServer : DG.config.poiMetaServer);
                        var arabicUrl = DG.config.protocol + (DG.Browser.retina ? DG.config.arabicRetinaPoiMetaServer : DG.config.arabicPoiMetaServer);
                        var lang = this._map.getLang();
                        var project = this._map.projectDetector && this._map.projectDetector.getProject();

                        // Change POI for Arabic language in Dubai project
                        if (this._currentTilesLang === '' && lang === 'ar' && project && project.country_code === 'ae') {
                            this._currentTilesLang = 'ar';
                            this._metaLayer.setUrl(arabicUrl);
                        } else if (this._currentTilesLang === 'ar' && (lang !== 'ar' || !project || project.country_code !== 'ae')) {
                            this._currentTilesLang = '';
                            this._metaLayer.setUrl(url);
                        }
                    },

                    _processData: function (data, coord) {
                        var tileOriginPoint = coord.scaleBy(this._metaLayer.getTileSize());
                        var polygonLngLatToPoints = DG.bind(this._polygonLngLatToPoints, this, tileOriginPoint, coord.z);

                        if (data.responseText === '') {
                            return [];
                        }

                        return data.result.poi.map(function (item) {
                            var hovers = item.hovers !== undefined ? item.hovers : [item.hover];

                            return {
                                id: item.id,
                                hint: item.links[0].name,
                                linked: item.links[0],
                                geometry: hovers.map(DG.Wkt.toGeoJSON)
                            };
                        }).map(function (item) {
                            var coordinates = item.geometry.reduce(function (result, item) {
                                if (item.type === 'Polygon') {
                                    result.push(polygonLngLatToPoints(item.coordinates));
                                } else if (item.type === 'MultiPolygon') {
                                    result = result.concat(item.coordinates.map(polygonLngLatToPoints));
                                }

                                return result;
                            }, []);

                            item.geometry = {
                                type: 'MultiPolygon',
                                coordinates: coordinates
                            };

                            return item;
                        });
                    },

                    _polygonLngLatToPoints: function (originPoint, zoom, polygon) {
                        var map = this._map;

                        return polygon.map(function (contour) {
                            return contour.map(function (lngLat) {
                                return map.project([lngLat[1], lngLat[0]], zoom).round().subtract(originPoint);
                            });
                        });
                    },

                    _layerEventsListeners: {
                        mouseover: function (e) {
                            // (Object)
                            this._setCursor('pointer');
                            if (e.meta.hint && e.meta.hint.length && !this.options.disableLabel) {
                                this._labelHelper.setPosition(e.latlng).setContent(e.meta.hint).setZIndexOffset(300);
                                this._map.addLayer(this._labelHelper);
                            }
                            this._map.fire('poihover', {
                                latlng: e.latlng,
                                meta: e.meta
                            });
                        },

                        mouseout: function (e) {
                            this._setCursor('');
                            if (!this.options.disableLabel) {
                                this._map.removeLayer(this._labelHelper);
                            }
                            this._map.fire('poileave', {
                                latlng: e.latlng,
                                meta: e.meta
                            });
                        },

                        mousemove: function (e) {
                            // (Object)
                            if (!this.options.disableLabel) {
                                this._labelHelper.setPosition(e.latlng);
                            }
                        }
                    },

                    _setCursor: function (cursor) {
                        // (String)
                        this._map.getContainer().style.cursor = cursor;
                    }

                });

                DG.Map.addInitHook('addHandler', 'poi', DG.Poi);

                DG.Map.mergeOptions({
                    geoclicker: false
                });

                DG.Geoclicker = DG.Handler.extend({
                    clickCount: 0,
                    pendingClick: 0,
                    timeout: 250, // should be equal to 'delay' value in DoubleTap event

                    initialize: function (map, options) {
                        // (Object)
                        this._map = map;
                        this._controller = new DG.Geoclicker.Controller(map, options);
                    },

                    addHooks: function () {
                        this._toggleEvents(true);

                        this._map.on('rulerstart', this._pause, this).on('rulerend', this._unpause, this);
                    },

                    removeHooks: function () {
                        this._toggleEvents();

                        this._map.off('rulerstart', this._pause, this).off('rulerend', this._unpause, this);
                    },

                    _checkOpenPopup: function () {
                        if (DG.Browser.mobile && this._map._popup && (this._map._popup.options.closeOnClick || this._map.options.closePopupOnClick)) {
                            this.popupWasOpen = true;
                        }
                    },

                    _pause: function () {
                        this._toggleEvents();
                    },

                    _unpause: function () {
                        // Reenable event handling only in case geoclicker is enabled
                        if (this.enabled()) {
                            this._toggleEvents(true);
                        }
                    },

                    _toggleEvents: function (flag) {
                        this._map[flag ? 'on' : 'off'](this._mapEventsListeners, this);
                        if (this._map.poi) {
                            this._map.poi.getMetaLayer()[flag ? 'on' : 'off']('click', this._onMetaClick, this);
                        }
                    },

                    getController: function () {
                        return this._controller;
                    },

                    _onMetaClick: function (e) {
                        this.clickCount = 0;
                        clearTimeout(this.pendingClick);
                        this.popupWasOpen = false;

                        this._mapEventsListeners.click.call(this, e);
                    },

                    _mapEventsListeners: {
                        langchange: function () {
                            this._controller.reinvokeHandler();
                        },

                        popupclose: function (e) {
                            // (Object)
                            this._controller.handlePopupClose(e.popup);
                        },

                        click: function (e) {
                            // (Object)
                            if (this.clickCount === 0) {
                                this.clickCount = 1;
                                this._singleClick(e);
                            } else {
                                this.clickCount = 0;
                                clearTimeout(this.pendingClick);
                                this.popupWasOpen = false;
                            }
                        },

                        dblclick: function () {
                            if (DG.Browser.ielt9) {
                                this.clickCount = 0;
                                this.popupWasOpen = false;
                                clearTimeout(this.pendingClick);
                            }
                        }
                    },

                    _singleClick: function (e) {
                        // (Object)
                        var self = this;

                        clearTimeout(this.pendingClick);

                        this.pendingClick = setTimeout(function () {
                            if (e.meta) {
                                self._checkOpenPopup();
                                self._map.closePopup();
                            }

                            //  DGPopup's '_close' method is the only place where .popupWasOpen is modified
                            //  It signals geoclicker that popup was open before user do a 'click' on map
                            //  Multistage behavior is needed as this processing occurs after popup was already closed
                            if (!self.popupWasOpen) {
                                var zoom = self._map.getZoom();
                                self._controller.handleClick(e.latlng, zoom, e.meta);
                            }

                            self.clickCount = 0;
                            self.popupWasOpen = false;
                        }, this.timeout);
                    }
                });

                DG.Map.addInitHook('addHandler', 'geoclicker', DG.Geoclicker);

                DG.Geoclicker.clampHelper = function (el, lineClamp) {
                    var measure,
                        text,
                        lineWidth,
                        lineStart,
                        lineCount,
                        wordStart,
                        line,
                        lineText,
                        wasNewLine,
                        ce = document.createElement.bind(document),
                        ctn = document.createTextNode.bind(document);

                    // measurement element is made a child of the clamped element to get it's style
                    measure = ce('span');

                    (function (s) {
                        s.position = 'absolute'; // prevent page reflow
                        s.whiteSpace = 'pre'; // cross-browser width results
                        s.visibility = 'hidden'; // prevent drawing
                        s.margin = '0 18px 8px 0';
                    })(measure.style);

                    // make sure the element belongs to the document
                    if (!el.ownerDocument || el.ownerDocument !== document) {
                        return;
                    }
                    // reset to safe starting values
                    lineStart = wordStart = 0;
                    lineCount = 1;
                    wasNewLine = false;
                    lineWidth = el.clientWidth;
                    // get all the text, remove any line changes
                    text = (el.textContent || el.innerText).replace(/\n/g, ' ');
                    // remove all content
                    while (el.firstChild !== null) {
                        el.removeChild(el.firstChild);
                    }
                    // add measurement element within so it inherits styles
                    el.appendChild(measure);
                    // http://ejohn.org/blog/search-and-dont-replace/
                    text.replace(/ |-/g, function (m, pos) {
                        // ignore any further processing if we have total lines
                        if (lineCount === lineClamp) {
                            return;
                        }
                        // create a text node and place it in the measurement element
                        measure.appendChild(ctn(text.substr(lineStart, pos - lineStart)));
                        // have we exceeded allowed line width?
                        if (lineWidth < measure.clientWidth) {
                            if (wasNewLine) {
                                // we have a long word so it gets a line of it's own
                                lineText = text.substr(lineStart, pos + 1 - lineStart);
                                // next line start position
                                lineStart = pos + 1;
                            } else {
                                // grab the text until this word
                                lineText = text.substr(lineStart, wordStart - lineStart);
                                // next line start position
                                lineStart = wordStart;
                            }
                            // create a line element
                            line = ce('span');
                            // add text to the line element
                            line.appendChild(ctn(lineText));
                            // add the line element to the container
                            el.appendChild(line);
                            line.className = 'dg-map-geoclicker__clamped-line';
                            // yes, we created a new line
                            wasNewLine = true;
                            lineCount++;
                        } else {
                            // did not create a new line
                            wasNewLine = false;
                        }
                        // remember last word start position
                        wordStart = pos + 1;
                        // clear measurement element
                        measure.removeChild(measure.firstChild);
                    });
                    // remove the measurement element from the container
                    el.removeChild(measure);
                    // create the last line element
                    line = ce('span');
                    // give styles required for text-overflow to kick in
                    line.className = 'dg-map-geoclicker__clamped-line dg-map-geoclicker__clamped-line_last';
                    // add all remaining text to the line element
                    line.appendChild(ctn(text.substr(lineStart)));
                    // add the line element to the container
                    el.appendChild(line);
                };

                DG.Geoclicker.Provider = {};

                DG.Geoclicker.Provider.CatalogApi = DG.Class.extend({
                    initialize: function (map) {
                        // (Object)
                        this._map = map;

                        var apiUrl = DG.config.protocol + DG.config.webApiServer + '/' + DG.config.webApiVersion + '/';

                        this._urlGeoSearch = apiUrl + 'geo/search';
                        this._urlGeoGet = apiUrl + 'geo/get';
                        this._urlDetails = apiUrl + 'catalog/branch/get';
                        this._urlFirmsInHouse = apiUrl + 'catalog/branch/list';

                        this._key = DG.config.geoclickerCatalogApiKey;
                        this._geoFields = DG.config.geoAdditionalFields;
                        this._firmInfoFields = DG.config.firmInfoFields;
                    },

                    getLocations: function (options) {
                        // (Object)
                        // Callback will receive array of found results or void if errors occurred or nothing was found.
                        var zoom = options.zoom,
                            latlng = options.latlng,
                            beforeRequest = options.beforeRequest || function () {},
                            types = this.getTypesByZoom(zoom),
                            q = latlng.lng + ',' + latlng.lat;

                        if (!types) {
                            return Promise.reject('no type');
                        }

                        beforeRequest();

                        return this.geoSearch(q, types, zoom).then(DG.bind(function (result) {
                            return this._filterResponse(result, types);
                        }, this));
                    },

                    firmsInHouse: function (houseId, parameters) {
                        // (String, Function, Number)
                        parameters = parameters || {};

                        /* eslint-disable camelcase */
                        var params = {
                            building_id: houseId,
                            page: parameters.page || 1
                        };
                        /* eslint-enable camelcase */

                        return this._performRequest(params, this._urlFirmsInHouse);
                    },

                    getFirmInfo: function (firmId) {
                        return this._performRequest({
                            type: 'filial',
                            id: firmId,
                            fields: this._firmInfoFields
                        }, this._urlDetails);
                    },

                    geoSearch: function (q, types, zoomlevel) {
                        // (String, String, Number)
                        /* eslint-disable camelcase */
                        var params = {
                            point: q,
                            type: types,
                            zoom_level: zoomlevel,
                            fields: this._geoFields
                        };
                        /* eslint-enable camelcase */

                        return this._performRequest(params, this._urlGeoSearch);
                    },

                    geoGet: function (id) {
                        var params = {
                            id: id,
                            fields: this._geoFields
                        };

                        return this._performRequest(params, this._urlGeoGet);
                    },

                    cancelLastRequest: function () {
                        if (this._lastRequest) {
                            this._lastRequest.abort();
                        }
                    },

                    getTypesByZoom: function (zoom) {
                        // (Number) -> String|Null
                        var types = {
                            'adm_div.settlement': 8,
                            'adm_div.city': 8,
                            'adm_div.division': 11,
                            'adm_div.district': 12,
                            'street': 14,
                            'building': 14,
                            'adm_div.place': 15,
                            'poi': 15,
                            'attraction': 17
                        },
                            selectedTypes = [];

                        Object.keys(types).forEach(function (type) {
                            if (zoom >= types[type]) {
                                selectedTypes.push(type);
                            }
                        });

                        if (selectedTypes.length) {
                            return selectedTypes.join(',');
                        } else {
                            return null;
                        }
                    },

                    _performRequest: function (params, url) {
                        // (Object, String, Function, Function)
                        var data = DG.extend({ key: this._key }, params);
                        var type = 'get';

                        this.cancelLastRequest();

                        if (!DG.ajax.corsSupport) {
                            type = data.format = 'jsonp';
                        }

                        this._lastRequest = DG.ajax(url, {
                            type: type,
                            data: data,
                            timeout: this._timeoutMs
                        });

                        return this._lastRequest;
                    },

                    _filterResponse: function (response, allowedTypes) {
                        // (Object, Array) -> Boolean|Object
                        var result = {},
                            i,
                            item,
                            found,
                            data,
                            type;

                        if (this._isNotFound(response)) {
                            return false;
                        }

                        data = response.result.items;

                        for (i = data.length - 1; i >= 0; i--) {
                            item = data[i];

                            type = item.type;
                            if (item.subtype) {
                                type += '.' + item.subtype;
                            }

                            if (allowedTypes && allowedTypes.indexOf(type) === -1) {
                                continue;
                            }

                            result[type] = item;
                            found = true;
                        }

                        if (found) {
                            return result;
                        } else {
                            return false;
                        }
                    },

                    _isNotFound: function (response) {
                        // (Object) -> Boolean
                        return !response || !!response.meta && !!response.meta.error || !response.result || !response.result.items || !response.result.items.length;
                    }

                });

                DG.Geoclicker.Handler = {};

                DG.Geoclicker.Handler.Default = DG.Class.extend({

                    includes: DG.Locale,

                    statics: {
                        Dictionary: {}
                    },

                    _eventHandlers: {},

                    initialize: function (controller, view, map) {
                        // (Object, Object, Object)
                        this._controller = controller;
                        this._view = view;
                        this._map = map;
                    },

                    handle: function () {
                        // () -> Promise
                        return Promise.resolve({
                            tmpl: 'popupHeader',
                            data: { 'title': this.t('we_have_not') }
                        });
                    },

                    addClickEvent: function () {
                        this._view._popup.on('click', this._runEventHandlers, this);
                        this._map.once('popupclose', this._removeClickEvent, this);
                    },

                    _removeClickEvent: function () {
                        this._view._popup.off('click', this._runEventHandlers, this);
                    },

                    _addEventHandler: function (el, handler) {
                        // (String, Function)
                        this._eventHandlers[el] = handler;
                    },

                    _runEventHandlers: function (e) {
                        var target = e.originalEvent.target;

                        for (var eventClass in this._eventHandlers) {
                            if (this._eventHandlers.hasOwnProperty(eventClass) && target.className.indexOf(eventClass) > -1) {
                                DG.DomEvent.preventDefault(e.originalEvent);
                                this._eventHandlers[eventClass].call(this, target);
                                return;
                            }
                        }
                    },

                    _clearEventHandlers: function () {
                        this._eventHandlers = {};
                    },

                    _getDirectionsUrl: function (name) {
                        return DG.Util.template(DG.config.ppnotLink, {
                            'domain': this._map.projectDetector.getProject().domain,
                            'projectCode': this._map.projectDetector.getProject().code,
                            'center': this._map.getCenter().lng + ',' + this._map.getCenter().lat,
                            'zoom': this._map.getZoom(),
                            'name': encodeURIComponent(name),
                            'rsType': this._map.projectDetector.getProject().transport ? 'bus' : 'car',
                            'point': this._popup._latlng.lng + ',' + this._popup._latlng.lat
                        });
                    },

                    _getDrilldown: function (object) {
                        var admDivs = [],
                            result;

                        if (object.adm_div) {
                            admDivs = object.adm_div.reduce(function (admDivs, admDiv) {
                                if (admDiv.name) {
                                    admDivs.push(admDiv.name);
                                }

                                return admDivs;
                            }, []).reverse();
                        }

                        if (admDivs.length && object.address && object.address.postcode) {
                            admDivs.push(object.address.postcode);
                        }

                        result = admDivs.join(', ');

                        return result;
                    }

                });

                DG.Geoclicker.Handler.HandlerExample = DG.Geoclicker.Handler.Default.extend({

                    handle: function (results, type) {
                        // (Object, String) -> Promise
                        return Promise.resolve({
                            tmpl: type + ':<br/>' + results[type].id
                        });
                    }
                });

                DG.Geoclicker.Handler.ApiError = DG.Geoclicker.Handler.Default.extend({
                    handle: function () {
                        // () -> Promise
                        var header = this._view.render({
                            tmpl: 'popupHeader',
                            data: {
                                title: this.t('apiErrorTitle')
                            }
                        });

                        return Promise.resolve({
                            header: header,
                            tmpl: this.t('apiErrorBody')
                        });
                    }
                });

                DG.Geoclicker.Handler.CityArea = DG.Geoclicker.Handler.Default.extend({

                    _polylineStyleDefault: {
                        fillColor: '#ff9387',
                        color: '#ff9387',
                        noClip: true,
                        opacity: 1
                    },

                    _polylineStyles: {
                        11: {
                            fillOpacity: 0.18,
                            weight: 1
                        },
                        12: {
                            fillOpacity: 0.12,
                            weight: 1
                        },
                        13: {
                            fillOpacity: 0.08,
                            weight: 2
                        },
                        18: {
                            fillOpacity: 0,
                            weight: 3
                        }
                    },

                    handle: function (results, type) {
                        // (Object, String) -> Promise
                        if (!results[type]) {
                            return false;
                        }

                        if (!this._stylesInited) {
                            this._initStyles();
                        }

                        // remove previous geometry see https://github.com/2gis/mapsapi/issues/213
                        if (this._geometry) {
                            this._map.removeLayer(this._geometry);
                        }

                        this._popup = this._view.getPopup();

                        this._geometryZoomStyle = this._getPolyStyleNum();
                        this._geometry = DG.Wkt.geoJsonLayer(results[type].geometry.selection, {
                            style: this._polylineStyles[this._geometryZoomStyle],
                            interactive: false
                        }).addTo(this._map);

                        this._map.on('zoomend', this._updateGeometry, this).once('popupclose', this._clearPopup, this);

                        return Promise.resolve(this._fillCityAreaObject(results, type));
                    },

                    _fillCityAreaObject: function (results, type) {
                        var data = {
                            name: this.t('noname'),
                            drilldown: '',
                            purpose: this.t(type),
                            type: type.split('.').join('_')
                        };

                        data.drilldown = this._getDrilldown(results[type]);

                        if (results[type].name) {
                            data.name = results[type].name;
                        }

                        return {
                            tmpl: 'cityarea',
                            data: data,
                            header: this._view.render({
                                tmpl: 'popupHeader',
                                data: { 'title': data.name }
                            })
                        };
                    },

                    _initStyles: function () {
                        this._stylesInited = true;

                        Object.keys(this._polylineStyles).forEach(function (zoom) {
                            DG.extend(this._polylineStyles[zoom], this._polylineStyleDefault);
                        }, this);
                    },

                    _getPolyStyleNum: function () {
                        var mapZoom = this._map.getZoom();

                        return Object.keys(this._polylineStyles).filter(function (zoom) {
                            return mapZoom <= zoom;
                        })[0] || false;
                    },

                    _updateGeometry: function () {
                        var newStyle = this._getPolyStyleNum();

                        if (newStyle && newStyle !== this._geometryZoomStyle) {
                            this._geometryZoomStyle = newStyle;
                            this._geometry.setStyle(this._polylineStyles[newStyle]);
                        }
                    },

                    _clearPopup: function () {
                        this._map.removeLayer(this._geometry).off('zoomend', this._updateGeometry, this);
                    }

                });

                /*global FirmCard */
                DG.Geoclicker.Handler.House = DG.Geoclicker.Handler.Default.extend({

                    _firmsOnPage: 20,
                    _scrollThrottleInterval: 400,
                    _scrollHeightReserve: 60,

                    options: {
                        'showBooklet': true,
                        'showPhotos': true,
                        'showRouteSearch': true
                    },

                    handle: function (results) {
                        // (Object) -> Promise
                        if (!results.building) {
                            return false;
                        }

                        // initialization setup
                        this.firmCard = null;
                        this._page = 1;
                        this._houseObject = null;
                        this._firmList = null;
                        this._firmListObject = null;
                        this._firmCardObject = null;
                        this._onScroll = false;
                        this._isFirmlistOpen = false;

                        this._id = results.building.id;
                        this._totalPages = 1;
                        this._api = this._controller.getCatalogApi();
                        this._popup = this._view.getPopup();
                        this._initedPopupClose = false;
                        this._directionsUrl = this._getDirectionsUrl(results.building.name);
                        this._firmListLoader = this._view.initLoader(true);

                        this._houseObject = this._fillHouseObject(results.building);

                        return Promise.resolve(this._houseObject);
                    },

                    _isRouteSearchAllowed: function () {
                        //() -> Boolean
                        var project = this._controller.getMap().projectDetector.getProject();
                        return project.transport || project.roads;
                    },

                    _firmCardSetup: function () {
                        //() -> Object
                        return {
                            render: this._view.renderTemplate,
                            lang: this._map.getLang(),
                            domain: this._controller.getMap().projectDetector.getProject().domain,
                            ajax: DG.bind(this._api.getFirmInfo, this._api),
                            timezoneOffset: this._controller.getMap().projectDetector.getProject().timeOffset,
                            map: this._map,
                            popup: this._popup,
                            isMobile: DG.Browser.mobile,
                            showEntrance: DG.Entrance,
                            gotoUrl: this._directionsUrl,
                            onFirmReady: DG.bind(this._onFirmReady, this),
                            onToggle: DG.bind(this._popup.resize, this._popup),
                            showBooklet: this.options.showBooklet,
                            showPhotos: this.options.showPhotos,
                            showRouteSearch: this.options.showRouteSearch && this._isRouteSearchAllowed(),
                            t: DG.bind(this.t, this)
                        };
                    },

                    // init single firm card in case of poi
                    _fillFirmCardObject: function (firmId) {
                        var options = this._firmCardSetup();

                        this.firmCard = new FirmCard(firmId, options);
                        this._initPopupClose();
                        return this.firmCard.getContainer();
                    },

                    _firmListSetup: function () {
                        var options = this._firmCardSetup();

                        DG.extend(options, {
                            backBtn: DG.bind(this._showHousePopup, this),
                            onFirmClick: DG.bind(this._onFirmListClick, this),
                            onShowLess: DG.bind(this._showHousePopup, this),
                            pasteLoader: DG.bind(this._pasteLoader, this)
                        });

                        return {
                            firmCard: options,
                            firmlistItemTmpl: 'firmlistItem',
                            onListReady: DG.bind(this._renderFirmList, this)
                        };
                    },

                    _initShortFirmList: function (firms) {
                        //(Object) -> DOMElement
                        var options = this._firmListSetup();

                        this._shortFirmList = new FirmCard.List(firms, options);

                        return this._shortFirmList.renderList();
                    },

                    _initFirmList: function (res) {
                        //(Object) -> Promise
                        if (!res) {
                            return false;
                        }

                        var results = res.result.items,
                            options = this._firmListSetup();

                        options.firmCard.backBtn = DG.bind(this._showListPopup, this);

                        this._shortFirmList._toggleEventHandlers(true);

                        this._firmList = new FirmCard.List(results, options);

                        this._firmListObject = this._fillFirmListObject(this._firmList.renderList());
                        this._clearAndRenderPopup(this._firmListObject);
                    },

                    _fillFirmListObject: function (firmList) {
                        //(DOMElement) -> Object
                        var self = this;

                        return {
                            tmpl: firmList,
                            header: this._header,
                            footer: this._view.render({
                                tmpl: 'popupFooterBtns',
                                data: {
                                    btns: [{
                                        name: 'back',
                                        label: this.t('back_button'),
                                        icon: true
                                    }]
                                }
                            }),
                            afterRender: function () {
                                self._initPopupClose();

                                if (self._totalPages > 1 && self._firmListLoader) {
                                    // "this" here is self._firmListObject
                                    this.tmpl.parentNode.appendChild(self._firmListLoader);
                                }
                            }
                        };
                    },

                    _onFirmReady: function (firmContentObject) {
                        var self = this;
                        firmContentObject.afterRender = function () {
                            var headerTitle = self._popup._popupStructure.header.firstChild;
                            if (!DG.Browser.ielt9) {
                                if (headerTitle.offsetHeight > 72) {
                                    //TODO: magic number
                                    DG.DomUtil.addClass(headerTitle, 'dg-popup__header-teaser');
                                    if (!DG.Browser.webkit) {
                                        DG.Geoclicker.clampHelper(headerTitle, 3);
                                    }
                                }
                            }
                        };
                        this._clearAndRenderPopup(firmContentObject);
                    },

                    _showHousePopup: function () {
                        this._popup.off('scroll', this._onScroll);
                        this._clearAndRenderPopup(this._houseObject);
                        this._shortFirmList._toggleEventHandlers();
                    },

                    _onFirmListClick: function () {
                        this._popup.off('scroll', this._onScroll);
                    },

                    _pasteLoader: function () {
                        var loaderWrapper = DG.DomUtil.create('div', 'dg-map-geoclicker__preloader-wrapper'),
                            loader = this._view.initLoader();

                        loaderWrapper.insertBefore(loader, loaderWrapper.firstChild);
                        loaderWrapper.style.height = this._popup._contentNode.offsetHeight - 1 + 'px'; // MAGIC
                        loaderWrapper.style.width = this._popup._contentNode.offsetWidth + 'px';
                        this._clearAndRenderPopup({ tmpl: loaderWrapper });
                    },

                    _initPopupClose: function () {
                        if (this._initedPopupClose) {
                            return;
                        }

                        this._controller.getMap().once('popupclose', DG.bind(this._onPopupClose, this));
                        this._initedPopupClose = true;
                    },

                    _showListPopup: function () {
                        var firmList = this._firmListObject;

                        this._pasteLoader();

                        if (!firmList) {
                            firmList = this._api.firmsInHouse(this._id).then(DG.bind(this._initFirmList, this));
                        } else {
                            this._clearAndRenderPopup(firmList);
                            this._firmList._toggleEventHandlers();
                        }

                        if (!this._onScroll) {
                            this._onScroll = DG.Util.throttle(this._handlePopupScroll, this._scrollThrottleInterval, this);
                        }

                        this._popup.on('scroll', this._onScroll);
                    },

                    _renderFirmList: function () {
                        if (!this._isFirmlistOpen) {
                            this._popup.resize();
                            this._isFirmlistOpen = true;
                        }
                    },

                    _onPopupClose: function () {
                        this._initedPopupClose = false;
                        if (this._firmList) {
                            this._firmList.clearList();
                            this._firmList = null;
                            this._popup.off('scroll', this._onScroll);
                        }
                        this._firmId = null;
                        if (this.firmCard) {
                            this.firmCard._toggleEventHandlers(true);
                            this.firmCard = null;
                        }
                        this._firmListLoader = null;
                        this._page = 1;
                        this._clearEventHandlers();
                    },

                    _initShowMore: function () {
                        var link = this._popup.findElement('.dg-popup__button_name_all');

                        if (link) {
                            this._addEventHandler('dg-popup__button_name_all', DG.bind(this._showListPopup, this));
                        }
                    },

                    _clearAndRenderPopup: function (popupObject) {
                        this._clearEventHandlers();
                        this._popup.clear('header', 'footer');
                        this._view.renderPopup(popupObject);
                    },

                    _appendFirmList: function (res) {
                        // (Object)
                        this._firmList.addFirms(res.result.items);
                        this._popup._updateScrollPosition();
                    },

                    _handlePopupScroll: function (e) {
                        var scroller = e.originalEvent.target || e.target._scroller;

                        DG.DomEvent.stop(e);

                        if (this._totalPages <= 1) {
                            return;
                        }
                        if (scroller && scroller.scrollHeight <= scroller.scrollTop + scroller.offsetHeight + this._scrollHeightReserve) {
                            this._handlePaging();
                        }
                    },

                    _handlePaging: function () {
                        this._page++;

                        if (this._totalPages && this._page <= this._totalPages) {
                            this._api.firmsInHouse(this._id, { page: this._page }).then(DG.bind(this._appendFirmList, this));
                        }

                        if (this._page === this._totalPages) {
                            var loader = this._firmListLoader;

                            if (loader && loader.parentNode) {
                                loader.parentNode.removeChild(loader);
                            }

                            this._popup.off('scroll', this._onScroll);
                        }
                    }
                });

                DG.Geoclicker.Handler.House.include({
                    _getAddressString: function (house) {
                        if (!house.address || !house.address.components) {
                            return '';
                        }

                        return house.address.components.filter(function (component) {
                            return component.type === 'street_number';
                        }).map(function (component) {
                            return component.street + ', ' + component.number;
                        }).join(' / ');
                    },

                    _fillBody: function (house) {
                        // // (Object) -> (DOMElement)
                        var data = {},
                            wrapper = DG.DomUtil.create('div', 'dg-building-callout__body'),
                            filials = house.links && house.links.branches;

                        var drilldown = this._getDrilldown(house);

                        if (house.building_name) {
                            data.address = {
                                header: this._getAddressString(house),
                                drilldown: drilldown
                            };
                        } else if (drilldown) {
                            data.address = {
                                drilldown: drilldown
                            };
                        }

                        data.purpose = house.purpose_name + (house.floors ? ', ' + this.t('n_floors', house.floors.ground_count) : '');

                        if (filials && filials.count > 0) {
                            this._totalPages = Math.ceil(house.links.branches.count / this._firmsOnPage);
                        }

                        if (house.links && house.links.attractions && house.links.attractions.length) {
                            data.attractions = house.links.attractions.reduce(function (attractions, attraction) {
                                if (attraction.name) {
                                    attractions.push(attraction.name);
                                }

                                return attractions;
                            }, []);
                        }

                        wrapper.innerHTML = this._view.render({
                            tmpl: 'house',
                            data: data
                        });

                        if (filials && filials.items) {
                            wrapper.appendChild(this._initShortFirmList(filials.items));
                        }

                        return wrapper;
                    },

                    _fillHeader: function (house) {
                        // (Object) -> (HTMLString)
                        var header = {};

                        if (house.building_name) {
                            header.title = house.building_name;
                        } else if (house.address && house.address.components) {
                            header.title = this._getAddressString(house);
                        } else {
                            header.title = house.purpose_name;
                        }

                        this._header = this._view.render({
                            tmpl: 'popupHeader',
                            data: header
                        });

                        return this._header;
                    },

                    _fillFooter: function (house) {
                        // (Object) -> (HTMLString)
                        var btns = [];
                        var houseFilials = house.links && house.links.branches;

                        // Decide if we need to display 'more organisations' button
                        if (houseFilials && houseFilials.items && houseFilials.items.length && houseFilials.count > houseFilials.items.length) {
                            btns.push(this._getShowAllData(houseFilials.count));
                        }

                        if (this._isRouteSearchAllowed()) {
                            btns.push({
                                name: 'goto',
                                label: this.t('go_to'),
                                icon: true,
                                href: this._directionsUrl
                            });
                        }

                        return this._view.render({
                            tmpl: 'popupFooterBtns',
                            data: { 'btns': btns }
                        });
                    },

                    _getShowAllData: function (filialsCount) {
                        return {
                            name: 'all',
                            label: this.t('show_organization_in_building', filialsCount)
                        };
                    },

                    _fillHouseObject: function (house) {
                        // (Object) -> (Object)
                        var self = this;

                        return {
                            header: this._fillHeader(house),
                            tmpl: this._fillBody(house),
                            footer: this._fillFooter(house),
                            afterRender: function () {
                                self._initShowMore();
                                self._initPopupClose();
                            }
                        };
                    }
                });

                DG.Geoclicker.Handler.Poi = DG.Geoclicker.Handler.House.extend({

                    handle: function (results) {
                        // (Object) -> Promise
                        if (!results.poi) {
                            return false;
                        }

                        // initialization setup
                        this.firmCard = null;
                        this._page = 1;
                        this._houseObject = null;
                        this._firmList = null;
                        this._firmListObject = null;
                        this._firmCardObject = null;
                        this._onScroll = false;
                        this._isFirmlistOpen = false;

                        this._id = results.poi.reference.id;
                        this._totalPages = 1;
                        this._api = this._controller.getCatalogApi();
                        this._popup = this._view.getPopup();
                        this._initedPopupClose = false;
                        this._directionsUrl = this._getDirectionsUrl(results.poi.reference.name);
                        this._firmListLoader = this._view.initLoader(true);

                        // If the POI refers to a building (e.g. galleries in Santiago),
                        // show a building callout
                        if (results.poi.reference.type === 'building') {
                            var self = this;

                            return self._api.geoGet(results.poi.reference.id).then(function (result) {
                                self._houseObject = self._fillHouseObject(result.result.items[0]);
                                return Promise.resolve(self._houseObject);
                            });
                        }

                        // Otherwise, show a firm callout
                        if (results.poi.reference.type === 'branch') {
                            this._fillFirmCardObject(results.poi.reference.id);
                            return true;
                        }

                        return false;
                    }

                });

                DG.Geoclicker.Handler.Sight = DG.Geoclicker.Handler.Default.extend({

                    handle: function (results) {
                        // (Object, String) -> Promise
                        if (!results.attraction) {
                            return false;
                        }

                        this._popup = this._view.getPopup();
                        this._initedPopupClose = false;

                        return Promise.resolve(this._fillSightObject(results));
                    },

                    _fillSightObject: function (results) {
                        // (Object) -> Object
                        var attraction = results.attraction,
                            data = {},
                            self = this,
                            footer = {
                            btns: [{
                                name: 'goto',
                                label: this.t('go_to'),
                                icon: true
                            }]
                        };

                        if (attraction.name) {
                            data.buildingName = attraction.name;
                            data.purpose = attraction.subtype_name;
                        } else {
                            data.buildingName = attraction.subtype_name;
                        }

                        data.description = attraction.description;

                        data.drillDown = this._getDrilldown(attraction);

                        if (this._checkDescFieldHeight(data.description)) {
                            data.showMoreText = this.t('show_more_about_sight');
                        }

                        footer.btns[0].href = this._getDirectionsUrl(data.buildingName);

                        return {
                            tmpl: 'sight',
                            data: data,
                            header: this._view.render({
                                tmpl: 'popupHeader',
                                data: { 'title': data.buildingName }
                            }),
                            footer: this._view.render({
                                tmpl: 'popupFooterBtns',
                                data: footer
                            }),
                            afterRender: function () {
                                if (self._needShowMore) {
                                    self._initShowMore();
                                }
                                self._initPopupClose();
                            }
                        };
                    },

                    _initPopupClose: function () {
                        if (this._initedPopupClose) {
                            return;
                        }

                        this._controller.getMap().once('popupclose', DG.bind(this._clearPopup, this));
                        this._initedPopupClose = true;
                    },

                    _clearPopup: function () {
                        this._initedPopupClose = false;
                        this._clearEventHandlers();
                    },

                    _showMoreText: function () {
                        this._desc.style.maxHeight = '100%';
                        this._link.parentNode.removeChild(this._link);
                        this._popup.resize();
                    },

                    _initShowMore: function () {
                        this._link = this._popup.findElement('.dg-map-geoclicker__show-more-sights-link');
                        this._desc = this._popup.findElement('.dg-map-geoclicker__sight-description');

                        if (this._link && this._desc) {
                            this._addEventHandler('dg-map-geoclicker__show-more-sights-link', DG.bind(this._showMoreText, this));
                        }
                    },

                    _checkDescFieldHeight: function (desc) {
                        var el = DG.DomUtil.create('div', ''),
                            height;

                        el.style.visibility = 'hidden';
                        el.innerHTML = desc;

                        this._popup._contentNode.appendChild(el);
                        height = el.offsetHeight;
                        this._popup._contentNode.removeChild(el);
                        this._needShowMore = height > 40;

                        return this._needShowMore;
                    }
                });

                DG.Geoclicker.View = DG.Class.extend({

                    initialize: function (map, options) {
                        // (Object, Object)
                        this._map = map;
                        this._popup = DG.popup({
                            maxHeight: 300,
                            minHeight: 50,
                            maxWidth: 385,
                            minWidth: 310,
                            sprawling: true,
                            closeOnClick: true
                        });

                        if (options) {
                            DG.Util.setOptions(this, options);
                        }
                    },

                    initLoader: function (isSmall) {
                        var loader = document.createElement('div');
                        loader.innerHTML = DG.dust('DGGeoclicker/loader', {
                            small: isSmall,
                            anim: this._detectCssAnimation()
                        });

                        return loader.firstChild;
                    },

                    showPopup: function (latlng, content) {
                        // (Object)
                        this._popup.setContent(content).setLatLng(latlng).openOn(this._map);
                    },

                    render: function (options) {
                        // (Object) -> String
                        var html,
                            data = {};

                        options = options || {};
                        options.tmpl = options.tmpl || '';

                        if (options.data) {
                            html = this.renderTemplate(options.tmpl, options.data);
                        } else {
                            html = options.tmpl;
                        }

                        if (options.beforeRender) {
                            options.beforeRender();
                        }

                        if (options.popup) {
                            if (options.header) {
                                data.header = options.header;
                            }
                            if (options.footer) {
                                data.footer = options.footer;
                            }
                            data.body = html;
                            this._popup.setContent(data);
                        }
                        if (options.afterRender) {
                            options.afterRender();
                        }

                        return html;
                    },

                    renderTemplate: function (name, data) {
                        return DG.dust('DGGeoclicker/' + name, data);
                    },

                    renderPopup: function (options) {
                        // (Object) -> String
                        options.popup = true;
                        return this.render(options);
                    },

                    getPopup: function () {
                        // () -> Object
                        return this._popup;
                    },

                    _detectCssAnimation: function () {
                        var animation = false,
                            domPrefixes = 'Webkit Moz O ms Khtml'.split(' '),
                            elm = document.createElement('div');

                        if (elm.style.animationName) {
                            animation = true;
                        }

                        if (animation === false) {
                            for (var i = 0; i < domPrefixes.length; i++) {
                                if (elm.style[domPrefixes[i] + 'AnimationName'] !== undefined) {
                                    animation = true;
                                    break;
                                }
                            }
                        }
                        return animation;
                    }
                });

                DG.Geoclicker.Controller = DG.Class.extend({

                    options: {
                        // if handler worked successfully, it should return rendering object that will be processed in View , otherwise it should return false
                        // default handler always should return rendering object
                        'handlersSequence': {
                            'poi': DG.Geoclicker.Handler.Poi,
                            'attraction': DG.Geoclicker.Handler.Sight,
                            'building': DG.Geoclicker.Handler.House,
                            'street': DG.Geoclicker.Handler.CityArea,
                            'adm_div.place': DG.Geoclicker.Handler.CityArea,
                            'adm_div.district': DG.Geoclicker.Handler.CityArea,
                            'adm_div.division': DG.Geoclicker.Handler.CityArea,
                            'adm_div.settlement': DG.Geoclicker.Handler.CityArea,
                            'adm_div.city': DG.Geoclicker.Handler.CityArea,

                            'default': DG.Geoclicker.Handler.Default,

                            'apiError': DG.Geoclicker.Handler.ApiError

                            //            station_platform
                            //            project
                            //            station
                            //            crossbroad
                            //            metro
                        }
                    },

                    initialize: function (map, options) {
                        // (Object, Object)
                        this._options = options;
                        this._handlers = {};
                        this._catalogApi = new DG.Geoclicker.Provider.CatalogApi(map);
                        this._map = map;
                        this._view = new DG.Geoclicker.View(map);

                        this._renderHandlerResult = DG.bind(this._renderHandlerResult, this);
                        this._lastHandleClickArguments = null;
                    },

                    handlePopupClose: function (popup) {
                        // (Object)
                        if (popup === this._view.getPopup()) {
                            this._lastHandleClickArguments = null;
                            this._catalogApi.cancelLastRequest();
                        }
                    },

                    handleClick: function (latlng, zoom, meta) {
                        // (Object, Number, Object)
                        var self = this,
                            args = Array.prototype.slice.call(arguments, 0);

                        function beforeRequest() {
                            var loader = self._view.initLoader();
                            self._view._popup.clear();
                            self._view.showPopup(latlng, loader);
                            self._lastHandleClickArguments = args;
                        }

                        if (meta && meta.linked && meta.linked.type != 'sight' && meta.linked.type != 'attraction') {
                            if (meta.linked.type != 'branch' && meta.linked.type != 'building') {
                                return;
                            }

                            beforeRequest();
                            self.handleResponse({
                                poi: {
                                    reference: meta.linked
                                }
                            });
                        } else {
                            this._catalogApi.getLocations({
                                latlng: latlng,
                                zoom: zoom,
                                beforeRequest: beforeRequest
                            }).then(function (result) {
                                self.handleResponse(result);
                            }, function (error) {
                                self.handleResponse(error);
                            });
                        }
                    },

                    handleResponse: function (result) {
                        // (Object)
                        var type;

                        if (!result) {
                            this._runHandler('default');
                            return;
                        }

                        if (result === 'no type') {
                            return;
                        }

                        if (result === 'aborted') {
                            this._runHandler('apiError');
                            return;
                        }

                        type = this.findHandler(result);

                        while (type) {
                            if (this._runHandler(type, result)) {
                                return;
                            }
                            delete result[type];

                            type = this.findHandler(result);
                        }
                        this._runHandler('default');
                    },

                    findHandler: function (result) {
                        // (Object) -> String|Null
                        for (var i in this.options.handlersSequence) {
                            if (result[i]) {
                                return i;
                            }
                        }

                        return null;
                    },

                    getCatalogApi: function () {
                        // () -> Object
                        return this._catalogApi;
                    },

                    getMap: function () {
                        return this._map;
                    },

                    reinvokeHandler: function () {
                        if (this._lastHandleClickArguments) {
                            this.handleClick.apply(this, this._lastHandleClickArguments);
                        }
                    },

                    _runHandler: function (type, data) {
                        // (String, Object) -> Boolean
                        data = data || {};
                        this._initHandlerOnce(type);
                        this._handlers[type].addClickEvent();

                        var handlerResult = this._handlers[type].handle(data, type);

                        return handlerResult && handlerResult.then ? handlerResult.then(this._renderHandlerResult) : handlerResult;
                    },

                    _renderHandlerResult: function (result) {
                        this._view.renderPopup(result);
                    },

                    _initHandlerOnce: function (type) {
                        // (String)
                        if (!this._handlers[type]) {
                            this._handlers[type] = new this.options.handlersSequence[type](this, this._view, this._map, this._options);
                        }
                    }
                });

                DG.Geoclicker.Handler.Default.Dictionary.it = DG.extend({
                    apiErrorTitle: 'Oh oh, c\'è&nbsp;un&nbsp;errore',
                    apiErrorBody: 'I nostri server si rifiutano di rispondere. Stiamo facendo del nostro meglio per convincerli a&nbsp;comportarsi bene. Ritorna tra qualche minuto.',
                    we_have_not: 'Non disponiamo ancora di informazioni su questo posto',
                    noname: 'Nome non indicato',
                    'adm_div.place': 'Luogo',
                    'adm_div.division': 'Zona',
                    'adm_div.settlement': 'Comune',
                    street: 'Via',
                    'adm_div.district': 'Municipalità',
                    'adm_div.city': 'Сittà',
                    go_to: 'Come arrivare',
                    show_organization_in_building: ['{n} azienda in tutto', '{n} aziende in tutto'],
                    show_more_about_sight: 'Maggiori informazioni',
                    back_button: 'Indietro',
                    n_floors: ['{n} piano', '{n} piani']
                }, DG.Dictionary.it);

                DG.Geoclicker.Handler.Default.Dictionary.ru = DG.extend({
                    apiErrorTitle: 'Ошибочка вышла',
                    apiErrorBody: 'Наши серверы отказываются отвечать. Мы уже прикладываем все силы, чтобы вразумить их. Возвращайтесь к&nbsp;нам через&nbsp;несколько минут.',
                    we_have_not: 'Это место мы ещё не успели изучить',
                    noname: 'Без названия',
                    'adm_div.place': 'Место',
                    'adm_div.division': 'Округ',
                    'adm_div.settlement': 'Населенный пункт',
                    street: 'Улица',
                    'adm_div.district': 'Район',
                    'adm_div.city': 'Город',
                    go_to: 'Проехать сюда',
                    show_organization_in_building: ['Всего {n} организация', 'Всего {n} организации', 'Всего {n} организаций'],
                    show_more_about_sight: 'Подробнее',
                    back_button: 'Назад',
                    n_floors: ['{n} этаж', '{n} этажа', '{n} этажей']
                }, DG.Dictionary.ru);

                DG.Geoclicker.Handler.Default.Dictionary.en = DG.extend({
                    apiErrorTitle: 'Oops! Error detected.',
                    apiErrorBody: 'Our servers are not responding. We are doing our best to straighten them out. Please return to us in a few minutes.',
                    we_have_not: 'We haven\'t collected info about this place yet',
                    noname: 'No name',
                    'adm_div.place': 'Place',
                    'adm_div.division': 'Area',
                    'adm_div.settlement': 'Village',
                    street: 'Street',
                    'adm_div.district': 'District',
                    'adm_div.city': 'City',
                    go_to: 'Directions to here',
                    show_organization_in_building: ['{n} organization total', '{n} organizations total'],
                    back_button: 'Back',
                    show_more_about_sight: 'More information',
                    n_floors: ['{n} floor', '{n} floors']
                }, DG.Dictionary.en);

                DG.Geoclicker.Handler.Default.Dictionary.cs = DG.extend({
                    apiErrorTitle: 'Chybička se&nbsp;vloudila',
                    apiErrorBody: 'Naše servery odmítají reagovat. Již nyní vynakládáme veškeré úsilí, abychom je přivedli k rozumu. Zkuste akci opakovat za několik minut.',
                    we_have_not: 'O tomto místě zatím nemáme informace',
                    noname: 'Bez názvu',
                    'adm_div.place': 'Místo',
                    'adm_div.division': 'Správní obvod',
                    'adm_div.settlement': 'Obec',
                    street: 'Ulice',
                    'adm_div.district': 'Městská část',
                    'adm_div.city': 'Město',
                    go_to: 'Cesta sem',
                    show_organization_in_building: ['Celkem {n} organizace', 'Celkem {n} organizace', 'Celkem {n} organizací'],
                    back_button: 'Zpět',
                    show_more_about_sight: 'Více',
                    n_floors: ['{n} patro', '{n} patra', '{n} pater']
                }, DG.Dictionary.cs);

                DG.Geoclicker.Handler.Default.Dictionary.es = DG.extend({
                    apiErrorTitle: 'Vaya, ha ocurrido un error',
                    apiErrorBody: 'Nuestros servidores se niegan a responder. Ya nos estamos esforzando por hacerlos entrar en razón. Vuelva con nosotros pasados unos minutos.',
                    we_have_not: 'Todavía no hemos recopilado la información sobre este lugar',
                    noname: 'Sin nombre',
                    'adm_div.place': 'Lugar',
                    'adm_div.division': 'Comuna',
                    'adm_div.settlement': 'Población',
                    street: 'Calle',
                    'adm_div.district': 'Comuna',
                    'adm_div.city': 'Ciudad',
                    go_to: 'Ir para allá',
                    show_organization_in_building: ['Total {n} organización', 'Total {n} organizaciones', 'Total {n} organizaciones'],
                    show_more_about_sight: 'Read more',
                    back_button: 'Atrás',
                    n_floors: ['{n} piso', '{n} pisos']
                }, DG.Dictionary.es);

                var FirmCard = function (firm, options) {
                    this._setOptions(options);
                    this._firmContentObject = {};
                    this._schedule = new FirmCard.Schedule({
                        localLang: this.options.lang,
                        dict: this.dict
                    });

                    this.render(firm);
                };

                FirmCard.prototype = {

                    render: function (firmId) {
                        if (!firmId) {
                            return;
                        }

                        if (firmId !== this._firmId) {
                            this._firmContentObject = {};
                            this._renderCardById(firmId);
                        } else {
                            this._toggleEventHandlers();
                        }

                        return this._firmContentObject;
                    },

                    getSchedule: function () {
                        return this._schedule;
                    },

                    getContainer: function () {
                        return this._container;
                    },

                    _renderCardById: function (firmId) {
                        var self = this;

                        this.options.ajax(firmId).then(function (res) {
                            if (!res) {
                                return false;
                            }
                            var data = res.result.items;
                            if (data !== 'undefined') {
                                self._firmData = data[0];

                                // Support for old WebAPI format.
                                // TODO: remove this call after WebAPI release
                                self._convertWebsite();

                                self._firmId = firmId;
                                self._renderFirmCard();
                                self._toggleEventHandlers();
                            }
                        }, function (error) {
                            self._renderError();
                        });
                    },

                    _createFirmContainer: function () {
                        var firm = document.createElement('div');
                        firm.setAttribute('id', 'dg-map-firm-full-' + this._firmId);
                        firm.setAttribute('class', 'dg-map-firm-full');

                        return firm;
                    },

                    _getPaymentTypes: function (data) {
                        var result = [],
                            groupName = 'general_payment_type';

                        if (!data.attribute_groups) {
                            return result;
                        }

                        data.attribute_groups.forEach(function (group) {
                            if (group.name) {
                                return;
                            }

                            group.attributes.forEach(function (attr) {
                                if (attr.tag.substring(0, groupName.length) === groupName) {
                                    result.push(attr.name);
                                }
                            });
                        });

                        return result;
                    },

                    _groupRubrics: function (data) {
                        var result = {
                            primary: [],
                            additional: []
                        };

                        if (!data.rubrics || !data.rubrics.length) {
                            return result;
                        }

                        data.rubrics.forEach(function (rubric) {
                            result[rubric.kind].push(rubric);
                        });

                        return result;
                    },

                    // Support for old WebAPI format.
                    // TODO: remove this function after WebAPI release
                    _convertWebsite: function () {
                        if (!this._firmData.contact_groups) {
                            return;
                        }

                        this._firmData.contact_groups.forEach(function (group) {
                            if (!group.contacts) {
                                return;
                            }

                            group.contacts.forEach(function (contact) {
                                if (contact.type != 'website') {
                                    return;
                                }

                                if (!contact.url) {
                                    contact.url = contact.value;
                                }
                            });
                        });
                    },

                    _renderFirmCard: function () {
                        var firmCardBody,
                            schedule,
                            forecast,
                            links,
                            btns,
                            paymentTypes,
                            rubrics,
                            data = this._firmData,
                            container = this._container = this._createFirmContainer();

                        schedule = this._schedule.transform(data.schedule, {
                            zoneOffset: this.options.timezoneOffset,
                            apiLang: this.options.lang,
                            localLang: this.options.lang
                        });

                        forecast = this._schedule.forecast(schedule);

                        paymentTypes = this._getPaymentTypes(data);
                        rubrics = this._groupRubrics(data);

                        firmCardBody = this._buildFirmCardBody(this._getConfigFirmCardBody(data, schedule, forecast, paymentTypes, rubrics));

                        links = this._fillHeaderLinks();
                        btns = this._fillFooterButtons();

                        //fill object for view render
                        this._firmContentObject.header = this.options.render('firmCardHeader', { 'firmName': data.name, 'links': links });
                        container.innerHTML = firmCardBody;
                        this._firmContentObject.tmpl = container;
                        if (btns.length) {
                            this._footerContainer = document.createElement('div');

                            this._footerContainer.innerHTML = this.options.render('popupFooterBtns', { 'btns': btns });
                            this._firmContentObject.footer = this._footerContainer;
                        }

                        if (this.options.onFirmReady) {
                            this.options.onFirmReady(this._firmContentObject);
                        }
                    },

                    _renderError: function () {
                        this._firmContentObject.header = this.options.render('popupHeader', {
                            title: this.options.t('apiErrorTitle')
                        });

                        this._firmContentObject.tmpl = this.options.t('apiErrorBody');

                        if (this.options.onFirmReady) {
                            this.options.onFirmReady(this._firmContentObject);
                        }
                    },

                    _getConfigFirmCardBody: function (data, schedule, forecast, attributes, rubrics) {
                        return [{
                            tmpl: 'firmCardAddr',
                            data: {
                                address: data.address_name,
                                comment: data.address_comment
                            }
                        }, {
                            tmpl: 'firmCardContacts',
                            data: {
                                groups: data.contact_groups
                            }
                        }, {
                            tmpl: 'firmCardSchedule',
                            data: {
                                schedule: schedule,
                                forecast: forecast
                            }
                        }, {
                            tmpl: 'frimCardPayments',
                            data: {
                                payments: attributes
                            }
                        }, {
                            tmpl: 'firmCardRubric',
                            data: {
                                rubrics: rubrics
                            }
                        }];
                    },

                    _buildFirmCardBody: function (parts) {
                        var self = this;
                        return parts.reduce(function (body, item) {
                            var html = self.options.render(item.tmpl, item.data);
                            return body + html;
                        }, '');
                    },

                    _fillFooterButtons: function () {
                        var btns = [];

                        if (this.options.backBtn) {
                            btns.push({ name: 'firm-card-back',
                                label: this.dict.t(this.options.lang, 'btnBack'),
                                icon: true
                            });
                        }

                        if (this.options.showRouteSearch) {
                            btns.push({ name: 'goto',
                                label: this.dict.t(this.options.lang, 'btnFindWay'),
                                icon: true,
                                href: this.options.gotoUrl
                            });
                        }

                        if (this._firmData.links && this._firmData.links.entrances && this.options.showEntrance) {
                            btns.push({ name: 'show-entrance',
                                label: this.dict.t(this.options.lang, 'btnEntrance'),
                                icon: true
                            });
                        }

                        return btns;
                    },

                    _fillHeaderLinks: function () {
                        var links = [],
                            reviewData = this._firmData.reviews,
                            booklet,
                            link;

                        if (this._firmData.external_content) {
                            this._firmData.external_content.forEach(function (el) {
                                if (el && el.type == 'booklet') {
                                    booklet = el;
                                }
                            });
                        }

                        if (reviewData && reviewData.is_reviewable) {
                            links.push({
                                name: 'flamp_stars',
                                width: reviewData.rating * 20
                            });
                            links.push({
                                name: 'flamp_reviews',
                                label: this.dict.t(this.options.lang, 'linkReviews', reviewData.review_count ? reviewData.review_count : 0),
                                href: FirmCard.DataHelper.getFlampUrl(this._firmId)
                            });
                        }

                        // Retrieve photo data from external content block
                        var photos;
                        var externalContent = this._firmData.external_content;

                        for (var i = 0; i < externalContent.length; i++) {
                            if (externalContent[i].type == 'photo_album' && externalContent[i].subtype == 'common') {
                                photos = externalContent[i];
                                break;
                            }
                        }

                        if (!this.options.isMobile && photos && photos.count && this.options.showPhotos) {
                            link = L.Util.template(DG.config.photosLink, {
                                'id': this._firmId,
                                'domain': this.options.domain
                            });

                            links.push({ name: 'photos',
                                href: link,
                                label: this.dict.t(this.options.lang, 'linkPhoto', photos.count)
                            });
                        }

                        if (!this.options.isMobile && booklet && booklet.url && this.options.showBooklet) {
                            links.push({
                                name: 'booklet',
                                href: booklet.url,
                                label: this.dict.t(this.options.lang, 'linkBooklet')
                            });
                        }

                        return links;
                    },

                    _events: {
                        'dg-popup__button_name_firm-card-back': function () {
                            this.options.backBtn();
                            this._toggleEventHandlers(true);
                        },
                        'dg-popup__button_name_show-entrance': function () {
                            var ent = new this.options.showEntrance({ 'vectors': this._firmData.links.entrances[0].geometry.vectors });
                            ent.addTo(this.options.map);
                            ent.fitBounds();
                            this._toggleEventHandlers(true);
                        },
                        'dg-schedule__today': function () {
                            this._onToggleSchedule();
                        }
                    },

                    _toggleEventHandlers: function (flag) {
                        this.options.popup[flag ? 'off' : 'on']('click', this._onClick, this);
                        this.options.map[flag ? 'off' : 'on']('popupclose', this._onClose, this);
                    },

                    _onClick: function (e) {
                        var target = e.originalEvent.target;

                        for (var eventClass in this._events) {
                            if (this._events.hasOwnProperty(eventClass) && target.className.indexOf(eventClass) > -1) {
                                DG.DomEvent.preventDefault(e.originalEvent);
                                this._events[eventClass].call(this, target);
                                return;
                            }
                        }
                    },

                    _onClose: function (e) {
                        this._toggleEventHandlers(true);
                    },

                    _onToggleSchedule: function () {
                        var schedule = this._container.querySelector('.dg-schedule__table'),
                            forecast = this._container.querySelector('.dg-schedule__now'),
                            target = this._container.querySelector('.dg-schedule__today'),
                            showClass = ' dg-schedule__today_shown_true';

                        if (!schedule) {
                            return;
                        }

                        if (schedule.style.display === 'block') {
                            schedule.style.display = 'none';
                            forecast.style.display = 'block';
                            target.className = target.className.replace(showClass, '');
                        } else {
                            forecast.style.display = 'none';
                            schedule.style.display = 'block';
                            target.className += showClass;
                        }

                        if (this.options.onToggle) {
                            this.options.onToggle();
                        }
                    },

                    _setOptions: function (options) {
                        var option,
                            options = options || {};

                        this.options = options;
                        options.lang = options.lang || 'ru';

                        for (option in options) {
                            if (options.hasOwnProperty(option)) {
                                this.options[option] = options[option];
                            }
                        }
                    },

                    _hasTouch: function () {
                        return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
                    }
                };

                FirmCard.DataHelper = {
                    payMethods: ['americanexpress', 'cash', 'dinersclub', 'goldcrown', 'internet', 'mastercard', 'noncash', 'visa'],

                    _msgs: {},

                    getFlampUrl: function (id) {
                        return DG.config.flampUrl.concat(id, '?', DG.config.flampGoogleAnalytics);
                    },

                    msg: function (msg) {
                        if (this._msgs.hasOwnProperty(msg)) {
                            return this._msgs[msg];
                        }
                        console && console.log("Cant't find translation for '" + msg + "'.");
                        return msg.toString().replace('_', ' ');
                    },

                    getProjectTime: function (timezoneOffset, time) {
                        var now, utc;

                        if (time) {
                            now = new Date(time);
                        } else {
                            now = new Date();
                        }

                        if (timezoneOffset) {
                            utc = now.getTime() + now.getTimezoneOffset() * 60000;
                            return new Date(utc + 60000 * timezoneOffset);
                        } else {
                            return now;
                        }
                    }
                };

                /* global
                    FirmCard: false
                */
                (function () {
                    FirmCard.List = function (firms, options) {
                        this._firms = {}; // {'firmID': firmDomObj}
                        this._setOptions(options);

                        this._container = options && options.container || document.createElement('ul');
                        this._container.setAttribute('class', 'dg-building-callout__list');

                        this._eventHandlersInited = false;
                        this._firmCard = this._createFirm();
                        this.renderList(firms);
                    };

                    FirmCard.List.prototype = {

                        renderList: function (firms) {
                            if (firms) {
                                this._toggleEventHandlers();
                                this.addFirms(firms);
                            }
                            if (this.options.onListReady) {
                                this.options.onListReady(this._container);
                            }

                            return this._container;
                        },

                        _processFirms: function (firms, action) {
                            if (!firms) {
                                return;
                            }
                            var method = '_' + action + 'Firm';
                            if (this._isArray(firms)) {
                                for (var i = 0, l = firms.length; i < l; i++) {
                                    this[method](firms[i]);
                                }
                            } else {
                                this[method](firms);
                            }
                        },

                        addFirms: function (firms) {
                            this._processFirms(firms, 'add');
                        },

                        removeFirms: function (firms) {
                            this._processFirms(firms, 'remove');
                        },

                        setLang: function (newLang) {
                            this.options.firmCard.lang = newLang;
                        },

                        getLang: function () {
                            return this.options.firmCard.lang;
                        },

                        getContainer: function () {
                            return this._container;
                        },

                        clearList: function () {
                            this._firms = {};
                            this._toggleEventHandlers(true);
                            this._clearContainer();
                        },

                        _removeFirm: function (id) {
                            if (!this._firms[id]) {
                                return false;
                            }
                            this._container.removeChild(this._firms[id]);
                            delete this._firms[id];
                        },

                        _addFirm: function (firmData) {
                            var tmpl = this.options.firmlistItemTmpl,
                                domFirm,
                                firm,
                                content;

                            firm = {
                                name: firmData.name,
                                id: firmData.id.split('_').slice(0, 1)
                            };

                            if (!(firm.id in this._firms)) {

                                domFirm = this._createListItem();

                                content = tmpl ? this.options.firmCard.render(tmpl, { 'firm': firm }) : firm.name;

                                domFirm.insertAdjacentHTML('beforeend', content);

                                this._firms[firm.id] = domFirm;
                                this._container.appendChild(domFirm);
                            }
                        },

                        _createListItem: function () {
                            var item = document.createElement('li');
                            item.setAttribute('class', 'dg-building-callout__list-item');

                            return item;
                        },

                        _isArray: function (obj) {
                            return {}.toString.call(obj) === '[object Array]';
                        },

                        _createFirm: function (firmData) {
                            return new FirmCard(firmData, this.options.firmCard);
                        },

                        _isEmptyObj: function (obj) {
                            for (var prop in obj) {
                                if (obj.hasOwnProperty(prop)) {
                                    return false;
                                }
                            }

                            return true;
                        },

                        _events: {
                            'dg-popup__link': function (target) {
                                var s = this._firmCard.render(target.id);

                                this.options.firmCard[this._isEmptyObj(s) ? 'pasteLoader' : 'onFirmReady'](s);

                                this.options.firmCard.onFirmClick && this.options.firmCard.onFirmClick();

                                this._toggleEventHandlers(true);
                            },
                            'dg-building-callout__list-item': function (target) {
                                target = target.children[0];

                                this._events['dg-popup__link'].call(this, target);
                            },
                            'dg-popup__button_name_back': function () {
                                this.options.firmCard.onShowLess();

                                this._toggleEventHandlers(true);
                            }
                        },

                        _toggleEventHandlers: function (flag) {
                            this.options.firmCard.popup[flag ? 'off' : 'on']('click', this._onClick, this);
                        },

                        _onClick: function (e) {
                            var target = e.originalEvent.target;

                            for (var eventClass in this._events) {
                                if (this._events.hasOwnProperty(eventClass) && target.className.indexOf(eventClass) > -1) {
                                    DG.DomEvent.preventDefault(e.originalEvent);
                                    this._events[eventClass].call(this, target);
                                    return;
                                }
                            }
                        },

                        _clearContainer: function () {
                            var container = this._container;

                            while (container.hasChildNodes()) {
                                container.removeChild(container.firstChild);
                            }
                        },

                        _setOptions: function (options) {
                            options || (options = {});
                            this.options = options;
                            this.options.firmCard || (this.options.firmCard = {});

                            if (!options.firmCard.lang) {
                                this.options.firmCard.lang = 'ru';
                            }

                            for (var option in options) {
                                if (options.hasOwnProperty(option)) {
                                    this.options[option] = options[option];
                                }
                            }
                        }
                    };
                })();

                /*global
                    FirmCard:false
                */
                FirmCard.Schedule = function (options) {
                    options = options || {};

                    this.localLang = options.localLang || 'ru';
                    this.dict = options.dict;
                    return this;
                };

                FirmCard.Schedule.prototype = {

                    setLang: function (lang) {
                        this.localLang = lang || 'ru';
                        return this;
                    },

                    transform: function (model, params) {
                        if (!model) {
                            return;
                        }
                        params = params || {};

                        function bind(fn, obj) {
                            // (Function, Object) -> Function
                            var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
                            return function () {
                                return fn.apply(obj, args || arguments);
                            };
                        }

                        var todayKey,
                            // Mon, Tue ...
                        today,
                            // Объект модели - текущий день недели
                        from,
                            // Самое раннее время открытия за день
                        to,
                            // Самое позднее время закрытия за день
                        zoneOffset = params.zoneOffset || 0,
                            schedule = {},
                            // Объект-расписание, формируемый под шаблон
                        now = params.now || FirmCard.DataHelper.getProjectTime(zoneOffset).getTime(),
                            // Current timestamp in milliseconds
                        weekKeys = [],
                            // Ключи дней недели, определяют порядок дней и первый день недели. 0 - первый день недели в регионе (не обязательно Mon)
                        weekKeysLocal = [],
                            weekFullKeysLocal = [],
                            weekKeysShort = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
                            weekKeysFull = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'],
                            localLang = params.localLang || this.localLang,
                            localWorkingDays = params.localWorkingDays || [0, 1, 1, 1, 1, 1, 0],
                            firstdayOffset = params.firstdayOffset || 1,
                            minHoursToDisplayClosure = params.minHoursToDisplayClosure || 4,
                            t = bind(this.dict.t, this.dict);

                        function capitaliseFirstLetter(string) {
                            return string.charAt(0).toUpperCase() + string.slice(1);
                        }

                        function getHours(str) {
                            return str.substr(0, 2);
                        }

                        function getMinutes(str) {
                            return str.substr(3, 2);
                        }

                        // Конвертация временной точки формата апи в формат отображения (25:00 -> 01:00)
                        function formatTime(str) {
                            var hours = +getHours(str) % 24 + '';

                            if (hours.length === 1) {
                                hours = '0' + hours;
                            }

                            return hours + ':' + getMinutes(str);
                        }

                        // Конвертация int числа в номер дня недели (диапазон 0-6)
                        // отрицательные чила: -1 вернёт 6, -2 -> 5 и т.д
                        // положительные: 7 -> 0, 8 -> 1
                        function dayNum(n) {
                            return (n + 70) % 7;
                        }

                        /* jshint ignore:start */
                        // Возвращает последний элемент массива
                        // Взято из Underscore.js http://underscorejs.org/#last
                        function getArrayLast(arr, n) {
                            if (arr == null) return void 0;
                            if (n == null) return arr[arr.length - 1];
                            return slice.call(arr, Math.max(arr.length - n, 0));
                        }

                        // Выполняет глубокое сравнение объектов
                        // Взято из Underscore.js http://underscorejs.org/#isEqual
                        // Упрощено для тех трёх сравнений, которые выполняются в Shedule.js
                        function isEqual(obj1, obj2) {
                            if (obj1 === obj2) return true;
                            if (!(obj1 instanceof Object) || !(obj2 instanceof Object)) return false;
                            if (obj1.constructor !== obj2.constructor) return false;
                            for (var prop in obj1) {
                                if (!obj1.hasOwnProperty(prop)) continue;
                                if (!obj2.hasOwnProperty(prop)) return false;
                                if (obj1[prop] === obj2[prop]) continue;
                                if (typeof obj1[prop] !== "object") return false;
                                if (!isEqual(obj1[prop], obj2[prop])) return false;
                            }
                            for (prop in obj2) {
                                if (obj2.hasOwnProperty(prop) && !obj1.hasOwnProperty(prop)) return false;
                            }

                            return true;
                        }

                        // Generate an integer Array containing an arithmetic progression. A port of
                        // the native Python `range()` function. See
                        // [the Python documentation](http://docs.python.org/library/functions.html#range).
                        function range(start, stop, step) {
                            if (arguments.length <= 1) {
                                stop = start || 0;
                                start = 0;
                            }
                            step = arguments[2] || 1;

                            var length = Math.max(Math.ceil((stop - start) / step), 0);
                            var idx = 0;
                            var range = new Array(length);
                            while (idx < length) {
                                range[idx++] = start;
                                start += step;
                            }

                            return range;
                        }

                        //Заполняет свойства объекта значениями по умолчанию
                        //Взято из Underscore.js http://underscorejs.org/#defaults
                        function fillDefaults(obj) {
                            var args = Array.prototype.slice.call(arguments, 1);
                            args.forEach(function (source) {
                                if (source) {
                                    for (var prop in source) {
                                        if (obj[prop] === void 0) obj[prop] = source[prop];
                                    }
                                }
                            });
                            return obj;
                        }

                        //Сортирует значения согласно с итератором
                        //Взято с Underscore.js http://underscorejs.org/#sortBy
                        function sortBy(obj, iterator) {
                            return pluck(obj.map(function (value, index, list) {
                                return {
                                    value: value,
                                    index: index,
                                    criteria: iterator.call(this, value, index, list)
                                };
                            }).sort(function (left, right) {
                                var a = left.criteria;
                                var b = right.criteria;
                                if (a !== b) {
                                    if (a > b || a === void 0) return 1;
                                    if (a < b || b === void 0) return -1;
                                }
                                return left.index - right.index;
                            }), 'value');
                        }

                        /* jshint ignore:end */

                        function pluck(arr, key) {
                            var i,
                                rv = [];
                            for (i = 0; i < arr.length; ++i) {
                                rv[i] = arr[i][key];
                            }
                            return rv;
                        }

                        // Преобразовать расписание на день в упорядоченный массив временных отсечек (string)
                        // Сейчас полагается, что API уже выдаёт сортированный массив
                        function getSortedTimePoints(day) {
                            var points = [],
                                from,
                                to,
                                deltaHours,
                                deltaMinutes;

                            if (!day || !day.working_hours) {
                                return [];
                            }

                            for (var i = 0; i < day.working_hours.length; i++) {
                                from = day.working_hours[i].from;
                                to = day.working_hours[i].to;

                                deltaHours = getHours(to) - getHours(from);
                                deltaMinutes = getMinutes(to) - getMinutes(from);
                                if (deltaHours < 0 || deltaHours === 0 && deltaMinutes <= 0) {
                                    // Если "до" меньше или равно "от" - значит указывает на завтра
                                    to = +getHours(to) + 24 + ':' + getMinutes(to); // (01:00 -> 25:00)
                                }

                                points[i * 2] = {
                                    time: from,
                                    type: 'open'
                                };
                                points[i * 2 + 1] = {
                                    time: to,
                                    type: day.working_hours.length - 1 === i ? 'close' : 'lunch'
                                };
                            }

                            return points;
                        }

                        // Возвращает массив timestamp всех точек, всех дней недели, от сегодняшнего и в будущее
                        // Например, сегодня среда, отсечки будут взяты для дат со среды (сегодня) по следующий вторник включительно
                        function getTimeStamps(model) {
                            var timestamps = [],
                                out = [],
                                timePoints,
                                num = weekKeys.indexOf(todayKey); // Номер сегодняшнего дня недели (для данного региона)


                            // Цикл по дням недели начиная с сегодняшнего
                            var j; // Номер текущего дня в массиве weekKeys
                            for (var i = 0; i < 7; i++) {
                                j = dayNum(num + i);
                                timePoints = getSortedTimePoints(model[weekKeys[j]]);
                                // Цикл по точкам времени с конвертацией в timestamp
                                timePoints.forEach(
                                /* jshint -W083 */
                                function (point) {
                                    // now - обязательно! иначе будет браться текущий timestamp что чревато несовпадениями при медленном быстродействии
                                    // Вычислить таймстемп для данного дня недели, часа и минуты, в будущем, но ближайший к now
                                    var tsp = new Date(now);
                                    tsp.setDate(tsp.getDate() + i);
                                    tsp.setHours(getHours(point.time));
                                    tsp.setMinutes(getMinutes(point.time));
                                    var ts = tsp.getTime();

                                    timestamps.push({
                                        ts: ts,
                                        type: point.type
                                    });

                                    if (timestamps[timestamps.length - 1] && timestamps[timestamps.length - 2]) {
                                        // Парно удаляем совпадающие точки (они не имеют смысла - это сегодня 24:00 и завтра 00:00)
                                        if (timestamps[timestamps.length - 1].ts === timestamps[timestamps.length - 2].ts) {
                                            timestamps.pop();
                                            timestamps.pop();
                                        }
                                    }

                                    if (timestamps[timestamps.length - 1] && timestamps[timestamps.length - 2]) {
                                        // Парно переносим точки в будущее, если они обе в прошлом (первая точка ([0]) должна быть всегда открытием!)
                                        if (timestamps[timestamps.length - 1].ts <= now && timestamps[timestamps.length - 2].ts <= now) {
                                            timestamps[timestamps.length - 1].ts += 7 * 24 * 60 * 60 * 1000;
                                            timestamps[timestamps.length - 2].ts += 7 * 24 * 60 * 60 * 1000;
                                        }
                                    }
                                }
                                /* jshint +W083 */
                                );
                            }

                            // Сортируем на возрастание, ведь возможно были переносы в будущее
                            timestamps = sortBy(timestamps, function (timestamp) {
                                return timestamp.ts;
                            });

                            // Удаляем попарно совпадающие точки времени
                            i = 0;
                            while (i < timestamps.length) {
                                if (timestamps[i + 1] && timestamps[i].ts === timestamps[i + 1].ts) {
                                    i++;
                                } else {
                                    out.push(timestamps[i].ts);
                                }
                                i++;
                            }

                            // Проверка на ежедневно-круглосуточность
                            if (out.length === 2 && out[1] - out[0] === 7 * 24 * 60 * 60 * 1000) {
                                return [];
                            }

                            return timestamps;
                        }

                        function whenOpenInverse(h, d, num) {
                            if (d === 1 && h > minHoursToDisplayClosure) {
                                return t(localLang, 'tommorow');
                            } else if (d > 1) {
                                /* jshint -W015 */
                                switch (num) {
                                    case 0:
                                        return t(localLang, 'nextSun');
                                    case 1:
                                        return t(localLang, 'nextMon');
                                    case 2:
                                        return t(localLang, 'nextTue');
                                    case 3:
                                        return t(localLang, 'nextWed');
                                    case 4:
                                        return t(localLang, 'nextThu');
                                    case 5:
                                        return t(localLang, 'nextFri');
                                    case 6:
                                        return t(localLang, 'nextSat');
                                }
                                /* jshint +W015 */
                            }

                            return;
                        }

                        //Возвращает интервал в целых днях, с поправкой на смену дня в полночь, между
                        // @param timestampEnd и @param dateStart
                        function dayInterval(timestampEnd, dateStart) {

                            var oneDay = 1000 * 60 * 60 * 24,
                                dateEnd = new Date(timestampEnd.ts);

                            var diff;

                            diff = Math.round((dateEnd - dateStart) / oneDay);

                            if (timestampEnd.type === 'open' && dateEnd.getHours() < 1) {
                                diff++;
                            }

                            return diff;
                        }

                        // Поместить данные в объект для шаблона о сегодняшнем дне
                        function setTodayString(today) {

                            var timePoints,
                                periods = [],
                                timestamps;

                            schedule.now = {};

                            // Timestamps всех отсечек
                            timestamps = getTimeStamps(model);

                            if (!timestamps.length) {
                                schedule.always = true; // Работает ежедневно круглосуточно
                                schedule.now.open = true;
                            }

                            for (var i = 0; i < timestamps.length; i++) {
                                // Попали между точками i-1 и i // Мы находимся заведомо в будущем относительно 1
                                if (now >= (timestamps[i - 1] && timestamps[i - 1].ts || 0) && now < timestamps[i].ts) {
                                    var h = Math.floor((timestamps[i].ts - now) / (1000 * 60 * 60)),
                                        // Количество часов до следующего timestamp
                                    m = Math.floor((timestamps[i].ts - now) / (1000 * 60) - h * 60),
                                        // Количество минут (без часов) до следующего timestamp
                                    dayNow = new Date(now),


                                    // открыто если следующая итерация не открытие
                                    nowIsOpen = timestamps[i].type !== 'open';

                                    //var d = dayOfYear(dayTs) - dayOfYear(dayNow);
                                    //var d = dayInterval(dayTs, dayNow, nowIsOpen);
                                    var d = dayInterval(timestamps[i], dayNow);

                                    // округляем минуты до кратных 5
                                    m = Math.floor(m / 10) * 10 ? Math.floor(m / 10) * 10 : 5;

                                    schedule.now.open = nowIsOpen;
                                    schedule.now.lunch = !!(timestamps[i - 1] && timestamps[i - 1].type === 'lunch' || getArrayLast(timestamps).type === 'lunch');

                                    schedule.will = {
                                        willType: timestamps[i].type,
                                        d: d,
                                        h: h,
                                        m: m
                                    };

                                    // Когда закроется или откроется
                                    var willWhen = new Date(timestamps[i].ts);
                                    schedule.will.when = whenOpenInverse(h, d, willWhen.getDay());

                                    var willTill = new Date(timestamps[i].ts),
                                        strHours = willTill.getHours(),
                                        strMinutes = willTill.getMinutes();

                                    if (strHours < 10) {
                                        strHours = '0' + strHours;
                                    }
                                    if (strMinutes < 10) {
                                        strMinutes = '0' + strMinutes;
                                    }

                                    schedule.will.till = strHours + ':' + strMinutes;
                                }
                            }

                            if (!today) {
                                return; // На сегодня расписания нет - сейчас закрыто
                            }

                            timePoints = pluck(getSortedTimePoints(today), 'time');

                            // Цикл по периодам работы за день
                            for (i = 2; i < timePoints.length; i = i + 2) {
                                periods.push({ from: timePoints[i - 1], to: timePoints[i] });
                            }

                            from = formatTime(timePoints[0]);
                            to = formatTime(timePoints[timePoints.length - 1]);

                            if (from === to) {
                                // Круглосуточно
                                schedule.today = {
                                    alltime: true,
                                    alltimeStr: t(localLang, 'worksAroundTheClock'),
                                    from: '00:00',
                                    to: '24:00'
                                };
                            } else {
                                // От from до to
                                schedule.today = {
                                    from: from,
                                    to: to
                                };
                            }

                            if (periods.length > 0) {
                                // Перерывы на обед
                                schedule.lunch = periods;
                                schedule.lunchStr = t(localLang, 'lunch');
                            }
                        }

                        // Формирование объекта-таблицы-расписания для шаблона
                        function makeTable() {
                            var column = [],
                                hasLunch = false;

                            for (var j = 0; j < 7; j++) {
                                var dayKey = weekKeys[j],
                                    lunchMaxLength = 0;

                                column[j] = {};

                                if (model[dayKey]) {
                                    var day = model[dayKey],
                                        timePoints = pluck(getSortedTimePoints(day), 'time'),
                                        lunch = []; // Отрезки времени (отсортированные моменты) на обеды

                                    // Цикл по периодам работы за день
                                    for (var i = 2; i < timePoints.length; i = i + 2) {
                                        hasLunch = true;
                                        lunch.push({ from: timePoints[i - 1], to: timePoints[i] });
                                    }
                                    lunchMaxLength = Math.max(timePoints.length / 2, lunchMaxLength);

                                    column[j] = {
                                        from: formatTime(timePoints[0]),
                                        to: formatTime(timePoints[timePoints.length - 1]),
                                        lunch: lunch
                                    };
                                }

                                if (dayKey === todayKey) {
                                    // Сегодняшний день надо подсветить
                                    column[j].active = true;
                                }

                                column[j].key = weekKeysLocal[j];
                            }

                            // Дополнение пустыми объектами массивов lunch
                            column.forEach(function (col) {
                                if (col.lunch) {
                                    fillDefaults(col.lunch, range(1, lunchMaxLength));
                                }
                            });

                            return {
                                table: column,
                                hasLunch: hasLunch
                            };
                        }

                        // Сгенерировать строку для всех дней model, совпадающих с day
                        function makeSimpleString(day, model) {
                            var points,
                                out = {
                                dayList: [],
                                lunch: []
                            },
                                lunchesTime = [];

                            if (day && day.working_hours && day.working_hours.length) {
                                points = pluck(getSortedTimePoints(day), 'time');
                                points.forEach(function (point, key) {
                                    if (key === 0) {
                                        out.from = formatTime(point);
                                    } else if (key === points.length - 1) {
                                        out.to = formatTime(point);
                                    } else {
                                        lunchesTime.push(formatTime(point));
                                    }
                                });
                                for (var i = 0; i < lunchesTime.length; i += 2) {
                                    out.lunch.push({
                                        from: lunchesTime[i],
                                        to: lunchesTime[i + 1],
                                        lunchStr: capitaliseFirstLetter(t(localLang, 'lunch'))
                                    });
                                }

                                if (out.from == '00:00' && out.to == '00:00') {
                                    out.to = '24:00';
                                }

                                if (day.round_the_clock) {
                                    out.alltime = true;
                                    out.alltimeStr = t(localLang, 'worksAroundTheClock');
                                }
                            } else {
                                // Выходной
                                out.holiday = true;
                            }

                            // Формируем список дней на локальном языке
                            var groupWorkingDays = [0, 0, 0, 0, 0, 0, 0]; // Флаги работы фирмы в дни текущей группы
                            var flow = 0;

                            weekKeys.forEach(function (dayKey, numKey) {
                                // 'Mon', 0
                                if (isEqual(model[dayKey], day) || !model[dayKey] && day === null) {
                                    out.dayList.push(weekFullKeysLocal[numKey]);
                                    groupWorkingDays[dayNum(numKey + firstdayOffset)] = 1;
                                    flow++;
                                } else {
                                    if (flow > 2) {
                                        // Более 2 дней подряд
                                        var lastDay = out.dayList.pop();

                                        for (var i = 1; i < flow - 1; i++) {
                                            out.dayList.pop();
                                        }

                                        out.dayList[out.dayList.length - 1] += ' — ' + lastDay;
                                    }

                                    flow = 0;
                                }
                            });

                            // Список дней в данной группе идентичен списку будних дней, значит можно заменить словом "Будни"
                            out.budni = isEqual(localWorkingDays, groupWorkingDays);
                            // Список рабочих дней - все дни недели, значит нужно выводить фразу "Ежедневно"
                            out.everyday = Math.min.apply(Math, groupWorkingDays) === 1;

                            if (out.holiday) {
                                out.holidayStr = t(localLang, 'restDay', out.dayList.length).slice(2);
                            }

                            // Делаем из массива строку и поднимаем первый символ
                            out.dayList = out.dayList.join(', ');
                            out.dayList = out.dayList.charAt(0).toUpperCase() + out.dayList.slice(1);

                            return out;
                        }

                        // Возвращает массив simple строк на основе массива дней days
                        function makeAdvancedString(days, model) {
                            var out = [];

                            for (var i = days.length - 1; i >= 0; i--) {
                                out.push(makeSimpleString(days[i], model));
                            }

                            return out;
                        }

                        // Заполняем названия дней недели, 1 - понедельник. В заполненных массивах понедельник это 0

                        for (var i = 0; i < 7; i++) {
                            weekKeys[i] = weekKeysShort[i];
                            weekKeysLocal[i] = this.dict.t(localLang, weekKeysShort[i].toLowerCase());
                            weekFullKeysLocal[i] = this.dict.t(localLang, weekKeysFull[i]);
                        }

                        // Вычисляем сегодняшний день недели (ссылку на объект дня в модели)
                        todayKey = weekKeysShort[dayNum(new Date(now).getDay() - firstdayOffset)];
                        today = model[todayKey]; // Объект расписания - текущий день недели
                        setTodayString(today); // Сделать объект для шаблона - строка, которая описывает время работы сегодня

                        // Находим количество разных расписаний и сохраняем их в массив
                        var apiDifferentDays = [],
                            // Массив различающихся дней из модели
                        apiScheduleDaysCount = 0,
                            // Количество описанных дней в расписании модели
                        apiDifferentDaysCount = 0,
                            // Количество разных дней в расписании модели
                        differentWorkingHoursCount = []; // Количество рабочих часов в разных днях

                        Object.keys(model).forEach(function (day) {
                            if (model[day] && model[day].working_hours) {
                                // Проверяем что это день, а не комментарий или что-то ещё
                                apiScheduleDaysCount++;
                                if (!isEqual(model[day], getArrayLast(apiDifferentDays))) {
                                    apiDifferentDays.push(model[day]);
                                }
                            }
                        });

                        apiDifferentDaysCount = apiDifferentDays.length;
                        // Если не все дни описаны в модели, значит есть ещё один тип дней - выходной (отсутствущий в модели)
                        if (apiScheduleDaysCount < 7) {
                            apiDifferentDaysCount++;
                        }

                        // Если разных более 2, то упростить не получится - делаем таблицу
                        if (apiDifferentDaysCount > 2) {
                            schedule.week = makeTable(model);
                        } else {
                            // Иначе, составляем комментарий из двух строк

                            // Случай, когда все одинаковые
                            if (apiDifferentDaysCount === 1) {
                                schedule.week = {
                                    evently: [makeSimpleString(model[weekKeys[0]], model)]
                                };
                            } else {
                                // Остаётся случай, когда есть два типа дней
                                // Определяем день с наибольшим количеством рабочих часов из числа разных дней
                                for (i = 0; i < apiDifferentDaysCount; i++) {
                                    differentWorkingHoursCount[i] = 0;

                                    if (apiDifferentDays[i]) {
                                        var points = pluck(getSortedTimePoints(apiDifferentDays[i]), 'time');

                                        for (var j = 0; j < points.length; j = j + 2) {
                                            var hours = getHours(points[j + 1]) + getMinutes(points[j + 1]) / 60 - (getHours(points[j]) + getMinutes(points[j]) / 60);
                                            differentWorkingHoursCount[i] += hours;
                                        }
                                    } else {
                                        // Выходной
                                        apiDifferentDays[i] = null;
                                    }
                                }

                                var apiSortedDifferentDays = sortBy(apiDifferentDays, function (day, key) {
                                    return differentWorkingHoursCount[key];
                                });

                                schedule.week = {
                                    evently: makeAdvancedString(apiSortedDifferentDays, model)
                                };
                            }
                        }

                        schedule.comment = model.comment;
                        if (schedule.week && schedule.week.evently && schedule.week.evently.length === 1) {
                            schedule.everyday = schedule.week.evently[0].everyday;
                        }
                        return schedule;
                    },

                    forecast: function (schedule, params) {
                        var interval = '',
                            open,
                            today = {},
                            nowText,
                            maxHours = params && params.maxHours || 1;

                        if (!schedule) {
                            return {};
                        }

                        if (schedule.always) {
                            // Круглосуточно ежедневно - более ничего выводить не нужно
                            return {
                                today: {
                                    text: this.dict.t(this.localLang, 'aroundTheClock')
                                },
                                open: true
                            };
                        }

                        // Формируем строку - через сколько произойдёт следующая инверсия открытости
                        if (schedule.will && schedule.will.h < maxHours) {
                            if (schedule.will.h) {
                                interval += this.dict.t(this.localLang, 'nHours', schedule.will.h) + ' ';
                            }

                            if (schedule.will.m) {
                                interval += this.dict.t(this.localLang, 'nMins', schedule.will.m);
                            }
                        }

                        // Данные на сегодня
                        if (schedule.today) {
                            today.text = this.dict.t(this.localLang, 'today');
                            if (schedule.everyday) {
                                today.text = this.dict.t(this.localLang, 'everyday');
                            }
                            today.from = schedule.today.from;
                            today.to = schedule.today.to;
                            today.lunch = schedule.lunch;
                            if (today.lunch) {
                                today.lunchStr = this.dict.t(this.localLang, 'lunch');
                            }
                        } else {
                            today.text = this.dict.t(this.localLang, 'todayIsRestDay');
                        }

                        // Текущий статус и прогноз
                        if (schedule.always) {
                            // Если круглосуточно, ничего кроме "Круглосуточно" выводить не нужно
                            today.text = this.dict.t(this.localLang, 'aroundTheClock');
                            open = true;
                        } else if (schedule.now) {
                            open = schedule.now.open;
                            if (open) {
                                // открыто
                                if (schedule.will && schedule.will.willType === 'lunch') {
                                    // далее - закрытие на обед
                                    if (schedule.will && schedule.will.h < maxHours) {
                                        // менее maxHours до закрытия  на обед
                                        nowText = this.dict.t(this.localLang, '_in') + ' ' + this.dict.t(this.localLang, 'nMins', interval) + this.dict.t(this.localLang, 'isClosingOnDinner');
                                    } else {
                                        // больше maxHours до закрытия  на обед
                                        nowText = this.dict.t(this.localLang, 'isOpen');
                                    }
                                } else {
                                    // далее просто закрытие
                                    if (schedule.will.h < maxHours) {
                                        // менее maxHours до закрытия просто
                                        nowText = this.dict.t(this.localLang, 'closeIn') + this.dict.t(this.localLang, 'nMins', interval);
                                    } else {
                                        // больше maxHours до закрытия просто
                                        nowText = this.dict.t(this.localLang, 'isOpen');
                                    }
                                }
                            } else {
                                // закрыто
                                if (schedule.will && schedule.will.when) {
                                    // откроется не сегодня
                                    nowText = this.dict.t(this.localLang, 'open') + schedule.will.when;
                                } else {
                                    // откроется сегодня
                                    if (schedule.now && schedule.now.lunch) {
                                        // сейчас обед
                                        if (schedule.will.h < maxHours) {
                                            // менее maxHours до открытия с обеда
                                            nowText = this.dict.t(this.localLang, 'Lunch') + this.dict.t(this.localLang, 'openIn') + this.dict.t(this.localLang, 'nMins', interval);
                                        } else {
                                            // больше maxHours до открытия с обеда
                                            nowText = this.dict.t(this.localLang, 'Lunch') + this.dict.t(this.localLang, 'openAt') + schedule.will.till;
                                        }
                                    } else {
                                        // просто закрыто
                                        if (schedule.will && schedule.will.h < maxHours) {
                                            // менее maxHours до открытия просто
                                            nowText = this.dict.t(this.localLang, 'openIn') + this.dict.t(this.localLang, 'nMins', interval);
                                        } else {
                                            // больше maxHours до открытия просто
                                            nowText = this.dict.t(this.localLang, 'openAt') + schedule.will.till;
                                        }
                                    }
                                }
                            }
                        }

                        return {
                            today: today,
                            now: nowText,
                            open: open,
                            week: schedule.week,
                            comment: schedule.comment,
                            everyday: schedule.everyday
                        };
                    }
                };

                /*global
                    FirmCard:false
                */
                // FirmCard.dictionary = {};

                FirmCard.prototype.dict = {

                    t: function (lang, msg, argument) {
                        // (String, Number) -> String
                        var result,
                            msgIsset = false,
                            dictionaryMsg,
                            exp;

                        if (typeof this[lang] === 'undefined') {
                            if (lang === 'ar') {
                                lang = 'en';
                            } else {
                                lang = 'ru';
                            }
                        }
                        dictionaryMsg = this[lang][msg];
                        msgIsset = typeof dictionaryMsg !== 'undefined';
                        if (!msgIsset) {
                            return msg;
                        }
                        result = msgIsset ? dictionaryMsg : msg;

                        if (argument !== undefined) {
                            argument = parseInt(argument, 10);
                            argument = isNaN(argument) ? 0 : argument;
                            exp = this[lang].pluralRules(argument);
                            result = argument + ' ' + dictionaryMsg[exp];
                        }
                        return result;
                    },

                    ru: {
                        pluralRules: function (n) {
                            // (Number)
                            if (n % 10 === 1 && n % 100 !== 11) {
                                // 1, 21
                                return 0;
                            }
                            if (n % 10 >= 2 && n % 10 <= 4 && n % 10 % 1 === 0 && (n % 100 < 12 || n % 100 > 14)) {
                                // 2, 3
                                return 1;
                            }

                            if (n % 10 === 0 || n % 10 >= 5 && n % 10 <= 9 && n % 10 % 1 === 0 || n % 100 >= 11 && n % 100 <= 14 && n % 100 % 1 === 0) {
                                // 13, 17
                                return 2;
                            }
                        },

                        btnBack: 'Назад',
                        btnFindWay: 'Проехать сюда',
                        btnEntrance: 'Найти вход',
                        linkReviews: ['отзыв', 'отзыва', 'отзывов'],
                        linkPhoto: ['фото', 'фото', 'фото'],
                        linkBooklet: 'Буклет',
                        tommorow: 'завтра',
                        afterTommorow: 'послезавтра',
                        afterWeek: 'через неделю',
                        nextSun: 'в воскресенье',
                        nextMon: 'в понедельник',
                        nextTue: 'во вторник',
                        nextWed: 'в среду',
                        nextThu: 'в четверг',
                        nextFri: 'в пятницу',
                        nextSat: 'в субботу',
                        willOpen: 'откроется',
                        willClose: 'закроется',
                        isOpen: 'Открыто',
                        openTill: 'Открыто до ',
                        closeIn: 'Закроется через ',
                        openAt: 'Откроется в ',
                        openIn: 'Откроется через ',
                        open: 'Откроется ',
                        nHours: ['час', 'часа', 'часов'],
                        nMins: ['минуту', 'минуты', 'минут'],
                        lunch: 'обед',
                        Lunch: 'Обед. ',
                        workingDays: 'Рабочие дни',
                        weekdays: 'Будние дни',
                        restDay: ['выходной', 'выходные', 'выходные'],
                        reviewsOnFlamp: 'Отзывы на Флампе',
                        writeReviewOnFlamp: 'Написать отзыв на Флампе',
                        payment: 'оплата',
                        everyday: 'Ежедневно c',
                        worksAroundTheClock: 'Работает круглосуточно',
                        aroundTheClock: 'Круглосуточно',
                        knowMore: 'узнать больше',
                        toClose: 'до закрытия',
                        monday: 'понедельник',
                        tuesday: 'вторник',
                        wednesday: 'среда',
                        thursday: 'четверг',
                        friday: 'пятница',
                        saturday: 'суббота',
                        sunday: 'воскресенье',
                        mon: 'пон',
                        tue: 'втр',
                        wed: 'срд',
                        thu: 'чтв',
                        fri: 'птн',
                        sat: 'сбт',
                        sun: 'вск',
                        toLunch: 'до обеда',
                        today: 'Сегодня',
                        lessThenHour: 'менее часа',
                        youCouldLate: 'вы можете не успеть',
                        workingTime: 'рабочее время',
                        showAllOrgInRubric: 'Показать все организации рубрики',
                        todayIsRestDay: 'Сегодня выходной',
                        internet: 'Оплата через Интернет',
                        noncash: 'Безналичный расчет',
                        goldcrown: 'Золотая Корона',
                        dinersclub: 'Diners Club',
                        mastercard: 'Mastercard',
                        maestrocard: 'MaestroCard',
                        visa: 'Visa',
                        cash: 'Наличный расчет',
                        americanexpress: 'American Express',
                        hour: 'час',
                        less: 'менее',
                        _in: 'Через',
                        isClosingOnDinner: ' закрывается на обед'
                    },

                    it: {
                        pluralRules: function (n) {
                            // (Number)
                            if (n === 1) {
                                // 1
                                return 0;
                            } else {
                                return 1; //0, 2, 3, 4 ..
                            }
                        },

                        btnBack: 'Indietro',
                        btnFindWay: 'Come arrivare ',
                        btnEntrance: 'Trova l\'ingresso',
                        linkReviews: ['recensione', 'recensioni'],
                        linkPhoto: ['fotografia', 'fotografie'],
                        linkBooklet: 'Sull\'azienda',
                        tommorow: 'domani',
                        afterTommorow: 'dopodomani',
                        afterWeek: 'tra una settimana',
                        nextSun: 'la domenica',
                        nextMon: 'il lunedi',
                        nextTue: 'il martedì',
                        nextWed: 'il mercoledì',
                        nextThu: 'il giovedi',
                        nextFri: 'il venerdì',
                        nextSat: 'il sabato',
                        willOpen: 'apre',
                        willClose: 'ciuso',
                        isOpen: 'Aperto',
                        openTill: 'Aperto fino alle ',
                        closeIn: 'Chiude tra ',
                        openAt: 'Apre alle ',
                        openIn: 'Apre tra ',
                        open: 'Apre ',
                        nHours: ['ora', 'ore'],
                        nMins: ['minuto', 'minuti'],
                        lunch: 'pausa pranzo',
                        Lunch: 'Pausa pranzo. ',
                        workingDays: 'Giorni feriali',
                        weekdays: 'Giorni feriali',
                        restDay: ['chiusura', 'chiusura'],
                        reviewsOnFlamp: 'Recensioni su Flamp',
                        writeReviewOnFlamp: 'Scrivi una recensione su Flamp',
                        payment: 'pagamento',
                        everyday: 'Ogni giorno dalole',
                        worksAroundTheClock: 'Operativo 24 ore su 24',
                        aroundTheClock: '24 ore su 24',
                        knowMore: 'ulteriori informazioni',
                        toClose: 'fino alla chiusura',
                        monday: 'lunedi',
                        tuesday: 'martedì',
                        wednesday: 'mercoledì',
                        thursday: 'giovedi',
                        friday: 'venerdì',
                        saturday: 'sabato',
                        sunday: 'domenica',
                        mon: 'lun',
                        tue: 'mar',
                        wed: 'mer',
                        thu: 'gio',
                        fri: 'ven',
                        sat: 'sab',
                        sun: 'dom',
                        toLunch: 'fino alla pausa pranzo',
                        today: 'Oggi',
                        lessThenHour: 'meno di un\'ora',
                        youCouldLate: 'affrettarsi, chiusura imminente',
                        workingTime: 'orario di lavoro',
                        showAllOrgInRubric: 'Visualizza tutte le aziende della categoria',
                        todayIsRestDay: 'oggi chiuso',
                        internet: 'Pagamento on-line',
                        noncash: 'Pagamento non in contanti',
                        goldcrown: 'Zolotaja Korona',
                        dinersclub: 'Diners Club',
                        mastercard: 'MasterCard',
                        maestrocard: 'MaestroCard',
                        visa: 'Visa',
                        cash: 'Pagamento in contanti',
                        americanexpress: 'American Express',
                        hour: 'un\'ora',
                        less: 'meno di',
                        _in: 'Tra',
                        isClosingOnDinner: 'chiude per pausa pranzo'
                    },

                    en: {
                        pluralRules: function (n) {
                            // (Number)
                            if (n === 1) {
                                // 1
                                return 0;
                            } else {
                                return 1; //0, 2, 3, 4 ..
                            }
                        },

                        btnBack: 'Back',
                        btnFindWay: 'Get here',
                        btnEntrance: 'Find entrance',
                        linkReviews: ['review', 'reviews'],
                        linkPhoto: ['photo', 'photos'],
                        linkBooklet: 'About company',
                        tommorow: 'tomorrow',
                        afterTommorow: 'the day after tomorrow',
                        afterWeek: 'in a week',
                        nextSun: 'on Sunday',
                        nextMon: 'on Monday',
                        nextTue: 'on Tuesday',
                        nextWed: 'on Wednesday',
                        nextThu: 'on Thursday',
                        nextFri: 'on Friday',
                        nextSat: 'on Saturday',
                        willOpen: 'opens ',
                        willClose: 'closes',
                        isOpen: 'Open',
                        openTill: 'Open till ',
                        closeIn: 'Closes in ',
                        openAt: 'Opens at ',
                        openIn: 'Opens in ',
                        open: 'Opens ',
                        nHours: ['hour', 'hours'],
                        nMins: ['minute', 'minutes'],
                        lunch: 'lunch break',
                        Lunch: 'Lunch break. ',
                        workingDays: 'Working days',
                        weekdays: 'Weekdays',
                        restDay: ['day off', 'days off'],
                        reviewsOnFlamp: 'Reviews on Flamp',
                        writeReviewOnFlamp: 'Write a review on Flamp',
                        payment: 'payment',
                        everyday: 'Daily from',
                        worksAroundTheClock: 'Open 24 hours',
                        aroundTheClock: '24h',
                        knowMore: 'see also',
                        toClose: 'until closing',
                        monday: 'Monday',
                        tuesday: 'Tuesday',
                        wednesday: 'Wednesday',
                        thursday: 'Thursday',
                        friday: 'Friday',
                        saturday: 'Saturday',
                        sunday: 'Sunday',
                        mon: 'Mon',
                        tue: 'Tue',
                        wed: 'Wed',
                        thu: 'Thu',
                        fri: 'Fri',
                        sat: 'Sat',
                        sun: 'Sun',
                        toLunch: 'until lunch',
                        today: 'Today',
                        lessThenHour: 'less then one hour',
                        youCouldLate: 'you might be late',
                        workingTime: 'working hours',
                        showAllOrgInRubric: 'Show all organizations in the category',
                        todayIsRestDay: 'closed today',
                        internet: 'Online',
                        noncash: ' No-cash',
                        goldcrown: 'Golden Crown',
                        dinersclub: 'Diners Club',
                        mastercard: 'Mastercard',
                        maestrocard: 'MaestroCard',
                        visa: 'Visa',
                        cash: 'Cash',
                        americanexpress: 'American Express',
                        hour: 'hour',
                        less: 'less',
                        _in: 'In',
                        isClosingOnDinner: 'will be closing for lunch'
                    },

                    cs: {
                        pluralRules: function (n) {
                            // (Number)
                            return n === 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2;
                        },

                        btnBack: 'Zpět',
                        btnFindWay: 'Jet sem',
                        btnEntrance: 'Hledat vstup',
                        linkReviews: ['recenze', 'recenze', 'recenzí'],
                        linkPhoto: ['fotografie', 'fotografie', 'fotografií'],
                        linkBooklet: 'Leták',
                        tommorow: 'zítra',
                        afterTommorow: 'pozítří',
                        afterWeek: 'za týden',
                        nextSun: 'v neděli',
                        nextMon: 'v pondělí',
                        nextTue: 'v úterý',
                        nextWed: 've středu',
                        nextThu: 've čtvrtek',
                        nextFri: 'v pátek',
                        nextSat: 'v sobotu',
                        willOpen: 'otevře se',
                        willClose: 'zavře se',
                        isOpen: 'Otevřeno',
                        openTill: 'Otevřeno do ',
                        closeIn: 'Zavře se za ',
                        openAt: 'Otevře se v ',
                        openIn: 'Otevře se za ',
                        open: 'Otevře se ',
                        nHours: ['hodinu', 'hodiny', 'hodin'],
                        nMins: ['minutu', 'minuty', 'minut'],
                        lunch: 'polední přestávka',
                        Lunch: 'Polední přestávka. ',
                        workingDays: 'Všední dny',
                        weekdays: 'Všední dny',
                        restDay: ['zavřeno', 'zavřeno'],
                        reviewsOnFlamp: 'Recenze na Flampu',
                        writeReviewOnFlamp: 'Napsat recenzi na Flampu',
                        payment: 'platba',
                        everyday: 'Denně od ',
                        worksAroundTheClock: 'Pracuje nonstop',
                        aroundTheClock: 'Nonstop',
                        knowMore: 'dozvědět se více',
                        toClose: 'do uzavření',
                        monday: 'pondělí',
                        tuesday: 'úterý',
                        wednesday: 'středa',
                        thursday: 'čtvrtek',
                        friday: 'pátek',
                        saturday: 'sobota',
                        sunday: 'neděle',
                        mon: 'po',
                        tue: 'út',
                        wed: 'st',
                        thu: 'čt',
                        fri: 'pá',
                        sat: 'so',
                        sun: 'ne',
                        toLunch: 'do polední přestávky',
                        today: 'Dnes',
                        lessThenHour: 'méně než hodinu',
                        youCouldLate: 'nemusíte to stihnout',
                        workingTime: 'pracovní doba',
                        showAllOrgInRubric: 'Zobrazit všechny organizace v rubrice',
                        todayIsRestDay: 'Dnes je zavřeno',
                        internet: 'Platba prostřednictvím Internetu',
                        noncash: 'Bezhotovostní platba',
                        goldcrown: 'Zolotaja Korona',
                        dinersclub: 'Diners Club',
                        mastercard: 'Mastercard',
                        maestrocard: 'MaestroCard',
                        visa: 'Visa',
                        cash: 'Platba hotově',
                        americanexpress: 'American Express',
                        hour: 'hodinu',
                        less: 'méně',
                        _in: 'Za',
                        isClosingOnDinner: 'začíná polední přestávka'
                    },

                    es: {
                        pluralRules: function (n) {
                            // (Number)
                            return n === 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2;
                        },

                        btnBack: 'Atrás',
                        btnFindWay: 'Ir para allá',
                        btnEntrance: 'Buscar acceso',
                        linkReviews: ['comentario', 'comentarios', 'comentarios'],
                        linkPhoto: ['foto', 'fotos', 'fotos'],
                        linkBooklet: 'Folleto',
                        tommorow: 'mañana',
                        afterTommorow: 'pasado mañana',
                        afterWeek: 'en una semana más',
                        nextSun: 'el domingo',
                        nextMon: 'el lunes',
                        nextTue: 'el martes',
                        nextWed: 'el miércoles',
                        nextThu: 'el jueves',
                        nextFri: 'el viernes',
                        nextSat: 'el sábado',
                        willOpen: 'se abrirá',
                        willClose: 'se cerrará',
                        isOpen: 'Abierto',
                        openTill: 'Abierto hasta ',
                        closeIn: 'Se cerrará dentro de ',
                        openAt: 'Se abrirá el ',
                        openIn: 'Se abrirá dentro de ',
                        open: 'Se abrirá ',
                        nHours: ['hora', 'horas', 'horas'],
                        nMins: ['minuto', 'minutos', 'minutos'],
                        lunch: 'hora de colación',
                        Lunch: 'Hora de colación. ',
                        workingDays: 'Días laborables',
                        weekdays: 'Días laborables',
                        restDay: ['cerrado', 'cerrado'],
                        reviewsOnFlamp: 'Comentarios en Flamp',
                        writeReviewOnFlamp: 'Escribir un comentario en Flamp',
                        payment: 'pago',
                        everyday: 'Cada día desde',
                        worksAroundTheClock: 'Abierto las 24 horas',
                        aroundTheClock: '24 horas',
                        knowMore: 'para saber más',
                        toClose: 'hasta el cierre',
                        monday: 'lunes',
                        tuesday: 'martes',
                        wednesday: 'miércoles',
                        thursday: 'jueves',
                        friday: 'viernes',
                        saturday: 'sábado',
                        sunday: 'domingo',
                        mon: 'lun',
                        tue: 'mar',
                        wed: 'mié',
                        thu: 'jue',
                        fri: 'vie',
                        sat: 'sáb',
                        sun: 'dom',
                        toLunch: 'antes de la hora de colación',
                        today: 'Hoy',
                        lessThenHour: 'menos de una hora',
                        youCouldLate: 'puede ser que no alcanzas a llegar',
                        workingTime: 'horario de trabajo',
                        showAllOrgInRubric: 'Mostrar todas las empresas de la categoría',
                        todayIsRestDay: 'Hoy cerrado',
                        internet: 'Pago por Internet',
                        noncash: 'Pago sin efectivo',
                        goldcrown: 'Zolotaya Korona',
                        dinersclub: 'Diners Club',
                        mastercard: 'Mastercard',
                        maestrocard: 'MaestroCard',
                        visa: 'Visa',
                        cash: 'Pago en efectivo',
                        americanexpress: 'American Express',
                        hour: 'hora',
                        less: 'menos de',
                        _in: 'Dentro de',
                        isClosingOnDinner: 'se cierra por hora de colación'
                    }
                };

                DG.Traffic = DG.TileLayer.extend({
                    options: {
                        period: 0,
                        disableLabel: false
                    },

                    statics: {
                        Dictionary: {}
                    },

                    initialize: function (options) {
                        this._tileUrl = DG.config.protocol + (DG.Browser.retina ? DG.config.retinaTrafficTileServer : DG.config.trafficTileServer);
                        this._metaUrl = DG.config.protocol + (DG.Browser.retina ? DG.config.retinaTrafficMetaServer : DG.config.trafficMetaServer);
                        this._timeUrl = DG.config.protocol + DG.config.trafficTimestampServer;
                        this._updateInterval = DG.config.trafficLayerUpdateInterval;

                        this._layersOptions = {
                            errorTileUrl: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
                            subdomains: '012345679',
                            maxNativeZoom: 18,
                            detectRetina: DG.config.detectRetina,
                            minZoom: DG.config.trafficLayerMinZoom
                        };

                        options = DG.setOptions(this, DG.extend(options || {}, this._layersOptions));
                        options.timestampString = options.period ? '' : '?' + new Date().getTime();
                        this._metaLayer = DG.Meta.layer(null, {
                            detectRetina: options.detectRetina,
                            maxNativeZoom: options.maxNativeZoom,
                            dataFilter: DG.bind(this._processData, this),
                            minZoom: options.minZoom
                        });
                        this._isDg = true;
                        this._onTimer = DG.bind(this._onTimer, this);
                        DG.TileLayer.prototype.initialize.call(this, this._tileUrl, options);
                    },

                    // #setTime(day [0-6], time[0-23]) ????

                    onAdd: function (map) {
                        this._updateLayerProject();

                        map.addLayer(this._metaLayer).on('projectchange projectleave', this._onMapProjectChange, this);

                        if (!this.options.disableLabel) {
                            this._metaLayer.on(this._layerEventsListeners, this);
                            this._labelHelper = DG.label();
                            this._map.on('langchange', this._updateLang, this);
                        }

                        if (this._updateInterval) {
                            this._updateTimer = setInterval(this._onTimer, this._updateInterval);
                        }

                        DG.TileLayer.prototype.onAdd.call(this, map);
                    },

                    onRemove: function (map) {
                        clearInterval(this._updateTimer);

                        map.removeLayer(this._metaLayer).off('projectchange projectleave', this._onMapProjectChange, this);

                        if (!this.options.disableLabel) {
                            this._metaLayer.off(this._layerEventsListeners, this);
                            this._map.removeLayer(this._labelHelper);
                            this._labelHelper = null;
                            this._map.off('langchange', this._updateLang, this);
                        }

                        DG.TileLayer.prototype.onRemove.call(this, map);
                    },

                    update: function () {
                        var self = this;
                        this._getTimestampString().then(function (response) {
                            self.options.timestampString = '?' + response;
                        }, function () {
                            self.options.timestampString = '?' + new Date().getTime();
                        }).then(function () {
                            self.fire('update', { timestamp: self.options.timestampString });
                            self._layerEventsListeners.mouseout.call(self);
                            self._metaLayer.getOrigin().setURL(self._prepareMetaURL(), self);
                            self.redraw();
                        });
                    },

                    getSubdomain: function () {
                        return this._layersOptions.subdomains[Math.floor(Math.random() * this._layersOptions.subdomains.length)];
                    },

                    _updateLang: function () {
                        var lang = this._map.getLang();
                        if (lang === 'ar') {
                            this._labelHelper.options.textDirection = 'rtl';
                        } else {
                            this._labelHelper.options.textDirection = 'auto';
                        }
                    },

                    _getTimestampString: function () {
                        return DG.ajax(DG.Util.template(this._timeUrl, DG.extend({
                            s: this.getSubdomain(),
                            projectCode: this._map.projectDetector.getProject().code
                        }, this.options || {})), { type: 'get' });
                    },

                    _onTimer: function () {
                        if (this.options.period === 0) {
                            this.update();
                        }
                    },

                    _processData: function (trafficData, coord) {
                        var tileOriginPoint = coord.scaleBy(this.getTileSize());
                        var polygonLngLatToPoints = DG.bind(this._polygonLngLatToPoints, this, tileOriginPoint);
                        var hints = {};

                        if (!DG.Util.isArray(trafficData)) {
                            // TODO remove
                            return [];
                        }

                        trafficData[1].forEach(function (item) {
                            this[item.graph_id] = item.speed_text;
                        }, hints);

                        return trafficData[0].map(function (item) {
                            return {
                                id: item.graph_id,
                                speed: hints[item.graph_id],
                                geometry: DG.Wkt.toGeoJSON(item.geometry[0].object[0])
                            };
                        }).filter(function (item) {
                            return item.geometry.type == 'Polygon' || item.geometry.type == 'MultiPolygon';
                        }).map(function (item) {
                            var geoJson = item.geometry;

                            if (geoJson.type == 'Polygon') {
                                geoJson.coordinates = polygonLngLatToPoints(geoJson.coordinates);
                            } else if (geoJson.type == 'MultiPolygon') {
                                geoJson.coordinates = geoJson.coordinates.map(polygonLngLatToPoints);
                            }

                            return item;
                        });
                    },

                    _polygonLngLatToPoints: function (originPoint, polygon) {
                        var map = this._map;

                        return polygon.map(function (contour) {
                            return contour.map(function (lngLat) {
                                return map.project([lngLat[1], lngLat[0]]).round().subtract(originPoint);
                            });
                        });
                    },

                    _prepareMetaURL: function () {
                        return DG.Util.template(this._metaUrl, DG.extend({
                            x: '{x}',
                            y: '{y}',
                            z: '{z}',
                            s: '{s}'
                        }, this.options));
                    },

                    _updateLayerProject: function () {
                        var project = this._map.projectDetector.getProject();
                        DG.setOptions(this, project && project.traffic ? {
                            projectCode: project.code,
                            bounds: project.latLngBounds,
                            minZoom: Math.max(project.minZoom, this._layersOptions.minZoom),
                            maxZoom: project.maxZoom
                        } : {
                            maxZoom: 0,
                            minZoom: 0
                        });
                        this._metaLayer.getOrigin().setURL(this._prepareMetaURL());
                    },

                    _onMapProjectChange: function () {
                        this._updateLayerProject();
                        this.redraw();
                    },

                    _layerEventsListeners: {
                        mouseover: function (e) {
                            // (Object)
                            this._setCursor('pointer');
                            if (this._labelHelper && e.meta.speed) {
                                this._labelHelper.setPosition(e.latlng).setContent(e.meta.speed + ' ' + this.t('speed_unit_km_h')).addTo(this._map);
                            }
                        },
                        mouseout: function () {
                            this._setCursor('');
                            if (this._labelHelper) {
                                this._map.removeLayer(this._labelHelper);
                            }
                        },
                        mousemove: function (e) {
                            if (this._labelHelper) {
                                this._labelHelper.setPosition(e.latlng);
                            }
                        }
                    },

                    _setCursor: function (cursor) {
                        // (String)
                        this._map.getContainer().style.cursor = cursor;
                    }

                });

                DG.Traffic.include(DG.Locale);

                DG.traffic = function (options) {
                    // (Object)
                    return new DG.Traffic(options);
                };

                DG.Traffic.Dictionary.ru = {
                    speed_unit_km_h: 'км/ч'
                };

                DG.Traffic.Dictionary.it = {
                    speed_unit_km_h: 'km/h'
                };

                DG.Traffic.Dictionary.cs = {
                    speed_unit_km_h: 'km/h'
                };

                DG.Traffic.Dictionary.es = {
                    speed_unit_km_h: 'km/h'
                };

                DG.Traffic.Dictionary.en = {
                    speed_unit_km_h: 'km/h'
                };

                DG.Traffic.Dictionary.ar = {
                    speed_unit_km_h: 'كم/ساعة'
                };

                DG.Control.Traffic = DG.RoundControl.extend({
                    options: {
                        position: 'topright',
                        iconClass: 'traffic'
                    },

                    statics: {
                        Dictionary: {}
                    },

                    initialize: function (options) {
                        this._trafficClass = 'dg-traffic-control';
                        this._controlHideClass = 'dg-control-round_is-hidden_true';

                        DG.setOptions(this, options);
                        DG.extend(this, {
                            _active: false,
                            _trafficLayer: null
                        }).on(this._controlEvents, this);
                    },

                    _controlEvents: {
                        add: function () {
                            this._trafficLayer = DG.traffic();
                            this._map.on('zoomend projectchange projectleave', this._updateControlVisibility, this);
                        },
                        click: function () {
                            this._active = !this._active;

                            if (this._active) {
                                this.setState('active');
                                this._showTraffic();
                            } else {
                                this.setState('');
                                this._hideTraffic();
                            }
                        },
                        remove: function () {
                            this.off(this._controlEvents, this);
                            this._map.off('zoomend projectchange projectleave', this._updateControlVisibility, this);
                            if (this._active) {
                                this._map.removeLayer(this._trafficLayer);
                                this._active = false;
                            }
                            this._trafficLayer = null;
                        }
                    },

                    _showTraffic: function () {
                        // ()
                        this._updateTrafficScore();
                        this._map.addLayer(this._trafficLayer);
                    },

                    _hideTraffic: function () {
                        // ()
                        this._handleDom('remove');
                        this._map.removeLayer(this._trafficLayer);
                    },

                    _handleDom: function (method, score) {
                        var a = this._link;

                        a.innerHTML = score || '';
                        DG.DomUtil[method + 'Class'](a, this._trafficClass);
                        DG.DomUtil[method + 'Class'](a, this._trafficClass + '_color_' + this._scoreRate);
                    },

                    _getTrafficColor: function (score) {
                        // (Number) -> String
                        var result = 'green';

                        if (score > 7) {
                            result = 'red';
                        } else if (score > 4) {
                            result = 'yellow';
                        }

                        return result;
                    },

                    _updateControlVisibility: function () {
                        var project = this._map.projectDetector.getProject(),
                            projectHasTraffic = project && project.traffic,
                            method = this._map.getZoom() < DG.config.trafficLayerMinZoom || !projectHasTraffic ? 'addClass' : 'removeClass';

                        DG.DomUtil[method](this._container, this._controlHideClass);
                        if (this._active && projectHasTraffic) {
                            this._updateTrafficScore();
                        }
                    },

                    _updateTrafficScore: function () {
                        var self = this;

                        this._getTrafficScore().then(function (score) {
                            score = parseInt(score, 10); // sometimes webapi returns something like '5,+'

                            self._scoreRate = self._getTrafficColor(score);
                            self._handleDom('add', score);
                        });
                    },

                    _getTrafficScore: function () {
                        // () -> Promise
                        var url = DG.Util.template(DG.config.protocol + DG.config.trafficScoreServer, {
                            s: this._trafficLayer.getSubdomain(),
                            projectCode: this._map.projectDetector.getProject().code
                        });

                        return DG.ajax(url, { type: 'get' });
                    },

                    _renderTranslation: function () {
                        // ()
                        this._link.title = this.t('button_title');
                    }
                });

                DG.control.traffic = function (options) {
                    return new DG.Control.Traffic(options);
                };

                DG.Map.mergeOptions({
                    trafficControl: false
                });

                DG.Map.addInitHook(function () {
                    if (this.options.trafficControl) {
                        this.trafficControl = DG.control.traffic(this.options.trafficControl);
                        this.addControl(this.trafficControl);
                    }
                });

                DG.Control.Traffic.Dictionary.ru = {
                    button_title: 'Пробки'
                };

                DG.Control.Traffic.Dictionary.it = {
                    button_title: 'Colonna'
                };

                DG.Control.Traffic.Dictionary.cs = {
                    button_title: 'Zácpy'
                };

                DG.Control.Traffic.Dictionary.es = {
                    button_title: 'Taco'
                };

                DG.Control.Traffic.Dictionary.en = {
                    button_title: 'Traffic'
                };

                DG.Control.Traffic.Dictionary.ar = {
                    button_title: 'حركة السير'
                };

                DG.Ruler = DG.Layer.extend({

                    options: {
                        editable: true
                    },

                    includes: [DG.Locale],

                    statics: {
                        Dictionary: {}
                    },

                    initialize: function (latlngs, options) {
                        // (Array, Object)
                        DG.Util.setOptions(this, options);

                        this._layers = {
                            back: null,
                            middle: null,
                            front: null,
                            mouse: null
                        };
                        this._points = [];

                        this._layersContainer = DG.featureGroup();
                        Object.keys(this._layers).forEach(function (name) {
                            this._layersContainer.addLayer(this._layers[name] = DG.featureGroup());
                        }, this);

                        this._reset();

                        if (DG.Browser.mobile) {
                            delete this._lineMouseEvents.mouseover;
                            delete this._lineMouseEvents.mouseout;
                            delete this._lineMouseEvents.mousemove;
                        } else {
                            delete this._lineMouseEvents.click;
                        }

                        if (latlngs && latlngs.length) {
                            this.setLatLngs(latlngs);
                        }
                    },

                    onAdd: function (map) {
                        // (Map)
                        this._map = map.on('langchange', this._updateDistance, this);

                        //  Pane for ruler Markers
                        if (!this._map.getPane('rulerMarkerPane')) {
                            this._map.createPane('rulerMarkerPane');
                        }

                        //  Main ruler pane (svg objects and runner)
                        if (!this._map.getPane('rulerPane')) {
                            this._map.createPane('rulerPane');
                        }

                        this._layersContainer.addTo(this._map);

                        if (this._points.length) {
                            this._layers.mouse.fire('layeradd');
                            this._updateDistance();
                        }

                        this._layers.mouse.on(this._lineMouseEvents, this);
                    },

                    onRemove: function (map) {
                        // (Map)
                        map.off('langchange', this._updateDistance, this).removeLayer(this._layersContainer);

                        this._layers.mouse.off(this._lineMouseEvents, this);
                        this._reset();
                    },

                    getTotalDistance: function () {
                        // () -> Number
                        return this._calcDistance();
                    },

                    spliceLatLngs: function (index) {
                        // (Number, Number, args ...) -> Array
                        var oldLength = this._points.length,
                            mutationStart = index >= 0 ? Math.min(index, oldLength) : oldLength - index,
                            removed = Array.prototype.splice.apply(this._points, arguments).map(function (point) {
                            this._layers.mouse.removeLayer(point);
                            return point.off().getLatLng();
                        }, this),
                            length = this._points.length;

                        if (length) {
                            for (var i = mutationStart; i < length; i++) {
                                if (!(this._points[i] instanceof DG.Ruler.LayeredMarker)) {
                                    this._points[i] = this._createPoint(this._points[i], this.options.iconStyles.large).on(this._pointEvents, this).once('add', this._addCloseHandler, this).addTo(this._layers.mouse, this._layers);
                                }
                                if (i && !this._points[i - 1]._legs) {
                                    this._addLegs(this._points[i - 1]);
                                }
                                this._points[i].setPointStyle(this.options.iconStyles[i && i < length - 1 ? 'small' : 'large']);
                                this._points[i]._pos = i;
                            }
                            this._removeLegs(this._points[length - 1]);
                            if (oldLength > 0 && oldLength < length) {
                                this._points[oldLength - 1].collapse();
                            }
                            if (this._points[mutationStart]) {
                                this._updateLegs(this._points[mutationStart]);
                            }
                            if (mutationStart > 1) {
                                this._points[mutationStart - 1].setPointStyle(this.options.iconStyles.small);
                            }
                            this._updateDistance();
                            this._normalizeRulerPoints();
                        }
                        if (DG.Browser.touch && this._lineMarkerHelper) {
                            this._lineMarkerHelper.collapse();
                        }
                        this._fireChangeEvent();
                        return removed;
                    },

                    addLatLng: function (latlng) {
                        // (LatLng) -> Ruler
                        var lastPoint = this._points[this._points.length - 1] || null;
                        latlng = DG.latLng(latlng);

                        if (lastPoint) {
                            latlng = this._normalizeLatLng(latlng, lastPoint.getLatLng());
                        }

                        this.spliceLatLngs(this._points.length, 0, latlng);
                        return this;
                    },

                    getLatLngs: function () {
                        // () -> Array
                        return this._points.map(function (point) {
                            return point.getLatLng();
                        });
                    },

                    setLatLngs: function (latlngs) {
                        // (Array) -> Ruler
                        var args = latlngs.slice();
                        args.unshift(0, this._points.length);
                        this.spliceLatLngs.apply(this, args);
                        return this;
                    },

                    _reset: function () {
                        // ()
                        DG.extend(this, {
                            _lineMarkerHelper: null,
                            _morphingNow: false
                        });
                    },

                    _lineMouseEvents: {
                        click: function (event) {
                            var target = event.layer;
                            if (target instanceof DG.Marker && target._pos !== this._points.length - 1) {
                                if (this._lineMarkerHelper) {
                                    this._lineMarkerHelper.collapse();
                                }
                                target.setText(this._getFormatedDistance(target));
                                this._lineMarkerHelper = target;
                            } else if (target instanceof DG.Path && this.options.editable) {
                                var latlng = event.latlng,
                                    insertPos = target._point._pos + 1;
                                this.spliceLatLngs(insertPos, 0, latlng);
                            }
                        },
                        mouseover: function (event) {
                            // (MouseEvent)
                            var target = event.layer;

                            target._hovered = true;
                            if (this._morphingNow) {
                                return;
                            }
                            if (target instanceof DG.Marker && target._pos !== this._points.length - 1) {
                                target.setText(this._getFormatedDistance(target));
                            } else if (target instanceof DG.Path && !this._lineMarkerHelper) {
                                var point = target._point;

                                this._lineMarkerHelper = this._addRunningLabel(this._nearestPoint(point._legs.middle, event.latlng), point);
                            }
                        },
                        mouseout: function (event) {
                            // (MouseEvent)
                            var target = event.layer,
                                originalEv = event.originalEvent;

                            target._hovered = false;
                            if (this._morphingNow || target._pos === this._points.length - 1) {
                                return;
                            }
                            if (target instanceof DG.Marker) {
                                // collapse only when we move out from label container (if browser support relatedTarget)
                                if (!originalEv.relatedTarget || originalEv.relatedTarget !== target.querySelector('container') && originalEv.relatedTarget.parentNode !== target.querySelector('container')) {
                                    target.collapse();
                                }
                            } else {
                                this._removeRunningLabel();
                            }
                        },
                        mousemove: function (event) {
                            // (MouseEvent)
                            if (this._morphingNow || !this._lineMarkerHelper) {
                                return;
                            }

                            var point = event.layer._point,
                                latlng = this._nearestPoint(point._legs.middle, event.latlng);

                            this._lineMarkerHelper.setLatLng(latlng).setText(this._getFormatedDistance(point, point.getLatLng().distanceTo(latlng)));
                        },
                        layeradd: function () {
                            // ()
                            Object.keys(this._layers).forEach(function (name) {
                                this._layers[name].bringToFront();
                            }, this);
                        }
                    },

                    _fireChangeEvent: function () {
                        this.fire('changed', { latlngs: this.getLatLngs() });
                    },

                    _addRunningLabel: function (latlng, previousPoint) {
                        // (LatLng, Ruler.LayeredMarker)
                        var point = this._createPoint(latlng).addTo(this._layers.mouse, this._layers);
                        var pane = this._map.getPane('rulerPane');
                        pane.insertBefore(point._icon, pane.lastElementChild);
                        return point.setText(this._getFormatedDistance(previousPoint, previousPoint.getLatLng().distanceTo(latlng)));
                    },

                    _removeRunningLabel: function () {
                        // ()
                        if (this._lineMarkerHelper) {
                            this._layers.mouse.removeLayer(this._lineMarkerHelper);
                            this._lineMarkerHelper = null;
                        }
                    },

                    _insertPointInLine: function (event) {
                        // (MouseEvent)
                        var latlng = this._lineMarkerHelper.getLatLng(),
                            insertPos = event.target._point._pos + 1,
                            point;

                        if (L.Browser.ie) {
                            var path = event.originalEvent.target || event.originalEvent.srcElement,
                                parent = path.parentNode;
                            parent.appendChild(path); // IE click event leaking problem solution: we reappend mousedown event target element
                        }

                        L.DomEvent.stopPropagation(event.originalEvent);

                        this.spliceLatLngs(insertPos, 0, latlng);
                        point = this._points[insertPos];
                        point.setText(this._getFormatedDistance(point));

                        setTimeout(function () {
                            if (document.createEvent) {
                                var e = document.createEvent('MouseEvents');
                                e.initMouseEvent('mouseup', false, false, document.defaultView, 1, 0, 0, 0, 0, false, false, false, false, 1, point._icon);
                                document.dispatchEvent(e);

                                e = document.createEvent('MouseEvents');
                                e.initMouseEvent('mousedown', false, false, document.defaultView, 1, 0, 0, 0, 0, false, false, false, false, 1, point._icon);
                                point._icon.dispatchEvent(e);
                            } else {
                                point._icon.fireEvent('onMouseUp', DG.extend(document.createEventObject(), {
                                    button: 1,
                                    bubbles: false,
                                    cancelable: false
                                }));
                                point._icon.fireEvent('onMouseDown', DG.extend(document.createEventObject(), {
                                    button: 1,
                                    bubbles: false,
                                    cancelable: false
                                }));
                            }
                        }, 0);

                        this._removeRunningLabel();

                        this._updateLegs(point);
                    },

                    // Find the point on given polyline which is closest to given latlng
                    _nearestPoint: function (polyline, latlng) {
                        // (Polyline, LatLng) -> LatLng
                        var self = this;

                        // Convert everything to pixel coordinates
                        var point = this._project(latlng);
                        var linePoints = polyline.getLatLngs().map(function (latlng) {
                            return self._project(latlng);
                        });

                        // First look for closest polyline segment
                        var minDistance;
                        var closestSegmentIndex;
                        for (var i = 0; i < linePoints.length - 1; i++) {
                            var distance = DG.LineUtil.pointToSegmentDistance(point, linePoints[i], linePoints[i + 1]);

                            if (minDistance === undefined || distance < minDistance) {
                                minDistance = distance;
                                closestSegmentIndex = i;
                            }
                        }

                        // Then look for closest point on that segment
                        var closestPoint = DG.LineUtil.closestPointOnSegment(point, linePoints[closestSegmentIndex], linePoints[closestSegmentIndex + 1]);

                        // Convert back to LatLng
                        return this._unproject(closestPoint);
                    },

                    _addCloseHandler: function (event) {
                        // (Event)
                        event.target.on('click', this._deletePoint, this).querySelector('remove-link').style.display = 'inline-block';
                    },

                    _createPoint: function (latlng, style) {
                        // (LatLng, Object) -> Ruler.LayeredMarker
                        var pointStyle = style ? style : this.options.iconStyles.large,
                            layers = {};
                        Object.keys(pointStyle).forEach(function (layer) {
                            layers[layer] = DG.circleMarker(latlng, pointStyle[layer]);
                        });

                        return DG.Ruler.layeredMarker(latlng, {
                            layers: layers,
                            draggable: this.options.editable,
                            textDirection: this._map.getLang() !== 'ar' ? 'auto' : 'rtl'
                        });
                    },

                    // Moves curr LatLng to correct world if necessary so that ruler section
                    // between curr and base can be plotted correctly. Returns a new LatLng
                    // object.
                    _normalizeLatLng: function (curr, base) {
                        // (LatLng, LatLng) -> LatLng
                        var diff = curr.lng < base.lng ? 360 : -360;

                        var newLng = curr.lng;
                        while (Math.abs(newLng - base.lng) > 180) {
                            newLng += diff;
                        }

                        return DG.latLng(curr.lat, newLng);
                    },

                    // Rearranges ruler points between worlds based on point param so that all
                    // ruler sections can be plotted correctly.
                    _normalizeRulerPoints: function (point) {
                        // (Ruler.LayeredMarker)
                        point = point || this._points[0];

                        var self = this;
                        var position = point._pos;
                        var changedPoints = [];
                        var i, currPoint, prevPoint, latlng, normalized;

                        // Check points to the right
                        for (i = position + 1; i < this._points.length; i++) {
                            currPoint = this._points[i];
                            prevPoint = this._points[i - 1];

                            latlng = currPoint.getLatLng();
                            normalized = this._normalizeLatLng(latlng, prevPoint.getLatLng());

                            if (!normalized.equals(latlng)) {
                                currPoint.setLatLng(normalized);
                                changedPoints.push(i);
                            }
                        }

                        // Check points to the left
                        for (i = position - 1; i >= 0; i--) {
                            currPoint = this._points[i];
                            prevPoint = this._points[i + 1];

                            latlng = currPoint.getLatLng();
                            normalized = this._normalizeLatLng(latlng, prevPoint.getLatLng());

                            if (!normalized.equals(latlng)) {
                                currPoint.setLatLng(normalized);
                                changedPoints.push(i);
                            }
                        }

                        // Update legs of all points that changed position
                        changedPoints.sort().reduce(function (previous, current) {
                            var skipPrevious = previous && previous === current - 1;

                            self._updateLegs(self._points[current], skipPrevious);

                            return current;
                        }, null);
                    },

                    _pointEvents: {
                        drag: function (event) {
                            // (Event)
                            var point = event.target;

                            this._normalizeRulerPoints(point);

                            if (!DG.Browser.touch && point !== this._points[this._points.length - 1]) {
                                point.setText(this._getFormatedDistance(point));
                            }

                            this._updateLegs(point);
                            this._updateDistance();
                        },
                        dragend: function (event) {
                            // (Event)
                            var point = event.target;
                            this._morphingNow = false;
                            if (!point._hovered && point !== this._points[this._points.length - 1]) {
                                point.collapse();
                            }
                            this._fireChangeEvent();
                        },
                        dragstart: function () {
                            // ()
                            if (DG.Browser.touch && this._lineMarkerHelper) {
                                this._lineMarkerHelper.collapse();
                            }
                            this._morphingNow = true;
                        }
                    },

                    _deletePoint: function (event) {
                        // (MouseEvent)
                        var originalEvent = event.originalEvent,
                            target = originalEvent.target || originalEvent.srcElement;

                        if (target.className !== 'dg-ruler__label-remove-link' && target.className !== 'dg-ruler__remove-link-overlay') {
                            return;
                        }
                        DG.DomEvent.stop(event.originalEvent);
                        this.spliceLatLngs(event.target._pos, 1);
                    },

                    _degToRad: function (deg) {
                        return Math.PI / 180 * deg;
                    },

                    _radToDeg: function (rad) {
                        return 180 / Math.PI * rad;
                    },

                    // Map-independent project method
                    _project: function (latlng) {
                        if (this._map) {
                            return this._map.project(latlng);
                        }

                        return DG.CRS.EPSG3857.latLngToPoint(latlng, 1);
                    },

                    // Map-independent unproject method
                    _unproject: function (point) {
                        if (this._map) {
                            return this._map.unproject(point);
                        }

                        return DG.CRS.EPSG3857.pointToLatLng(point, 1);
                    },

                    // Calculates the size of angle point1-point-point2
                    _calcAngle: function (point, point1, point2) {
                        // (LatLng, LatLng, LatLng) -> Number
                        point1 = this._normalizeLatLng(point1, point);
                        point2 = this._normalizeLatLng(point2, point);

                        point = this._project(point);
                        point1 = this._project(point1);
                        point2 = this._project(point2);

                        var x1 = point1.x - point.x;
                        var x2 = point2.x - point.x;
                        var y1 = point1.y - point.y;
                        var y2 = point2.y - point.y;

                        var dotProduct = x1 * x2 + y1 * y2;
                        var mag1 = Math.sqrt(x1 * x1 + y1 * y1);
                        var mag2 = Math.sqrt(x2 * x2 + y2 * y2);

                        return Math.acos(dotProduct / (mag1 * mag2));
                    },

                    // Calculates the midpoint on the great circle between two LatLngs
                    _calcMidPoint: function (latlng1, latlng2) {
                        // (LatLng, LatLng) -> LatLng
                        var lon1 = this._degToRad(latlng1.lng);
                        var lat1 = this._degToRad(latlng1.lat);

                        var lon2 = this._degToRad(latlng2.lng);
                        var lat2 = this._degToRad(latlng2.lat);

                        // Based on formulae from
                        // http://williams.best.vwh.net/avform.htm#Intermediate
                        var d = Math.acos(Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon1 - lon2));

                        // Split the arc in half
                        var f = 0.5;

                        var A = Math.sin((1 - f) * d) / Math.sin(d);
                        var B = Math.sin(f * d) / Math.sin(d);

                        var x = A * Math.cos(lat1) * Math.cos(lon1) + B * Math.cos(lat2) * Math.cos(lon2);

                        var y = A * Math.cos(lat1) * Math.sin(lon1) + B * Math.cos(lat2) * Math.sin(lon2);

                        var z = A * Math.sin(lat1) + B * Math.sin(lat2);

                        var lat = Math.atan2(z, Math.sqrt(x * x + y * y));
                        var lon = Math.atan2(y, x);

                        return DG.latLng(this._radToDeg(lat), this._radToDeg(lon));
                    },

                    // Adaptive sampling algorithm based on
                    // http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf
                    _adaptiveSample: function (left, right, depth, middle) {
                        // (LatLng, LatLng, Number[, LatLng]) -> LatLng[]
                        if (depth > 9) {
                            // Max recursion depth reached
                            return [];
                        }

                        middle = middle || this._calcMidPoint(left, right);

                        var leftMiddle = this._calcMidPoint(left, middle);
                        var rightMiddle = this._calcMidPoint(middle, right);

                        var angle1 = this._calcAngle(leftMiddle, middle, left);
                        var angle2 = this._calcAngle(middle, left, right);
                        var angle3 = this._calcAngle(rightMiddle, middle, right);

                        // left --- leftMiddle --- middle --- rightMiddle --- right
                        //            angle1       angle2       angle3

                        var minAngle = 3.1;
                        if (angle1 > minAngle && angle2 > minAngle && angle3 > minAngle) {
                            // This section is straight enough, no intermediate points needed.
                            return [];
                        } else {
                            // Angles are too small. Recursively sample halves of this section.
                            var result = [];
                            result = result.concat(this._adaptiveSample(left, middle, depth + 1, leftMiddle));
                            result.push(middle);
                            result = result.concat(this._adaptiveSample(middle, right, depth + 1, rightMiddle));

                            return result;
                        }
                    },

                    // Calculates the great circle arc between two LatLngs.
                    _calcGreatCircle: function (latlng1, latlng2) {
                        // (LatLng, LatLng) -> LatLng[]
                        latlng2 = this._normalizeLatLng(latlng2, latlng1);

                        // Special case: points are close to each other (within 1 degree)
                        if (latlng1.equals(latlng2, 1)) {
                            return [latlng1, latlng2];
                        }

                        // Special case: the great circle crosses a pole
                        if (Math.abs(latlng2.lng - latlng1.lng) == 180) {
                            // North or south pole?
                            var latitude = latlng1.lat + latlng2.lat > 0 ? 90 : -90;

                            return [latlng1, DG.latLng(latitude, latlng1.lng), DG.latLng(latitude, latlng2.lng), latlng2];
                        }

                        var result = [];

                        result.push(latlng1);
                        result = result.concat(this._adaptiveSample(latlng1, latlng2, 0));
                        result.push(latlng2);

                        // Make sure the arc doesn't jump between worlds
                        for (var i = 1; i < result.length; i++) {
                            result[i] = this._normalizeLatLng(result[i], result[i - 1]);
                        }

                        return result;
                    },

                    _addLegs: function (point) {
                        var pathStyles = this.options.pathStyles;

                        var greatCirclePoints = this._calcGreatCircle(point.getLatLng(), this._points[point._pos + 1].getLatLng());

                        point._legs = {};
                        Object.keys(pathStyles).forEach(function (layer) {
                            point._legs[layer] = DG.polyline(greatCirclePoints, pathStyles[layer]).addTo(this._layers[layer]);
                        }, this);

                        point._legs.mouse._point = point.once('remove', this._clearRemovingPointLegs, this);

                        if (this.options.editable && !DG.Browser.mobile) {
                            point._legs.mouse.on('mousedown', this._insertPointInLine, this);
                        }

                        if (this._map) {
                            this._layers.mouse.addLayer(point._legs.mouse);
                        }
                    },

                    _clearRemovingPointLegs: function (event) {
                        // (Event)
                        this._removeLegs(event.target);
                    },

                    _removeLegs: function (point) {
                        // (Ruler.LayeredMarker)
                        if (point._legs) {
                            Object.keys(point._legs).forEach(function (layer) {
                                this._layers[layer].removeLayer(point._legs[layer]);
                            }, this);
                            point._legs = null;
                        }
                    },

                    _updateLegs: function (point, skipPrevious) {
                        // (Ruler.LayeredMarker, Boolean)
                        var latlng = point.getLatLng(),
                            previousPoint = this._points[point._pos - 1],
                            nextPoint = this._points[point._pos + 1],
                            self = this,
                            newPoints;

                        if (previousPoint && !skipPrevious) {
                            newPoints = self._calcGreatCircle(previousPoint.getLatLng(), latlng);

                            Object.keys(previousPoint._legs).forEach(function (layer) {
                                previousPoint._legs[layer].setLatLngs(newPoints);
                            });
                        }

                        if (nextPoint) {
                            newPoints = self._calcGreatCircle(latlng, nextPoint.getLatLng());

                            Object.keys(point._legs).forEach(function (layer) {
                                point._legs[layer].setLatLngs(newPoints);
                            });
                        }
                    },

                    _calcDistance: function (finishPoint, tail) {
                        // (Ruler.LayeredMarker, Number) -> Number
                        var distance = tail ? tail : 0,
                            calcTo = finishPoint ? finishPoint._pos : this._points.length - 1;

                        for (var i = 0; i < calcTo; i++) {
                            distance += this._points[i].getLatLng().distanceTo(this._points[i + 1].getLatLng());
                        }

                        return distance;
                    },

                    _getFormatedDistance: function () {
                        // () -> String
                        var distance = this._calcDistance.apply(this, arguments),
                            units = 'm';

                        if (distance > 1000) {
                            distance /= 1000;
                            units = 'km';
                            if (distance > 1000) {
                                distance = distance.toFixed();
                                distance = distance.slice(0, -3) + ' ' + distance.slice(-3);
                            } else {
                                distance = distance.toFixed(2).split('.').join(this.t('delimiter'));
                            }
                        } else {
                            distance = Math.round(distance);
                        }

                        return [distance || 0, ' ', this.t(units)].join('');
                    },

                    _updateDistance: function () {
                        // ()
                        if (this._map && this._points.length) {
                            this._points[this._points.length - 1].setText(this._getFormatedDistance());
                        }
                    }
                });

                DG.ruler = function (latlngs, options) {
                    // (Array, Object)
                    return new DG.Ruler(latlngs, options);
                };

                DG.Ruler.LayeredMarker = DG.Marker.extend({
                    options: {
                        draggable: false,
                        keyboard: false,
                        riseOnHover: true,
                        pane: 'rulerMarkerPane',
                        textDirection: 'auto', // 'auto' | 'ltr' | 'rtl'
                        iconHTML: ['<img class="dg-ruler__label-spacer" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" width="26" height="26" />', '<div class="dg-ruler__label-container">', '    <div class="dg-ruler__point"></div>', '    <span class="dg-ruler__label-distance">0 км</span>', '    <span class="dg-ruler__label-remove-link"></span>', '    <div class="dg-ruler__remove-link-overlay"></div>', '</div>'].join('\n')
                    },

                    statics: {
                        domClass: 'dg-ruler__label'
                    },

                    addTo: function (map, layers) {
                        Object.keys(this._layers).forEach(function (name) {
                            layers[name].addLayer(this._layers[name]);
                        }, this);

                        this._viewport = layers;
                        return DG.Marker.prototype.addTo.call(this.on('move', this._onMove), map);
                    },

                    onRemove: function (map) {
                        Object.keys(this._layers).forEach(function (name) {
                            this._viewport[name].removeLayer(this._layers[name]);
                        }, this);
                        this.off('move', this._onMove);
                        this._viewport = null;
                        this._style = null;
                        return DG.Marker.prototype.onRemove.call(this, map);
                    },

                    setText: function (text) {
                        if (this._iconCollapsed) {
                            this.expand();
                        }
                        this._iconNodes.label.innerHTML = text;
                        this._iconNodes.label.setAttribute('dir', this.options.textDirection);
                        return this;
                    },

                    setPointStyle: function (style) {
                        if (this._style !== style) {
                            Object.keys(this._style = style).forEach(function (name) {
                                this._layers[name].setStyle(style[name]);
                            }, this);
                        }
                        return this;
                    },

                    expand: function () {
                        this._iconCollapsed = false;
                        this._iconNodes.container.style.display = 'block';
                        this._iconNodes.spacer.style.display = 'none';
                        return this;
                    },

                    collapse: function () {
                        this._iconCollapsed = true;
                        this._iconNodes.container.style.display = 'none';
                        this._iconNodes.spacer.style.display = 'block';
                        return this;
                    },

                    querySelector: function (selector) {
                        return this._icon.querySelector('.' + DG.Ruler.LayeredMarker.domClass + '-' + selector);
                    },

                    _onMove: function (event) {
                        var latlng = event.latlng;
                        Object.keys(this._layers).forEach(function (name) {
                            this._layers[name].setLatLng(latlng);
                        }, this);
                    },

                    _initIcon: function () {
                        DG.Marker.prototype._initIcon.call(this);
                        this._iconCollapsed = true;
                        this._icon.style.width = '';
                        this._iconNodes = {
                            label: this.querySelector('distance'),
                            spacer: this.querySelector('spacer'),
                            container: this.querySelector('container')
                        };
                    },

                    // don't change icon zIndex
                    _setPos: function (pos) {
                        L.DomUtil.setPosition(this._icon, pos);

                        if (this._shadow) {
                            L.DomUtil.setPosition(this._shadow, pos);
                        }
                    },

                    _afterInit: function () {
                        this._layers = this.options.layers || null;
                        this.options.icon = DG.divIcon({
                            className: DG.Ruler.LayeredMarker.domClass,
                            iconSize: [26, 26],
                            iconAnchor: [13, 13],
                            html: this.options.iconHTML
                        });
                    }

                });

                DG.Ruler.LayeredMarker.addInitHook('_afterInit');

                DG.Ruler.layeredMarker = function (latlng, options) {
                    return new DG.Ruler.LayeredMarker(latlng, options);
                };

                var rulerRenderer = DG.svg({ pane: 'rulerPane' });
                var hoverRenderer = DG.svg({ pane: 'rulerPane' });

                DG.Ruler.mergeOptions({
                    pathStyles: {
                        back: {
                            color: '#fff',
                            opacity: 1,
                            weight: 12,
                            pointerEvents: 'none',
                            noClip: true,
                            renderer: rulerRenderer,
                            smoothFactor: 0
                        },
                        middle: {
                            color: '#0da5d5',
                            opacity: 1,
                            weight: 4,
                            pointerEvents: 'none',
                            noClip: true,
                            renderer: rulerRenderer,
                            smoothFactor: 0
                        },
                        mouse: {
                            color: '#fff',
                            opacity: DG.Browser.vml ? 0.1 : 0,
                            weight: DG.Browser.touch ? 40 : 20,
                            pointerEvents: 'painted',
                            noClip: true,
                            renderer: hoverRenderer,
                            smoothFactor: 0
                        }
                    },
                    iconStyles: {
                        large: {
                            back: {
                                color: '#fff',
                                opacity: 1,
                                fillColor: '#fff',
                                fillOpacity: 1,
                                weight: 1,
                                radius: 13,
                                renderer: rulerRenderer
                            },
                            middle: {
                                color: '#0da5d5',
                                opacity: 1,
                                fillColor: '#0da5d5',
                                fillOpacity: 1,
                                weight: 1,
                                radius: 9,
                                renderer: rulerRenderer
                            },
                            front: {
                                color: '#fff',
                                opacity: 1,
                                fillColor: '#0da5d5',
                                fillOpacity: 1,
                                weight: 4,
                                radius: 5,
                                renderer: rulerRenderer
                            }
                        },
                        small: {
                            back: {
                                color: '#fff',
                                opacity: 1,
                                fillColor: '#fff',
                                fillOpacity: 1,
                                weight: 1,
                                radius: 9,
                                renderer: rulerRenderer
                            },
                            middle: {
                                color: '#0da5d5',
                                opacity: 1,
                                fillColor: '#0da5d5',
                                fillOpacity: 1,
                                weight: 1,
                                radius: 5,
                                renderer: rulerRenderer
                            },
                            front: {
                                color: '#fff',
                                opacity: 1,
                                fillColor: '#0da5d5',
                                fillOpacity: 1,
                                weight: 4,
                                radius: 2,
                                renderer: rulerRenderer
                            }
                        }
                    }
                });

                DG.Ruler.Dictionary.ru = {
                    km: 'км',
                    m: 'м',
                    delimiter: ','
                };

                DG.Ruler.Dictionary.it = {
                    km: 'km',
                    m: 'm',
                    delimiter: ','
                };

                DG.Ruler.Dictionary.cs = {
                    km: 'km',
                    m: 'm',
                    delimiter: ','
                };

                DG.Ruler.Dictionary.es = {
                    km: 'km',
                    m: 'm',
                    delimiter: ','
                };

                DG.Ruler.Dictionary.en = {
                    km: 'km',
                    m: 'm',
                    delimiter: '.'
                };

                DG.Ruler.Dictionary.ar = {
                    km: 'كم',
                    m: 'م',
                    delimiter: '.'
                };

                DG.Control.Ruler = DG.RoundControl.extend({

                    options: {
                        position: 'topright',
                        iconClass: 'ruler'
                    },

                    statics: {
                        Dictionary: {}
                    },

                    initialize: function (options) {
                        DG.setOptions(this, options);
                        DG.extend(this, {
                            _active: false,
                            _drawingHelper: null,
                            _geoclickerNeedRestore: false
                        }).on(this._controlEvents, this);
                    },

                    _controlEvents: {
                        add: function () {
                            this._drawingHelper = DG.ruler([]);
                        },
                        click: function () {
                            this._active = !this._active;

                            if (this._active) {
                                this.setState('active');
                                this._startDrawing();
                            } else {
                                this.setState('');
                                this._finishDrawing();
                            }
                        },
                        remove: function () {
                            this.off(this._controlEvents, this);
                            if (this._active) {
                                this._map.removeLayer(this._drawingHelper);
                                this._active = false;
                            }
                            this._drawingHelper = null;
                        }
                    },

                    _startDrawing: function () {
                        // ()
                        this._map.addLayer(this._drawingHelper).on('click', this._handleMapClick, this);

                        this._map.fire('rulerstart');
                    },

                    _finishDrawing: function () {
                        // ()
                        this._map.off('click', this._handleMapClick, this).removeLayer(this._drawingHelper);

                        this._drawingHelper.setLatLngs([]);

                        this._map.fire('rulerend');
                    },

                    _handleMapClick: function (event) {
                        // (MouseEvents)
                        this._drawingHelper.addLatLng(event.latlng);
                    },

                    _renderTranslation: function () {
                        // ()
                        this._link.title = this.t('button_title');
                    }
                });

                DG.control.ruler = function (options) {
                    return new DG.Control.Ruler(options);
                };

                DG.Map.mergeOptions({
                    rulerControl: false
                });

                DG.Map.addInitHook(function () {
                    if (this.options.rulerControl) {
                        this.rulerControl = DG.control.ruler(this.options.rulerControl);
                        this.addControl(this.rulerControl);
                    }
                });

                DG.Control.Ruler.Dictionary.ru = {
                    button_title: 'Линейка'
                };

                DG.Control.Ruler.Dictionary.it = {
                    button_title: 'Righello'
                };

                DG.Control.Ruler.Dictionary.cs = {
                    button_title: 'Pravítko'
                };

                DG.Control.Ruler.Dictionary.es = {
                    button_title: 'Regla'
                };

                DG.Control.Ruler.Dictionary.en = {
                    button_title: 'Ruler'
                };

                DG.Control.Ruler.Dictionary.ar = {
                    button_title: 'مسطرة'
                };

                (function (dust) {
                    dust.register("DGAttribution\/copyright", body_0);function body_0(chk, ctx) {
                        return chk.w("<div class=\"dg-attribution__copyright\"><ul class=\"dg-attribution__links\"><li class=\"dg-attribution__link-item\">").x(ctx.get(["osm"], false), ctx, { "else": body_1, "block": body_2 }, {}).w("</li><li class=\"dg-attribution__link-item\"><a href=\"").f(ctx.get(["copyright_license"], false), ctx, "h").w("\" target=\"_blank\" class=\"dg-attribution__link\">").f(ctx.get(["license_agreement"], false), ctx, "h").w("</a></li></ul><a href=\"").f(ctx.get(["copyright_logo"], false), ctx, "h").w("\" target=\"_blank\" class=\"dg-attribution__logo-url\"></a></div>");
                    }body_0.__dustBody = !0;function body_1(chk, ctx) {
                        return chk.w("<a href=\"").f(ctx.get(["copyright_apilink"], false), ctx, "h").w("\" target=\"_blank\" class=\"dg-attribution__link\" dir=\"").f(ctx.get(["dir"], false), ctx, "h").w("\">").f(ctx.get(["work_on"], false), ctx, "h").w("</a>");
                    }body_1.__dustBody = !0;function body_2(chk, ctx) {
                        return chk.w("© <a href=\"http://www.openstreetmap.org/copyright\" target=\"_blank\" class=\"dg-attribution__link\">OpenStreetMap contributors</a>, <a href=\"").f(ctx.get(["copyright_apilink"], false), ctx, "h").w("\" target=\"_blank\" class=\"dg-attribution__link\" dir=\"").f(ctx.get(["dir"], false), ctx, "h").w("\">").f(ctx.get(["work_on_with_osm"], false), ctx, "h").w("</a>");
                    }body_2.__dustBody = !0;return body_0;
                })(dust);
                (function (dust) {
                    dust.register("DGGeoclicker\/cityarea", body_0);function body_0(chk, ctx) {
                        return chk.w("<div class=\"dg-map-geoclicker__purpose dg-map-geoclicker__purpose_type_").f(ctx.get(["type"], false), ctx, "h").w("\">").f(ctx.get(["purpose"], false), ctx, "h").w("</div>").s(ctx.get(["drilldown"], false), ctx, { "block": body_1 }, {});
                    }body_0.__dustBody = !0;function body_1(chk, ctx) {
                        return chk.w("<div class=\"dg-map-geoclicker__drilldown\">").f(ctx.get(["drilldown"], false), ctx, "h").w("</div>");
                    }body_1.__dustBody = !0;return body_0;
                })(dust);
                (function (dust) {
                    dust.register("DGGeoclicker\/firmCardAddr", body_0);function body_0(chk, ctx) {
                        return chk.w("<address class=\"dg-firm-card__address dg-firm-card__icon\">").f(ctx.get(["address"], false), ctx, "h").s(ctx.get(["comment"], false), ctx, { "block": body_1 }, {}).w("</address>");
                    }body_0.__dustBody = !0;function body_1(chk, ctx) {
                        return chk.w("<span class=\"dg-firm-card__comment\">&mdash; ").f(ctx.getPath(true, []), ctx, "h").w("</span>");
                    }body_1.__dustBody = !0;return body_0;
                })(dust);
                (function (dust) {
                    dust.register("DGGeoclicker\/firmCardContacts", body_0);function body_0(chk, ctx) {
                        return chk.s(ctx.get(["groups"], false), ctx, { "block": body_1 }, {});
                    }body_0.__dustBody = !0;function body_1(chk, ctx) {
                        return chk.s(ctx.get(["contacts"], false), ctx, { "block": body_2 }, {});
                    }body_1.__dustBody = !0;function body_2(chk, ctx) {
                        return chk.h("select", ctx, { "block": body_3 }, { "key": ctx.get(["type"], false), "type": "string" }, "h");
                    }body_2.__dustBody = !0;function body_3(chk, ctx) {
                        return chk.h("eq", ctx, { "block": body_4 }, { "value": "phone", "type": "string" }, "h").h("eq", ctx, { "block": body_6 }, { "value": "fax", "type": "string" }, "h").h("eq", ctx, { "block": body_8 }, { "value": "website", "type": "string" }, "h").h("eq", ctx, { "block": body_9 }, { "value": "email", "type": "string" }, "h");
                    }body_3.__dustBody = !0;function body_4(chk, ctx) {
                        return chk.w("<div class=\"dg-firm-card__phone dg-firm-card__icon\"><span class=\"dg-firm-card__phone-num\">").f(ctx.get(["text"], false), ctx, "h").s(ctx.get(["comment"], false), ctx, { "block": body_5 }, {}).w("</span></div>");
                    }body_4.__dustBody = !0;function body_5(chk, ctx) {
                        return chk.w("<span class=\"dg-firm-card__comment\" title=\"").f(ctx.getPath(true, []), ctx, "h").w("\">&mdash;&nbsp;&nbsp;").f(ctx.getPath(true, []), ctx, "h").w("</span>");
                    }body_5.__dustBody = !0;function body_6(chk, ctx) {
                        return chk.w("<div class=\"dg-firm-card__phone dg-firm-card__icon\"><span class=\"dg-firm-card__phone-num\">").f(ctx.get(["text"], false), ctx, "h").s(ctx.get(["comment"], false), ctx, { "block": body_7 }, {}).w("</span></div>");
                    }body_6.__dustBody = !0;function body_7(chk, ctx) {
                        return chk.w("<span class=\"dg-firm-card__comment\" title=\"").f(ctx.getPath(true, []), ctx, "h").w("\">&mdash;&nbsp;&nbsp;").f(ctx.getPath(true, []), ctx, "h").w("</span>");
                    }body_7.__dustBody = !0;function body_8(chk, ctx) {
                        return chk.w("<div class=\"dg-firm-card__link dg-firm-card__site dg-firm-card__icon\"><a href=\"").f(ctx.get(["url"], false), ctx, "h").w("\" target=\"_blank\" class=\"dg-link_scheme_dark dg-firm-card__sitelink\">").f(ctx.get(["text"], false), ctx, "h").w("</a></div>");
                    }body_8.__dustBody = !0;function body_9(chk, ctx) {
                        return chk.w("<div class=\"dg-firm-card__link dg-firm-card__email dg-firm-card__icon\"><a href=\"mailto:").f(ctx.get(["value"], false), ctx, "h").w("\">").f(ctx.get(["value"], false), ctx, "h").w("</a></div>");
                    }body_9.__dustBody = !0;return body_0;
                })(dust);
                (function (dust) {
                    dust.register("DGGeoclicker\/firmCardHeader", body_0);function body_0(chk, ctx) {
                        return chk.w("<div class=\"dg-popup__header-title dg-popup__header-title_for_firmcard\" title=\"").f(ctx.get(["firmName"], false), ctx, "h").w("\">").f(ctx.get(["firmName"], false), ctx, "h").w("</div>").x(ctx.get(["links"], false), ctx, { "block": body_1 }, {});
                    }body_0.__dustBody = !0;function body_1(chk, ctx) {
                        return chk.w("<div class=\"dg-popup__header-links\">").s(ctx.get(["links"], false), ctx, { "block": body_2 }, {}).w("</div>");
                    }body_1.__dustBody = !0;function body_2(chk, ctx) {
                        return chk.h("eq", ctx, { "else": body_3, "block": body_6 }, { "key": body_7, "value": "flamp_stars", "type": "string" }, "h");
                    }body_2.__dustBody = !0;function body_3(chk, ctx) {
                        return chk.w("<a class=\"dg-popup__header-link dg-popup__link dg-popup__link_type_").f(ctx.get(["name"], false), ctx, "h").w("\"").x(ctx.get(["href"], false), ctx, { "else": body_4, "block": body_5 }, {}).w(">").f(ctx.get(["label"], false), ctx, "h").w("</a>");
                    }body_3.__dustBody = !0;function body_4(chk, ctx) {
                        return chk.w("href=\"javascript:void(0)\"");
                    }body_4.__dustBody = !0;function body_5(chk, ctx) {
                        return chk.w("href=").f(ctx.get(["href"], false), ctx, "h").w(" target=\"_blank\"");
                    }body_5.__dustBody = !0;function body_6(chk, ctx) {
                        return chk.w("<div class=\"dg-popup__rating\"><div class=\"dg-popup__rating-stars\" style=\"width: ").f(ctx.get(["width"], false), ctx, "h").w("%\"></div></div>");
                    }body_6.__dustBody = !0;function body_7(chk, ctx) {
                        return chk.f(ctx.get(["name"], false), ctx, "h");
                    }body_7.__dustBody = !0;return body_0;
                })(dust);
                (function (dust) {
                    dust.register("DGGeoclicker\/firmCardRubric", body_0);function body_0(chk, ctx) {
                        return chk.s(ctx.get(["rubrics"], false), ctx, { "block": body_1 }, {});
                    }body_0.__dustBody = !0;function body_1(chk, ctx) {
                        return chk.w("<section class=\"dg-firm-card__rubrics\">").x(ctx.get(["primary"], false), ctx, { "block": body_2 }, {}).x(ctx.get(["additional"], false), ctx, { "block": body_4 }, {}).w("</section>");
                    }body_1.__dustBody = !0;function body_2(chk, ctx) {
                        return chk.w("<ul class=\"dg-firm-card__rubrics-list dg-firm-card__rubrics-list_type_primary\">").s(ctx.get(["primary"], false), ctx, { "block": body_3 }, {}).w("</ul>");
                    }body_2.__dustBody = !0;function body_3(chk, ctx) {
                        return chk.w("<li class=\"dg-firm-card__rubrics-list-item\">").f(ctx.get(["name"], false), ctx, "h").w("</li>");
                    }body_3.__dustBody = !0;function body_4(chk, ctx) {
                        return chk.w("<ul class=\"dg-firm-card__rubrics-list dg-firm-card__rubrics-list_type_additional\">").s(ctx.get(["additional"], false), ctx, { "block": body_5 }, {}).w("</ul>");
                    }body_4.__dustBody = !0;function body_5(chk, ctx) {
                        return chk.w("<li class=\"dg-firm-card__rubrics-list-item\">").f(ctx.get(["name"], false), ctx, "h").w("</li>");
                    }body_5.__dustBody = !0;return body_0;
                })(dust);
                (function (dust) {
                    dust.register("DGGeoclicker\/firmCardSchedule", body_0);function body_0(chk, ctx) {
                        return chk.w("<div class=\"dg-firm-card__schedule dg-schedule dg-schedule_open_").x(ctx.getPath(false, ["forecast", "open"]), ctx, { "else": body_1, "block": body_2 }, {}).w(" dg-schedule_works-everyday_").x(ctx.getPath(false, ["schedule", "everyday"]), ctx, { "else": body_3, "block": body_4 }, {}).w("\">").x(ctx.get(["schedule"], false), ctx, { "block": body_5 }, {}).w("</div>");
                    }body_0.__dustBody = !0;function body_1(chk, ctx) {
                        return chk.w("false");
                    }body_1.__dustBody = !0;function body_2(chk, ctx) {
                        return chk.w("true");
                    }body_2.__dustBody = !0;function body_3(chk, ctx) {
                        return chk.w("false");
                    }body_3.__dustBody = !0;function body_4(chk, ctx) {
                        return chk.w("true");
                    }body_4.__dustBody = !0;function body_5(chk, ctx) {
                        return chk.x(ctx.getPath(false, ["forecast", "today"]), ctx, { "block": body_6 }, {}).s(ctx.getPath(false, ["forecast", "now"]), ctx, { "block": body_10 }, {}).nx(ctx.getPath(false, ["schedule", "everyday"]), ctx, { "block": body_12 }, {});
                    }body_5.__dustBody = !0;function body_6(chk, ctx) {
                        return chk.w("<div class=\"dg-schedule__today\"><div class=\"dg-schedule__today-inner\">").f(ctx.getPath(false, ["forecast", "today", "text"]), ctx, "h").w("&nbsp;").x(ctx.getPath(false, ["forecast", "today", "from"]), ctx, { "block": body_7 }, {}).x(ctx.getPath(false, ["schedule", "lunch"]), ctx, { "block": body_8 }, {}).w("</div></div>");
                    }body_6.__dustBody = !0;function body_7(chk, ctx) {
                        return chk.f(ctx.getPath(false, ["forecast", "today", "from"]), ctx, "h").w("&ndash;").f(ctx.getPath(false, ["forecast", "today", "to"]), ctx, "h");
                    }body_7.__dustBody = !0;function body_8(chk, ctx) {
                        return chk.w(",&nbsp;").f(ctx.getPath(false, ["forecast", "today", "lunchStr"]), ctx, "h").w("&nbsp;").s(ctx.getPath(false, ["schedule", "lunch"]), ctx, { "block": body_9 }, {});
                    }body_8.__dustBody = !0;function body_9(chk, ctx) {
                        return chk.f(ctx.get(["from"], false), ctx, "h").w("&ndash;").f(ctx.get(["to"], false), ctx, "h");
                    }body_9.__dustBody = !0;function body_10(chk, ctx) {
                        return chk.w("<div class=\"dg-schedule__now\"><span class=\"dg-schedule__now-text\">").f(ctx.getPath(true, []), ctx, "h").s(ctx.getPath(false, ["schedule", "comment"]), ctx, { "block": body_11 }, {}).w("</span></div>");
                    }body_10.__dustBody = !0;function body_11(chk, ctx) {
                        return chk.w(", ").f(ctx.getPath(true, []), ctx, "h");
                    }body_11.__dustBody = !0;function body_12(chk, ctx) {
                        return chk.x(ctx.getPath(false, ["schedule", "week"]), ctx, { "block": body_13 }, {});
                    }body_12.__dustBody = !0;function body_13(chk, ctx) {
                        return chk.x(ctx.getPath(false, ["schedule", "week", "evently"]), ctx, { "block": body_14 }, {}).x(ctx.getPath(false, ["schedule", "week", "table"]), ctx, { "block": body_22 }, {});
                    }body_13.__dustBody = !0;function body_14(chk, ctx) {
                        return chk.w("<div class=\"dg-schedule__table\">").s(ctx.getPath(false, ["schedule", "week", "evently"]), ctx, { "block": body_15 }, {}).w("</div>");
                    }body_14.__dustBody = !0;function body_15(chk, ctx) {
                        return chk.w("<div class=\"dg-schedule__string\">").x(ctx.get(["alltime"], false), ctx, { "block": body_16 }, {}).x(ctx.get(["everyday"], false), ctx, { "else": body_17, "block": body_18 }, {}).x(ctx.get(["holiday"], false), ctx, { "else": body_19, "block": body_21 }, {}).w("</div>");
                    }body_15.__dustBody = !0;function body_16(chk, ctx) {
                        return chk.f(ctx.get(["alltimeStr"], false), ctx, "h");
                    }body_16.__dustBody = !0;function body_17(chk, ctx) {
                        return chk.f(ctx.get(["dayList"], false), ctx, "h");
                    }body_17.__dustBody = !0;function body_18(chk, ctx) {
                        return chk.f(ctx.getPath(false, ["forecast", "today", "text"]), ctx, "h");
                    }body_18.__dustBody = !0;function body_19(chk, ctx) {
                        return chk.w("<span class=\"schedule__string-time\">&nbsp;").f(ctx.get(["from"], false), ctx, "h").w("&ndash;").f(ctx.get(["to"], false), ctx, "h").w("</span>").s(ctx.get(["lunch"], false), ctx, { "block": body_20 }, {});
                    }body_19.__dustBody = !0;function body_20(chk, ctx) {
                        return chk.w("<p>").f(ctx.get(["lunchStr"], false), ctx, "h").w("&mdash;<span class=\"schedule__string-time\">").f(ctx.get(["from"], false), ctx, "h").w("&ndash;").f(ctx.get(["to"], false), ctx, "h").w("</span></p>");
                    }body_20.__dustBody = !0;function body_21(chk, ctx) {
                        return chk.w("&nbsp;&mdash;<span class=\"schedule__string-time\">&nbsp;").f(ctx.get(["holidayStr"], false), ctx, "h").w("</span>");
                    }body_21.__dustBody = !0;function body_22(chk, ctx) {
                        return chk.w("<div><div class=\"dg-schedule__table\"><div class=\"dg-schedule__tc dg-schedule__tc_pre\"><div class=\"dg-schedule__day-name\">&nbsp;</div><div class=\"dg-schedule__table-clock dg-schedule__td\"></div>").x(ctx.getPath(false, ["schedule", "week", "hasLunch"]), ctx, { "block": body_23 }, {}).w("</div>").s(ctx.getPath(false, ["schedule", "week", "table"]), ctx, { "block": body_24 }, {}).w("</div>  </div>");
                    }body_22.__dustBody = !0;function body_23(chk, ctx) {
                        return chk.w("<div class=\"dg-schedule__table-lunch dg-schedule__td\"></div>");
                    }body_23.__dustBody = !0;function body_24(chk, ctx) {
                        return chk.h("if", ctx, { "block": body_25 }, { "cond": body_26 }, "h").w("<div class=\"dg-schedule__tc").x(ctx.get(["active"], false), ctx, { "block": body_27 }, {}).w("\"><div class=\"dg-schedule__day-name\">").f(ctx.get(["key"], false), ctx, "h").w("</div><div class=\"dg-schedule__td\">").x(ctx.get(["from"], false), ctx, { "else": body_28, "block": body_29 }, {}).w("</div>").s(ctx.get(["lunch"], false), ctx, { "block": body_30 }, {}).w("</div> ").h("if", ctx, { "block": body_33 }, { "cond": body_34 }, "h");
                    }body_24.__dustBody = !0;function body_25(chk, ctx) {
                        return chk.w("<span class=\"dg-schedule__table-cell-group\">");
                    }body_25.__dustBody = !0;function body_26(chk, ctx) {
                        return chk.w("(").f(ctx.get(["$idx"], false), ctx, "h").w(" == ").f(ctx.get(["$len"], false), ctx, "h").w(" - 2)");
                    }body_26.__dustBody = !0;function body_27(chk, ctx) {
                        return chk.w(" dg-schedule__tc_active_true");
                    }body_27.__dustBody = !0;function body_28(chk, ctx) {
                        return chk.w("&ndash;");
                    }body_28.__dustBody = !0;function body_29(chk, ctx) {
                        return chk.f(ctx.get(["from"], false), ctx, "h").w(" ").f(ctx.get(["to"], false), ctx, "h");
                    }body_29.__dustBody = !0;function body_30(chk, ctx) {
                        return chk.w("<div class=\"dg-schedule__td\">").x(ctx.get(["from"], false), ctx, { "else": body_31, "block": body_32 }, {}).w("</div>");
                    }body_30.__dustBody = !0;function body_31(chk, ctx) {
                        return chk.w("&ndash;");
                    }body_31.__dustBody = !0;function body_32(chk, ctx) {
                        return chk.f(ctx.get(["from"], false), ctx, "h").w(" ").f(ctx.get(["to"], false), ctx, "h");
                    }body_32.__dustBody = !0;function body_33(chk, ctx) {
                        return chk.w("</span>");
                    }body_33.__dustBody = !0;function body_34(chk, ctx) {
                        return chk.w("(").f(ctx.get(["$idx"], false), ctx, "h").w(" == ").f(ctx.get(["$len"], false), ctx, "h").w(")");
                    }body_34.__dustBody = !0;return body_0;
                })(dust);
                (function (dust) {
                    dust.register("DGGeoclicker\/firmlistItem", body_0);function body_0(chk, ctx) {
                        return chk.w("<a id=\"").f(ctx.getPath(false, ["firm", "id"]), ctx, "h").w("\" class=\"dg-popup__link\" href=\"#\">").f(ctx.getPath(false, ["firm", "name"]), ctx, "h").w("</a>");
                    }body_0.__dustBody = !0;return body_0;
                })(dust);
                (function (dust) {
                    dust.register("DGGeoclicker\/frimCardPayments", body_0);function body_0(chk, ctx) {
                        return chk.x(ctx.get(["payments"], false), ctx, { "block": body_1 }, {});
                    }body_0.__dustBody = !0;function body_1(chk, ctx) {
                        return chk.w("<section class=\"dg-firm-card__aa\"><ul class=\"dg-firm-card__aa-list\">").s(ctx.get(["payments"], false), ctx, { "block": body_2 }, {}).w("</ul></section>");
                    }body_1.__dustBody = !0;function body_2(chk, ctx) {
                        return chk.w("<li class=\"dg-firm-card__aa-list-item\">").f(ctx.getPath(true, []), ctx, "h").w("</li>");
                    }body_2.__dustBody = !0;return body_0;
                })(dust);
                (function (dust) {
                    dust.register("DGGeoclicker\/house", body_0);function body_0(chk, ctx) {
                        return chk.s(ctx.get(["address"], false), ctx, { "block": body_1 }, {}).s(ctx.get(["purpose"], false), ctx, { "block": body_4 }, {}).s(ctx.get(["attractions"], false), ctx, { "block": body_5 }, {});
                    }body_0.__dustBody = !0;function body_1(chk, ctx) {
                        return chk.w("<address class=\"dg-map-geoclicker__address\">").s(ctx.getPath(false, ["address", "header"]), ctx, { "block": body_2 }, {}).s(ctx.getPath(false, ["address", "drilldown"]), ctx, { "block": body_3 }, {}).w("</address>");
                    }body_1.__dustBody = !0;function body_2(chk, ctx) {
                        return chk.w("<div class=\"dg-map-geoclicker__address-header\">").f(ctx.getPath(true, []), ctx, "h").w("</div>");
                    }body_2.__dustBody = !0;function body_3(chk, ctx) {
                        return chk.w("<div class=\"dg-map-geoclicker__address-drilldown\">").f(ctx.getPath(true, []), ctx, "h").w("</div>");
                    }body_3.__dustBody = !0;function body_4(chk, ctx) {
                        return chk.w("<div class=\"dg-map-geoclicker__purpose\">").f(ctx.getPath(true, []), ctx, "h").w("</div>");
                    }body_4.__dustBody = !0;function body_5(chk, ctx) {
                        return chk.w("<div class=\"dg-map-geoclicker__purpose dg-map-geoclicker__purpose_type_sight\">").f(ctx.getPath(true, []), ctx, "h").w("</div>");
                    }body_5.__dustBody = !0;return body_0;
                })(dust);
                (function (dust) {
                    dust.register("DGGeoclicker\/loader", body_0);function body_0(chk, ctx) {
                        return chk.w("<div class=\"dg-preloader dg-preloader_scheme_regular dg-preloader_animation_").x(ctx.get(["anim"], false), ctx, { "else": body_1, "block": body_2 }, {}).x(ctx.get(["small"], false), ctx, { "block": body_3 }, {}).w("\"></div>");
                    }body_0.__dustBody = !0;function body_1(chk, ctx) {
                        return chk.w("false");
                    }body_1.__dustBody = !0;function body_2(chk, ctx) {
                        return chk.w("true");
                    }body_2.__dustBody = !0;function body_3(chk, ctx) {
                        return chk.w(" dg-preloader_size_small");
                    }body_3.__dustBody = !0;return body_0;
                })(dust);
                (function (dust) {
                    dust.register("DGGeoclicker\/popupFooter", body_0);function body_0(chk, ctx) {
                        return chk.w("<div class=\"dg-popup__footer-title\"><a class=\"dg-popup__show-less-house-link\" href=\"javascript:void(0)\">").f(ctx.get(["hideFirmsText"], false), ctx, "h").w("</a></div>");
                    }body_0.__dustBody = !0;return body_0;
                })(dust);
                (function (dust) {
                    dust.register("DGGeoclicker\/popupFooterBtns", body_0);function body_0(chk, ctx) {
                        return chk.x(ctx.get(["btns"], false), ctx, { "block": body_1 }, {});
                    }body_0.__dustBody = !0;function body_1(chk, ctx) {
                        return chk.w("<footer class=\"dg-popup__footer-buttons\">").s(ctx.get(["btns"], false), ctx, { "block": body_2 }, {}).w("</footer>");
                    }body_1.__dustBody = !0;function body_2(chk, ctx) {
                        return chk.w("<div class=\"dg-popup__footer-button-wrapper\"><a class=\"dg-popup__button_name_").f(ctx.get(["name"], false), ctx, "h").w(" dg-popup__footer-button").x(ctx.get(["icon"], false), ctx, { "block": body_3 }, {}).w("\"").x(ctx.get(["href"], false), ctx, { "else": body_4, "block": body_5 }, {}).w(">").f(ctx.get(["label"], false), ctx, "h").w("</a></div>");
                    }body_2.__dustBody = !0;function body_3(chk, ctx) {
                        return chk.w(" dg-popup__footer-icon-button");
                    }body_3.__dustBody = !0;function body_4(chk, ctx) {
                        return chk.w("href=\"javascript:void(0)\"");
                    }body_4.__dustBody = !0;function body_5(chk, ctx) {
                        return chk.w("href=").f(ctx.get(["href"], false), ctx, "h").w(" target=\"_blank\"");
                    }body_5.__dustBody = !0;return body_0;
                })(dust);
                (function (dust) {
                    dust.register("DGGeoclicker\/popupHeader", body_0);function body_0(chk, ctx) {
                        return chk.s(ctx.get(["title"], false), ctx, { "block": body_1 }, {});
                    }body_0.__dustBody = !0;function body_1(chk, ctx) {
                        return chk.w("<div class=\"dg-popup__header-title\">").f(ctx.getPath(true, []), ctx, "h").w("</div>");
                    }body_1.__dustBody = !0;return body_0;
                })(dust);
                (function (dust) {
                    dust.register("DGGeoclicker\/sight", body_0);function body_0(chk, ctx) {
                        return chk.s(ctx.get(["purpose"], false), ctx, { "block": body_1 }, {}).s(ctx.get(["address"], false), ctx, { "block": body_2 }, {}).s(ctx.get(["description"], false), ctx, { "block": body_5 }, {});
                    }body_0.__dustBody = !0;function body_1(chk, ctx) {
                        return chk.w("<div class=\"dg-map-geoclicker__purpose dg-map-geoclicker__purpose_type_sight\">").f(ctx.getPath(true, []), ctx, "h").w("</div>");
                    }body_1.__dustBody = !0;function body_2(chk, ctx) {
                        return chk.w("<address class=\"dg-map-geoclicker__address\">").s(ctx.getPath(false, ["address", "header"]), ctx, { "block": body_3 }, {}).s(ctx.getPath(false, ["address", "drilldown"]), ctx, { "block": body_4 }, {}).w("</address>");
                    }body_2.__dustBody = !0;function body_3(chk, ctx) {
                        return chk.w("<div class=\"dg-map-geoclicker__address-header\">").f(ctx.getPath(true, []), ctx, "h").w("</div>");
                    }body_3.__dustBody = !0;function body_4(chk, ctx) {
                        return chk.w("<div class=\"dg-map-geoclicker__address-drilldown\">").f(ctx.getPath(true, []), ctx, "h").w("</div>");
                    }body_4.__dustBody = !0;function body_5(chk, ctx) {
                        return chk.w("<div class=\"dg-map-geoclicker__sight-description\">").f(ctx.getPath(true, []), ctx, "h").w("</div>").s(ctx.get(["showMoreText"], false), ctx, { "block": body_6 }, {});
                    }body_5.__dustBody = !0;function body_6(chk, ctx) {
                        return chk.w("<a class=\"dg-map-geoclicker__show-more-sights-link\" href=\"javascript:void(0)\">").f(ctx.getPath(true, []), ctx, "h").w("</a>");
                    }body_6.__dustBody = !0;return body_0;
                })(dust);DG.fallbackProjectsList = JSON.parse('[{"name":"Cyprus","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":false,"road_network":true},"domain":"com.cy","bounds":"POLYGON((34.280779 35.226702,34.230518 35.176645,34.311619 35.053578,34.333255 34.94624,34.30553 34.86475,34.246532 34.802092,34.131869 34.756001,33.987598 34.764336,33.917176 34.742875,33.835702 34.739903,33.790212 34.684859,33.72822 34.642865,33.448103 34.538793,33.259541 34.501493,33.192432 34.413254,33.066976 34.363612,32.915196 34.369952,32.805837 34.40138,32.743846 34.438844,32.58024 34.461878,32.38906 34.52014,32.257081 34.592284,32.192743 34.651138,32.082486 34.819072,32.02449 35.022688,32.045537 35.17596,32.115025 35.264403,32.213492 35.309184,32.362822 35.30542,32.471669 35.368093,32.671189 35.399121,32.678969 35.453037,32.711632 35.513637,32.766439 35.562413,32.837579 35.594163,32.949971 35.603965,33.302016 35.553834,33.553453 35.562031,33.937128 35.666397,34.067997 35.744069,34.543625 35.906784,34.67294 35.905835,34.78423 35.852299,34.837429 35.785874,34.855318 35.707916,34.841183 35.642705,34.776411 35.536547,34.710709 35.47953,34.280779 35.226702))","zoom_level":{"min":8,"max":19},"code":"cyprus","country_code":"cy","id":"173","type":"region","time_zone":{"name":"Asia/Nicosia","offset":180}},{"name":"Dubai. Sharjah. Ajman","flags":{"metro":true,"2gis_reviews":true,"public_transport":true,"flamp":false,"traffic":true,"road_network":true},"domain":"ae","bounds":"POLYGON((55.665917 25.064124,55.672767 24.999998,55.711847 24.967028,55.71658 24.834622,55.739179 24.75341,55.58799 24.71345,55.56927 24.682478,55.520958 24.654226,55.331943 24.625137,55.212666 24.656029,55.188406 24.682019,55.106521 24.715319,55.028704 24.82491,54.886953 24.911904,54.715398 25.069339,54.820977 25.181934,54.904421 25.226069,54.947577 25.351786,55.067949 25.500619,55.17036 25.560219,55.279599 25.566579,55.37579 25.69898,55.54617 25.498799,55.708833 25.421307,55.642643 25.174119,55.665917 25.064124))","zoom_level":{"min":8,"max":18},"code":"dubai","country_code":"ae","id":"99","type":"region","time_zone":{"name":"Asia/Dubai","offset":240}},{"name":"Praha","flags":{"metro":true,"2gis_reviews":true,"public_transport":true,"flamp":false,"road_network":true},"domain":"cz","bounds":"POLYGON((14.219495 49.934897,14.215528 50.17879,14.713797 50.181086,14.715245 49.937173,14.219495 49.934897))","zoom_level":{"min":8,"max":18},"code":"praha","country_code":"cz","id":"92","type":"region","time_zone":{"name":"Europe/Prague","offset":120}},{"name":"Santiago","flags":{"metro":true,"2gis_reviews":false,"public_transport":true,"flamp":false,"road_network":true},"domain":"cl","bounds":"POLYGON((-70.483526 -33.665691,-70.857156 -33.660641,-70.849333 -33.293335,-70.477276 -33.298315,-70.483526 -33.665691))","zoom_level":{"min":8,"max":19},"code":"santiago","country_code":"cl","id":"101","type":"region","time_zone":{"name":"America/Santiago","offset":-180}},{"name":"Venezia e Padova","flags":{"metro":false,"2gis_reviews":false,"public_transport":true,"flamp":false,"road_network":false},"domain":"it","bounds":"POLYGON((11.381405 45.733677,12.61199 45.701369,12.572035 45.071337,11.355023 45.102946,11.381405 45.733677))","zoom_level":{"min":8,"max":18},"code":"padova","country_code":"it","id":"66","type":"region","time_zone":{"name":"Europe/Rome","offset":120}},{"name":"Абакан","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((91.144335 53.893079,91.817626 53.901599,91.826689 53.577496,91.158554 53.569076,91.144335 53.893079))","zoom_level":{"min":8,"max":18},"code":"abakan","country_code":"ru","id":"69","type":"region","time_zone":{"name":"Asia/Krasnoyarsk","offset":420}},{"name":"Актау","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":false,"road_network":true},"domain":"kz","bounds":"POLYGON((50.989242 43.559453,50.700278 43.960347,50.548767 44.143806,50.310331 44.173939,50.159119 44.240731,50.077464 44.316906,50.050169 44.386403,50.033572 44.549467,49.924839 44.758753,49.858647 44.834275,49.815392 44.920822,49.810497 44.995622,49.847194 45.094706,49.8831 45.134367,49.961917 45.172278,50.074094 45.193608,50.363547 45.194894,50.707747 45.080803,50.871631 45.115622,51.078633 45.264022,51.269189 45.462642,51.342392 45.507019,51.730008 45.592703,52.155669 45.534531,52.290372 45.552439,52.471922 45.607825,52.541508 45.719714,53.204813 45.361991,53.554441 45.304917,53.812126 45.218172,54.179526 45.035255,54.199893 44.961962,54.295384 44.966118,54.313581 44.90285,54.248564 44.85274,54.5737 44.715114,54.764596 44.731684,55.523533 44.506984,55.620943 44.528128,55.804195 44.46278,55.998725 44.436752,55.994149 42.60045,55.816587 42.184507,55.696231 42.072576,55.445782 41.959161,55.21846 41.916605,54.953666 41.907111,54.779408 42.052145,54.216368 42.37921,53.570558 42.288924,52.984788 42.121175,52.449984 41.761967,52.335076 41.719338,52.259144 41.724447,52.229019 42.117106,52.258633 42.212153,52.440644 42.469697,52.392847 42.601758,52.195397 42.6508,51.836542 42.695872,51.737094 42.757403,51.635567 42.893483,51.557783 42.967481,51.262286 43.003889,51.132642 43.05145,51.077578 43.123231,51.071017 43.160703,51.096811 43.450783,50.989242 43.559453))","zoom_level":{"min":8,"max":18},"code":"aktau","country_code":"kz","id":"196","type":"region","time_zone":{"name":"Asia/Aqtau","offset":300}},{"name":"Актобе","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":false,"road_network":true},"domain":"kz","bounds":"POLYGON((57.072839 50.14836,57.028468 50.173757,57.039338 50.391376,57.066857 50.403663,57.413514 50.403416,57.463802 50.377448,57.440597 50.31981,57.436186 50.186005,57.39508 50.151762,57.244292 50.130843,57.072839 50.14836))","zoom_level":{"min":8,"max":18},"code":"aktobe","country_code":"kz","id":"167","type":"region","time_zone":{"name":"Asia/Aqtobe","offset":300}},{"name":"Алматы","flags":{"metro":true,"2gis_reviews":true,"public_transport":true,"flamp":false,"traffic":true,"road_network":true},"domain":"kz","bounds":"POLYGON((76.72599 43.469093,77.1084 43.462692,77.096182 43.108051,76.715991 43.114387,76.72599 43.469093))","zoom_level":{"min":8,"max":18},"code":"almaty","country_code":"kz","id":"67","type":"region","time_zone":{"name":"Asia/Almaty","offset":360}},{"name":"Альметьевск","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((52.223466 54.858607,52.225581 54.896841,52.201091 54.925634,52.271902 54.972811,52.353207 54.986941,52.466983 54.87767,52.482409 54.827772,52.452724 54.803623,52.391155 54.816144,52.308586 54.807339,52.231899 54.837975,52.223466 54.858607))","zoom_level":{"min":8,"max":18},"code":"almetevsk","country_code":"ru","id":"108","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Армавир","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((41.306107 44.718112,41.249612 44.671822,41.186821 44.715704,41.1145 44.66542,41.070272 44.69744,41.054013 44.687595,41.018874 44.743803,40.974331 44.728943,40.940735 44.766746,40.900976 44.752949,40.873061 44.793149,40.838805 44.781364,40.800459 44.857603,40.902811 44.893435,40.864347 44.961848,40.900608 44.987223,40.842616 45.033578,40.878791 45.056262,40.854148 45.076757,40.900974 45.107242,40.866832 45.134524,40.858846 45.150726,40.880047 45.165058,40.858388 45.184086,40.938913 45.241526,41.005788 45.241262,41.00537 45.229101,41.039447 45.22527,41.35348 45.223054,41.353171 45.186895,41.365911 45.186898,41.352481 45.150892,41.31891 45.15106,41.316496 45.091465,41.267332 45.056419,41.322559 45.016188,41.286438 44.991202,41.367978 44.932597,41.287273 44.860127,41.342416 44.830816,41.317765 44.793729,41.347284 44.746855,41.306107 44.718112))","zoom_level":{"min":8,"max":18},"code":"armawir","country_code":"ru","id":"106","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Архангельск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.467082 64.829966,41.321175 64.812571,41.276671 64.284305,39.458118 64.301293,39.467082 64.829966))","zoom_level":{"min":8,"max":18},"code":"arkhangelsk","country_code":"ru","id":"49","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Астана","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":false,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"kz","bounds":"POLYGON((71.18796 51.371885,71.882791 51.35684,71.856572 50.934375,71.168047 50.949196,71.18796 51.371885))","zoom_level":{"min":8,"max":18},"code":"astana","country_code":"kz","id":"68","type":"region","time_zone":{"name":"Asia/Qyzylorda","offset":360}},{"name":"Астрахань","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((47.747405 46.794839,47.776244 46.800521,47.810135 46.761605,47.907265 46.740644,47.928378 46.720807,48.067759 46.731313,48.098791 46.712483,48.151499 46.714994,48.33634 46.663608,48.395222 46.544961,48.402786 46.492407,48.379384 46.340769,48.362235 46.327207,48.372658 46.316606,48.355751 46.22781,48.383153 46.195758,48.44409 46.171003,48.381341 46.137798,48.348806 46.057503,48.15419 46.054404,48.107321 46.033126,47.985383 46.019315,47.894663 46.029965,47.871002 46.061984,47.697541 46.053889,47.667071 46.097238,47.702048 46.117454,47.666533 46.152288,47.655593 46.258052,47.608108 46.303432,47.626158 46.340853,47.613269 46.362228,47.624706 46.701364,47.747405 46.794839))","zoom_level":{"min":8,"max":18},"code":"astrakhan","country_code":"ru","id":"8","type":"region","time_zone":{"name":"Europe/Astrakhan","offset":240}},{"name":"Барнаул","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((83.928748 53.507088,83.958924 53.474057,84.085515 53.473398,84.175059 53.491398,84.244766 53.479354,84.252861 53.450982,84.212018 53.445806,84.220531 53.397514,84.153577 53.393644,84.113666 53.342338,84.065249 53.322099,84.085325 53.299145,84.007656 53.124723,83.829412 53.119967,83.841391 53.105761,83.82457 53.091551,83.752618 53.110593,83.765491 53.119643,83.743587 53.128187,83.66524 53.124648,83.62449 53.145085,83.62725 53.129512,83.597794 53.129087,83.480861 53.171378,83.447607 53.152209,83.423017 53.173034,83.440163 53.184845,83.393189 53.243041,83.420765 53.275431,83.355743 53.326489,83.417758 53.339642,83.39828 53.373223,83.359899 53.358989,83.345893 53.372393,83.4203 53.408614,83.423045 53.420274,83.385145 53.425419,83.41033 53.445014,83.401345 53.460413,83.454096 53.455281,83.510199 53.504089,83.604538 53.478418,83.69242 53.482115,83.700773 53.473259,83.686064 53.462011,83.70283 53.453045,83.773714 53.458918,83.928748 53.507088))","zoom_level":{"min":8,"max":18},"code":"barnaul","country_code":"ru","id":"4","type":"region","time_zone":{"name":"Asia/Barnaul","offset":420}},{"name":"Белгород","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((36.408454 50.586924,36.364963 50.614887,36.375499 50.618519,36.351604 50.645128,36.360667 50.672724,36.502029 50.713398,36.5567 50.702049,36.558012 50.689755,36.58454 50.697503,36.598181 50.682437,36.660204 50.70429,36.707462 50.693417,36.804933 50.733931,36.765165 50.703819,36.779617 50.657712,36.76248 50.635657,36.790589 50.624682,36.778163 50.614472,36.798107 50.596844,36.791261 50.57059,36.74007 50.54822,36.695989 50.499614,36.607104 50.497135,36.610968 50.482069,36.464342 50.489211,36.407339 50.51763,36.460387 50.542201,36.458536 50.563008,36.408454 50.586924))","zoom_level":{"min":8,"max":18},"code":"belgorod","country_code":"ru","id":"46","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Бийск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((84.874519 52.630301,84.96163 52.640567,84.982697 52.620134,85.093095 52.688834,85.116926 52.689539,85.153911 52.634772,85.220059 52.615266,85.344146 52.674309,85.416886 52.616859,85.538556 52.454311,85.544664 52.424316,85.680389 52.416048,85.773647 52.385701,85.790168 52.29163,85.731543 52.277005,85.730345 52.210825,85.577013 52.212472,85.57808 52.180982,85.614329 52.140175,85.608661 52.111591,85.549344 52.104764,85.545184 52.090548,85.552467 52.04871,85.590302 52.027,85.584219 51.981935,85.544145 51.942899,85.558749 51.906102,85.415412 51.879329,85.364843 51.890686,85.252811 51.873429,85.052969 51.887588,84.909731 51.82692,84.777548 51.897267,84.763076 51.88263,84.715642 51.905948,84.678258 51.877171,84.59717 51.888289,84.558869 51.925041,84.512641 51.932725,84.500581 51.956761,84.464805 51.945612,84.450834 51.973785,84.463158 51.992048,84.504642 52.021509,84.532127 52.022362,84.553064 52.053188,84.504543 52.079354,84.473112 52.075977,84.449089 52.100058,84.573503 52.137237,84.503848 52.222385,84.483005 52.277609,84.588967 52.290758,84.612451 52.484775,84.573893 52.523347,84.680635 52.549619,84.669706 52.572998,84.874519 52.630301))","zoom_level":{"min":8,"max":18},"code":"biysk","country_code":"ru","id":"20","type":"region","time_zone":{"name":"Asia/Barnaul","offset":420}},{"name":"Бишкек","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":false,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"kg","bounds":"POLYGON((75.33643 42.85545,75.570302 42.830459,75.716812 42.797344,75.761433 42.833491,75.786311 42.899161,75.823518 42.940253,75.937224 42.955718,75.949176 42.933001,76.028275 42.911042,76.194148 42.931117,76.200932 42.91645,76.302069 42.910942,76.303927 42.874442,76.343846 42.860756,76.47828 42.884302,76.522591 42.922249,76.575247 42.906103,76.603487 42.916155,76.708886 42.904153,76.749231 42.921514,76.755876 42.949774,76.822744 42.955093,76.835842 42.982848,76.917246 42.965857,76.9719 42.986711,77.004469 42.98309,77.035094 42.947192,77.062577 42.976592,77.154973 42.972254,77.156765 42.944425,77.179907 42.946993,77.234786 42.911813,77.302013 42.916541,77.350501 42.898513,77.47156 42.939266,77.485265 42.924637,77.552523 42.941107,77.581041 42.915514,77.670445 42.917955,77.696993 42.903906,77.780651 42.914754,77.82376 42.884439,77.874056 42.888611,77.911121 42.870732,77.934015 42.881626,77.968122 42.85082,78.002178 42.870654,78.054338 42.847632,78.091759 42.849356,78.116667 42.864588,78.171543 42.860289,78.197829 42.881989,78.348808 42.854848,78.370535 42.886981,78.430884 42.878797,78.464812 42.896432,78.566261 42.511021,78.677523 42.274735,77.64754 41.928742,77.283159 41.907998,77.092381 41.914309,76.583726 41.973638,76.17608 42.104976,76.021959 42.228659,75.992606 42.278642,75.996152 42.316469,75.982604 42.334876,75.995431 42.383247,75.984839 42.390884,75.908185 42.398192,75.884981 42.362349,75.80915 42.354529,75.77166 42.393324,75.679856 42.418716,75.635548 42.448328,75.568927 42.419523,75.530117 42.424251,75.515018 42.454551,75.486241 42.434229,75.407376 42.424195,75.376071 42.450156,75.280345 42.417396,75.197902 42.435125,75.153735 42.42587,75.108622 42.4444,75.079342 42.420226,75.045402 42.419472,75.007472 42.445055,74.969555 42.423173,74.916158 42.438041,74.791378 42.409699,74.416615 42.409699,74.414462 42.78905,74.39828 42.813256,74.413494 42.891453,74.4117 43.079799,74.633389 43.080409,74.749879 42.989881,74.853304 42.999852,75.223534 42.855173,75.33643 42.85545))","zoom_level":{"min":8,"max":18},"code":"bishkek","country_code":"kg","id":"112","type":"region","time_zone":{"name":"Asia/Bishkek","offset":360}},{"name":"Благовещенск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((127.363676 50.403782,127.352443 50.441714,127.286463 50.467049,127.310836 50.523899,127.355179 50.544151,127.365704 50.578455,127.343002 50.610638,127.537138 50.604785,127.751082 50.627248,127.750568 50.598176,127.68732 50.544328,127.689631 50.500392,127.756813 50.434523,127.777421 50.337837,127.763905 50.248109,127.73903 50.224478,127.612184 50.208694,127.598956 50.238392,127.37093 50.289745,127.325315 50.33611,127.363676 50.403782))","zoom_level":{"min":8,"max":18},"code":"blagoveshensk","country_code":"ru","id":"52","type":"region","time_zone":{"name":"Asia/Yakutsk","offset":540}},{"name":"Братск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((101.089619 56.502645,102.059766 56.482523,102.016041 55.92995,101.059727 55.949659,101.089619 56.502645))","zoom_level":{"min":8,"max":18},"code":"bratsk","country_code":"ru","id":"51","type":"region","time_zone":{"name":"Asia/Irkutsk","offset":480}},{"name":"Брянск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((34.306993 53.164362,34.180919 53.124632,34.121062 53.140568,34.091692 53.164732,34.097431 53.204355,34.11895 53.226269,34.088316 53.250407,34.103132 53.263035,34.089647 53.278232,34.154639 53.367685,34.144788 53.411926,34.193721 53.450275,34.297092 53.452291,34.34449 53.486122,34.464258 53.473829,34.543914 53.407776,34.606363 53.270293,34.581757 53.171344,34.432761 53.148647,34.306993 53.164362))","zoom_level":{"min":8,"max":18},"code":"bryansk","country_code":"ru","id":"62","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Великий Новгород","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((31.211943 58.6702,31.254682 58.712294,31.34888 58.696046,31.373219 58.722165,31.419891 58.716772,31.4286 58.697627,31.518878 58.684671,31.518065 58.618393,31.642191 58.534742,31.323177 58.410328,31.255009 58.436947,31.261078 58.452358,31.18483 58.473859,31.121912 58.437613,31.055469 58.474338,31.121487 58.536682,31.143158 58.634691,31.182295 58.677821,31.211943 58.6702))","zoom_level":{"min":8,"max":18},"code":"v_novgorod","country_code":"ru","id":"77","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Владивосток","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((132.275102 43.150151,132.21611 43.028072,132.078173 42.898095,131.953248 42.837472,131.683704 42.786249,131.556063 42.836001,131.587829 43.001127,131.576277 43.03842,131.463549 43.143762,131.411051 43.399272,131.352056 43.462375,131.469144 43.517281,131.542647 43.523577,131.624304 43.564967,131.656048 43.582531,131.684033 43.635493,131.730653 43.665958,131.972032 43.633195,132.025225 43.594097,132.144108 43.572415,132.264317 43.527039,132.291052 43.534936,132.377914 43.481564,132.356268 43.458463,132.371029 43.453495,132.343238 43.430952,132.364157 43.419062,132.349499 43.396926,132.363818 43.367117,132.337976 43.336729,132.275102 43.150151))","zoom_level":{"min":8,"max":18},"code":"vladivostok","country_code":"ru","id":"25","type":"region","time_zone":{"name":"Asia/Vladivostok","offset":600}},{"name":"Владимир","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((40.553697 56.016865,40.321166 56.021603,40.181044 56.034779,40.141737 56.053492,40.159347 56.071072,40.162239 56.12833,40.185872 56.155526,40.161254 56.184066,40.179205 56.210653,40.158592 56.250966,40.162371 56.288428,40.181312 56.297852,40.17218 56.344226,40.198005 56.43593,40.259638 56.467022,40.303939 56.466565,40.695168 56.461839,40.743413 56.430182,40.70655 56.397878,40.703366 56.336406,40.716351 56.326915,40.678552 56.280342,40.688775 56.179039,40.713729 56.10864,40.613067 56.009461,40.553697 56.016865))","zoom_level":{"min":8,"max":18},"code":"vladimir","country_code":"ru","id":"59","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Волгоград","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((44.516273 48.264479,44.516501 48.286667,44.428333 48.293447,44.399822 48.305594,44.396745 48.328586,44.344889 48.33147,44.196749 48.239567,43.979783 48.328917,43.961466 48.345426,43.97311 48.362576,43.965729 48.407124,44.027168 48.465634,43.980829 48.472365,43.967298 48.506967,43.93733 48.506507,43.938644 48.52096,43.905835 48.519426,43.914095 48.547647,43.87482 48.582051,43.861216 48.623052,43.92897 48.621593,43.903636 48.658218,43.948472 48.707149,43.93956 48.731587,43.866099 48.764575,43.887828 48.792165,43.973955 48.851479,44.016491 48.828807,44.031502 48.841955,44.019816 48.847323,44.074949 48.89183,44.051643 48.903585,44.085706 48.932574,44.204013 48.899536,44.28802 48.924258,44.328352 48.985704,44.515948 48.948977,44.539657 48.963183,44.615677 48.950562,44.62823 48.972865,44.657701 48.955667,44.859461 48.923239,45.067555 48.808391,45.084772 48.779438,45.070885 48.765136,45.013591 48.761033,45.018099 48.743039,44.962483 48.700986,44.972802 48.677196,45.01123 48.663225,44.992745 48.646118,44.996412 48.618735,45.061759 48.574899,45.028151 48.572541,44.973857 48.454641,45.010793 48.444727,45.025871 48.383055,45.025853 48.357655,44.991761 48.3592,44.983554 48.293086,44.660355 48.266084,44.621043 48.277476,44.626912 48.258531,44.615641 48.25488,44.516273 48.264479))","zoom_level":{"min":8,"max":18},"code":"volgograd","country_code":"ru","id":"33","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Вологда","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((38.515933 59.121961,38.470498 59.099405,38.287173 59.086542,38.242049 59.06971,38.256449 59.06776,38.249376 59.060387,38.13843 59.057545,37.884693 59.011516,37.711939 59.029731,37.664721 59.081546,37.70754 59.099668,37.682968 59.118858,37.65629 59.212859,37.773079 59.211941,37.763425 59.225848,37.792745 59.234262,37.780588 59.268631,37.808478 59.305886,37.842804 59.311179,37.858537 59.336171,37.92028 59.34456,38.00095 59.328976,38.056271 59.346564,38.264175 59.320357,38.288699 59.328943,38.294461 59.306707,38.345585 59.291117,38.364161 59.312854,38.431422 59.30282,38.469535 59.318513,38.579894 59.291833,38.619833 59.303979,38.639694 59.288489,38.772389 59.30097,38.797706 59.285033,39.147462 59.305821,39.286558 59.337414,39.341859 59.330348,39.369125 59.306394,39.389929 59.335065,39.446643 59.35701,39.517848 59.358059,39.564516 59.331783,39.64683 59.350232,39.706341 59.344757,39.73792 59.371294,39.844323 59.411915,39.889432 59.392979,39.954988 59.398814,40.02458 59.371897,40.030302 59.35394,40.084607 59.349239,40.106504 59.356582,40.089706 59.374115,40.130857 59.382287,40.216618 59.391638,40.27283 59.375595,40.250158 59.354497,40.26296 59.346693,40.242702 59.342184,40.252141 59.332838,40.225744 59.336649,40.246397 59.325743,40.228672 59.316877,40.247251 59.311451,40.224826 59.310067,40.240377 59.299427,40.21765 59.300999,40.218215 59.278978,40.240547 59.266124,40.181195 59.256487,40.251511 59.213126,40.243574 59.204086,40.265573 59.213458,40.31158 59.19275,40.29853 59.186994,40.31338 59.169114,40.302155 59.15758,40.320565 59.15105,40.307792 59.141563,40.278849 59.152818,40.274394 59.132783,40.314184 59.123407,40.280647 59.101449,40.226748 59.096124,40.224546 59.077343,40.197595 59.066177,40.21457 59.039474,40.020498 59.016182,39.97751 59.031356,39.986346 59.045589,39.954664 59.067231,39.591774 59.041542,39.263641 59.061524,39.210222 59.076502,39.203899 59.063475,39.174891 59.062283,39.178316 59.072796,39.159241 59.060182,38.800039 59.068355,38.515933 59.121961))","zoom_level":{"min":8,"max":18},"code":"vologda","country_code":"ru","id":"78","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Воронеж","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.636447 51.797968,39.607537 51.754585,39.622517 51.734659,39.606708 51.714575,39.610185 51.660125,39.58174 51.613567,39.610219 51.594727,39.587116 51.548658,39.595572 51.472616,39.432197 51.463614,39.367228 51.482856,39.282321 51.47193,39.239086 51.494705,39.043242 51.47568,39.036446 51.460721,38.985148 51.451112,38.95836 51.467983,38.975484 51.587634,38.951825 51.601623,38.981717 51.616267,39.01502 51.668308,39.004525 51.686329,38.963301 51.685541,38.949909 51.702812,38.961571 51.744377,38.993182 51.762764,38.986398 51.78014,39.03206 51.824939,38.998914 51.869945,39.080845 51.918867,39.110392 51.906079,39.171912 51.925341,39.17323 51.913889,39.208998 51.916168,39.213598 51.938079,39.277114 51.947584,39.360584 51.926612,39.352964 51.907998,39.5571 51.903533,39.654444 51.882491,39.686652 51.855648,39.66049 51.849479,39.636447 51.797968))","zoom_level":{"min":8,"max":18},"code":"voronezh","country_code":"ru","id":"31","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Днепр","flags":{"metro":true,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":false,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ua","bounds":"POLYGON((34.749305 48.687967,35.296754 48.67835,35.281569 48.341385,34.737733 48.35089,34.749305 48.687967))","zoom_level":{"min":8,"max":18},"code":"dnepropetrovsk","country_code":"ua","id":"105","type":"region","time_zone":{"name":"Europe/Kiev","offset":180}},{"name":"Екатеринбург","flags":{"metro":true,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((59.714357 57.010251,59.843218 57.01357,59.858607 57.032897,59.904726 57.03104,59.923061 57.050275,59.965298 57.054922,60.047762 57.045734,60.038449 57.016691,60.267319 56.995452,60.271682 57.013143,60.419812 57.069198,60.505544 57.043206,60.549708 57.055081,60.70108 57.03633,60.708262 57.058072,60.956449 57.021245,60.940021 56.971993,60.987937 56.928045,60.923753 56.789944,60.976652 56.751103,61.013608 56.744555,60.980369 56.72748,60.977227 56.693708,60.924551 56.702746,60.91685 56.678767,60.963803 56.613703,60.922024 56.602385,60.569054 56.588469,60.2624 56.607099,60.255886 56.591301,60.051382 56.601268,60.043108 56.579619,59.770501 56.602052,59.744221 56.627375,59.74666 56.694076,59.700893 56.827711,59.699866 56.855848,59.726605 56.870853,59.714357 57.010251))","zoom_level":{"min":8,"max":18},"code":"ekaterinburg","country_code":"ru","id":"9","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Иваново","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((41.197218 56.988588,41.188512 56.952433,41.209276 56.910049,41.142312 56.875722,40.950307 56.862373,40.826517 56.883451,40.832547 56.923862,40.787609 57.009888,40.794165 57.055793,40.834003 57.092259,41.203988 57.090369,41.223977 57.050149,41.197218 56.988588))","zoom_level":{"min":8,"max":18},"code":"ivanovo","country_code":"ru","id":"65","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Ижевск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":false,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((52.95169 57.057889,53.495625 57.04823,53.477541 56.776345,53.49634 56.717556,53.473268 56.711399,53.470393 56.667543,52.93186 56.675205,52.939246 56.818944,52.922659 56.824009,52.943466 56.90041,52.95169 57.057889))","zoom_level":{"min":8,"max":18},"code":"izhevsk","country_code":"ru","id":"41","type":"region","time_zone":{"name":"Europe/Samara","offset":240}},{"name":"Иркутск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((103.618853 52.641505,103.558668 52.756303,103.558686 52.82878,103.732417 52.82878,103.733328 52.754448,103.754112 52.726338,103.806039 52.685174,103.854878 52.68341,103.928989 52.644714,104.97019 52.64955,104.970807 51.718225,103.975229 51.71376,103.657739 51.697291,103.635022 51.734936,103.646101 51.753829,103.625789 52.419895,103.576145 52.430001,103.568526 52.448971,103.624012 52.476944,103.618853 52.641505))","zoom_level":{"min":8,"max":18},"code":"irkutsk","country_code":"ru","id":"11","type":"region","time_zone":{"name":"Asia/Irkutsk","offset":480}},{"name":"Йошкар-Ола","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((47.588902 56.761482,48.153297 56.748478,48.147576 56.680101,48.161312 56.671347,48.145753 56.658248,48.133249 56.507529,47.572432 56.520416,47.588902 56.761482))","zoom_level":{"min":8,"max":18},"code":"yoshkarola","country_code":"ru","id":"70","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Кавказские Минеральные Воды","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((42.578142 44.002138,42.61262 44.127676,42.580833 44.178897,42.578513 44.269256,42.844476 44.304247,42.898396 44.287205,43.109725 44.285919,43.30466 44.306366,43.370345 44.261905,43.494471 44.253583,43.551152 44.211293,43.50578 44.139313,43.558606 44.083451,43.505289 44.031903,43.547468 43.948391,43.608438 43.924491,43.608506 43.901408,43.596063 43.901416,43.589321 43.846011,43.408126 43.84147,43.320009 43.801639,43.305784 43.816049,43.109967 43.767679,42.940469 43.810721,42.895215 43.799429,42.733643 43.817514,42.68112 43.807332,42.647469 43.825702,42.62712 43.86502,42.636618 43.879133,42.586434 43.920709,42.578142 44.002138))","zoom_level":{"min":8,"max":18},"code":"minvody","country_code":"ru","id":"89","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Казань","flags":{"metro":true,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((48.293219 55.785858,48.300915 55.83784,48.210824 55.87347,48.264539 55.975911,48.333619 55.987526,48.465319 55.962675,48.549971 55.968903,48.585898 55.99431,48.863615 56.001223,48.935786 56.022691,48.980327 55.999077,49.132549 56.014912,49.172108 55.997201,49.23801 55.998644,49.268193 56.018944,49.425019 55.99398,49.532486 56.012359,49.576513 55.960059,49.572622 55.90025,49.603065 55.871306,49.564515 55.850699,49.569746 55.828722,49.549902 55.803099,49.576929 55.762639,49.553998 55.746684,49.548006 55.711488,49.587559 55.691345,49.549204 55.677128,49.533053 55.652126,49.535477 55.587187,48.477911 55.569986,48.446543 55.546812,48.335021 55.542882,48.302773 55.562068,48.299046 55.576462,48.332055 55.606612,48.289505 55.669048,48.312089 55.675824,48.310374 55.700797,48.265838 55.766996,48.293219 55.785858))","zoom_level":{"min":8,"max":18},"code":"kazan","country_code":"ru","id":"21","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Калининград","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((19.833135 54.586099,19.539731 54.713885,19.592596 54.772306,19.580491 54.890235,19.602075 54.967186,19.681958 55.065929,19.760019 55.116599,19.921503 55.158093,20.201823 55.16015,20.401084 55.18063,20.653783 55.384,20.953702 55.280833,21.137338 55.253862,21.136177 54.889236,21.196062 54.84523,21.163697 54.806789,21.1801 54.783729,21.169734 54.745675,21.143762 54.746284,21.121719 54.718137,21.179906 54.65098,21.15228 54.629143,21.173176 54.569384,21.151091 54.554846,20.822897 54.548373,20.766945 54.528812,20.516593 54.505253,20.495685 54.489603,20.400609 54.518031,20.279696 54.524275,20.205102 54.496552,20.090973 54.539175,20.018733 54.522701,19.833135 54.586099))","zoom_level":{"min":8,"max":18},"code":"kaliningrad","country_code":"ru","id":"40","type":"region","time_zone":{"name":"Europe/Kaliningrad","offset":120}},{"name":"Калуга","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((35.894818 54.755461,36.233835 54.780396,36.305069 54.765277,36.455305 54.768523,36.469927 54.533953,36.484893 54.525984,36.470977 54.516984,36.482233 54.33388,36.210971 54.327911,36.181685 54.299591,36.116858 54.321124,35.927655 54.321024,35.919922 54.424265,35.908394 54.430411,35.909715 54.559813,35.894602 54.569411,35.905908 54.610036,35.901032 54.674135,35.886054 54.687341,35.899607 54.69282,35.894818 54.755461))","zoom_level":{"min":8,"max":18},"code":"kaluga","country_code":"ru","id":"61","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Каменск-Уральский","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((61.715751 56.571122,62.254705 56.57552,62.260467 56.279794,61.725677 56.275445,61.721387 56.403924,61.694523 56.412715,61.719382 56.463611,61.715751 56.571122))","zoom_level":{"min":8,"max":18},"code":"k_uralskiy","country_code":"ru","id":"109","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Караганда","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":false,"traffic":true,"road_network":true},"domain":"kz","bounds":"POLYGON((73.394974 50.132623,73.41063 49.658415,72.880917 49.64993,72.860052 50.123995,73.394974 50.132623))","zoom_level":{"min":8,"max":18},"code":"karaganda","country_code":"kz","id":"84","type":"region","time_zone":{"name":"Asia/Qyzylorda","offset":360}},{"name":"Кемерово","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((86.326511 55.27068,86.327501 55.212118,85.914901 55.209146,85.909911 55.391534,85.878124 55.455955,85.975237 55.53017,86.147776 55.546002,86.177738 55.53357,86.322012 55.534428,86.326511 55.27068))","zoom_level":{"min":8,"max":18},"code":"kemerovo","country_code":"ru","id":"5","type":"region","time_zone":{"name":"Asia/Krasnoyarsk","offset":420}},{"name":"Киров","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((49.036766 58.786454,49.936128 58.797004,49.939573 58.684007,49.959251 58.673889,49.93995 58.668113,49.941856 58.608637,49.954576 58.598196,49.934361 58.587878,49.947791 58.410879,49.279365 58.403646,49.046044 58.381452,49.013389 58.401974,49.056584 58.431236,49.044913 58.641473,49.024698 58.656477,49.042463 58.685214,49.036766 58.786454))","zoom_level":{"min":8,"max":18},"code":"kirov","country_code":"ru","id":"58","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Київ","flags":{"metro":true,"2gis_reviews":true,"public_transport":true,"flamp":false,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ua","bounds":"POLYGON((30.210468 50.619492,31.021354 50.636093,31.039177 50.206516,30.235576 50.190165,30.210468 50.619492))","zoom_level":{"min":8,"max":18},"code":"kiev","country_code":"ua","id":"107","type":"region","time_zone":{"name":"Europe/Kiev","offset":180}},{"name":"Кокшетау","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":false,"road_network":true},"domain":"kz","bounds":"POLYGON((69.004116 53.276659,68.997167 53.318062,69.167949 53.327877,69.161429 53.39313,69.274826 53.383133,69.277034 53.397231,69.315124 53.404166,69.327714 53.370948,69.426323 53.365164,69.615022 53.377566,69.762747 53.305991,69.867178 53.20418,70.039459 53.155209,70.24582 53.165043,70.368026 53.153623,70.404051 53.116561,70.33428 53.02602,70.308269 52.919803,70.236916 52.874545,70.201804 52.871445,70.179755 52.895084,70.12915 52.907667,70.024734 53.010686,69.941737 53.033424,69.930216 53.061288,69.757815 53.113193,69.636768 53.209834,69.457975 53.23141,69.012491 53.225447,69.004116 53.276659))","zoom_level":{"min":8,"max":18},"code":"kokshetau","country_code":"kz","id":"201","type":"region","time_zone":{"name":"Asia/Qyzylorda","offset":360}},{"name":"Комсомольск-на-Амуре","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((136.753811 50.349972,136.732015 50.546639,136.73738 50.63626,136.77424 50.671445,136.80805 50.6719,136.854575 50.708454,137.019275 50.726093,137.047688 50.709087,137.256608 50.703973,137.300987 50.652509,137.309118 50.592302,137.281873 50.545506,137.254966 50.304488,137.178429 50.223625,137.11257 50.180152,137.020128 50.156,136.927338 50.192698,136.781474 50.184059,136.673594 50.228365,136.66226 50.244675,136.69045 50.321326,136.753811 50.349972))","zoom_level":{"min":8,"max":18},"code":"komsomolsk","country_code":"ru","id":"94","type":"region","time_zone":{"name":"Asia/Vladivostok","offset":600}},{"name":"Кострома","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((40.788473 57.681147,40.721084 57.692701,40.692564 57.764686,40.707715 57.874069,40.735404 57.932043,40.981818 57.9303,41.147257 57.918584,41.160962 57.905824,41.137488 57.675732,40.788473 57.681147))","zoom_level":{"min":8,"max":18},"code":"kostroma","country_code":"ru","id":"34","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Краснодар","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((38.648205 45.176459,38.711098 45.219943,38.64025 45.271538,38.739748 45.340829,38.781788 45.31473,38.809501 45.327281,38.918451 45.294308,39.028441 45.284592,39.133021 45.284649,39.126668 45.316536,39.18719 45.315047,39.203489 45.300914,39.195239 45.289067,39.229994 45.265847,39.342399 45.254044,39.341222 45.278697,39.375139 45.284872,39.375049 45.305136,39.42069 45.309048,39.420767 45.33267,39.438429 45.332534,39.438452 45.305691,39.476685 45.305822,39.515106 45.314946,39.514719 45.360149,39.590516 45.360254,39.58218 45.375156,39.61652 45.377122,39.616013 45.441469,39.782302 45.441817,39.884814 45.419673,39.884766 45.432944,39.974064 45.432962,39.972445 45.45423,40.033952 45.458633,40.053085 45.413529,40.05355 45.358697,40.066274 45.359836,40.061038 45.260974,40.084628 45.256029,40.120102 45.278532,40.121369 45.245675,40.087582 45.197403,40.125426 45.184296,40.091663 45.135792,40.103098 45.131839,40.090267 45.099343,40.075233 45.109694,40.067071 45.094767,40.040236 45.102505,39.968812 45.080594,39.932968 45.095803,39.893669 45.084306,39.900028 45.096349,39.8718 45.111831,39.811315 45.113393,39.801652 45.129778,39.779674 45.123251,39.763667 45.136796,39.748665 45.128406,39.679284 45.167582,39.512034 45.037447,39.471249 45.035691,39.477936 44.987874,39.494979 44.975921,39.519018 44.987239,39.504601 44.968403,39.575083 44.942018,39.598598 44.911517,39.642513 44.894467,39.636756 44.878842,39.652507 44.87109,39.56203 44.837481,39.559578 44.806959,39.528955 44.811802,39.525045 44.789938,39.552019 44.795464,39.577078 44.765319,39.607462 44.775225,39.601502 44.742373,39.538293 44.691646,39.527854 44.65156,39.471062 44.640018,39.44626 44.575409,39.400566 44.576687,39.399677 44.556433,39.348204 44.529861,39.434926 44.505319,39.429588 44.483089,39.393221 44.455096,39.318938 44.459505,39.270371 44.426891,39.139535 44.457873,39.087526 44.448877,39.023849 44.38142,39.016852 44.409412,38.988065 44.397481,38.919437 44.421173,38.978084 44.443491,38.917879 44.495954,38.835643 44.510765,38.82169 44.500486,38.801122 44.513945,38.648179 44.489009,38.621174 44.718423,38.637552 44.732517,38.654426 44.726165,38.661505 44.828782,38.628541 44.83052,38.632211 44.886243,38.571424 44.976362,38.57103 45.038671,38.558308 45.040626,38.558543 45.053779,38.583641 45.05373,38.593846 45.138214,38.648205 45.176459))","zoom_level":{"min":8,"max":18},"code":"krasnodar","country_code":"ru","id":"23","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Красноярск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((92.113779 56.321481,92.546479 56.312921,92.686641 56.325006,92.698244 56.291704,92.880347 56.302262,92.918469 56.291319,92.944001 56.307758,92.963621 56.302029,92.967659 56.283178,92.996031 56.282857,93.02555 56.286858,93.024781 56.301334,93.089399 56.288399,93.351495 56.315506,93.353739 56.342098,93.385382 56.363574,93.483792 56.38784,93.525359 56.374674,93.77863 56.398338,93.778276 56.380571,93.821835 56.380351,93.812101 56.372773,93.825779 56.354057,93.727457 56.346694,93.733019 56.312658,93.651538 56.2072,93.676809 56.082704,93.676166 55.971304,93.645915 55.960206,93.693796 55.933158,93.663013 55.903518,93.698591 55.864907,93.668272 55.853942,93.681915 55.826012,93.654649 55.815941,93.650075 55.798052,93.344177 55.79616,93.321039 55.768104,93.279456 55.75733,92.945976 55.703893,92.906977 55.71333,92.906321 55.728977,92.823133 55.719781,92.795316 55.731038,92.781834 55.71597,92.76803 55.762376,92.720126 55.706235,92.706141 55.730738,92.545351 55.70355,92.477531 55.726778,92.405115 55.714618,92.34148 55.750768,92.272349 55.750681,92.271845 55.76861,92.227358 55.785552,92.226932 55.808601,92.118327 55.809971,92.105462 55.889204,91.850422 55.921905,91.746327 55.980599,91.291593 56.116023,91.146534 56.138309,90.665944 56.126281,90.207837 56.179432,90.201484 56.209533,90.182071 56.213938,90.210508 56.261959,90.143113 56.33793,90.479371 56.361035,90.582924 56.405539,90.676753 56.418299,90.8965 56.387376,91.040676 56.345942,91.102184 56.350933,91.305577 56.280725,91.373457 56.331809,91.535323 56.305279,91.781009 56.295613,92.113779 56.321481))","zoom_level":{"min":8,"max":18},"code":"krasnoyarsk","country_code":"ru","id":"7","type":"region","time_zone":{"name":"Asia/Krasnoyarsk","offset":420}},{"name":"Курган","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((65.113307 55.505372,65.3122 55.533618,65.467434 55.529287,65.583217 55.483367,65.594049 55.449838,65.66975 55.429862,65.617468 55.423847,65.574765 55.388161,65.627644 55.301062,65.58624 55.287247,65.576998 55.258639,65.546631 55.243932,65.340727 55.245305,65.185597 55.308037,65.132927 55.350148,65.151683 55.427834,65.119873 55.444896,65.131751 55.467184,65.113307 55.505372))","zoom_level":{"min":8,"max":18},"code":"kurgan","country_code":"ru","id":"10","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Курск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((35.849262 51.606059,35.879043 51.638528,35.8626 51.657259,35.886388 51.672482,35.871927 51.686705,35.895263 51.728444,35.883312 51.751074,35.897331 51.765358,35.891286 51.788043,35.934091 51.831118,36.017808 51.855342,36.110698 51.829456,36.276347 51.856813,36.413323 51.838129,36.425002 51.820996,36.444293 51.714533,36.421006 51.691959,36.432607 51.674272,36.416084 51.660402,36.414402 51.596078,36.391361 51.577032,36.262953 51.554483,36.243018 51.569354,36.13865 51.563039,36.132669 51.548845,35.978087 51.54813,35.820868 51.567552,35.849262 51.606059))","zoom_level":{"min":8,"max":18},"code":"kursk","country_code":"ru","id":"73","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Ленинск-Кузнецкий","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((85.750103 54.768861,86.495701 54.774252,86.502903 54.184679,85.767947 54.179404,85.766991 54.211526,85.745419 54.22624,85.764502 54.294869,85.761107 54.407891,85.705274 54.437493,85.759129 54.473382,85.750103 54.768861))","zoom_level":{"min":8,"max":18},"code":"lenkuz","country_code":"ru","id":"86","type":"region","time_zone":{"name":"Asia/Novokuznetsk","offset":420}},{"name":"Липецк","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.379824 52.626781,39.37616 52.689433,39.437992 52.71159,39.492999 52.757372,39.569775 52.721367,39.602138 52.740383,39.679225 52.720608,39.755873 52.732008,39.865104 52.702656,39.878631 52.711235,39.903903 52.688304,39.838586 52.667735,39.875348 52.630581,39.799054 52.595293,39.869859 52.538809,39.850993 52.479662,39.807101 52.503142,39.546783 52.477641,39.387742 52.513898,39.376843 52.520679,39.41612 52.57348,39.392041 52.58361,39.395286 52.600255,39.36358 52.602605,39.379824 52.626781))","zoom_level":{"min":8,"max":18},"code":"lipetsk","country_code":"ru","id":"56","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Магнитогорск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((59.504226 53.910884,59.464288 53.229865,58.523119 53.245612,58.525287 53.306553,58.507627 53.308733,58.489263 53.338765,58.528757 53.403605,58.547823 53.927025,59.12927 53.927438,59.504226 53.910884))","zoom_level":{"min":8,"max":18},"code":"magnitogorsk","country_code":"ru","id":"26","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Махачкала","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":false,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((47.187874 42.95798,47.182898 42.983038,47.209252 43.00368,47.224663 43.05064,47.218505 43.079063,47.201618 43.08445,47.206434 43.159023,47.25122 43.157566,47.369732 43.200312,47.446098 43.181238,47.667854 43.183177,47.892502 42.734118,47.681265 42.678887,47.553966 42.677473,47.533198 42.703034,47.457293 42.718739,47.227232 42.848998,47.200873 42.894054,47.216738 42.932082,47.187874 42.95798))","zoom_level":{"min":8,"max":18},"code":"makhachkala","country_code":"ru","id":"113","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Миасс и Златоуст","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((59.545758 55.280232,60.258434 55.263275,60.228055 54.888197,59.89406 54.894059,59.771438 54.866503,59.729146 54.886954,59.734627 54.900317,59.522002 54.90492,59.545758 55.280232))","zoom_level":{"min":8,"max":18},"code":"miass","country_code":"ru","id":"87","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Москва","flags":{"metro":true,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((36.843932 55.391978,36.784794 55.397859,36.777835 55.41889,36.815383 55.465206,36.8162 55.507692,36.752402 55.555974,36.766606 55.578763,36.801687 55.582252,36.79972 55.645047,36.773692 55.685786,36.789344 55.74412,36.764182 55.789763,36.789031 55.849394,36.774963 55.851828,36.788479 55.861756,36.771319 55.932067,36.812267 55.953735,36.778755 55.980113,36.768954 56.033447,36.738275 56.063624,36.78088 56.105518,36.764686 56.14976,36.831297 56.180969,36.987334 56.224143,37.181348 56.186352,37.350372 56.224372,37.459617 56.200237,37.553765 56.22045,37.787512 56.230706,37.859514 56.218694,38.144384 56.237691,38.284403 56.225313,38.514408 56.244101,38.527957 56.227682,38.756502 56.230105,38.953443 56.213203,39.079952 56.240858,39.1025 56.228962,39.116844 56.127081,39.090756 56.066463,39.142483 56.020898,39.107487 55.925753,39.130746 55.864247,39.102731 55.80784,39.056191 55.775004,39.034139 55.688025,39.046769 55.638546,39.145126 55.566943,39.074506 55.526778,39.079897 55.500779,39.118629 55.481078,39.093981 55.464646,39.110068 55.373845,39.144718 55.352206,39.084704 55.23022,39.091986 55.184523,39.1251 55.151805,39.089913 55.078944,39.06333 55.066245,39.07943 55.055834,39.055515 55.022353,39.004875 55.036595,38.950345 55.004012,38.888025 55.039996,38.599576 55.020946,38.466983 55.054381,38.086314 55.012933,38.008821 55.024609,37.999858 55.042258,37.94916 55.057919,37.864935 55.020766,37.680995 55.006601,37.663283 55.022916,37.619529 55.025243,37.544039 54.989247,37.420827 54.981554,37.415807 54.962128,37.316566 54.96838,36.773438 55.138651,36.8076 55.152578,36.812302 55.214944,36.787527 55.246629,36.803125 55.284317,36.915699 55.347485,36.843932 55.391978))","zoom_level":{"min":8,"max":18},"code":"moscow","country_code":"ru","id":"32","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Мурманск","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((33.225325 69.064731,33.265186 69.064731,33.265186 69.027421,33.286743 68.9972,33.294137 68.761176,33.566892 68.660816,33.5178 68.538753,33.75677 68.511817,33.741198 68.388309,33.751091 68.341711,33.838172 68.344937,33.99075 68.220577,34.016668 68.173774,34.087206 68.110861,33.990565 68.061996,33.952018 68.022917,33.970512 67.924501,34.17425 67.898561,34.297463 67.90726,34.355219 67.89508,34.354257 67.828489,34.385445 67.778911,34.468613 67.731858,34.597987 67.691075,34.643639 67.587172,34.63382 67.546138,34.431674 67.485337,33.571687 67.444568,32.632767 67.545538,32.211875 67.677328,31.949716 67.689008,31.734705 67.720632,31.760746 67.833984,31.738646 67.934812,31.783979 67.971397,31.892181 67.996356,32.073269 68.159487,32.23191 68.509206,32.289074 68.570651,32.174659 68.65378,32.067711 68.708298,32.347924 68.778872,32.634009 68.817618,32.679829 68.856852,32.703928 68.859229,32.701158 69.064619,33.225325 69.064731))","zoom_level":{"min":8,"max":18},"code":"murmansk","country_code":"ru","id":"96","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Набережные Челны","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((51.723646 55.554874,51.646247 55.574375,51.662207 55.58784,51.65101 55.6276,51.687547 55.640433,51.750524 55.710224,51.706732 55.771285,51.674603 55.784503,51.655854 55.845784,51.789333 55.84846,51.805722 55.856219,51.796582 55.868951,51.914799 55.885486,52.095047 55.849758,52.174898 55.881161,52.234244 55.881702,52.293636 55.853347,52.311799 55.877797,52.33168 55.878953,52.464703 55.858961,52.527841 55.866224,52.622474 55.830049,52.60666 55.798331,52.612551 55.769244,52.591918 55.760726,52.605917 55.756947,52.598503 55.722374,52.632144 55.713565,52.609146 55.696526,52.605417 55.632693,52.618832 55.614353,52.582857 55.607379,52.576773 55.590283,52.510541 55.555623,52.413221 55.54469,52.295177 55.563714,52.171722 55.543903,52.117172 55.555648,51.996244 55.529149,51.935327 55.546367,51.888186 55.540568,51.874118 55.567662,51.723646 55.554874))","zoom_level":{"min":8,"max":18},"code":"nabchelny","country_code":"ru","id":"29","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Находка","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((132.750811 42.90212,133.241339 42.910709,133.248191 42.668281,132.759571 42.659764,132.750811 42.90212))","zoom_level":{"min":8,"max":18},"code":"nahodka","country_code":"ru","id":"82","type":"region","time_zone":{"name":"Asia/Vladivostok","offset":600}},{"name":"Нижневартовск","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((75.931826 61.190935,77.028582 61.178947,77.007817 60.862874,76.79989 60.811169,76.675993 60.819973,76.608242 60.866834,76.574744 60.87297,76.405904 60.85454,75.922257 60.863009,75.931826 61.190935))","zoom_level":{"min":8,"max":18},"code":"nizhnevartovsk","country_code":"ru","id":"12","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Нижний Новгород","flags":{"metro":true,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((43.698905 55.546439,43.70569 55.558721,43.681576 55.561972,43.67454 55.578248,43.593297 55.572642,43.590418 55.602468,43.510025 55.663714,43.534796 55.689363,43.539725 55.72664,43.620532 55.727312,43.632723 55.745959,43.602127 55.74409,43.570877 55.762944,43.570502 55.781537,43.533283 55.778601,43.538975 55.806361,43.525344 55.798613,43.483009 55.820534,43.438804 55.801096,43.435333 55.823104,43.474067 55.84075,43.439979 55.895645,43.449855 55.962492,43.400646 55.983169,43.403214 56.02306,43.350545 56.011747,43.334068 56.019705,43.348812 56.028625,43.30845 56.023735,43.318973 56.03415,43.266285 56.085781,43.285191 56.135121,43.229605 56.165666,43.27404 56.176864,43.268324 56.224575,43.333095 56.277604,43.331742 56.291613,43.262507 56.288856,43.232795 56.46447,43.478804 56.50302,43.556139 56.484948,43.578748 56.436087,43.674309 56.463834,43.651633 56.489502,43.673258 56.501015,43.662704 56.510861,43.74359 56.504769,43.746049 56.537651,43.760063 56.544098,43.898733 56.56825,43.918577 56.550293,43.902015 56.531725,43.929245 56.519835,44.117989 56.489175,44.302017 56.487725,44.257758 56.303471,44.285621 56.293472,44.326035 56.18255,44.263031 56.143551,44.287549 56.109782,44.336492 56.112459,44.324849 56.089192,44.337515 56.078338,44.110198 56.038875,44.119245 56.01916,44.093979 56.002272,44.121 55.997692,44.107902 55.988437,44.123674 55.967723,44.097652 55.9638,44.08311 55.922851,44.103838 55.916349,44.054165 55.890125,44.040117 55.859208,44.110739 55.824992,44.040112 55.80138,44.064329 55.787559,44.066411 55.737674,44.026988 55.659793,44.039148 55.654767,44.011864 55.646937,44.028688 55.631216,44.001 55.611813,43.996515 55.586966,44.026632 55.537536,44.008255 55.530253,44.001105 55.495508,43.966379 55.476111,44.016565 55.438413,44.003405 55.36925,43.913842 55.332731,43.86906 55.287421,43.837718 55.292673,43.802249 55.331555,43.74567 55.33908,43.735367 55.36641,43.687526 55.356322,43.682425 55.372337,43.722341 55.438373,43.727634 55.49936,43.660456 55.500093,43.698905 55.546439))","zoom_level":{"min":8,"max":18},"code":"n_novgorod","country_code":"ru","id":"19","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Нижний Тагил","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((60.386228 58.025926,60.543553 58.1012,60.591976 58.084258,60.59383 58.065848,60.629422 58.071692,60.626558 58.034145,60.588851 58.030923,60.56379 57.970664,60.525869 57.975302,60.478097 57.921059,60.322368 57.884501,60.2264 57.751651,59.763185 57.762607,59.779216 57.972882,59.753076 57.975012,59.802461 58.102842,60.216094 58.067059,60.238445 58.084283,60.309211 58.076303,60.302152 58.057252,60.33775 58.05346,60.329853 58.033965,60.386228 58.025926))","zoom_level":{"min":8,"max":18},"code":"ntagil","country_code":"ru","id":"45","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Новокузнецк","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((86.517836 53.497554,86.514138 53.82036,86.500994 53.827564,86.513934 53.838037,86.512736 53.941118,86.480362 53.944854,86.458678 53.991061,86.492783 54.018733,86.46447 54.054813,86.4792 54.065258,86.618448 54.103252,86.651443 54.130632,87.463657 54.121473,87.456823 53.497654,87.274477 53.498212,87.265593 53.487551,87.250459 53.498264,86.517836 53.497554))","zoom_level":{"min":8,"max":18},"code":"novokuznetsk","country_code":"ru","id":"6","type":"region","time_zone":{"name":"Asia/Novokuznetsk","offset":420}},{"name":"Новороссийск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((38.611788 44.334654,38.50188 44.149785,38.424852 44.176741,38.29588 44.189945,38.06936 44.261427,37.909643 44.39079,37.826166 44.417904,37.75347 44.470943,37.508447 44.490233,37.333602 44.54604,37.216533 44.607242,37.148688 44.663571,37.114741 44.747825,37.062663 44.794421,37.035232 44.845064,36.84376 44.913379,36.952521 45.139209,36.955897 45.231096,37.270595 45.252601,37.323008 45.221241,37.370325 45.225698,37.418648 45.190935,37.469267 45.200845,37.483318 45.221778,37.632022 45.195207,37.665645 45.213873,37.777513 45.211867,37.850508 45.240846,37.862296 45.226127,37.969276 45.232012,38.140004 45.188567,38.395601 45.212132,38.450284 45.20257,38.499801 45.235955,38.581237 45.224853,38.648205 45.176459,38.593846 45.138214,38.583641 45.05373,38.558543 45.053779,38.558308 45.040626,38.57103 45.038671,38.571424 44.976362,38.632211 44.886243,38.628541 44.83052,38.661505 44.828782,38.654426 44.726165,38.637552 44.732517,38.621174 44.718423,38.648179 44.489009,38.670827 44.489693,38.665686 44.474828,38.688965 44.46535,38.630156 44.366958,38.608527 44.361301,38.611788 44.334654))","zoom_level":{"min":8,"max":18},"code":"novorossiysk","country_code":"ru","id":"74","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Новосибирск","flags":{"metro":true,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((85.088133 54.816411,85.002688 54.800048,85.013252 54.779662,84.964301 54.781279,84.910658 54.751737,84.89515 54.728577,84.980047 54.704903,85.004084 54.6799,84.986639 54.667145,85.011185 54.637544,84.917052 54.600394,84.854156 54.601173,84.861065 54.578554,84.810533 54.546933,84.777987 54.546627,84.763373 54.557022,84.771612 54.564639,84.674109 54.541517,84.464711 54.694354,84.351643 54.752476,84.331715 54.747296,84.256032 54.653791,84.142705 54.678399,84.175484 54.689316,84.093196 54.728848,84.095783 54.691032,84.060724 54.662546,84.074733 54.632952,84.066363 54.614937,84.035617 54.589884,83.922557 54.549433,83.937476 54.528926,83.905113 54.502403,83.824504 54.487596,83.838965 54.4588,83.822805 54.43073,83.796516 54.43001,83.814956 54.403784,83.765982 54.39795,83.763786 54.3856,83.823713 54.331402,83.831259 54.301255,83.962024 54.247008,83.968601 54.188796,83.995478 54.190074,83.998623 54.175215,83.931934 54.158279,83.877221 54.122944,83.836223 54.118712,83.830747 54.12978,83.722303 54.101173,83.553128 54.109112,83.531248 54.078262,83.474428 54.062407,83.48778 53.979297,83.439161 53.973706,83.448509 53.947246,83.349582 53.933688,83.292679 54.085893,83.274482 54.051634,83.220299 54.050249,83.196775 54.065401,83.165888 54.051188,83.049376 53.969325,83.025492 53.975652,83.021283 54.00262,82.994051 54.01605,82.76229 54.012318,82.693122 54.106213,82.693979 54.131095,82.645574 54.14543,82.634722 54.248572,82.664822 54.29484,82.68705 54.30104,82.661704 54.35505,82.61106 54.369053,82.547634 54.419858,82.470375 54.420101,82.370414 54.412567,82.371804 54.399905,82.127851 54.268898,82.118361 54.252095,82.134209 54.241847,82.083649 54.219871,82.059678 54.184372,82.068814 54.177768,82.027336 54.157662,82.00034 54.171321,81.941353 54.133285,81.823904 54.099327,81.805615 54.061834,81.756478 54.033153,81.751897 53.99627,81.661622 53.981295,81.587024 53.921394,81.542805 53.909614,81.568083 54.00842,81.613035 54.021479,81.493979 54.02924,81.482831 54.058427,81.442213 54.041825,81.342891 54.08114,81.248852 54.070884,81.216226 54.124181,81.211528 54.112355,81.137057 54.109871,81.087729 54.19626,80.98516 54.294763,80.95166 54.375446,81.015929 54.437403,81.069744 54.449125,81.206379 54.469828,81.232671 54.43442,81.349135 54.442051,81.553585 54.533401,81.510757 54.591568,81.533405 54.612019,81.619201 54.634727,81.648241 54.614816,81.697814 54.622579,81.666411 54.644833,81.719479 54.657871,81.535705 54.795751,81.525131 54.835634,81.576033 54.854323,81.569753 54.873304,81.486161 54.938744,81.457861 54.932468,81.40791 54.950068,81.360969 54.937569,81.361438 54.979388,81.414723 55.001194,81.428126 55.044341,81.472002 55.050177,81.474095 55.080272,81.397608 55.101903,81.459733 55.139028,81.446447 55.247257,81.477305 55.251991,81.330338 55.319242,81.467239 55.352554,81.500579 55.380705,82.154603 55.51402,82.046328 55.623863,81.735848 56.025943,81.553507 56.235201,81.873966 56.305406,82.3392 56.357462,82.499393 56.405493,82.56553 56.399756,82.69004 56.425818,82.774176 56.409006,82.818171 56.429882,82.796319 56.46359,82.80499 56.512522,82.862728 56.535243,82.946637 56.537902,83.02902 56.518057,83.095518 56.54937,83.285825 56.445179,83.254023 56.433978,83.273679 56.431915,83.247805 56.395426,83.143274 56.374558,83.170399 56.342775,83.163827 56.314939,83.114137 56.290972,83.131482 56.275494,83.064804 56.230587,83.108472 56.211577,83.156686 56.227959,83.211845 56.209412,83.213935 56.180724,83.169868 56.18774,83.154684 56.176784,83.183089 56.166603,83.178743 56.153147,83.12927 56.120556,83.182767 56.112253,83.22148 56.086762,83.274055 56.113913,83.301553 56.095779,83.233736 56.059526,83.245146 56.024221,83.230086 56.013203,83.340089 55.978252,83.313369 55.961143,83.403008 55.896203,83.37566 55.89601,83.392788 55.863976,83.385188 55.851263,83.318525 55.854541,83.211507 55.729573,83.314218 55.70373,83.31518 55.687675,83.338522 55.710005,83.445276 55.723903,83.444876 55.694989,83.417853 55.673155,83.428686 55.664132,83.501531 55.706658,83.585493 55.670769,83.599621 55.650771,83.590415 55.616456,83.631408 55.605505,83.597281 55.578084,83.643364 55.58456,83.74695 55.537542,83.793479 55.544837,83.835711 55.529631,83.909543 55.54795,83.926346 55.568309,83.972523 55.555768,83.939427 55.51155,83.964213 55.51613,84.042645 55.444071,84.000495 55.408305,84.150837 55.400365,84.139598 55.439327,84.161904 55.455684,84.213271 55.462875,84.284625 55.43016,84.330678 55.462837,84.456308 55.468194,84.51098 55.506032,84.541189 55.468097,84.595177 55.483997,84.660798 55.479568,84.725026 55.446609,84.620578 55.404334,84.652652 55.380482,84.754742 55.379815,84.818767 55.361752,84.858737 55.375536,84.916854 55.324764,84.915525 55.277327,84.85607 55.260773,84.815445 55.227775,84.917085 55.183553,84.927023 55.163725,84.903557 55.053879,84.837145 54.997021,84.887657 54.969707,84.887673 54.9523,84.971822 54.944968,85.038038 54.873817,85.07845 54.857497,85.046502 54.844635,85.088133 54.816411))","zoom_level":{"min":8,"max":18},"code":"novosibirsk","country_code":"ru","id":"1","type":"region","time_zone":{"name":"Asia/Novosibirsk","offset":420}},{"name":"Новый Уренгой","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":false,"road_network":true},"domain":"ru","bounds":"POLYGON((76.550608 66.176745,77.02186 66.185037,77.085372 66.076551,77.246806 66.036483,77.502758 66.038639,77.717867 66.101555,77.822187 66.070509,78.095049 66.132742,78.197085 66.137732,78.314914 66.113537,78.336981 66.071776,78.412791 66.007583,78.499318 65.98269,78.481427 65.958847,78.460859 65.962934,78.305241 65.861272,78.20881 65.777623,78.042981 65.718308,78.024399 65.691381,77.930064 65.689318,77.877699 65.659784,77.64937 65.641188,77.201953 65.800799,76.921259 65.790684,76.713723 65.823542,76.647881 65.84942,76.600136 65.89055,76.461521 65.914944,76.373292 66.091023,76.387134 66.109593,76.550608 66.176745))","zoom_level":{"min":8,"max":18},"code":"n_urengoy","country_code":"ru","id":"139","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Норильск","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((88.529535 69.242435,86.000942 69.246318,85.986318 69.559455,88.551918 69.555507,88.529535 69.242435))","zoom_level":{"min":8,"max":18},"code":"norilsk","country_code":"ru","id":"76","type":"region","time_zone":{"name":"Asia/Krasnoyarsk","offset":420}},{"name":"Ноябрьск","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((74.30478 63.879187,76.263372 63.875343,76.226155 63.018251,74.325265 63.021954,74.30478 63.879187))","zoom_level":{"min":8,"max":18},"code":"noyabrsk","country_code":"ru","id":"103","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Одесса","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":false,"road_network":true},"domain":"ua","bounds":"POLYGON((30.512168 46.64901,30.896079 46.656702,30.911286 46.261025,30.530141 46.253438,30.512168 46.64901))","zoom_level":{"min":8,"max":18},"code":"odessa","country_code":"ua","id":"14","type":"region","time_zone":{"name":"Europe/Kiev","offset":180}},{"name":"Омск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((72.9275 54.78532,72.877229 54.78445,72.844079 55.404999,73.25143 55.411503,73.27756 55.430606,73.32946 55.412594,73.75247 55.41764,73.762279 55.10337,73.7772 55.094703,73.763533 55.06273,73.771665 54.796804,73.213126 54.789864,73.074267 54.775192,73.059208 54.787499,72.9275 54.78532))","zoom_level":{"min":8,"max":18},"code":"omsk","country_code":"ru","id":"2","type":"region","time_zone":{"name":"Asia/Omsk","offset":360}},{"name":"Оренбург","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((55.397659 51.620872,55.28373 51.637597,54.906781 51.643137,54.906756 51.728877,54.849285 51.718242,54.83241 51.765792,54.875718 51.813504,54.842325 51.851931,55.069006 51.965505,55.133556 51.92549,55.190471 51.924788,55.250638 51.947908,55.269167 51.92153,55.379206 51.921589,55.380686 51.890251,55.463369 51.890643,55.462422 51.862277,55.506478 51.820429,55.515763 51.763054,55.602497 51.740792,55.578399 51.705268,55.603926 51.693925,55.584852 51.664817,55.537511 51.664477,55.499267 51.610351,55.397659 51.620872))","zoom_level":{"min":8,"max":18},"code":"orenburg","country_code":"ru","id":"48","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Орёл","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((35.853124 52.882663,35.840989 52.911897,35.84926 52.994905,35.878061 53.038401,35.860952 53.047981,35.874297 53.056616,35.860656 53.072489,35.871515 53.088745,35.93747 53.082329,35.965898 53.100819,36.064945 53.105009,36.199071 53.086792,36.249337 53.100916,36.329336 53.080138,36.284661 53.059816,36.295392 53.040838,36.284711 53.027058,36.313628 53.019657,36.31769 52.992176,36.346317 52.983267,36.305475 52.952624,36.32892 52.932396,36.28261 52.885783,36.235773 52.876645,36.203546 52.846229,36.106135 52.835902,36.014244 52.859097,35.902308 52.84126,35.864119 52.857087,35.853124 52.882663))","zoom_level":{"min":8,"max":18},"code":"orel","country_code":"ru","id":"71","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Ош","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":false,"pedestrian_routing":true,"road_network":true},"domain":"kg","bounds":"POLYGON((72.880651 40.410746,72.824373 40.386391,72.716869 40.41987,72.700391 40.551882,72.71733 40.589844,72.760236 40.572754,72.74911 40.597372,72.762679 40.627708,72.791396 40.616625,72.843441 40.651018,72.875985 40.619755,72.893399 40.544166,72.880651 40.410746))","zoom_level":{"min":8,"max":18},"code":"osh","country_code":"kg","id":"171","type":"region","time_zone":{"name":"Asia/Bishkek","offset":360}},{"name":"Павлодар","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":false,"road_network":true},"domain":"kz","bounds":"POLYGON((77.223834 52.214201,77.241662 52.014535,76.992875 51.991758,76.9173 51.989277,76.769674 52.020351,76.660819 52.166653,76.600238 52.180226,76.645111 52.229329,76.675924 52.439188,76.992228 52.479541,77.235345 52.446979,77.223834 52.214201))","zoom_level":{"min":8,"max":18},"code":"pavlodar","country_code":"kz","id":"111","type":"region","time_zone":{"name":"Asia/Qyzylorda","offset":360}},{"name":"Пенза","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((45.104058 53.066054,44.963755 53.041572,44.794662 53.061626,44.776161 53.076518,44.770048 53.262088,44.810489 53.286551,44.832085 53.335556,44.977002 53.363303,45.02642 53.389323,45.054239 53.376283,45.061104 53.348888,45.35881 53.348717,45.357781 53.225766,45.391043 53.135605,45.340927 53.030362,45.300415 53.009999,45.155505 53.031889,45.104058 53.066054))","zoom_level":{"min":8,"max":18},"code":"penza","country_code":"ru","id":"42","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Пермь","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((56.921347 59.020265,56.905943 59.002546,56.972596 58.803898,56.885783 58.649364,56.849216 58.539439,56.843605 58.463639,56.899714 58.459027,56.898912 58.430923,56.921007 58.426045,56.899566 58.37942,56.872117 58.368386,56.873707 58.348237,56.909328 58.336781,56.895896 58.307611,56.912771 58.295503,56.896229 58.300431,56.853229 58.270343,56.857187 58.168006,56.825286 58.162266,56.786944 58.052761,56.831451 58.041996,56.816486 58.03891,56.829434 58.018053,56.816349 58.01115,56.824115 57.977059,56.770845 57.981386,56.71997 57.962514,56.749126 57.96009,56.734893 57.949979,56.746497 57.929909,56.815844 57.899191,56.81149 57.874553,56.759037 57.870989,56.822721 57.848471,56.831583 57.830761,56.649625 57.770252,56.606307 57.780272,56.445855 57.745008,56.436767 57.738924,56.461364 57.718418,56.438413 57.713822,56.463189 57.701114,56.454315 57.685357,56.468739 57.658593,56.254311 57.681783,56.249596 57.664133,55.976853 57.68302,55.955104 57.673509,55.983188 57.723328,55.97954 57.755518,55.900356 57.761933,55.908485 57.791562,55.814272 57.782843,55.748424 57.755537,55.716144 57.780353,55.687488 57.780003,55.709884 57.799233,55.702676 57.807087,55.591751 57.823949,55.554895 57.814259,55.589075 57.888804,55.503048 57.902516,55.648536 58.003859,55.619639 58.01355,55.520852 57.993174,55.520067 58.01337,55.504631 58.013045,55.569992 58.050236,55.575935 58.067054,55.554071 58.096959,55.572171 58.120218,55.562953 58.133018,55.648806 58.144972,55.637379 58.15999,55.686498 58.175148,55.681709 58.212463,55.742136 58.205958,55.740747 58.243583,55.788805 58.267762,55.846184 58.287641,55.955649 58.277983,55.980887 58.306921,55.961852 58.316612,55.963489 58.333627,56.007718 58.34083,56.002223 58.323261,56.028648 58.316982,56.068234 58.36527,56.124484 58.364976,56.162678 58.409374,56.148442 58.412692,56.15577 58.430813,56.122181 58.431366,56.071865 58.462076,56.103019 58.501165,56.069958 58.58524,56.260193 58.779141,56.302683 58.883024,56.253783 58.95531,56.239793 59.0072,56.199364 59.01991,56.177032 59.046108,56.221751 59.150502,56.215606 59.220063,56.252426 59.25211,56.472407 59.33059,56.460479 59.357147,56.484969 59.366504,56.39135 59.396913,56.321278 59.389305,56.323657 59.408076,56.413663 59.451677,56.525174 59.578228,56.574141 59.59962,56.643024 59.602979,56.662338 59.592683,56.65927 59.569141,56.72323 59.556509,56.798945 59.56039,56.824834 59.616743,56.87807 59.609381,56.914826 59.622718,56.988254 59.561737,57.076139 59.520211,57.178887 59.512805,57.301958 59.426418,57.268844 59.379168,57.2326 59.378983,57.199205 59.297491,57.164119 59.292824,57.178037 59.284982,57.167344 59.274844,57.192223 59.275825,57.166065 59.265167,57.187326 59.259679,57.171776 59.25297,57.179179 59.244273,57.140821 59.2268,57.16359 59.219585,57.07673 59.192596,57.076428 59.175407,57.128875 59.155157,57.054208 59.148638,57.039587 59.130936,57.057589 59.11709,57.018078 59.098206,56.97406 59.10476,56.921347 59.020265))","zoom_level":{"min":8,"max":18},"code":"perm","country_code":"ru","id":"16","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Петрозаводск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((34.102722 61.959477,34.70885 61.953295,34.694352 61.691472,34.093364 61.697587,34.102722 61.959477))","zoom_level":{"min":8,"max":18},"code":"petrozavodsk","country_code":"ru","id":"80","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Петропавловск-Камчатский","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((158.93997 52.708399,158.207589 52.869935,158.098651 52.921805,158.103729 52.978899,158.122863 53.005263,158.070474 53.123971,158.038502 53.158854,158.036961 53.18785,158.110492 53.246335,158.115759 53.275807,158.172805 53.29123,158.185568 53.360891,158.767001 53.363873,158.934418 53.326234,159.031063 53.266487,159.282336 52.942785,159.099675 52.85838,158.93997 52.708399))","zoom_level":{"min":8,"max":18},"code":"p_kamchatskiy","country_code":"ru","id":"95","type":"region","time_zone":{"name":"Asia/Kamchatka","offset":720}},{"name":"Псков","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((28.236627 57.893868,28.487391 57.87357,28.506529 57.852656,28.489222 57.82986,28.475856 57.739093,28.383826 57.720002,28.314786 57.730288,28.165414 57.714437,28.066706 57.753157,27.879575 57.697647,27.844135 57.700623,27.81286 57.73521,27.718068 57.752111,27.662905 57.797518,27.618062 57.782609,27.541574 57.823176,27.70805 57.848447,27.740926 57.827721,27.795637 57.841216,27.800355 57.854737,27.8879 57.839632,27.916041 57.860544,27.912105 57.876503,28.167686 57.912474,28.236627 57.893868))","zoom_level":{"min":8,"max":18},"code":"pskov","country_code":"ru","id":"90","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Республика Алтай","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((86.741415 52.1575,86.740159 52.171359,86.801044 52.158722,86.805639 52.187755,86.723874 52.197203,86.767102 52.243,86.783393 52.293024,86.693579 52.294799,86.68961 52.341377,86.667052 52.342734,86.642405 52.402575,86.62298 52.406021,86.62298 52.423775,86.679427 52.43683,86.676711 52.466176,86.649409 52.494794,86.661859 52.498895,86.627938 52.52683,86.722129 52.508723,86.763347 52.524257,86.794917 52.514808,86.775138 52.595801,86.821192 52.608641,86.809816 52.648098,86.844945 52.6264,86.932994 52.635155,86.936726 52.654524,86.989466 52.658492,87.012755 52.642514,87.068836 52.657448,87.099071 52.619226,87.134484 52.616339,87.11888 52.598563,87.197136 52.57321,87.218457 52.58875,87.297162 52.59237,87.33368 52.572745,87.37119 52.573691,87.371806 52.498746,87.428271 52.49947,87.494308 52.474214,87.539995 52.483464,87.583791 52.46215,87.611621 52.47148,87.623351 52.464791,87.610656 52.456439,87.617976 52.438341,87.653327 52.422416,87.700823 52.464322,87.732916 52.462713,87.755305 52.484868,87.845122 52.491026,87.864908 52.518856,87.892618 52.525854,87.891369 52.539479,88.021112 52.511055,88.123465 52.462634,88.143614 52.428852,88.231529 52.400058,88.281036 52.414455,88.310877 52.436896,88.317271 52.464244,88.445685 52.432956,88.442629 52.40601,88.406032 52.378341,88.463945 52.341503,88.403297 52.311662,88.391393 52.292277,88.402091 52.276754,88.380374 52.273215,88.396944 52.239674,88.363573 52.169065,88.374518 52.154623,88.360185 52.146284,88.378254 52.12461,88.286261 52.111732,88.248387 52.07755,88.25247 52.0458,88.178285 52.065758,88.151791 52.095988,88.126426 52.068234,88.061536 52.044389,88.057627 52.016808,88.087596 52.000021,87.97684 51.952266,88.001771 51.941712,88.001424 51.916173,87.945307 51.885704,87.934536 51.848568,87.898573 51.822291,87.882589 51.782897,87.932712 51.784547,87.991173 51.751386,88.084121 51.758335,88.110094 51.740266,88.106794 51.70856,88.076043 51.674834,88.019145 51.664388,88.00125 51.632399,88.003943 51.58927,87.959032 51.576348,87.950085 51.55133,87.900397 51.551548,87.934449 51.526312,87.945742 51.475191,88.052328 51.466461,88.141106 51.428543,88.125209 51.394057,88.143278 51.386152,88.133288 51.374165,88.156395 51.348495,88.187319 51.359006,88.315101 51.344413,88.325265 51.32452,88.401447 51.308059,88.424641 51.286255,88.590383 51.323347,88.631385 51.385349,88.700879 51.39093,88.693842 51.440444,88.680552 51.44444,88.692452 51.480816,88.658053 51.52805,88.750393 51.545358,88.763075 51.561429,88.79735 51.549455,88.814539 51.520634,88.846101 51.516319,88.863883 51.467884,88.919894 51.46392,89.004949 51.398852,89.006801 51.373922,88.985834 51.361067,88.997689 51.321504,88.960126 51.248341,88.9765 51.239932,88.960719 51.228301,88.963313 51.206481,89.031326 51.186793,89.049849 51.159806,89.036513 51.144358,89.048664 51.119576,89.022288 51.102517,89.054147 51.08231,89.054221 51.047136,89.100972 51.037486,89.123199 51.007425,89.192472 50.982957,89.241964 50.921557,89.268044 50.915982,89.267748 50.880456,89.346949 50.881253,89.348579 50.859675,89.398663 50.850525,89.375918 50.826409,89.390217 50.809925,89.453415 50.79257,89.477939 50.745449,89.528394 50.724075,89.582776 50.645801,89.639825 50.642893,89.631972 50.617147,89.649457 50.576936,89.729103 50.568638,89.85135 50.524889,89.842163 50.499885,89.865649 50.472046,89.8189 50.411201,89.735772 50.409274,89.707322 50.384121,89.664721 50.38501,89.655164 50.369729,89.613229 50.374267,89.58989 50.428129,89.50291 50.459801,89.510615 50.449948,89.4915 50.44528,89.48135 50.399919,89.501577 50.385732,89.496835 50.363912,89.381479 50.338889,89.379479 50.314921,89.406595 50.314032,89.390296 50.28636,89.343768 50.264245,89.333026 50.21668,89.308428 50.207937,89.403485 50.177932,89.440603 50.203696,89.520175 50.191731,89.532474 50.147871,89.511507 50.11931,89.58241 50.106974,89.592042 50.084192,89.533956 50.065855,89.524696 50.03935,89.543959 50.01503,89.592932 50.01553,89.598711 49.984524,89.62479 49.970855,89.608713 49.963743,89.614715 49.939182,89.591721 49.912627,89.63088 49.899345,89.611741 49.86352,89.651037 49.82644,89.624463 49.806369,89.673452 49.783475,89.711881 49.790098,89.7192 49.7283,89.6074 49.686,89.461564 49.666217,89.427352 49.619381,89.405269 49.621127,89.3846 49.6062,89.391 49.5953,89.36 49.5844,89.2506 49.6423,89.193637 49.634683,89.182398 49.622898,89.199073 49.604776,89.191469 49.58602,89.2327 49.5537,89.2009 49.5228,88.9845 49.4637,88.9326 49.5168,88.9295 49.5429,88.90009 49.558961,88.869615 49.546741,88.879675 49.513767,88.8571 49.4918,88.8801 49.4781,88.8534 49.4667,88.8628 49.4595,88.8429 49.4416,88.8022 49.4604,88.6836 49.4622,88.5992 49.5009,88.4949 49.4719,88.445 49.4726,88.4059 49.4946,88.368004 49.483846,88.3312 49.4935,88.297742 49.470898,88.221784 49.47966,88.165591 49.445452,88.184379 49.415928,88.118763 49.390801,88.124131 49.372926,88.160451 49.362761,88.170112 49.293567,88.106706 49.256569,88.054756 49.258389,88.056412 49.241085,88.017979 49.226295,87.988438 49.18302,87.805862 49.168484,87.695023 49.175738,87.670519 49.15207,87.492854 49.138516,87.503232 49.09253,87.427347 49.071318,87.28579 49.115872,87.303812 49.172181,87.291593 49.201769,87.309671 49.233885,87.198325 49.252499,87.02935 49.253989,87.006045 49.298864,86.970987 49.305851,86.926469 49.348878,86.924715 49.369818,86.9492 49.379942,86.936266 49.400195,86.947328 49.409624,86.833377 49.452247,86.82972 49.48174,86.855415 49.49914,86.814847 49.532322,86.827174 49.545425,86.739513 49.571169,86.665905 49.560272,86.618249 49.570377,86.597577 49.609524,86.615549 49.628524,86.659159 49.643789,86.665733 49.665502,86.699725 49.684973,86.72419 49.676651,86.778924 49.696016,86.752998 49.742395,86.782843 49.793792,86.735862 49.787154,86.688375 49.810899,86.590212 49.80559,86.6105 49.768929,86.582292 49.724142,86.509239 49.690951,86.488451 49.65791,86.428612 49.629352,86.420003 49.60759,86.2716 49.5827,86.267004 49.546539,86.202038 49.466113,86.17391 49.478979,86.166345 49.503304,86.112922 49.524383,86.037199 49.521846,86.024507 49.503727,85.968991 49.487116,85.929409 49.535866,85.944281 49.561326,85.883737 49.566907,85.826225 49.544254,85.809912 49.565881,85.75689 49.57715,85.677689 49.550396,85.589914 49.614381,85.553288 49.594414,85.490205 49.598129,85.38844 49.634803,85.321261 49.590847,85.257519 49.588524,85.264671 49.619788,85.210125 49.627086,85.215526 49.71853,85.203369 49.745268,85.148748 49.76791,85.144565 49.796419,85.101607 49.824213,85.100427 49.852116,85.059699 49.885036,84.985489 49.906772,84.984927 49.949919,84.972947 49.954279,84.994726 49.970128,84.978046 49.976294,85.049258 50.010397,85.035365 50.018876,85.035543 50.052494,84.974827 50.066958,84.945831 50.09661,84.8507 50.0939,84.813908 50.120772,84.825375 50.142985,84.75802 50.136943,84.692012 50.188623,84.628187 50.210679,84.567522 50.196841,84.456801 50.247256,84.409847 50.209226,84.362523 50.205465,84.251587 50.290141,84.272029 50.320659,84.269559 50.353755,84.242026 50.376855,84.241988 50.408662,84.203975 50.468975,84.232571 50.483066,84.248707 50.515566,84.230577 50.540242,84.169136 50.551745,84.144961 50.605966,84.115294 50.609194,84.080418 50.639877,84.127972 50.659636,84.343851 50.686268,84.397739 50.710053,84.42595 50.682196,84.473729 50.687078,84.514354 50.721437,84.511298 50.765456,84.557563 50.779921,84.589885 50.823992,84.539808 50.847646,84.437357 50.859917,84.438271 50.908374,84.490696 50.948059,84.34091 50.980694,84.305924 51.003878,84.222168 50.987377,84.127497 51.014216,84.101388 51.042257,84.061625 51.032231,84.02079 51.044188,84.038283 51.057608,83.943117 51.069148,83.956379 51.11019,83.932919 51.138087,84.042042 51.15374,84.096635 51.143349,84.069691 51.110609,84.120656 51.071237,84.146973 51.104134,84.153865 51.182773,84.179634 51.192381,84.200886 51.227941,84.192322 51.247157,84.234305 51.255878,84.256471 51.282613,84.331794 51.290341,84.376937 51.267314,84.412915 51.271282,84.452913 51.287731,84.458891 51.317025,84.633715 51.34705,84.641286 51.374725,84.68306 51.391487,84.716156 51.426799,84.766555 51.417022,84.849529 51.442452,84.897987 51.437753,84.923129 51.465532,84.92057 51.482868,84.989627 51.513625,85.111038 51.524095,85.166854 51.486525,85.195571 51.485502,85.244031 51.499162,85.260818 51.528716,85.29912 51.530649,85.305882 51.555556,85.449976 51.566314,85.446007 51.601769,85.479896 51.623074,85.48206 51.69047,85.582319 51.697222,85.626286 51.747247,85.623264 51.782779,85.539096 51.838252,85.536318 51.859355,85.616988 51.871872,85.544145 51.942899,85.585383 51.992331,85.682498 52.024578,85.701278 52.096576,85.74295 52.113436,85.850951 52.105479,85.869512 52.130262,85.898144 52.119127,85.914404 52.147076,86.116311 52.165694,86.114619 52.151813,86.132003 52.149228,86.172874 52.173167,86.282628 52.190286,86.4337 52.165022,86.466748 52.142065,86.456421 52.12839,86.60878 52.104938,86.648831 52.105669,86.688594 52.140995,86.725961 52.139143,86.741415 52.1575))","zoom_level":{"min":8,"max":18},"code":"gornoaltaysk","country_code":"ru","id":"27","type":"region","time_zone":{"name":"Asia/Barnaul","offset":420}},{"name":"Ростов-на-Дону","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.35785 47.239013,39.358001 47.261508,39.310916 47.264747,39.31884 47.283311,39.486713 47.328345,39.559365 47.376813,39.734563 47.385205,39.734689 47.417805,39.804088 47.425666,39.868718 47.455781,39.864309 47.46816,39.878046 47.471547,39.834574 47.516331,39.861573 47.526634,39.996426 47.5208,40.038389 47.479463,40.012236 47.457735,40.036528 47.436502,40.028784 47.420259,39.983399 47.415849,39.96051 47.363195,39.924723 47.358403,39.919436 47.053314,39.746241 47.04353,39.743526 47.06029,39.619994 47.050119,39.618758 47.062267,39.541011 47.061609,39.535676 47.040827,39.367812 47.036168,39.355318 47.048678,39.35785 47.239013))","zoom_level":{"min":8,"max":18},"code":"rostov","country_code":"ru","id":"24","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Рязань","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.404406 54.733859,39.344055 54.776871,39.415177 54.839913,39.388799 54.854473,39.401008 54.870252,39.444898 54.883538,39.576876 54.908518,39.610584 54.901857,39.615095 54.881368,40.082101 54.878236,40.072595 54.486578,39.402002 54.490668,39.391534 54.582714,39.402966 54.588546,39.404406 54.733859))","zoom_level":{"min":8,"max":18},"code":"ryazan","country_code":"ru","id":"44","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Самара","flags":{"metro":true,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((50.543117 53.364846,50.533219 53.25976,50.516002 53.24489,50.55769 53.126904,50.543375 53.056351,50.412611 53.01015,49.973323 53.005299,49.910829 53.01341,49.899516 53.033312,49.747249 53.03528,49.787691 53.052236,49.794395 53.092844,49.807912 53.096481,49.77879 53.208185,49.796888 53.215506,49.792086 53.25618,49.777904 53.256952,49.787115 53.322185,49.74678 53.316751,49.707458 53.33157,49.681209 53.442657,49.728745 53.443838,49.733939 53.534138,49.794308 53.574405,49.762931 53.605617,49.797112 53.630996,49.7745 53.644768,49.811818 53.695905,50.005342 53.741546,50.225728 53.761331,50.240908 53.787848,50.328294 53.771345,50.364095 53.787345,50.497233 53.712068,50.588739 53.573857,50.567375 53.566267,50.613965 53.422232,50.543117 53.364846))","zoom_level":{"min":8,"max":18},"code":"samara","country_code":"ru","id":"18","type":"region","time_zone":{"name":"Europe/Samara","offset":240}},{"name":"Санкт-Петербург","flags":{"metro":true,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((29.434359 59.946365,29.445579 59.959851,29.384119 60.174382,29.405012 60.224502,29.400164 60.252241,29.521252 60.258295,29.627703 60.278179,29.66498 60.299917,29.84095 60.308972,30.06164 60.281094,30.242995 60.303807,30.447249 60.290476,30.523715 60.320691,30.752071 60.301317,30.816189 60.315166,30.855095 60.301614,30.942787 60.325074,31.105005 60.16026,31.168335 60.018131,31.106791 59.898566,31.063075 59.885463,31.112742 59.796151,31.086122 59.724592,31.033585 59.698741,31.064892 59.563652,31.04545 59.524782,30.970836 59.485961,30.80349 59.478467,30.697059 59.506842,30.561983 59.47743,30.428788 59.490007,30.359155 59.480736,30.348887 59.463495,30.110774 59.492718,30.080227 59.491851,30.062839 59.468795,29.931194 59.489972,29.738708 59.469542,29.602223 59.489989,29.523615 59.476495,29.456031 59.535583,29.458275 59.633169,29.434451 59.70411,29.45926 59.780422,29.482875 59.793804,29.406808 59.808405,29.390717 59.828508,29.430398 59.891821,29.419245 59.945138,29.434359 59.946365))","zoom_level":{"min":8,"max":18},"code":"spb","country_code":"ru","id":"38","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Саранск","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((45.081871 54.301948,45.511721 54.300891,45.507836 53.984632,44.868027 53.985633,44.867159 54.263361,44.852386 54.305301,45.081871 54.301948))","zoom_level":{"min":8,"max":18},"code":"saransk","country_code":"ru","id":"85","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Саратов","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((45.856039 51.724488,45.992106 51.720064,46.06242 51.754989,46.09597 51.802026,46.136889 51.825832,46.181012 51.820402,46.208087 51.850335,46.357733 51.821791,46.430843 51.835331,46.409443 51.716977,46.433873 51.728667,46.486963 51.718232,46.493745 51.696684,46.540915 51.696023,46.588358 51.65045,46.525517 51.644371,46.496915 51.621779,46.531394 51.605031,46.510981 51.609141,46.51517 51.59486,46.418306 51.562717,46.334533 51.362232,46.364391 51.356598,46.309454 51.254999,46.280529 51.260371,46.253535 51.195964,45.636831 51.218825,45.629584 51.289772,45.675365 51.374963,45.57571 51.450277,45.542994 51.5536,45.559352 51.587834,45.534988 51.607904,45.560031 51.644779,45.527193 51.639659,45.502507 51.673286,45.531848 51.694726,45.520355 51.708246,45.581883 51.699862,45.63943 51.74748,45.71945 51.781457,45.77254 51.765501,45.81311 51.725493,45.856039 51.724488))","zoom_level":{"min":8,"max":18},"code":"saratov","country_code":"ru","id":"43","type":"region","time_zone":{"name":"Europe/Saratov","offset":240}},{"name":"Саяногорск","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":false,"road_network":true},"domain":"ru","bounds":"POLYGON((91.574125 53.166227,91.585384 52.823144,91.303032 52.819442,91.287154 53.222249,91.571805 53.225993,91.574125 53.166227))","zoom_level":{"min":8,"max":18},"code":"sayanogorsk","country_code":"ru","id":"194","type":"region","time_zone":{"name":"Asia/Krasnoyarsk","offset":420}},{"name":"Смоленск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((32.015394 54.690209,31.835486 54.688614,31.7783 54.707531,31.759145 54.729714,31.758252 54.779403,31.779213 54.858475,31.799064 54.879794,31.835458 54.883678,31.999494 54.881113,32.100553 54.907209,32.168106 54.944012,32.211606 54.918212,32.270858 54.815571,32.247847 54.735598,32.167074 54.698384,32.015394 54.690209))","zoom_level":{"min":8,"max":18},"code":"smolensk","country_code":"ru","id":"63","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Сочи","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((40.383094 43.821667,40.365371 43.773998,40.389201 43.76582,40.370934 43.72688,40.452068 43.724357,40.464546 43.712482,40.44948 43.671334,40.460069 43.655847,40.552923 43.623576,40.604766 43.587745,40.653978 43.584486,40.661776 43.563048,40.564559 43.519058,40.50541 43.524875,40.477821 43.549126,40.259202 43.586214,40.103393 43.568154,40.095163 43.529315,40.010289 43.425017,40.009014 43.385546,39.88448 43.224431,39.849882 43.228041,39.713913 43.282428,39.641385 43.368903,39.517373 43.438142,39.471188 43.494287,39.398814 43.537163,39.334137 43.608194,39.12771 43.776747,38.852504 43.952338,38.797372 44.002146,38.691373 44.050731,38.623879 44.118782,38.50188 44.149785,38.612587 44.335728,38.608527 44.361301,38.630156 44.366958,38.638208 44.396334,38.678873 44.431986,38.688965 44.46535,38.665686 44.474828,38.670827 44.489693,38.801122 44.513945,38.937865 44.485387,38.978084 44.443491,38.919437 44.421173,38.988065 44.397481,39.016852 44.409412,39.029765 44.392764,39.017479 44.38142,39.063696 44.409298,39.05287 44.420898,39.083895 44.44668,39.139535 44.457873,39.417834 44.381504,39.490156 44.346222,39.482191 44.324272,39.503685 44.298895,39.585877 44.276664,39.634013 44.283478,39.673372 44.314531,39.733904 44.282985,39.793339 44.332707,39.895499 44.351638,39.974611 44.338574,40.067177 44.369326,40.077202 44.320229,40.104932 44.310694,40.193777 44.355403,40.189229 44.337124,40.204925 44.326856,40.284236 44.329373,40.336778 44.304877,40.384576 44.319191,40.384083 44.284023,40.418532 44.278134,40.359829 44.246745,40.406793 44.167246,40.405546 44.132848,40.432671 44.114017,40.413294 44.063314,40.480476 43.964506,40.409687 43.938768,40.402758 43.894816,40.420424 43.882593,40.383094 43.821667))","zoom_level":{"min":8,"max":18},"code":"sochi","country_code":"ru","id":"30","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Ставрополь","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((41.71342 44.893581,41.685529 44.896281,41.667935 44.929958,41.661667 45.008331,41.692812 45.027643,41.698853 45.060774,41.669371 45.069375,41.670132 45.103091,41.657403 45.103223,41.65798 45.130207,41.677233 45.13,41.671025 45.193197,41.697373 45.19275,41.697868 45.248583,41.812934 45.256127,41.954393 45.233953,41.994568 45.261419,42.147241 45.270428,42.304986 45.202801,42.366514 45.133954,42.317058 45.003834,42.242955 44.960936,42.11413 44.931575,42.061039 44.894863,42.040056 44.90999,41.999899 44.895762,41.944234 44.913399,41.71342 44.893581))","zoom_level":{"min":8,"max":18},"code":"stavropol","country_code":"ru","id":"57","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Старый Оскол","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((37.988967 51.393172,38.033751 51.338068,38.014496 51.330424,38.029978 51.322342,38.065141 51.230624,37.99364 51.155762,37.975804 51.115372,37.89047 51.137642,37.867872 51.194118,37.752363 51.240665,37.711636 51.276762,37.748802 51.303268,37.718561 51.367014,37.830964 51.42328,37.971237 51.414969,37.988967 51.393172))","zoom_level":{"min":8,"max":18},"code":"staroskol","country_code":"ru","id":"60","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Стерлитамак","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((56.141291 53.395949,56.132481 53.322821,56.107835 53.306713,55.876997 53.303411,55.850201 53.317461,55.762754 53.429216,55.710701 53.440577,55.691776 53.492937,55.796363 53.556787,55.817194 53.688315,55.940534 53.745092,56.108566 53.731209,56.140225 53.685013,56.150362 53.610702,56.128378 53.523897,56.141291 53.395949))","zoom_level":{"min":8,"max":18},"code":"sterlitamak","country_code":"ru","id":"54","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Сургут","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((72.38176 61.388553,73.693324 61.407472,73.718338 61.430866,73.826706 61.418172,73.782279 61.384658,73.797164 60.996565,72.41568 60.977161,72.38176 61.388553))","zoom_level":{"min":8,"max":18},"code":"surgut","country_code":"ru","id":"39","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Сыктывкар","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((50.657504 61.527715,50.636068 61.539362,50.589385 61.519683,50.584943 61.502181,50.358049 61.524635,50.374515 61.558666,50.155553 61.579157,50.192685 61.663327,50.211824 61.66137,50.219814 61.67932,50.259702 61.675254,50.297554 61.796039,50.390698 61.787261,50.470677 61.976617,50.518438 62.005444,50.658374 61.998829,50.700115 61.965373,50.831057 61.968262,51.042965 61.943237,51.023169 61.898419,51.300937 61.871537,51.285704 61.836303,51.363189 61.812802,51.439821 61.82162,51.438722 61.778192,51.451565 61.776999,51.394151 61.675321,51.254831 61.689574,51.204445 61.576752,51.047363 61.592638,51.012532 61.514285,50.742016 61.546535,50.657504 61.527715))","zoom_level":{"min":8,"max":18},"code":"syktyvkar","country_code":"ru","id":"72","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Таганрог","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":false,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((38.960129 47.28818,38.973252 47.204558,38.95631 47.187762,38.765481 47.21002,38.808288 47.238429,38.799428 47.250036,38.820496 47.271938,38.960129 47.28818))","zoom_level":{"min":8,"max":18},"code":"taganrog","country_code":"ru","id":"116","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Тамбов","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((41.260005 52.567998,41.268479 52.731323,41.236387 52.735174,41.271138 52.78225,41.274267 52.841987,41.459271 52.838296,41.480049 52.862206,41.51864 52.846945,41.517378 52.833462,41.638962 52.800252,41.641853 52.769172,41.602466 52.733497,41.596914 52.674708,41.615396 52.638425,41.609795 52.616906,41.625776 52.610338,41.587211 52.551951,41.481204 52.574653,41.359109 52.55523,41.260005 52.567998))","zoom_level":{"min":8,"max":18},"code":"tambov","country_code":"ru","id":"81","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Тверь","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((35.607908 56.678784,35.570898 56.695545,35.538946 56.757706,35.588963 56.772938,35.591409 56.789031,35.571466 56.851008,35.537348 56.874905,35.532145 56.924343,35.508421 56.938997,35.556666 56.956783,35.570436 56.978595,35.664379 57.00865,35.73051 57.007665,35.808084 57.041392,35.898954 57.050067,35.97844 57.037342,36.015941 57.015087,36.337513 56.974103,36.352173 56.854836,36.323448 56.787361,36.361046 56.758043,36.270183 56.694838,36.239273 56.682469,35.607908 56.678784))","zoom_level":{"min":8,"max":18},"code":"tver","country_code":"ru","id":"47","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Тобольск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((68.027461 58.334051,68.202464 58.347584,68.330932 58.333173,68.627747 58.337205,68.630591 58.064257,68.610922 58.051367,68.515642 58.063872,68.03489 58.061137,68.027461 58.334051))","zoom_level":{"min":8,"max":18},"code":"tobolsk","country_code":"ru","id":"97","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Тольятти","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((49.757851 53.315548,49.787115 53.322185,49.777904 53.256952,49.792086 53.25618,49.796888 53.215506,49.77879 53.208185,49.807912 53.096481,49.794395 53.092844,49.787691 53.052236,49.664636 53.027741,49.576552 53.034333,49.572233 53.048521,49.544847 53.040739,49.543582 53.06297,49.510492 53.066913,49.456518 53.050985,49.452008 53.035115,49.41868 53.036828,49.417156 53.018136,49.366877 53.00935,49.341312 52.985902,49.198784 53.018644,49.194897 52.941977,49.182276 52.932441,49.108312 52.935222,49.107225 52.912333,49.025792 52.908694,48.986242 52.882038,48.929584 52.908165,48.946418 52.921663,48.892282 52.946993,48.850016 52.927677,48.73638 52.978646,48.715833 52.962543,48.666568 52.986212,48.634927 52.967427,48.576346 52.99159,48.487947 52.989752,48.519065 52.958914,48.499645 52.940519,48.449405 52.952114,48.439113 52.972607,48.359834 52.957324,48.353057 52.973451,48.371755 52.99315,48.325122 52.997345,48.342014 53.058921,48.159756 53.086096,48.212202 53.137432,48.107527 53.180833,48.111779 53.204457,48.218927 53.261041,48.246979 53.305485,48.275755 53.290227,48.385685 53.315284,48.472727 53.283413,48.536172 53.325795,48.611318 53.314063,48.637623 53.320761,48.640492 53.338086,48.705562 53.336534,48.731976 53.373765,48.769055 53.382194,48.758106 53.407056,48.849668 53.39149,48.872272 53.435382,48.830441 53.465481,48.909851 53.478603,48.894586 53.491142,48.90861 53.509192,48.933523 53.515975,48.941069 53.497287,48.98353 53.533523,48.949824 53.578564,48.939025 53.648958,48.994849 53.715323,49.253207 53.696572,49.246297 53.718195,49.273159 53.733744,49.300792 53.711797,49.371995 53.723999,49.626178 53.677744,49.640868 53.72903,49.815231 53.714027,49.804274 53.670863,49.7745 53.644768,49.797836 53.632407,49.762931 53.605617,49.794308 53.574405,49.733939 53.534138,49.728745 53.443838,49.681209 53.442657,49.707458 53.33157,49.757851 53.315548))","zoom_level":{"min":8,"max":18},"code":"togliatti","country_code":"ru","id":"22","type":"region","time_zone":{"name":"Europe/Samara","offset":240}},{"name":"Томск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((84.783402 56.581901,84.991724 56.591998,84.974638 56.639988,85.004481 56.687753,85.045182 56.688676,85.070721 56.678106,85.073288 56.650464,85.096105 56.650621,85.097019 56.637889,85.206565 56.608536,85.279646 56.569455,85.342194 56.524661,85.372239 56.469756,85.402749 56.459643,85.375987 56.453381,85.389566 56.411841,85.248355 56.351724,85.170078 56.345417,85.137633 56.327633,84.831578 56.323503,84.680085 56.540089,84.760897 56.558353,84.783402 56.581901))","zoom_level":{"min":8,"max":18},"code":"tomsk","country_code":"ru","id":"3","type":"region","time_zone":{"name":"Asia/Tomsk","offset":420}},{"name":"Тула","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((38.399267 54.266118,38.470992 54.193999,38.508234 54.178173,38.515886 54.160246,38.501516 54.156541,38.534027 54.123972,38.600428 54.112699,38.569552 54.063692,38.592478 54.044262,38.572731 54.016646,38.551337 54.01423,38.550516 53.995377,38.638449 53.9623,38.568617 53.959038,38.457578 53.848801,38.401631 53.820618,38.220688 53.849514,38.198672 53.864001,38.200643 53.890444,38.147397 53.902982,38.12458 53.891291,38.069076 53.910786,38.051279 53.901962,38.027663 53.918465,37.919557 53.890565,37.899904 53.90477,37.464798 53.889914,37.429616 53.899539,37.418328 54.197775,37.368526 54.228625,37.38038 54.252292,37.415747 54.265208,37.425436 54.309681,37.53468 54.311057,37.552533 54.334955,37.677493 54.300075,37.727011 54.316028,37.915046 54.315078,37.962779 54.325534,37.98144 54.352026,38.159244 54.352882,38.194297 54.365283,38.205572 54.354426,38.289137 54.372007,38.298507 54.345095,38.340918 54.328254,38.343188 54.300073,38.399267 54.266118))","zoom_level":{"min":8,"max":18},"code":"tula","country_code":"ru","id":"36","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Тюмень","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((66.665516 57.236788,66.690851 57.236046,66.695691 57.221026,66.673562 57.06223,66.712652 57.016171,66.674961 56.962332,66.657754 56.901559,66.621048 56.52188,66.655094 56.516231,66.618862 56.498976,66.609235 56.397678,65.560375 56.416201,65.461425 56.437632,65.307668 56.400165,65.196699 56.429248,65.170515 56.463611,65.216947 56.494441,65.243024 56.934976,65.203136 57.082456,65.184508 57.090626,65.199421 57.108857,65.184607 57.113573,65.198384 57.119297,65.193532 57.136906,65.17139 57.137306,65.18333 57.151991,65.169414 57.165587,65.199666 57.186041,65.169046 57.188989,65.172235 57.205579,65.182515 57.232831,65.217693 57.249693,65.209177 57.262337,65.361132 57.304899,65.762215 57.307211,65.809373 57.258866,66.665516 57.236788))","zoom_level":{"min":8,"max":18},"code":"tyumen","country_code":"ru","id":"13","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Улан-Удэ","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((106.861968 51.716814,106.283352 51.667014,106.28283 51.733313,106.305681 51.758435,106.218217 51.785023,106.204013 51.835589,105.872764 52.053418,106.172533 52.361056,106.999934 52.716939,108.012655 53.233717,108.297403 53.673511,108.373418 53.764052,108.929363 54.269942,109.543217 54.137962,109.571009 54.113442,109.576767 54.085589,109.623624 54.05345,109.783346 54.037236,109.79646 54.023096,109.820289 54.032949,110.109045 53.946227,110.190087 53.942366,110.228012 53.881763,110.033421 53.822867,110.026644 53.786567,109.95741 53.769449,109.79495 53.658651,109.827281 53.640473,109.82049 53.63228,109.774956 53.628465,109.772408 53.611417,109.728834 53.582666,109.676847 53.576952,109.681191 53.513946,109.693225 53.506872,109.665725 53.503162,109.672112 53.452787,109.586413 53.447626,109.606989 53.431008,109.586024 53.413111,109.606315 53.368601,109.208361 52.884073,109.140834 52.856747,109.056377 52.847811,108.921689 52.788249,108.905273 52.758485,108.857134 52.727341,108.866852 52.705676,108.836543 52.692437,108.837103 52.654528,108.806788 52.65392,108.750081 52.613573,108.756079 52.587244,108.72445 52.553625,108.743334 52.538009,108.735983 52.524572,108.709908 52.507941,108.614333 52.500895,108.59248 52.474767,108.520384 52.453709,108.455362 52.391449,108.417289 52.327266,108.384674 52.31775,108.396699 52.298447,108.366236 52.255853,108.316805 52.246193,108.334497 52.219036,108.316998 52.199566,108.225298 52.173283,108.183579 52.191812,108.099225 52.168549,108.081204 52.141838,108.047051 52.144982,108.045473 52.101028,107.94766 52.082032,107.868383 52.045537,107.990789 52.042492,107.96757 51.691351,107.72592 51.697211,107.71946 51.666309,107.686974 51.655509,107.693405 51.633601,107.653763 51.635855,107.6514 51.622049,107.625089 51.622971,107.620335 51.60418,107.578042 51.588984,107.519873 51.597276,107.511453 51.583054,107.481824 51.589882,107.433019 51.568023,107.361924 51.575733,107.355257 51.604579,107.296583 51.593291,107.21547 51.63668,107.217548 51.651711,107.084965 51.671417,107.063882 51.686935,107.068379 51.702306,107.038434 51.715087,106.861968 51.716814))","zoom_level":{"min":8,"max":18},"code":"ulanude","country_code":"ru","id":"37","type":"region","time_zone":{"name":"Asia/Irkutsk","offset":480}},{"name":"Ульяновск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((48.634539 54.121281,48.56085 54.0901,48.552474 54.05428,48.524714 54.061226,48.519761 54.077286,48.445814 54.090836,48.408869 54.074805,48.322982 54.099049,48.179784 54.107706,48.159518 54.09732,48.069958 54.124575,48.04981 54.173416,48.00799 54.217115,48.035851 54.233839,48.022491 54.271162,48.035469 54.305415,48.056294 54.310561,48.041922 54.337865,47.965906 54.379922,47.992768 54.38293,47.984027 54.401357,48.035637 54.40986,48.011365 54.436125,48.029376 54.461865,48.08464 54.477654,48.318008 54.451123,48.336596 54.476568,48.861951 54.469107,48.860767 54.430261,48.924566 54.399153,48.914048 54.377469,48.930143 54.378176,48.929059 54.361941,48.911705 54.332877,48.938859 54.327409,48.942332 54.283077,48.976672 54.24835,48.976294 54.215558,48.93621 54.182404,48.856589 54.159136,48.634539 54.121281))","zoom_level":{"min":8,"max":18},"code":"ulyanovsk","country_code":"ru","id":"55","type":"region","time_zone":{"name":"Europe/Ulyanovsk","offset":240}},{"name":"Уральск","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":false,"pedestrian_routing":true,"road_network":true},"domain":"kz","bounds":"POLYGON((51.526154 51.284431,51.569632 51.284246,51.567598 51.109229,51.255488 51.110327,51.256457 51.285243,51.526154 51.284431))","zoom_level":{"min":8,"max":18},"code":"uralsk","country_code":"kz","id":"162","type":"region","time_zone":{"name":"Asia/Oral","offset":300}},{"name":"Уссурийск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((131.816747 43.70959,131.787156 43.708761,131.73639 43.752125,131.756949 43.851284,131.749195 43.962278,132.076996 43.975946,132.130901 43.964375,132.142052 43.718194,132.01259 43.703639,131.816747 43.70959))","zoom_level":{"min":8,"max":18},"code":"ussuriysk","country_code":"ru","id":"83","type":"region","time_zone":{"name":"Asia/Vladivostok","offset":600}},{"name":"Усть-Каменогорск","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":false,"road_network":true},"domain":"kz","bounds":"POLYGON((82.444837 49.862906,82.450724 50.059192,82.805717 50.054212,82.798391 49.857959,82.444837 49.862906))","zoom_level":{"min":8,"max":18},"code":"ustkam","country_code":"kz","id":"91","type":"region","time_zone":{"name":"Asia/Qyzylorda","offset":360}},{"name":"Уфа","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((55.513299 54.50669,55.494061 54.522228,55.482358 54.499942,55.370533 54.502842,55.333781 54.478486,55.337286 54.466929,55.274856 54.490371,55.260739 54.468126,54.842509 54.456509,54.843068 54.473374,54.814564 54.483257,54.769627 54.445091,54.72315 54.443431,54.560293 54.483057,54.5318 54.466239,54.418596 54.494966,54.313238 54.485285,54.271603 54.443735,54.199599 54.436248,54.075626 54.458357,53.976709 54.41731,53.943558 54.374826,53.782489 54.397594,53.778182 54.378343,53.6907 54.386323,53.682825 54.407089,53.6494 54.40974,53.647372 54.396844,53.549588 54.40325,53.551157 54.422996,53.44346 54.416616,53.382596 54.452052,53.3771 54.502991,53.39054 54.504767,53.37469 54.540229,53.538948 54.687529,53.586984 54.678888,53.607935 54.696374,53.636725 54.686446,53.631588 54.66209,53.789475 54.637296,53.823796 54.605438,53.903618 54.607387,54.024752 54.643675,54.064318 54.60893,54.116066 54.608192,54.267083 54.620174,54.386915 54.667322,54.651514 54.672082,54.683258 54.687295,54.700007 54.717494,54.805092 54.724984,54.985053 54.786446,54.980276 54.803046,55.071891 54.802814,55.076182 54.82451,55.140601 54.829387,55.152037 54.79505,55.207401 54.802098,55.215732 54.787228,55.318581 54.78635,55.349396 54.816566,55.409092 54.807305,55.413453 54.832513,55.492898 54.819783,55.531936 54.879929,55.628156 54.866742,55.699121 54.99436,55.850751 55.006685,55.954333 54.967073,55.985465 54.994674,55.983949 54.977749,56.145711 54.952649,56.258965 54.975092,56.318201 54.969843,56.337313 54.947487,56.326867 54.941947,56.346624 54.93736,56.340896 54.924482,56.390036 54.901869,56.323125 54.869466,56.3214 54.8343,56.3454 54.8317,56.3646 54.7925,56.3317 54.7626,56.322659 54.712084,56.346087 54.678995,56.398652 54.671201,56.405036 54.642382,56.396789 54.622894,56.355509 54.617458,56.346136 54.575489,56.38673 54.581848,56.417876 54.567333,56.353748 54.527367,56.366802 54.502181,56.326085 54.49152,56.352179 54.466123,56.338955 54.455575,56.290272 54.435125,56.2344 54.458465,56.045708 54.41963,55.949653 54.46844,55.917946 54.44712,55.894078 54.474544,55.865215 54.467268,55.870203 54.476916,55.850475 54.4818,55.81172 54.462923,55.670207 54.520705,55.576685 54.523908,55.513299 54.50669))","zoom_level":{"min":8,"max":18},"code":"ufa","country_code":"ru","id":"17","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Хабаровск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((135.258155 48.433811,135.257422 48.288578,135.064085 48.274463,134.874409 48.288797,134.873526 48.629594,135.259151 48.629372,135.275151 48.597403,135.258155 48.433811))","zoom_level":{"min":8,"max":18},"code":"khabarovsk","country_code":"ru","id":"35","type":"region","time_zone":{"name":"Asia/Vladivostok","offset":600}},{"name":"Харьков","flags":{"metro":true,"2gis_reviews":true,"public_transport":true,"flamp":false,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ua","bounds":"POLYGON((36.031103 50.115121,36.467033 50.125456,36.481687 49.845767,36.048271 49.835534,36.031103 50.115121))","zoom_level":{"min":8,"max":18},"code":"kharkov","country_code":"ua","id":"110","type":"region","time_zone":{"name":"Europe/Kiev","offset":180}},{"name":"Чебоксары","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((47.003696 56.264089,47.157621 56.330593,47.604562 56.313312,47.577505 56.071351,47.599217 56.03641,47.584692 56.032973,47.57594 55.988608,47.5156 55.968684,47.423278 55.984072,47.366692 55.97116,47.307714 55.990549,47.198503 55.967518,47.167182 55.981611,46.993093 55.988177,46.96654 56.009043,46.986605 56.02278,46.984365 56.072908,46.997421 56.078488,46.939627 56.229502,47.003696 56.264089))","zoom_level":{"min":8,"max":18},"code":"cheboksary","country_code":"ru","id":"53","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Челябинск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"pedestrian_routing":true,"road_network":true},"domain":"ru","bounds":"POLYGON((61.252272 54.968614,61.203292 54.974499,61.154767 55.001658,61.045568 55.121512,61.100754 55.175448,61.084098 55.195727,61.149519 55.295912,61.284521 55.36403,61.360806 55.379536,61.385601 55.362557,61.470025 55.375552,61.600387 55.321009,61.69485 55.304482,61.756228 55.265544,61.745198 55.160898,61.779485 55.083582,61.76733 55.046807,61.746429 55.036978,61.757873 54.97934,61.70127 54.987808,61.599819 54.966064,61.54954 54.932824,61.570157 54.915237,61.501835 54.895912,61.469463 54.906971,61.470091 54.938297,61.403401 54.928846,61.368564 54.96636,61.252272 54.968614))","zoom_level":{"min":8,"max":18},"code":"chelyabinsk","country_code":"ru","id":"15","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Чита","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((113.069162 52.396705,113.152477 52.452545,113.371366 52.464993,113.470022 52.356606,113.534077 52.332884,113.516717 52.31346,113.536592 52.3132,113.527842 52.29535,113.560493 52.277937,113.551234 52.264949,113.666419 52.217868,113.764267 52.222663,113.798989 52.19943,113.815862 52.148641,113.785471 51.966389,113.676566 51.862738,113.451038 51.818171,113.370101 51.78102,113.348087 51.718262,113.272946 51.744414,113.219211 51.796579,113.144941 51.825077,113.064818 51.827423,112.930694 51.886475,112.505278 51.925249,112.39496 51.950602,112.334198 51.982953,112.33115 51.996715,112.361117 52.021256,112.322516 52.033757,112.323024 52.086064,112.343848 52.109777,112.332928 52.123188,112.359593 52.18084,112.436054 52.228411,112.511075 52.249215,112.505306 52.294373,112.546581 52.346365,112.610136 52.357394,112.653274 52.340795,112.680258 52.354375,112.735469 52.326659,112.804526 52.326126,112.881217 52.351024,112.922137 52.329699,112.981963 52.376365,113.008415 52.370063,113.069162 52.396705))","zoom_level":{"min":8,"max":18},"code":"chita","country_code":"ru","id":"64","type":"region","time_zone":{"name":"Asia/Chita","offset":540}},{"name":"Шымкент","flags":{"metro":false,"2gis_reviews":true,"public_transport":true,"flamp":false,"traffic":false,"road_network":true},"domain":"kz","bounds":"POLYGON((69.416245 42.43852,69.802137 42.436468,69.799675 42.242484,69.414967 42.244521,69.416245 42.43852))","zoom_level":{"min":8,"max":18},"code":"shymkent","country_code":"kz","id":"161","type":"region","time_zone":{"name":"Asia/Almaty","offset":360}},{"name":"Южно-Сахалинск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((141.675118 47.669621,141.68309 47.687322,141.996815 47.620946,142.054915 47.55946,142.061898 47.524003,142.091643 47.501389,142.137566 47.497304,142.204846 47.523722,142.193993 47.575909,142.235882 47.559828,142.277984 47.599893,142.379936 47.641676,142.34477 47.668283,142.367085 47.708999,142.433038 47.712816,142.391115 47.759771,142.40718 47.802399,142.363027 47.810485,142.335671 47.859543,142.35035 47.872389,142.319167 47.908044,142.370514 47.950153,142.36785 47.967077,142.430172 48.004207,142.498338 47.965237,142.528036 47.977203,142.840258 47.976952,142.823431 47.796041,142.862919 47.705495,142.929041 47.619192,143.129518 47.50829,143.201995 47.44488,143.304514 47.297502,143.335109 47.108297,143.648645 46.992415,143.716886 46.939107,143.762274 46.870484,143.79941 46.735728,143.825875 46.545657,143.890542 46.444329,143.903581 46.350373,143.879647 46.289696,143.772449 46.143633,143.736816 46.032721,143.665992 45.923211,143.595467 45.864906,143.472308 45.824532,143.33642 45.828324,143.236326 45.864426,143.165438 45.9208,143.129995 45.983756,143.109984 46.088789,143.117793 46.22435,143.064302 46.324019,142.933805 46.40737,142.847268 46.408042,142.768372 46.398919,142.588021 46.335876,142.540337 46.242406,142.52034 46.126556,142.457837 45.977249,142.34959 45.822267,142.291767 45.656078,141.716427 45.742255,141.762841 45.852956,141.677199 45.939908,141.643665 45.996301,141.600864 46.276621,141.542085 46.432746,141.52014 46.544633,141.530207 46.654188,141.716865 46.997716,141.758166 47.128712,141.690923 47.226766,141.671864 47.284024,141.659125 47.521747,141.675118 47.669621))","zoom_level":{"min":8,"max":18},"code":"yuzhnosakhalinsk","country_code":"ru","id":"88","type":"region","time_zone":{"name":"Asia/Sakhalin","offset":660}},{"name":"Якутск","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((129.586408 62.268402,129.881158 62.266844,129.928407 62.288252,129.931495 62.266516,129.994959 62.266076,129.970862 62.185033,129.974815 62.130719,129.997789 62.10425,129.981284 62.090761,129.989853 62.065925,129.96753 61.950891,130.022313 61.884783,129.896152 61.796782,129.735681 61.642089,129.688132 61.55616,129.495135 61.456515,129.324613 61.390668,128.737649 61.239092,128.596587 61.226232,128.449352 61.28631,128.385933 61.356958,128.346052 61.577842,128.314499 61.601685,128.311397 61.645908,128.274516 61.678607,128.480197 61.722612,128.538972 61.708541,128.788768 61.795172,128.778269 61.821213,128.750271 61.835257,128.853587 61.964803,129.311442 62.262601,129.519606 62.250452,129.533901 62.268614,129.586408 62.268402))","zoom_level":{"min":8,"max":18},"code":"yakutsk","country_code":"ru","id":"50","type":"region","time_zone":{"name":"Asia/Yakutsk","offset":540}},{"name":"Ярославль","flags":{"metro":false,"has_net_booklet":true,"2gis_reviews":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.707415 57.626018,39.726133 57.726358,39.696686 57.753943,39.783415 57.776164,40.004961 57.777804,40.032512 57.763814,40.010655 57.728992,40.024879 57.706287,40.017841 57.680009,40.063737 57.628303,40.006906 57.559198,40.006358 57.539321,40.02355 57.536474,40.008208 57.517025,39.711997 57.507209,39.677242 57.526629,39.675203 57.549456,39.692672 57.560453,39.664961 57.581545,39.707584 57.585252,39.707415 57.626018))","zoom_level":{"min":8,"max":18},"code":"yaroslavl","country_code":"ru","id":"28","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}}]');DG.config = { "host": null, "port": 3000, "defaultSkin": "dark", "defaultLang": "ru", "trafficLayerMinZoom": 10, "trafficLayerUpdateInterval": 300000, "ppnotLink": "http://2gis.{domain}/{projectCode}/center/{center}/zoom/{zoom}/routeTab/rsType/{rsType}/to/{point}╎{name}", "photosLink": "http://2gis.{domain}/photos/{id}", "poiLayerMinZoom": 11, "detectRetina": false, "webApiKey": "ruregt3044", "webApiVersion": "2.0", "regionListFields": "items.bounds,items.zoom_level,items.time_zone,items.code,items.flags,items.country_code,items.domain,items.default_pos", "firmInfoFields": "items.reviews,items.links,items.external_content", "geoAdditionalFields": "items.geometry.selection,items.links,items.adm_div,items.address,items.floors,items.description", "geoclickerCatalogApiKey": "ruregt3044", "projectLeaveMaxZoom": 13, "flampUrl": "http://flamp.ru/r/", "flampGoogleAnalytics": "utm_source=api2gis&utm_medium=api&utm_campaign=geoclicker", "gaCode": "UA-38243181-2", "gaName": "mapsapi2gis", "protocol": "https:", "baseUrl": "//maps.api.2gis.ru/2.0", "tileServer": "//tile{s}.maps.2gis.com/tiles?x={x}&y={y}&z={z}&v=1&ts=online_sd", "retinaTileServer": "//tile{s}.maps.2gis.com/tiles?x={x}&y={y}&z={z}&v=1&ts=online_hd", "previewTileServer": "//tile{s}.maps.2gis.com/tiles?x={x}&y={y}&z={z}&v=1&size=64&ts=online_sd", "previewRetinaTileServer": "//tile{s}.maps.2gis.com/tiles?x={x}&y={y}&z={z}&v=1&size=64&ts=online_hd", "arabicTileServer": "//tile{s}.maps.2gis.com/tiles?x={x}&y={y}&z={z}&v=1&ts=online_sd_ar", "arabicRetinaTileServer": "//tile{s}.maps.2gis.com/tiles?x={x}&y={y}&z={z}&v=1&ts=online_hd_ar", "arabicPreviewTileServer": "//tile{s}.maps.2gis.com/tiles?x={x}&y={y}&z={z}&v=1&size=64&ts=online_sd_ar", "arabicPreviewRetinaTileServer": "//tile{s}.maps.2gis.com/tiles?x={x}&y={y}&z={z}&v=1&size=64&ts=online_hd_ar", "trafficTileServer": "//traffic{s}.maps.2gis.com/{projectCode}/traffic/{z}/{x}/{y}/speed/{period}/{timestampString}", "retinaTrafficTileServer": "//traffic{s}.maps.2gis.com/{projectCode}/traffic/{z}/{x}/{y}/speed/{period}/retina/{timestampString}", "trafficMetaServer": "//meta{s}.maps.2gis.com/{projectCode}/meta/{z}/{x}/{y}/graph_speed/{period}/{timestampString}", "retinaTrafficMetaServer": "//meta{s}.maps.2gis.com/{projectCode}/meta/{z}/{x}/{y}/graph_speed/{period}/retina/{timestampString}", "trafficTimestampServer": "//traffic{s}.maps.2gis.com/{projectCode}/meta/speed/time/", "trafficScoreServer": "//traffic{s}.maps.2gis.com/{projectCode}/meta/score/0/", "poiMetaServer": "//tile{s}.maps.2gis.com/poi?x={x}&y={y}&z={z}&v=1&ts=online_sd", "retinaPoiMetaServer": "//tile{s}.maps.2gis.com/poi?x={x}&y={y}&z={z}&v=1&ts=online_hd", "arabicPoiMetaServer": "//tile{s}.maps.2gis.com/poi?x={x}&y={y}&z={z}&v=1&ts=online_sd_ar", "arabicRetinaPoiMetaServer": "//tile{s}.maps.2gis.com/poi?x={x}&y={y}&z={z}&v=1&ts=online_hd_ar", "webApiServer": "//catalog.api.2gis.ru", "analytics": "//maps.api.2gis.ru/analytics/track-user.png", "googleAnalytics": "https://www.google-analytics.com/analytics.js", "loadProjectListTimeout": 5000 };_dereq_("../../../dist/css/styles.full.dark.css");
            }).call(this, _dereq_('_process'));
        }, { "../../../dist/css/styles.full.dark.css": 1, "../../../vendors/baron": 9, "_process": 8, "dustjs-helpers": 4, "dustjs-linkedin": 5, "html5shiv": 6, "leaflet": 7 }], 3: [function (_dereq_, module, exports) {
            'use strict';
            // For more information about browser field, check out the browser field at https://github.com/substack/browserify-handbook#browser-field.

            var styleElementsInsertedAtTop = [];

            var insertStyleElement = function (styleElement, options) {
                var head = document.head || document.getElementsByTagName('head')[0];
                var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];

                options = options || {};
                options.insertAt = options.insertAt || 'bottom';

                if (options.insertAt === 'top') {
                    if (!lastStyleElementInsertedAtTop) {
                        head.insertBefore(styleElement, head.firstChild);
                    } else if (lastStyleElementInsertedAtTop.nextSibling) {
                        head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
                    } else {
                        head.appendChild(styleElement);
                    }
                    styleElementsInsertedAtTop.push(styleElement);
                } else if (options.insertAt === 'bottom') {
                    head.appendChild(styleElement);
                } else {
                    throw new Error('Invalid value for parameter \'insertAt\'. Must be \'top\' or \'bottom\'.');
                }
            };

            module.exports = {
                // Create a <link> tag with optional data attributes
                createLink: function (href, attributes) {
                    var head = document.head || document.getElementsByTagName('head')[0];
                    var link = document.createElement('link');

                    link.href = href;
                    link.rel = 'stylesheet';

                    for (var key in attributes) {
                        if (!attributes.hasOwnProperty(key)) {
                            continue;
                        }
                        var value = attributes[key];
                        link.setAttribute('data-' + key, value);
                    }

                    head.appendChild(link);
                },
                // Create a <style> tag with optional data attributes
                createStyle: function (cssText, attributes, extraOptions) {
                    extraOptions = extraOptions || {};

                    var style = document.createElement('style');
                    style.type = 'text/css';

                    for (var key in attributes) {
                        if (!attributes.hasOwnProperty(key)) {
                            continue;
                        }
                        var value = attributes[key];
                        style.setAttribute('data-' + key, value);
                    }

                    if (style.sheet) {
                        // for jsdom and IE9+
                        style.innerHTML = cssText;
                        style.sheet.cssText = cssText;
                        insertStyleElement(style, { insertAt: extraOptions.insertAt });
                    } else if (style.styleSheet) {
                        // for IE8 and below
                        insertStyleElement(style, { insertAt: extraOptions.insertAt });
                        style.styleSheet.cssText = cssText;
                    } else {
                        // for Chrome, Firefox, and Safari
                        style.appendChild(document.createTextNode(cssText));
                        insertStyleElement(style, { insertAt: extraOptions.insertAt });
                    }
                }
            };
        }, {}], 4: [function (_dereq_, module, exports) {
            (function (root, factory) {
                if (typeof define === 'function' && define.amd && define.amd.dust === true) {
                    define(['dust.core'], factory);
                } else if (typeof exports === 'object') {
                    module.exports = factory(_dereq_('dustjs-linkedin'));
                } else {
                    factory(root.dust);
                }
            })(this, function (dust) {

                function log(helper, msg, level) {
                    level = level || "INFO";
                    helper = helper ? '{@' + helper + '}: ' : '';
                    dust.log(helper + msg, level);
                }

                var _deprecatedCache = {};
                function _deprecated(target) {
                    if (_deprecatedCache[target]) {
                        return;
                    }
                    log(target, "Deprecation warning: " + target + " is deprecated and will be removed in a future version of dustjs-helpers", "WARN");
                    log(null, "For help and a deprecation timeline, see https://github.com/linkedin/dustjs-helpers/wiki/Deprecated-Features#" + target.replace(/\W+/g, ""), "WARN");
                    _deprecatedCache[target] = true;
                }

                function isSelect(context) {
                    return context.stack.tail && context.stack.tail.head && typeof context.stack.tail.head.__select__ !== "undefined";
                }

                function getSelectState(context) {
                    return isSelect(context) && context.get('__select__');
                }

                /**
                 * Adds a special __select__ key behind the head of the context stack. Used to maintain the state
                 * of {@select} blocks
                 * @param context {Context} add state to this Context
                 * @param opts {Object} add these properties to the state (`key` and `type`)
                 */
                function addSelectState(context, opts) {
                    var head = context.stack.head,
                        newContext = context.rebase(),
                        key;

                    if (context.stack && context.stack.tail) {
                        newContext.stack = context.stack.tail;
                    }

                    var state = {
                        isPending: false,
                        isResolved: false,
                        isDeferredComplete: false,
                        deferreds: []
                    };

                    for (key in opts) {
                        state[key] = opts[key];
                    }

                    return newContext.push({ "__select__": state }).push(head, context.stack.index, context.stack.of);
                }

                /**
                 * After a {@select} or {@math} block is complete, they invoke this function
                 */
                function resolveSelectDeferreds(state) {
                    var x, len;
                    state.isDeferredPending = true;
                    if (state.deferreds.length) {
                        state.isDeferredComplete = true;
                        for (x = 0, len = state.deferreds.length; x < len; x++) {
                            state.deferreds[x]();
                        }
                    }
                    state.isDeferredPending = false;
                }

                /**
                 * Used by {@contextDump}
                 */
                function jsonFilter(key, value) {
                    if (typeof value === "function") {
                        return value.toString().replace(/(^\s+|\s+$)/mg, '').replace(/\n/mg, '').replace(/,\s*/mg, ', ').replace(/\)\{/mg, ') {');
                    }
                    return value;
                }

                /**
                 * Generate a truth test helper
                 */
                function truthTest(name, test) {
                    return function (chunk, context, bodies, params) {
                        return filter(chunk, context, bodies, params, name, test);
                    };
                }

                /**
                 * This function is invoked by truth test helpers
                 */
                function filter(chunk, context, bodies, params, helperName, test) {
                    var body = bodies.block,
                        skip = bodies['else'],
                        selectState = getSelectState(context) || {},
                        willResolve,
                        key,
                        value,
                        type;

                    // Once one truth test in a select passes, short-circuit the rest of the tests
                    if (selectState.isResolved && !selectState.isDeferredPending) {
                        return chunk;
                    }

                    // First check for a key on the helper itself, then look for a key on the {@select}
                    if (params.hasOwnProperty('key')) {
                        key = params.key;
                    } else if (selectState.hasOwnProperty('key')) {
                        key = selectState.key;
                    } else {
                        log(helperName, "No key specified", "WARN");
                        return chunk;
                    }

                    type = params.type || selectState.type;

                    key = coerce(context.resolve(key), type);
                    value = coerce(context.resolve(params.value), type);

                    if (test(key, value)) {
                        // Once a truth test passes, put the select into "pending" state. Now we can render the body of
                        // the truth test (which may contain truth tests) without altering the state of the select.
                        if (!selectState.isPending) {
                            willResolve = true;
                            selectState.isPending = true;
                        }
                        if (body) {
                            chunk = chunk.render(body, context);
                        }
                        if (willResolve) {
                            selectState.isResolved = true;
                        }
                    } else if (skip) {
                        chunk = chunk.render(skip, context);
                    }
                    return chunk;
                }

                function coerce(value, type) {
                    if (type) {
                        type = type.toLowerCase();
                    }
                    switch (type) {
                        case 'number':
                            return +value;
                        case 'string':
                            return String(value);
                        case 'boolean':
                            value = value === 'false' ? false : value;
                            return Boolean(value);
                        case 'date':
                            return new Date(value);
                    }

                    return value;
                }

                var helpers = {

                    // Utility helping to resolve dust references in the given chunk
                    // uses native Dust Context#resolve (available since Dust 2.6.2)
                    "tap": function (input, chunk, context) {
                        // deprecated for removal in 1.8
                        _deprecated("tap");
                        return context.resolve(input);
                    },

                    "sep": function (chunk, context, bodies) {
                        var body = bodies.block;
                        if (context.stack.index === context.stack.of - 1) {
                            return chunk;
                        }
                        if (body) {
                            return body(chunk, context);
                        } else {
                            return chunk;
                        }
                    },

                    "first": function (chunk, context, bodies) {
                        if (context.stack.index === 0) {
                            return bodies.block(chunk, context);
                        }
                        return chunk;
                    },

                    "last": function (chunk, context, bodies) {
                        if (context.stack.index === context.stack.of - 1) {
                            return bodies.block(chunk, context);
                        }
                        return chunk;
                    },

                    /**
                     * {@contextDump}
                     * @param key {String} set to "full" to the full context stack, otherwise the current context is dumped
                     * @param to {String} set to "console" to log to console, otherwise outputs to the chunk
                     */
                    "contextDump": function (chunk, context, bodies, params) {
                        var to = context.resolve(params.to),
                            key = context.resolve(params.key),
                            target,
                            output;
                        switch (key) {
                            case 'full':
                                target = context.stack;
                                break;
                            default:
                                target = context.stack.head;
                        }
                        output = JSON.stringify(target, jsonFilter, 2);
                        switch (to) {
                            case 'console':
                                log('contextDump', output);
                                break;
                            default:
                                output = output.replace(/</g, '\\u003c');
                                chunk = chunk.write(output);
                        }
                        return chunk;
                    },

                    /**
                     * {@math}
                     * @param key first value
                     * @param method {String} operation to perform
                     * @param operand second value (not required for operations like `abs`)
                     * @param round if truthy, round() the result
                     */
                    "math": function (chunk, context, bodies, params) {
                        var key = params.key,
                            method = params.method,
                            operand = params.operand,
                            round = params.round,
                            output,
                            state,
                            x,
                            len;

                        if (!params.hasOwnProperty('key') || !params.method) {
                            log("math", "`key` or `method` was not provided", "ERROR");
                            return chunk;
                        }

                        key = parseFloat(context.resolve(key));
                        operand = parseFloat(context.resolve(operand));

                        switch (method) {
                            case "mod":
                                if (operand === 0) {
                                    log("math", "Division by 0", "ERROR");
                                }
                                output = key % operand;
                                break;
                            case "add":
                                output = key + operand;
                                break;
                            case "subtract":
                                output = key - operand;
                                break;
                            case "multiply":
                                output = key * operand;
                                break;
                            case "divide":
                                if (operand === 0) {
                                    log("math", "Division by 0", "ERROR");
                                }
                                output = key / operand;
                                break;
                            case "ceil":
                            case "floor":
                            case "round":
                            case "abs":
                                output = Math[method](key);
                                break;
                            case "toint":
                                output = parseInt(key, 10);
                                break;
                            default:
                                log("math", "Method `" + method + "` is not supported", "ERROR");
                        }

                        if (typeof output !== 'undefined') {
                            if (round) {
                                output = Math.round(output);
                            }
                            if (bodies && bodies.block) {
                                context = addSelectState(context, { key: output });
                                chunk = chunk.render(bodies.block, context);
                                resolveSelectDeferreds(getSelectState(context));
                            } else {
                                chunk = chunk.write(output);
                            }
                        }

                        return chunk;
                    },

                    /**
                     * {@select}
                     * Groups a set of truth tests and outputs the first one that passes.
                     * Also contains {@any} and {@none} blocks.
                     * @param key a value or reference to use as the left-hand side of comparisons
                     * @param type coerce all truth test keys without an explicit type to this type
                     */
                    "select": function (chunk, context, bodies, params) {
                        var body = bodies.block,
                            state = {};

                        if (params.hasOwnProperty('key')) {
                            state.key = context.resolve(params.key);
                        }
                        if (params.hasOwnProperty('type')) {
                            state.type = params.type;
                        }

                        if (body) {
                            context = addSelectState(context, state);
                            chunk = chunk.render(body, context);
                            resolveSelectDeferreds(getSelectState(context));
                        } else {
                            log("select", "Missing body block", "WARN");
                        }
                        return chunk;
                    },

                    /**
                     * Truth test helpers
                     * @param key a value or reference to use as the left-hand side of comparisons
                     * @param value a value or reference to use as the right-hand side of comparisons
                     * @param type if specified, `key` and `value` will be forcibly cast to this type
                     */
                    "eq": truthTest('eq', function (left, right) {
                        return left === right;
                    }),
                    "ne": truthTest('ne', function (left, right) {
                        return left !== right;
                    }),
                    "lt": truthTest('lt', function (left, right) {
                        return left < right;
                    }),
                    "lte": truthTest('lte', function (left, right) {
                        return left <= right;
                    }),
                    "gt": truthTest('gt', function (left, right) {
                        return left > right;
                    }),
                    "gte": truthTest('gte', function (left, right) {
                        return left >= right;
                    }),

                    /**
                     * {@any}
                     * Outputs as long as at least one truth test inside a {@select} has passed.
                     * Must be contained inside a {@select} block.
                     * The passing truth test can be before or after the {@any} block.
                     */
                    "any": function (chunk, context, bodies, params) {
                        var selectState = getSelectState(context);

                        if (!selectState) {
                            log("any", "Must be used inside a {@select} block", "ERROR");
                        } else {
                            if (selectState.isDeferredComplete) {
                                log("any", "Must not be nested inside {@any} or {@none} block", "ERROR");
                            } else {
                                chunk = chunk.map(function (chunk) {
                                    selectState.deferreds.push(function () {
                                        if (selectState.isResolved) {
                                            chunk = chunk.render(bodies.block, context);
                                        }
                                        chunk.end();
                                    });
                                });
                            }
                        }
                        return chunk;
                    },

                    /**
                     * {@none}
                     * Outputs if no truth tests inside a {@select} pass.
                     * Must be contained inside a {@select} block.
                     * The position of the helper does not matter.
                     */
                    "none": function (chunk, context, bodies, params) {
                        var selectState = getSelectState(context);

                        if (!selectState) {
                            log("none", "Must be used inside a {@select} block", "ERROR");
                        } else {
                            if (selectState.isDeferredComplete) {
                                log("none", "Must not be nested inside {@any} or {@none} block", "ERROR");
                            } else {
                                chunk = chunk.map(function (chunk) {
                                    selectState.deferreds.push(function () {
                                        if (!selectState.isResolved) {
                                            chunk = chunk.render(bodies.block, context);
                                        }
                                        chunk.end();
                                    });
                                });
                            }
                        }
                        return chunk;
                    },

                    /**
                    * {@size}
                    * Write the size of the target to the chunk
                    * Falsy values and true have size 0
                    * Numbers are returned as-is
                    * Arrays and Strings have size equal to their length
                    * Objects have size equal to the number of keys they contain
                    * Dust bodies are evaluated and the length of the string is returned
                    * Functions are evaluated and the length of their return value is evaluated
                    * @param key find the size of this value or reference
                    */
                    "size": function (chunk, context, bodies, params) {
                        var key = params.key,
                            value,
                            k;

                        key = context.resolve(params.key);
                        if (!key || key === true) {
                            value = 0;
                        } else if (dust.isArray(key)) {
                            value = key.length;
                        } else if (!isNaN(parseFloat(key)) && isFinite(key)) {
                            value = key;
                        } else if (typeof key === "object") {
                            value = 0;
                            for (k in key) {
                                if (key.hasOwnProperty(k)) {
                                    value++;
                                }
                            }
                        } else {
                            value = (key + '').length;
                        }
                        return chunk.write(value);
                    }

                };

                for (var key in helpers) {
                    dust.helpers[key] = helpers[key];
                }

                return dust;
            });
        }, { "dustjs-linkedin": 5 }], 5: [function (_dereq_, module, exports) {
            (function (process) {
                (function (root, factory) {
                    if (typeof define === 'function' && define.amd && define.amd.dust === true) {
                        define('dust.core', [], factory);
                    } else if (typeof exports === 'object') {
                        module.exports = factory();
                    } else {
                        root.dust = factory();
                    }
                })(this, function () {
                    var dust = {
                        "version": "2.7.5"
                    },
                        NONE = 'NONE',
                        ERROR = 'ERROR',
                        WARN = 'WARN',
                        INFO = 'INFO',
                        DEBUG = 'DEBUG',
                        EMPTY_FUNC = function () {};

                    dust.config = {
                        whitespace: false,
                        amd: false,
                        cjs: false,
                        cache: true
                    };

                    // Directive aliases to minify code
                    dust._aliases = {
                        "write": "w",
                        "end": "e",
                        "map": "m",
                        "render": "r",
                        "reference": "f",
                        "section": "s",
                        "exists": "x",
                        "notexists": "nx",
                        "block": "b",
                        "partial": "p",
                        "helper": "h"
                    };

                    (function initLogging() {
                        /*global process, console*/
                        var loggingLevels = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, NONE: 4 },
                            consoleLog,
                            log;

                        if (typeof console !== 'undefined' && console.log) {
                            consoleLog = console.log;
                            if (typeof consoleLog === 'function') {
                                log = function () {
                                    consoleLog.apply(console, arguments);
                                };
                            } else {
                                log = function () {
                                    consoleLog(Array.prototype.slice.apply(arguments).join(' '));
                                };
                            }
                        } else {
                            log = EMPTY_FUNC;
                        }

                        /**
                         * Filters messages based on `dust.debugLevel`.
                         * This default implementation will print to the console if it exists.
                         * @param {String|Error} message the message to print/throw
                         * @param {String} type the severity of the message(ERROR, WARN, INFO, or DEBUG)
                         * @public
                         */
                        dust.log = function (message, type) {
                            type = type || INFO;
                            if (loggingLevels[type] >= loggingLevels[dust.debugLevel]) {
                                log('[DUST:' + type + ']', message);
                            }
                        };

                        dust.debugLevel = NONE;
                        if (typeof process !== 'undefined' && process.env && /\bdust\b/.test(undefined)) {
                            dust.debugLevel = DEBUG;
                        }
                    })();

                    dust.helpers = {};

                    dust.cache = {};

                    dust.register = function (name, tmpl) {
                        if (!name) {
                            return;
                        }
                        tmpl.templateName = name;
                        if (dust.config.cache !== false) {
                            dust.cache[name] = tmpl;
                        }
                    };

                    dust.render = function (nameOrTemplate, context, callback) {
                        var chunk = new Stub(callback).head;
                        try {
                            load(nameOrTemplate, chunk, context).end();
                        } catch (err) {
                            chunk.setError(err);
                        }
                    };

                    dust.stream = function (nameOrTemplate, context) {
                        var stream = new Stream(),
                            chunk = stream.head;
                        dust.nextTick(function () {
                            try {
                                load(nameOrTemplate, chunk, context).end();
                            } catch (err) {
                                chunk.setError(err);
                            }
                        });
                        return stream;
                    };

                    /**
                     * Extracts a template function (body_0) from whatever is passed.
                     * @param nameOrTemplate {*} Could be:
                     *   - the name of a template to load from cache
                     *   - a CommonJS-compiled template (a function with a `template` property)
                     *   - a template function
                     * @param loadFromCache {Boolean} if false, don't look in the cache
                     * @return {Function} a template function, if found
                     */
                    function getTemplate(nameOrTemplate, loadFromCache /*=true*/) {
                        if (!nameOrTemplate) {
                            return;
                        }
                        if (typeof nameOrTemplate === 'function' && nameOrTemplate.template) {
                            // Sugar away CommonJS module templates
                            return nameOrTemplate.template;
                        }
                        if (dust.isTemplateFn(nameOrTemplate)) {
                            // Template functions passed directly
                            return nameOrTemplate;
                        }
                        if (loadFromCache !== false) {
                            // Try loading a template with this name from cache
                            return dust.cache[nameOrTemplate];
                        }
                    }

                    function load(nameOrTemplate, chunk, context) {
                        if (!nameOrTemplate) {
                            return chunk.setError(new Error('No template or template name provided to render'));
                        }

                        var template = getTemplate(nameOrTemplate, dust.config.cache);

                        if (template) {
                            return template(chunk, Context.wrap(context, template.templateName));
                        } else {
                            if (dust.onLoad) {
                                return chunk.map(function (chunk) {
                                    // Alias just so it's easier to read that this would always be a name
                                    var name = nameOrTemplate;
                                    // Three possible scenarios for a successful callback:
                                    //   - `require(nameOrTemplate)(dust); cb()`
                                    //   - `src = readFile('src.dust'); cb(null, src)`
                                    //   - `compiledTemplate = require(nameOrTemplate)(dust); cb(null, compiledTemplate)`
                                    function done(err, srcOrTemplate) {
                                        var template;
                                        if (err) {
                                            return chunk.setError(err);
                                        }
                                        // Prefer a template that is passed via callback over the cached version.
                                        template = getTemplate(srcOrTemplate, false) || getTemplate(name, dust.config.cache);
                                        if (!template) {
                                            // It's a template string, compile it and register under `name`
                                            if (dust.compile) {
                                                template = dust.loadSource(dust.compile(srcOrTemplate, name));
                                            } else {
                                                return chunk.setError(new Error('Dust compiler not available'));
                                            }
                                        }
                                        template(chunk, Context.wrap(context, template.templateName)).end();
                                    }

                                    if (dust.onLoad.length === 3) {
                                        dust.onLoad(name, context.options, done);
                                    } else {
                                        dust.onLoad(name, done);
                                    }
                                });
                            }
                            return chunk.setError(new Error('Template Not Found: ' + nameOrTemplate));
                        }
                    }

                    dust.loadSource = function (source) {
                        /*jshint evil:true*/
                        return eval(source);
                    };

                    if (Array.isArray) {
                        dust.isArray = Array.isArray;
                    } else {
                        dust.isArray = function (arr) {
                            return Object.prototype.toString.call(arr) === '[object Array]';
                        };
                    }

                    dust.nextTick = function () {
                        return function (callback) {
                            setTimeout(callback, 0);
                        };
                    }();

                    /**
                     * Dust has its own rules for what is "empty"-- which is not the same as falsy.
                     * Empty arrays, null, and undefined are empty
                     */
                    dust.isEmpty = function (value) {
                        if (value === 0) {
                            return false;
                        }
                        if (dust.isArray(value) && !value.length) {
                            return true;
                        }
                        return !value;
                    };

                    dust.isEmptyObject = function (obj) {
                        var key;
                        if (obj === null) {
                            return false;
                        }
                        if (obj === undefined) {
                            return false;
                        }
                        if (obj.length > 0) {
                            return false;
                        }
                        for (key in obj) {
                            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                                return false;
                            }
                        }
                        return true;
                    };

                    dust.isTemplateFn = function (elem) {
                        return typeof elem === 'function' && elem.__dustBody;
                    };

                    /**
                     * Decide somewhat-naively if something is a Thenable.
                     * @param elem {*} object to inspect
                     * @return {Boolean} is `elem` a Thenable?
                     */
                    dust.isThenable = function (elem) {
                        return elem && typeof elem === 'object' && typeof elem.then === 'function';
                    };

                    /**
                     * Decide very naively if something is a Stream.
                     * @param elem {*} object to inspect
                     * @return {Boolean} is `elem` a Stream?
                     */
                    dust.isStreamable = function (elem) {
                        return elem && typeof elem.on === 'function' && typeof elem.pipe === 'function';
                    };

                    // apply the filter chain and return the output string
                    dust.filter = function (string, auto, filters, context) {
                        var i, len, name, filter;
                        if (filters) {
                            for (i = 0, len = filters.length; i < len; i++) {
                                name = filters[i];
                                if (!name.length) {
                                    continue;
                                }
                                filter = dust.filters[name];
                                if (name === 's') {
                                    auto = null;
                                } else if (typeof filter === 'function') {
                                    string = filter(string, context);
                                } else {
                                    dust.log('Invalid filter `' + name + '`', WARN);
                                }
                            }
                        }
                        // by default always apply the h filter, unless asked to unescape with |s
                        if (auto) {
                            string = dust.filters[auto](string, context);
                        }
                        return string;
                    };

                    dust.filters = {
                        h: function (value) {
                            return dust.escapeHtml(value);
                        },
                        j: function (value) {
                            return dust.escapeJs(value);
                        },
                        u: encodeURI,
                        uc: encodeURIComponent,
                        js: function (value) {
                            return dust.escapeJSON(value);
                        },
                        jp: function (value) {
                            if (!JSON) {
                                dust.log('JSON is undefined; could not parse `' + value + '`', WARN);
                                return value;
                            } else {
                                return JSON.parse(value);
                            }
                        }
                    };

                    function Context(stack, global, options, blocks, templateName) {
                        if (stack !== undefined && !(stack instanceof Stack)) {
                            stack = new Stack(stack);
                        }
                        this.stack = stack;
                        this.global = global;
                        this.options = options;
                        this.blocks = blocks;
                        this.templateName = templateName;
                        this._isContext = true;
                    }

                    dust.makeBase = dust.context = function (global, options) {
                        return new Context(undefined, global, options);
                    };

                    dust.isContext = function (obj) {
                        return typeof obj === "object" && obj._isContext === true;
                    };

                    /**
                     * Factory function that creates a closure scope around a Thenable-callback.
                     * Returns a function that can be passed to a Thenable that will resume a
                     * Context lookup once the Thenable resolves with new data, adding that new
                     * data to the lookup stack.
                     */
                    function getWithResolvedData(ctx, cur, down) {
                        return function (data) {
                            return ctx.push(data)._get(cur, down);
                        };
                    }

                    Context.wrap = function (context, name) {
                        if (dust.isContext(context)) {
                            return context;
                        }
                        return new Context(context, {}, {}, null, name);
                    };

                    /**
                     * Public API for getting a value from the context.
                     * @method get
                     * @param {string|array} path The path to the value. Supported formats are:
                     * 'key'
                     * 'path.to.key'
                     * '.path.to.key'
                     * ['path', 'to', 'key']
                     * ['key']
                     * @param {boolean} [cur=false] Boolean which determines if the search should be limited to the
                     * current context (true), or if get should search in parent contexts as well (false).
                     * @public
                     * @returns {string|object}
                     */
                    Context.prototype.get = function (path, cur) {
                        if (typeof path === 'string') {
                            if (path[0] === '.') {
                                cur = true;
                                path = path.substr(1);
                            }
                            path = path.split('.');
                        }
                        return this._get(cur, path);
                    };

                    /**
                     * Get a value from the context
                     * @method _get
                     * @param {boolean} cur Get only from the current context
                     * @param {array} down An array of each step in the path
                     * @private
                     * @return {string | object}
                     */
                    Context.prototype._get = function (cur, down) {
                        var ctx = this.stack || {},
                            i = 1,
                            value,
                            first,
                            len,
                            ctxThis,
                            fn;

                        first = down[0];
                        len = down.length;

                        if (cur && len === 0) {
                            ctxThis = ctx;
                            ctx = ctx.head;
                        } else {
                            if (!cur) {
                                // Search up the stack for the first value
                                while (ctx) {
                                    if (ctx.isObject) {
                                        ctxThis = ctx.head;
                                        value = ctx.head[first];
                                        if (value !== undefined) {
                                            break;
                                        }
                                    }
                                    ctx = ctx.tail;
                                }

                                // Try looking in the global context if we haven't found anything yet
                                if (value !== undefined) {
                                    ctx = value;
                                } else {
                                    ctx = this.global && this.global[first];
                                }
                            } else if (ctx) {
                                // if scope is limited by a leading dot, don't search up the tree
                                if (ctx.head) {
                                    ctx = ctx.head[first];
                                } else {
                                    // context's head is empty, value we are searching for is not defined
                                    ctx = undefined;
                                }
                            }

                            while (ctx && i < len) {
                                if (dust.isThenable(ctx)) {
                                    // Bail early by returning a Thenable for the remainder of the search tree
                                    return ctx.then(getWithResolvedData(this, cur, down.slice(i)));
                                }
                                ctxThis = ctx;
                                ctx = ctx[down[i]];
                                i++;
                            }
                        }

                        if (typeof ctx === 'function') {
                            fn = function () {
                                try {
                                    return ctx.apply(ctxThis, arguments);
                                } catch (err) {
                                    dust.log(err, ERROR);
                                    throw err;
                                }
                            };
                            fn.__dustBody = !!ctx.__dustBody;
                            return fn;
                        } else {
                            if (ctx === undefined) {
                                dust.log('Cannot find reference `{' + down.join('.') + '}` in template `' + this.getTemplateName() + '`', INFO);
                            }
                            return ctx;
                        }
                    };

                    Context.prototype.getPath = function (cur, down) {
                        return this._get(cur, down);
                    };

                    Context.prototype.push = function (head, idx, len) {
                        if (head === undefined) {
                            dust.log("Not pushing an undefined variable onto the context", INFO);
                            return this;
                        }
                        return this.rebase(new Stack(head, this.stack, idx, len));
                    };

                    Context.prototype.pop = function () {
                        var head = this.current();
                        this.stack = this.stack && this.stack.tail;
                        return head;
                    };

                    Context.prototype.rebase = function (head) {
                        return new Context(head, this.global, this.options, this.blocks, this.getTemplateName());
                    };

                    Context.prototype.clone = function () {
                        var context = this.rebase();
                        context.stack = this.stack;
                        return context;
                    };

                    Context.prototype.current = function () {
                        return this.stack && this.stack.head;
                    };

                    Context.prototype.getBlock = function (key) {
                        var blocks, len, fn;

                        if (typeof key === 'function') {
                            key = key(new Chunk(), this).data.join('');
                        }

                        blocks = this.blocks;

                        if (!blocks) {
                            dust.log('No blocks for context `' + key + '` in template `' + this.getTemplateName() + '`', DEBUG);
                            return false;
                        }

                        len = blocks.length;
                        while (len--) {
                            fn = blocks[len][key];
                            if (fn) {
                                return fn;
                            }
                        }

                        dust.log('Malformed template `' + this.getTemplateName() + '` was missing one or more blocks.');
                        return false;
                    };

                    Context.prototype.shiftBlocks = function (locals) {
                        var blocks = this.blocks,
                            newBlocks;

                        if (locals) {
                            if (!blocks) {
                                newBlocks = [locals];
                            } else {
                                newBlocks = blocks.concat([locals]);
                            }
                            return new Context(this.stack, this.global, this.options, newBlocks, this.getTemplateName());
                        }
                        return this;
                    };

                    Context.prototype.resolve = function (body) {
                        var chunk;

                        if (typeof body !== 'function') {
                            return body;
                        }
                        chunk = new Chunk().render(body, this);
                        if (chunk instanceof Chunk) {
                            return chunk.data.join(''); // ie7 perf
                        }
                        return chunk;
                    };

                    Context.prototype.getTemplateName = function () {
                        return this.templateName;
                    };

                    function Stack(head, tail, idx, len) {
                        this.tail = tail;
                        this.isObject = head && typeof head === 'object';
                        this.head = head;
                        this.index = idx;
                        this.of = len;
                    }

                    function Stub(callback) {
                        this.head = new Chunk(this);
                        this.callback = callback;
                        this.out = '';
                    }

                    Stub.prototype.flush = function () {
                        var chunk = this.head;

                        while (chunk) {
                            if (chunk.flushable) {
                                this.out += chunk.data.join(''); //ie7 perf
                            } else if (chunk.error) {
                                this.callback(chunk.error);
                                dust.log('Rendering failed with error `' + chunk.error + '`', ERROR);
                                this.flush = EMPTY_FUNC;
                                return;
                            } else {
                                return;
                            }
                            chunk = chunk.next;
                            this.head = chunk;
                        }
                        this.callback(null, this.out);
                    };

                    /**
                     * Creates an interface sort of like a Streams2 ReadableStream.
                     */
                    function Stream() {
                        this.head = new Chunk(this);
                    }

                    Stream.prototype.flush = function () {
                        var chunk = this.head;

                        while (chunk) {
                            if (chunk.flushable) {
                                this.emit('data', chunk.data.join('')); //ie7 perf
                            } else if (chunk.error) {
                                this.emit('error', chunk.error);
                                this.emit('end');
                                dust.log('Streaming failed with error `' + chunk.error + '`', ERROR);
                                this.flush = EMPTY_FUNC;
                                return;
                            } else {
                                return;
                            }
                            chunk = chunk.next;
                            this.head = chunk;
                        }
                        this.emit('end');
                    };

                    /**
                     * Executes listeners for `type` by passing data. Note that this is different from a
                     * Node stream, which can pass an arbitrary number of arguments
                     * @return `true` if event had listeners, `false` otherwise
                     */
                    Stream.prototype.emit = function (type, data) {
                        var events = this.events || {},
                            handlers = events[type] || [],
                            i,
                            l;

                        if (!handlers.length) {
                            dust.log('Stream broadcasting, but no listeners for `' + type + '`', DEBUG);
                            return false;
                        }

                        handlers = handlers.slice(0);
                        for (i = 0, l = handlers.length; i < l; i++) {
                            handlers[i](data);
                        }
                        return true;
                    };

                    Stream.prototype.on = function (type, callback) {
                        var events = this.events = this.events || {},
                            handlers = events[type] = events[type] || [];

                        if (typeof callback !== 'function') {
                            dust.log('No callback function provided for `' + type + '` event listener', WARN);
                        } else {
                            handlers.push(callback);
                        }
                        return this;
                    };

                    /**
                     * Pipes to a WritableStream. Note that backpressure isn't implemented,
                     * so we just write as fast as we can.
                     * @param stream {WritableStream}
                     * @return self
                     */
                    Stream.prototype.pipe = function (stream) {
                        if (typeof stream.write !== 'function' || typeof stream.end !== 'function') {
                            dust.log('Incompatible stream passed to `pipe`', WARN);
                            return this;
                        }

                        var destEnded = false;

                        if (typeof stream.emit === 'function') {
                            stream.emit('pipe', this);
                        }

                        if (typeof stream.on === 'function') {
                            stream.on('error', function () {
                                destEnded = true;
                            });
                        }

                        return this.on('data', function (data) {
                            if (destEnded) {
                                return;
                            }
                            try {
                                stream.write(data, 'utf8');
                            } catch (err) {
                                dust.log(err, ERROR);
                            }
                        }).on('end', function () {
                            if (destEnded) {
                                return;
                            }
                            try {
                                stream.end();
                                destEnded = true;
                            } catch (err) {
                                dust.log(err, ERROR);
                            }
                        });
                    };

                    function Chunk(root, next, taps) {
                        this.root = root;
                        this.next = next;
                        this.data = []; //ie7 perf
                        this.flushable = false;
                        this.taps = taps;
                    }

                    Chunk.prototype.write = function (data) {
                        var taps = this.taps;

                        if (taps) {
                            data = taps.go(data);
                        }
                        this.data.push(data);
                        return this;
                    };

                    Chunk.prototype.end = function (data) {
                        if (data) {
                            this.write(data);
                        }
                        this.flushable = true;
                        this.root.flush();
                        return this;
                    };

                    Chunk.prototype.map = function (callback) {
                        var cursor = new Chunk(this.root, this.next, this.taps),
                            branch = new Chunk(this.root, cursor, this.taps);

                        this.next = branch;
                        this.flushable = true;
                        try {
                            callback(branch);
                        } catch (err) {
                            dust.log(err, ERROR);
                            branch.setError(err);
                        }
                        return cursor;
                    };

                    Chunk.prototype.tap = function (tap) {
                        var taps = this.taps;

                        if (taps) {
                            this.taps = taps.push(tap);
                        } else {
                            this.taps = new Tap(tap);
                        }
                        return this;
                    };

                    Chunk.prototype.untap = function () {
                        this.taps = this.taps.tail;
                        return this;
                    };

                    Chunk.prototype.render = function (body, context) {
                        return body(this, context);
                    };

                    Chunk.prototype.reference = function (elem, context, auto, filters) {
                        if (typeof elem === 'function') {
                            elem = elem.apply(context.current(), [this, context, null, { auto: auto, filters: filters }]);
                            if (elem instanceof Chunk) {
                                return elem;
                            } else {
                                return this.reference(elem, context, auto, filters);
                            }
                        }
                        if (dust.isThenable(elem)) {
                            return this.await(elem, context, null, auto, filters);
                        } else if (dust.isStreamable(elem)) {
                            return this.stream(elem, context, null, auto, filters);
                        } else if (!dust.isEmpty(elem)) {
                            return this.write(dust.filter(elem, auto, filters, context));
                        } else {
                            return this;
                        }
                    };

                    Chunk.prototype.section = function (elem, context, bodies, params) {
                        var body = bodies.block,
                            skip = bodies['else'],
                            chunk = this,
                            i,
                            len,
                            head;

                        if (typeof elem === 'function' && !dust.isTemplateFn(elem)) {
                            try {
                                elem = elem.apply(context.current(), [this, context, bodies, params]);
                            } catch (err) {
                                dust.log(err, ERROR);
                                return this.setError(err);
                            }
                            // Functions that return chunks are assumed to have handled the chunk manually.
                            // Make that chunk the current one and go to the next method in the chain.
                            if (elem instanceof Chunk) {
                                return elem;
                            }
                        }

                        if (dust.isEmptyObject(bodies)) {
                            // No bodies to render, and we've already invoked any function that was available in
                            // hopes of returning a Chunk.
                            return chunk;
                        }

                        if (!dust.isEmptyObject(params)) {
                            context = context.push(params);
                        }

                        /*
                        Dust's default behavior is to enumerate over the array elem, passing each object in the array to the block.
                        When elem resolves to a value or object instead of an array, Dust sets the current context to the value
                        and renders the block one time.
                        */
                        if (dust.isArray(elem)) {
                            if (body) {
                                len = elem.length;
                                if (len > 0) {
                                    head = context.stack && context.stack.head || {};
                                    head.$len = len;
                                    for (i = 0; i < len; i++) {
                                        head.$idx = i;
                                        chunk = body(chunk, context.push(elem[i], i, len));
                                    }
                                    head.$idx = undefined;
                                    head.$len = undefined;
                                    return chunk;
                                } else if (skip) {
                                    return skip(this, context);
                                }
                            }
                        } else if (dust.isThenable(elem)) {
                            return this.await(elem, context, bodies);
                        } else if (dust.isStreamable(elem)) {
                            return this.stream(elem, context, bodies);
                        } else if (elem === true) {
                            // true is truthy but does not change context
                            if (body) {
                                return body(this, context);
                            }
                        } else if (elem || elem === 0) {
                            // everything that evaluates to true are truthy ( e.g. Non-empty strings and Empty objects are truthy. )
                            // zero is truthy
                            // for anonymous functions that did not returns a chunk, truthiness is evaluated based on the return value
                            if (body) {
                                return body(this, context.push(elem));
                            }
                            // nonexistent, scalar false value, scalar empty string, null,
                            // undefined are all falsy
                        } else if (skip) {
                            return skip(this, context);
                        }
                        dust.log('Section without corresponding key in template `' + context.getTemplateName() + '`', DEBUG);
                        return this;
                    };

                    Chunk.prototype.exists = function (elem, context, bodies) {
                        var body = bodies.block,
                            skip = bodies['else'];

                        if (!dust.isEmpty(elem)) {
                            if (body) {
                                return body(this, context);
                            }
                            dust.log('No block for exists check in template `' + context.getTemplateName() + '`', DEBUG);
                        } else if (skip) {
                            return skip(this, context);
                        }
                        return this;
                    };

                    Chunk.prototype.notexists = function (elem, context, bodies) {
                        var body = bodies.block,
                            skip = bodies['else'];

                        if (dust.isEmpty(elem)) {
                            if (body) {
                                return body(this, context);
                            }
                            dust.log('No block for not-exists check in template `' + context.getTemplateName() + '`', DEBUG);
                        } else if (skip) {
                            return skip(this, context);
                        }
                        return this;
                    };

                    Chunk.prototype.block = function (elem, context, bodies) {
                        var body = elem || bodies.block;

                        if (body) {
                            return body(this, context);
                        }
                        return this;
                    };

                    Chunk.prototype.partial = function (elem, context, partialContext, params) {
                        var head;

                        if (params === undefined) {
                            // Compatibility for < 2.7.0 where `partialContext` did not exist
                            params = partialContext;
                            partialContext = context;
                        }

                        if (!dust.isEmptyObject(params)) {
                            partialContext = partialContext.clone();
                            head = partialContext.pop();
                            partialContext = partialContext.push(params).push(head);
                        }

                        if (dust.isTemplateFn(elem)) {
                            // The eventual result of evaluating `elem` is a partial name
                            // Load the partial after getting its name and end the async chunk
                            return this.capture(elem, context, function (name, chunk) {
                                partialContext.templateName = name;
                                load(name, chunk, partialContext).end();
                            });
                        } else {
                            partialContext.templateName = elem;
                            return load(elem, this, partialContext);
                        }
                    };

                    Chunk.prototype.helper = function (name, context, bodies, params, auto) {
                        var chunk = this,
                            filters = params.filters,
                            ret;

                        // Pre-2.7.1 compat: if auto is undefined, it's an old template. Automatically escape
                        if (auto === undefined) {
                            auto = 'h';
                        }

                        // handle invalid helpers, similar to invalid filters
                        if (dust.helpers[name]) {
                            try {
                                ret = dust.helpers[name](chunk, context, bodies, params);
                                if (ret instanceof Chunk) {
                                    return ret;
                                }
                                if (typeof filters === 'string') {
                                    filters = filters.split('|');
                                }
                                if (!dust.isEmptyObject(bodies)) {
                                    return chunk.section(ret, context, bodies, params);
                                }
                                // Helpers act slightly differently from functions in context in that they will act as
                                // a reference if they are self-closing (due to grammar limitations)
                                // In the Chunk.await function we check to make sure bodies is null before acting as a reference
                                return chunk.reference(ret, context, auto, filters);
                            } catch (err) {
                                dust.log('Error in helper `' + name + '`: ' + err.message, ERROR);
                                return chunk.setError(err);
                            }
                        } else {
                            dust.log('Helper `' + name + '` does not exist', WARN);
                            return chunk;
                        }
                    };

                    /**
                     * Reserve a chunk to be evaluated once a thenable is resolved or rejected
                     * @param thenable {Thenable} the target thenable to await
                     * @param context {Context} context to use to render the deferred chunk
                     * @param bodies {Object} must contain a "body", may contain an "error"
                     * @param auto {String} automatically apply this filter if the Thenable is a reference
                     * @param filters {Array} apply these filters if the Thenable is a reference
                     * @return {Chunk}
                     */
                    Chunk.prototype.await = function (thenable, context, bodies, auto, filters) {
                        return this.map(function (chunk) {
                            thenable.then(function (data) {
                                if (bodies) {
                                    chunk = chunk.section(data, context, bodies);
                                } else {
                                    // Actually a reference. Self-closing sections don't render
                                    chunk = chunk.reference(data, context, auto, filters);
                                }
                                chunk.end();
                            }, function (err) {
                                var errorBody = bodies && bodies.error;
                                if (errorBody) {
                                    chunk.render(errorBody, context.push(err)).end();
                                } else {
                                    dust.log('Unhandled promise rejection in `' + context.getTemplateName() + '`', INFO);
                                    chunk.end();
                                }
                            });
                        });
                    };

                    /**
                     * Reserve a chunk to be evaluated with the contents of a streamable.
                     * Currently an error event will bomb out the stream. Once an error
                     * is received, we push it to an {:error} block if one exists, and log otherwise,
                     * then stop listening to the stream.
                     * @param streamable {Streamable} the target streamable that will emit events
                     * @param context {Context} context to use to render each thunk
                     * @param bodies {Object} must contain a "body", may contain an "error"
                     * @return {Chunk}
                     */
                    Chunk.prototype.stream = function (stream, context, bodies, auto, filters) {
                        var body = bodies && bodies.block,
                            errorBody = bodies && bodies.error;
                        return this.map(function (chunk) {
                            var ended = false;
                            stream.on('data', function data(thunk) {
                                if (ended) {
                                    return;
                                }
                                if (body) {
                                    // Fork a new chunk out of the blockstream so that we can flush it independently
                                    chunk = chunk.map(function (chunk) {
                                        chunk.render(body, context.push(thunk)).end();
                                    });
                                } else if (!bodies) {
                                    // When actually a reference, don't fork, just write into the master async chunk
                                    chunk = chunk.reference(thunk, context, auto, filters);
                                }
                            }).on('error', function error(err) {
                                if (ended) {
                                    return;
                                }
                                if (errorBody) {
                                    chunk.render(errorBody, context.push(err));
                                } else {
                                    dust.log('Unhandled stream error in `' + context.getTemplateName() + '`', INFO);
                                }
                                if (!ended) {
                                    ended = true;
                                    chunk.end();
                                }
                            }).on('end', function end() {
                                if (!ended) {
                                    ended = true;
                                    chunk.end();
                                }
                            });
                        });
                    };

                    Chunk.prototype.capture = function (body, context, callback) {
                        return this.map(function (chunk) {
                            var stub = new Stub(function (err, out) {
                                if (err) {
                                    chunk.setError(err);
                                } else {
                                    callback(out, chunk);
                                }
                            });
                            body(stub.head, context).end();
                        });
                    };

                    Chunk.prototype.setError = function (err) {
                        this.error = err;
                        this.root.flush();
                        return this;
                    };

                    // Chunk aliases
                    for (var f in Chunk.prototype) {
                        if (dust._aliases[f]) {
                            Chunk.prototype[dust._aliases[f]] = Chunk.prototype[f];
                        }
                    }

                    function Tap(head, tail) {
                        this.head = head;
                        this.tail = tail;
                    }

                    Tap.prototype.push = function (tap) {
                        return new Tap(tap, this);
                    };

                    Tap.prototype.go = function (value) {
                        var tap = this;

                        while (tap) {
                            value = tap.head(value);
                            tap = tap.tail;
                        }
                        return value;
                    };

                    var HCHARS = /[&<>"']/,
                        AMP = /&/g,
                        LT = /</g,
                        GT = />/g,
                        QUOT = /\"/g,
                        SQUOT = /\'/g;

                    dust.escapeHtml = function (s) {
                        if (typeof s === "string" || s && typeof s.toString === "function") {
                            if (typeof s !== "string") {
                                s = s.toString();
                            }
                            if (!HCHARS.test(s)) {
                                return s;
                            }
                            return s.replace(AMP, '&amp;').replace(LT, '&lt;').replace(GT, '&gt;').replace(QUOT, '&quot;').replace(SQUOT, '&#39;');
                        }
                        return s;
                    };

                    var BS = /\\/g,
                        FS = /\//g,
                        CR = /\r/g,
                        LS = /\u2028/g,
                        PS = /\u2029/g,
                        NL = /\n/g,
                        LF = /\f/g,
                        SQ = /'/g,
                        DQ = /"/g,
                        TB = /\t/g;

                    dust.escapeJs = function (s) {
                        if (typeof s === 'string') {
                            return s.replace(BS, '\\\\').replace(FS, '\\/').replace(DQ, '\\"').replace(SQ, '\\\'').replace(CR, '\\r').replace(LS, '\\u2028').replace(PS, '\\u2029').replace(NL, '\\n').replace(LF, '\\f').replace(TB, '\\t');
                        }
                        return s;
                    };

                    dust.escapeJSON = function (o) {
                        if (!JSON) {
                            dust.log('JSON is undefined; could not escape `' + o + '`', WARN);
                            return o;
                        } else {
                            return JSON.stringify(o).replace(LS, '\\u2028').replace(PS, '\\u2029').replace(LT, '\\u003c');
                        }
                    };

                    return dust;
                });
            }).call(this, _dereq_('_process'));
        }, { "_process": 8 }], 6: [function (_dereq_, module, exports) {
            /**
            * @preserve HTML5 Shiv 3.7.3 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
            */
            ;(function (window, document) {
                /*jshint evil:true */
                /** version */
                var version = '3.7.3-pre';

                /** Preset options */
                var options = window.html5 || {};

                /** Used to skip problem elements */
                var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;

                /** Not all elements can be cloned in IE **/
                var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;

                /** Detect whether the browser supports default html5 styles */
                var supportsHtml5Styles;

                /** Name of the expando, to work with multiple documents or to re-shiv one document */
                var expando = '_html5shiv';

                /** The id for the the documents expando */
                var expanID = 0;

                /** Cached data for each document */
                var expandoData = {};

                /** Detect whether the browser supports unknown elements */
                var supportsUnknownElements;

                (function () {
                    try {
                        var a = document.createElement('a');
                        a.innerHTML = '<xyz></xyz>';
                        //if the hidden property is implemented we can assume, that the browser supports basic HTML5 Styles
                        supportsHtml5Styles = 'hidden' in a;

                        supportsUnknownElements = a.childNodes.length == 1 || function () {
                            // assign a false positive if unable to shiv
                            document.createElement('a');
                            var frag = document.createDocumentFragment();
                            return typeof frag.cloneNode == 'undefined' || typeof frag.createDocumentFragment == 'undefined' || typeof frag.createElement == 'undefined';
                        }();
                    } catch (e) {
                        // assign a false positive if detection fails => unable to shiv
                        supportsHtml5Styles = true;
                        supportsUnknownElements = true;
                    }
                })();

                /*--------------------------------------------------------------------------*/

                /**
                 * Creates a style sheet with the given CSS text and adds it to the document.
                 * @private
                 * @param {Document} ownerDocument The document.
                 * @param {String} cssText The CSS text.
                 * @returns {StyleSheet} The style element.
                 */
                function addStyleSheet(ownerDocument, cssText) {
                    var p = ownerDocument.createElement('p'),
                        parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;

                    p.innerHTML = 'x<style>' + cssText + '</style>';
                    return parent.insertBefore(p.lastChild, parent.firstChild);
                }

                /**
                 * Returns the value of `html5.elements` as an array.
                 * @private
                 * @returns {Array} An array of shived element node names.
                 */
                function getElements() {
                    var elements = html5.elements;
                    return typeof elements == 'string' ? elements.split(' ') : elements;
                }

                /**
                 * Extends the built-in list of html5 elements
                 * @memberOf html5
                 * @param {String|Array} newElements whitespace separated list or array of new element names to shiv
                 * @param {Document} ownerDocument The context document.
                 */
                function addElements(newElements, ownerDocument) {
                    var elements = html5.elements;
                    if (typeof elements != 'string') {
                        elements = elements.join(' ');
                    }
                    if (typeof newElements != 'string') {
                        newElements = newElements.join(' ');
                    }
                    html5.elements = elements + ' ' + newElements;
                    shivDocument(ownerDocument);
                }

                /**
                * Returns the data associated to the given document
                * @private
                * @param {Document} ownerDocument The document.
                * @returns {Object} An object of data.
                */
                function getExpandoData(ownerDocument) {
                    var data = expandoData[ownerDocument[expando]];
                    if (!data) {
                        data = {};
                        expanID++;
                        ownerDocument[expando] = expanID;
                        expandoData[expanID] = data;
                    }
                    return data;
                }

                /**
                 * returns a shived element for the given nodeName and document
                 * @memberOf html5
                 * @param {String} nodeName name of the element
                 * @param {Document} ownerDocument The context document.
                 * @returns {Object} The shived element.
                 */
                function createElement(nodeName, ownerDocument, data) {
                    if (!ownerDocument) {
                        ownerDocument = document;
                    }
                    if (supportsUnknownElements) {
                        return ownerDocument.createElement(nodeName);
                    }
                    if (!data) {
                        data = getExpandoData(ownerDocument);
                    }
                    var node;

                    if (data.cache[nodeName]) {
                        node = data.cache[nodeName].cloneNode();
                    } else if (saveClones.test(nodeName)) {
                        node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
                    } else {
                        node = data.createElem(nodeName);
                    }

                    // Avoid adding some elements to fragments in IE < 9 because
                    // * Attributes like `name` or `type` cannot be set/changed once an element
                    //   is inserted into a document/fragment
                    // * Link elements with `src` attributes that are inaccessible, as with
                    //   a 403 response, will cause the tab/window to crash
                    // * Script elements appended to fragments will execute when their `src`
                    //   or `text` property is set
                    return node.canHaveChildren && !reSkip.test(nodeName) && !node.tagUrn ? data.frag.appendChild(node) : node;
                }

                /**
                 * returns a shived DocumentFragment for the given document
                 * @memberOf html5
                 * @param {Document} ownerDocument The context document.
                 * @returns {Object} The shived DocumentFragment.
                 */
                function createDocumentFragment(ownerDocument, data) {
                    if (!ownerDocument) {
                        ownerDocument = document;
                    }
                    if (supportsUnknownElements) {
                        return ownerDocument.createDocumentFragment();
                    }
                    data = data || getExpandoData(ownerDocument);
                    var clone = data.frag.cloneNode(),
                        i = 0,
                        elems = getElements(),
                        l = elems.length;
                    for (; i < l; i++) {
                        clone.createElement(elems[i]);
                    }
                    return clone;
                }

                /**
                 * Shivs the `createElement` and `createDocumentFragment` methods of the document.
                 * @private
                 * @param {Document|DocumentFragment} ownerDocument The document.
                 * @param {Object} data of the document.
                 */
                function shivMethods(ownerDocument, data) {
                    if (!data.cache) {
                        data.cache = {};
                        data.createElem = ownerDocument.createElement;
                        data.createFrag = ownerDocument.createDocumentFragment;
                        data.frag = data.createFrag();
                    }

                    ownerDocument.createElement = function (nodeName) {
                        //abort shiv
                        if (!html5.shivMethods) {
                            return data.createElem(nodeName);
                        }
                        return createElement(nodeName, ownerDocument, data);
                    };

                    ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' + 'var n=f.cloneNode(),c=n.createElement;' + 'h.shivMethods&&(' +
                    // unroll the `createElement` calls
                    getElements().join().replace(/[\w\-:]+/g, function (nodeName) {
                        data.createElem(nodeName);
                        data.frag.createElement(nodeName);
                        return 'c("' + nodeName + '")';
                    }) + ');return n}')(html5, data.frag);
                }

                /*--------------------------------------------------------------------------*/

                /**
                 * Shivs the given document.
                 * @memberOf html5
                 * @param {Document} ownerDocument The document to shiv.
                 * @returns {Document} The shived document.
                 */
                function shivDocument(ownerDocument) {
                    if (!ownerDocument) {
                        ownerDocument = document;
                    }
                    var data = getExpandoData(ownerDocument);

                    if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
                        data.hasCSS = !!addStyleSheet(ownerDocument,
                        // corrects block display not defined in IE6/7/8/9
                        'article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}' +
                        // adds styling not present in IE6/7/8/9
                        'mark{background:#FF0;color:#000}' +
                        // hides non-rendered elements
                        'template{display:none}');
                    }
                    if (!supportsUnknownElements) {
                        shivMethods(ownerDocument, data);
                    }
                    return ownerDocument;
                }

                /*--------------------------------------------------------------------------*/

                /**
                 * The `html5` object is exposed so that more elements can be shived and
                 * existing shiving can be detected on iframes.
                 * @type Object
                 * @example
                 *
                 * // options can be changed before the script is included
                 * html5 = { 'elements': 'mark section', 'shivCSS': false, 'shivMethods': false };
                 */
                var html5 = {

                    /**
                     * An array or space separated string of node names of the elements to shiv.
                     * @memberOf html5
                     * @type Array|String
                     */
                    'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video',

                    /**
                     * current version of html5shiv
                     */
                    'version': version,

                    /**
                     * A flag to indicate that the HTML5 style sheet should be inserted.
                     * @memberOf html5
                     * @type Boolean
                     */
                    'shivCSS': options.shivCSS !== false,

                    /**
                     * Is equal to true if a browser supports creating unknown/HTML5 elements
                     * @memberOf html5
                     * @type boolean
                     */
                    'supportsUnknownElements': supportsUnknownElements,

                    /**
                     * A flag to indicate that the document's `createElement` and `createDocumentFragment`
                     * methods should be overwritten.
                     * @memberOf html5
                     * @type Boolean
                     */
                    'shivMethods': options.shivMethods !== false,

                    /**
                     * A string to describe the type of `html5` object ("default" or "default print").
                     * @memberOf html5
                     * @type String
                     */
                    'type': 'default',

                    // shivs the document according to the specified `html5` object options
                    'shivDocument': shivDocument,

                    //creates a shived element
                    createElement: createElement,

                    //creates a shived documentFragment
                    createDocumentFragment: createDocumentFragment,

                    //extends list of elements
                    addElements: addElements
                };

                /*--------------------------------------------------------------------------*/

                // expose html5
                window.html5 = html5;

                // shiv the document
                shivDocument(document);

                if (typeof module == 'object' && module.exports) {
                    module.exports = html5;
                }
            })(typeof window !== "undefined" ? window : this, document);
        }, {}], 7: [function (_dereq_, module, exports) {

            var L = {
                version: '1.0.1'
            };

            function expose() {
                var oldL = window.L;

                L.noConflict = function () {
                    window.L = oldL;
                    return this;
                };

                window.L = L;
            }

            // define Leaflet for Node module pattern loaders, including Browserify
            if (typeof module === 'object' && typeof module.exports === 'object') {
                module.exports = L;

                // define Leaflet as an AMD module
            } else if (typeof define === 'function' && define.amd) {
                define(L);
            }

            // define Leaflet as a global L variable, saving the original L to restore later if needed
            if (typeof window !== 'undefined') {
                expose();
            }

            /*
             * @namespace Util
             *
             * Various utility functions, used by Leaflet internally.
             */

            L.Util = {

                // @function extend(dest: Object, src?: Object): Object
                // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
                extend: function (dest) {
                    var i, j, len, src;

                    for (j = 1, len = arguments.length; j < len; j++) {
                        src = arguments[j];
                        for (i in src) {
                            dest[i] = src[i];
                        }
                    }
                    return dest;
                },

                // @function create(proto: Object, properties?: Object): Object
                // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
                create: Object.create || function () {
                    function F() {}
                    return function (proto) {
                        F.prototype = proto;
                        return new F();
                    };
                }(),

                // @function bind(fn: Function, …): Function
                // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
                // Has a `L.bind()` shortcut.
                bind: function (fn, obj) {
                    var slice = Array.prototype.slice;

                    if (fn.bind) {
                        return fn.bind.apply(fn, slice.call(arguments, 1));
                    }

                    var args = slice.call(arguments, 2);

                    return function () {
                        return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
                    };
                },

                // @function stamp(obj: Object): Number
                // Returns the unique ID of an object, assiging it one if it doesn't have it.
                stamp: function (obj) {
                    /*eslint-disable */
                    obj._leaflet_id = obj._leaflet_id || ++L.Util.lastId;
                    return obj._leaflet_id;
                    /*eslint-enable */
                },

                // @property lastId: Number
                // Last unique ID used by [`stamp()`](#util-stamp)
                lastId: 0,

                // @function throttle(fn: Function, time: Number, context: Object): Function
                // Returns a function which executes function `fn` with the given scope `context`
                // (so that the `this` keyword refers to `context` inside `fn`'s code). The function
                // `fn` will be called no more than one time per given amount of `time`. The arguments
                // received by the bound function will be any arguments passed when binding the
                // function, followed by any arguments passed when invoking the bound function.
                // Has an `L.bind` shortcut.
                throttle: function (fn, time, context) {
                    var lock, args, wrapperFn, later;

                    later = function () {
                        // reset lock and call if queued
                        lock = false;
                        if (args) {
                            wrapperFn.apply(context, args);
                            args = false;
                        }
                    };

                    wrapperFn = function () {
                        if (lock) {
                            // called too soon, queue to call later
                            args = arguments;
                        } else {
                            // call and lock until later
                            fn.apply(context, arguments);
                            setTimeout(later, time);
                            lock = true;
                        }
                    };

                    return wrapperFn;
                },

                // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
                // Returns the number `num` modulo `range` in such a way so it lies within
                // `range[0]` and `range[1]`. The returned value will be always smaller than
                // `range[1]` unless `includeMax` is set to `true`.
                wrapNum: function (x, range, includeMax) {
                    var max = range[1],
                        min = range[0],
                        d = max - min;
                    return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
                },

                // @function falseFn(): Function
                // Returns a function which always returns `false`.
                falseFn: function () {
                    return false;
                },

                // @function formatNum(num: Number, digits?: Number): Number
                // Returns the number `num` rounded to `digits` decimals, or to 5 decimals by default.
                formatNum: function (num, digits) {
                    var pow = Math.pow(10, digits || 5);
                    return Math.round(num * pow) / pow;
                },

                // @function trim(str: String): String
                // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
                trim: function (str) {
                    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
                },

                // @function splitWords(str: String): String[]
                // Trims and splits the string on whitespace and returns the array of parts.
                splitWords: function (str) {
                    return L.Util.trim(str).split(/\s+/);
                },

                // @function setOptions(obj: Object, options: Object): Object
                // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
                setOptions: function (obj, options) {
                    if (!obj.hasOwnProperty('options')) {
                        obj.options = obj.options ? L.Util.create(obj.options) : {};
                    }
                    for (var i in options) {
                        obj.options[i] = options[i];
                    }
                    return obj.options;
                },

                // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
                // Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
                // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
                // be appended at the end. If `uppercase` is `true`, the parameter names will
                // be uppercased (e.g. `'?A=foo&B=bar'`)
                getParamString: function (obj, existingUrl, uppercase) {
                    var params = [];
                    for (var i in obj) {
                        params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
                    }
                    return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');
                },

                // @function template(str: String, data: Object): String
                // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
                // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
                // `('Hello foo, bar')`. You can also specify functions instead of strings for
                // data values — they will be evaluated passing `data` as an argument.
                template: function (str, data) {
                    return str.replace(L.Util.templateRe, function (str, key) {
                        var value = data[key];

                        if (value === undefined) {
                            throw new Error('No value provided for variable ' + str);
                        } else if (typeof value === 'function') {
                            value = value(data);
                        }
                        return value;
                    });
                },

                templateRe: /\{ *([\w_\-]+) *\}/g,

                // @function isArray(obj): Boolean
                // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
                isArray: Array.isArray || function (obj) {
                    return Object.prototype.toString.call(obj) === '[object Array]';
                },

                // @function indexOf(array: Array, el: Object): Number
                // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
                indexOf: function (array, el) {
                    for (var i = 0; i < array.length; i++) {
                        if (array[i] === el) {
                            return i;
                        }
                    }
                    return -1;
                },

                // @property emptyImageUrl: String
                // Data URI string containing a base64-encoded empty GIF image.
                // Used as a hack to free memory from unused images on WebKit-powered
                // mobile devices (by setting image `src` to this string).
                emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
            };

            (function () {
                // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

                function getPrefixed(name) {
                    return window['webkit' + name] || window['moz' + name] || window['ms' + name];
                }

                var lastTime = 0;

                // fallback for IE 7-8
                function timeoutDefer(fn) {
                    var time = +new Date(),
                        timeToCall = Math.max(0, 16 - (time - lastTime));

                    lastTime = time + timeToCall;
                    return window.setTimeout(fn, timeToCall);
                }

                var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer,
                    cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {
                    window.clearTimeout(id);
                };

                // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
                // Schedules `fn` to be executed when the browser repaints. `fn` is bound to
                // `context` if given. When `immediate` is set, `fn` is called immediately if
                // the browser doesn't have native support for
                // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
                // otherwise it's delayed. Returns a request ID that can be used to cancel the request.
                L.Util.requestAnimFrame = function (fn, context, immediate) {
                    if (immediate && requestFn === timeoutDefer) {
                        fn.call(context);
                    } else {
                        return requestFn.call(window, L.bind(fn, context));
                    }
                };

                // @function cancelAnimFrame(id: Number): undefined
                // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
                L.Util.cancelAnimFrame = function (id) {
                    if (id) {
                        cancelFn.call(window, id);
                    }
                };
            })();

            // shortcuts for most used utility functions
            L.extend = L.Util.extend;
            L.bind = L.Util.bind;
            L.stamp = L.Util.stamp;
            L.setOptions = L.Util.setOptions;

            // @class Class
            // @aka L.Class

            // @section
            // @uninheritable

            // Thanks to John Resig and Dean Edwards for inspiration!

            L.Class = function () {};

            L.Class.extend = function (props) {

                // @function extend(props: Object): Function
                // [Extends the current class](#class-inheritance) given the properties to be included.
                // Returns a Javascript function that is a class constructor (to be called with `new`).
                var NewClass = function () {

                    // call the constructor
                    if (this.initialize) {
                        this.initialize.apply(this, arguments);
                    }

                    // call all constructor hooks
                    this.callInitHooks();
                };

                var parentProto = NewClass.__super__ = this.prototype;

                var proto = L.Util.create(parentProto);
                proto.constructor = NewClass;

                NewClass.prototype = proto;

                // inherit parent's statics
                for (var i in this) {
                    if (this.hasOwnProperty(i) && i !== 'prototype') {
                        NewClass[i] = this[i];
                    }
                }

                // mix static properties into the class
                if (props.statics) {
                    L.extend(NewClass, props.statics);
                    delete props.statics;
                }

                // mix includes into the prototype
                if (props.includes) {
                    L.Util.extend.apply(null, [proto].concat(props.includes));
                    delete props.includes;
                }

                // merge options
                if (proto.options) {
                    props.options = L.Util.extend(L.Util.create(proto.options), props.options);
                }

                // mix given properties into the prototype
                L.extend(proto, props);

                proto._initHooks = [];

                // add method for calling all hooks
                proto.callInitHooks = function () {

                    if (this._initHooksCalled) {
                        return;
                    }

                    if (parentProto.callInitHooks) {
                        parentProto.callInitHooks.call(this);
                    }

                    this._initHooksCalled = true;

                    for (var i = 0, len = proto._initHooks.length; i < len; i++) {
                        proto._initHooks[i].call(this);
                    }
                };

                return NewClass;
            };

            // @function include(properties: Object): this
            // [Includes a mixin](#class-includes) into the current class.
            L.Class.include = function (props) {
                L.extend(this.prototype, props);
                return this;
            };

            // @function mergeOptions(options: Object): this
            // [Merges `options`](#class-options) into the defaults of the class.
            L.Class.mergeOptions = function (options) {
                L.extend(this.prototype.options, options);
                return this;
            };

            // @function addInitHook(fn: Function): this
            // Adds a [constructor hook](#class-constructor-hooks) to the class.
            L.Class.addInitHook = function (fn) {
                // (Function) || (String, args...)
                var args = Array.prototype.slice.call(arguments, 1);

                var init = typeof fn === 'function' ? fn : function () {
                    this[fn].apply(this, args);
                };

                this.prototype._initHooks = this.prototype._initHooks || [];
                this.prototype._initHooks.push(init);
                return this;
            };

            /*
             * @class Evented
             * @aka L.Evented
             * @inherits Class
             *
             * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
             *
             * @example
             *
             * ```js
             * map.on('click', function(e) {
             * 	alert(e.latlng);
             * } );
             * ```
             *
             * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
             *
             * ```js
             * function onClick(e) { ... }
             *
             * map.on('click', onClick);
             * map.off('click', onClick);
             * ```
             */

            L.Evented = L.Class.extend({

                /* @method on(type: String, fn: Function, context?: Object): this
                 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
                 *
                 * @alternative
                 * @method on(eventMap: Object): this
                 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
                 */
                on: function (types, fn, context) {

                    // types can be a map of types/handlers
                    if (typeof types === 'object') {
                        for (var type in types) {
                            // we don't process space-separated events here for performance;
                            // it's a hot path since Layer uses the on(obj) syntax
                            this._on(type, types[type], fn);
                        }
                    } else {
                        // types can be a string of space-separated words
                        types = L.Util.splitWords(types);

                        for (var i = 0, len = types.length; i < len; i++) {
                            this._on(types[i], fn, context);
                        }
                    }

                    return this;
                },

                /* @method off(type: String, fn?: Function, context?: Object): this
                 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
                 *
                 * @alternative
                 * @method off(eventMap: Object): this
                 * Removes a set of type/listener pairs.
                 *
                 * @alternative
                 * @method off: this
                 * Removes all listeners to all events on the object.
                 */
                off: function (types, fn, context) {

                    if (!types) {
                        // clear all listeners if called without arguments
                        delete this._events;
                    } else if (typeof types === 'object') {
                        for (var type in types) {
                            this._off(type, types[type], fn);
                        }
                    } else {
                        types = L.Util.splitWords(types);

                        for (var i = 0, len = types.length; i < len; i++) {
                            this._off(types[i], fn, context);
                        }
                    }

                    return this;
                },

                // attach listener (without syntactic sugar now)
                _on: function (type, fn, context) {
                    this._events = this._events || {};

                    /* get/init listeners for type */
                    var typeListeners = this._events[type];
                    if (!typeListeners) {
                        typeListeners = [];
                        this._events[type] = typeListeners;
                    }

                    if (context === this) {
                        // Less memory footprint.
                        context = undefined;
                    }
                    var newListener = { fn: fn, ctx: context },
                        listeners = typeListeners;

                    // check if fn already there
                    for (var i = 0, len = listeners.length; i < len; i++) {
                        if (listeners[i].fn === fn && listeners[i].ctx === context) {
                            return;
                        }
                    }

                    listeners.push(newListener);
                    typeListeners.count++;
                },

                _off: function (type, fn, context) {
                    var listeners, i, len;

                    if (!this._events) {
                        return;
                    }

                    listeners = this._events[type];

                    if (!listeners) {
                        return;
                    }

                    if (!fn) {
                        // Set all removed listeners to noop so they are not called if remove happens in fire
                        for (i = 0, len = listeners.length; i < len; i++) {
                            listeners[i].fn = L.Util.falseFn;
                        }
                        // clear all listeners for a type if function isn't specified
                        delete this._events[type];
                        return;
                    }

                    if (context === this) {
                        context = undefined;
                    }

                    if (listeners) {

                        // find fn and remove it
                        for (i = 0, len = listeners.length; i < len; i++) {
                            var l = listeners[i];
                            if (l.ctx !== context) {
                                continue;
                            }
                            if (l.fn === fn) {

                                // set the removed listener to noop so that's not called if remove happens in fire
                                l.fn = L.Util.falseFn;

                                if (this._firingCount) {
                                    /* copy array in case events are being fired */
                                    this._events[type] = listeners = listeners.slice();
                                }
                                listeners.splice(i, 1);

                                return;
                            }
                        }
                    }
                },

                // @method fire(type: String, data?: Object, propagate?: Boolean): this
                // Fires an event of the specified type. You can optionally provide an data
                // object — the first argument of the listener function will contain its
                // properties. The event might can optionally be propagated to event parents.
                fire: function (type, data, propagate) {
                    if (!this.listens(type, propagate)) {
                        return this;
                    }

                    var event = L.Util.extend({}, data, { type: type, target: this });

                    if (this._events) {
                        var listeners = this._events[type];

                        if (listeners) {
                            this._firingCount = this._firingCount + 1 || 1;
                            for (var i = 0, len = listeners.length; i < len; i++) {
                                var l = listeners[i];
                                l.fn.call(l.ctx || this, event);
                            }

                            this._firingCount--;
                        }
                    }

                    if (propagate) {
                        // propagate the event to parents (set with addEventParent)
                        this._propagateEvent(event);
                    }

                    return this;
                },

                // @method listens(type: String): Boolean
                // Returns `true` if a particular event type has any listeners attached to it.
                listens: function (type, propagate) {
                    var listeners = this._events && this._events[type];
                    if (listeners && listeners.length) {
                        return true;
                    }

                    if (propagate) {
                        // also check parents for listeners if event propagates
                        for (var id in this._eventParents) {
                            if (this._eventParents[id].listens(type, propagate)) {
                                return true;
                            }
                        }
                    }
                    return false;
                },

                // @method once(…): this
                // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
                once: function (types, fn, context) {

                    if (typeof types === 'object') {
                        for (var type in types) {
                            this.once(type, types[type], fn);
                        }
                        return this;
                    }

                    var handler = L.bind(function () {
                        this.off(types, fn, context).off(types, handler, context);
                    }, this);

                    // add a listener that's executed once and removed after that
                    return this.on(types, fn, context).on(types, handler, context);
                },

                // @method addEventParent(obj: Evented): this
                // Adds an event parent - an `Evented` that will receive propagated events
                addEventParent: function (obj) {
                    this._eventParents = this._eventParents || {};
                    this._eventParents[L.stamp(obj)] = obj;
                    return this;
                },

                // @method removeEventParent(obj: Evented): this
                // Removes an event parent, so it will stop receiving propagated events
                removeEventParent: function (obj) {
                    if (this._eventParents) {
                        delete this._eventParents[L.stamp(obj)];
                    }
                    return this;
                },

                _propagateEvent: function (e) {
                    for (var id in this._eventParents) {
                        this._eventParents[id].fire(e.type, L.extend({ layer: e.target }, e), true);
                    }
                }
            });

            var proto = L.Evented.prototype;

            // aliases; we should ditch those eventually

            // @method addEventListener(…): this
            // Alias to [`on(…)`](#evented-on)
            proto.addEventListener = proto.on;

            // @method removeEventListener(…): this
            // Alias to [`off(…)`](#evented-off)

            // @method clearAllEventListeners(…): this
            // Alias to [`off()`](#evented-off)
            proto.removeEventListener = proto.clearAllEventListeners = proto.off;

            // @method addOneTimeEventListener(…): this
            // Alias to [`once(…)`](#evented-once)
            proto.addOneTimeEventListener = proto.once;

            // @method fireEvent(…): this
            // Alias to [`fire(…)`](#evented-fire)
            proto.fireEvent = proto.fire;

            // @method hasEventListeners(…): Boolean
            // Alias to [`listens(…)`](#evented-listens)
            proto.hasEventListeners = proto.listens;

            L.Mixin = { Events: proto };

            /*
             * @namespace Browser
             * @aka L.Browser
             *
             * A namespace with static properties for browser/feature detection used by Leaflet internally.
             *
             * @example
             *
             * ```js
             * if (L.Browser.ielt9) {
             *   alert('Upgrade your browser, dude!');
             * }
             * ```
             */

            (function () {

                var ua = navigator.userAgent.toLowerCase(),
                    doc = document.documentElement,
                    ie = 'ActiveXObject' in window,
                    webkit = ua.indexOf('webkit') !== -1,
                    phantomjs = ua.indexOf('phantom') !== -1,
                    android23 = ua.search('android [23]') !== -1,
                    chrome = ua.indexOf('chrome') !== -1,
                    gecko = ua.indexOf('gecko') !== -1 && !webkit && !window.opera && !ie,
                    win = navigator.platform.indexOf('Win') === 0,
                    mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1,
                    msPointer = !window.PointerEvent && window.MSPointerEvent,
                    pointer = window.PointerEvent || msPointer,
                    ie3d = ie && 'transition' in doc.style,
                    webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23,
                    gecko3d = 'MozPerspective' in doc.style,
                    opera12 = 'OTransition' in doc.style;

                var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch);

                L.Browser = {

                    // @property ie: Boolean
                    // `true` for all Internet Explorer versions (not Edge).
                    ie: ie,

                    // @property ielt9: Boolean
                    // `true` for Internet Explorer versions less than 9.
                    ielt9: ie && !document.addEventListener,

                    // @property edge: Boolean
                    // `true` for the Edge web browser.
                    edge: 'msLaunchUri' in navigator && !('documentMode' in document),

                    // @property webkit: Boolean
                    // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
                    webkit: webkit,

                    // @property gecko: Boolean
                    // `true` for gecko-based browsers like Firefox.
                    gecko: gecko,

                    // @property android: Boolean
                    // `true` for any browser running on an Android platform.
                    android: ua.indexOf('android') !== -1,

                    // @property android23: Boolean
                    // `true` for browsers running on Android 2 or Android 3.
                    android23: android23,

                    // @property chrome: Boolean
                    // `true` for the Chrome browser.
                    chrome: chrome,

                    // @property safari: Boolean
                    // `true` for the Safari browser.
                    safari: !chrome && ua.indexOf('safari') !== -1,

                    // @property win: Boolean
                    // `true` when the browser is running in a Windows platform
                    win: win,

                    // @property ie3d: Boolean
                    // `true` for all Internet Explorer versions supporting CSS transforms.
                    ie3d: ie3d,

                    // @property webkit3d: Boolean
                    // `true` for webkit-based browsers supporting CSS transforms.
                    webkit3d: webkit3d,

                    // @property gecko3d: Boolean
                    // `true` for gecko-based browsers supporting CSS transforms.
                    gecko3d: gecko3d,

                    // @property opera12: Boolean
                    // `true` for the Opera browser supporting CSS transforms (version 12 or later).
                    opera12: opera12,

                    // @property any3d: Boolean
                    // `true` for all browsers supporting CSS transforms.
                    any3d: !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs,

                    // @property mobile: Boolean
                    // `true` for all browsers running in a mobile device.
                    mobile: mobile,

                    // @property mobileWebkit: Boolean
                    // `true` for all webkit-based browsers in a mobile device.
                    mobileWebkit: mobile && webkit,

                    // @property mobileWebkit3d: Boolean
                    // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
                    mobileWebkit3d: mobile && webkit3d,

                    // @property mobileOpera: Boolean
                    // `true` for the Opera browser in a mobile device.
                    mobileOpera: mobile && window.opera,

                    // @property mobileGecko: Boolean
                    // `true` for gecko-based browsers running in a mobile device.
                    mobileGecko: mobile && gecko,

                    // @property touch: Boolean
                    // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
                    touch: !!touch,

                    // @property msPointer: Boolean
                    // `true` for browsers implementing the Microsoft touch events model (notably IE10).
                    msPointer: !!msPointer,

                    // @property pointer: Boolean
                    // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
                    pointer: !!pointer,

                    // @property retina: Boolean
                    // `true` for browsers on a high-resolution "retina" screen.
                    retina: (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1
                };
            })();

            /*
             * @class Point
             * @aka L.Point
             *
             * Represents a point with `x` and `y` coordinates in pixels.
             *
             * @example
             *
             * ```js
             * var point = L.point(200, 300);
             * ```
             *
             * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
             *
             * ```js
             * map.panBy([200, 300]);
             * map.panBy(L.point(200, 300));
             * ```
             */

            L.Point = function (x, y, round) {
                this.x = round ? Math.round(x) : x;
                this.y = round ? Math.round(y) : y;
            };

            L.Point.prototype = {

                // @method clone(): Point
                // Returns a copy of the current point.
                clone: function () {
                    return new L.Point(this.x, this.y);
                },

                // @method add(otherPoint: Point): Point
                // Returns the result of addition of the current and the given points.
                add: function (point) {
                    // non-destructive, returns a new point
                    return this.clone()._add(L.point(point));
                },

                _add: function (point) {
                    // destructive, used directly for performance in situations where it's safe to modify existing point
                    this.x += point.x;
                    this.y += point.y;
                    return this;
                },

                // @method subtract(otherPoint: Point): Point
                // Returns the result of subtraction of the given point from the current.
                subtract: function (point) {
                    return this.clone()._subtract(L.point(point));
                },

                _subtract: function (point) {
                    this.x -= point.x;
                    this.y -= point.y;
                    return this;
                },

                // @method divideBy(num: Number): Point
                // Returns the result of division of the current point by the given number.
                divideBy: function (num) {
                    return this.clone()._divideBy(num);
                },

                _divideBy: function (num) {
                    this.x /= num;
                    this.y /= num;
                    return this;
                },

                // @method multiplyBy(num: Number): Point
                // Returns the result of multiplication of the current point by the given number.
                multiplyBy: function (num) {
                    return this.clone()._multiplyBy(num);
                },

                _multiplyBy: function (num) {
                    this.x *= num;
                    this.y *= num;
                    return this;
                },

                // @method scaleBy(scale: Point): Point
                // Multiply each coordinate of the current point by each coordinate of
                // `scale`. In linear algebra terms, multiply the point by the
                // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
                // defined by `scale`.
                scaleBy: function (point) {
                    return new L.Point(this.x * point.x, this.y * point.y);
                },

                // @method unscaleBy(scale: Point): Point
                // Inverse of `scaleBy`. Divide each coordinate of the current point by
                // each coordinate of `scale`.
                unscaleBy: function (point) {
                    return new L.Point(this.x / point.x, this.y / point.y);
                },

                // @method round(): Point
                // Returns a copy of the current point with rounded coordinates.
                round: function () {
                    return this.clone()._round();
                },

                _round: function () {
                    this.x = Math.round(this.x);
                    this.y = Math.round(this.y);
                    return this;
                },

                // @method floor(): Point
                // Returns a copy of the current point with floored coordinates (rounded down).
                floor: function () {
                    return this.clone()._floor();
                },

                _floor: function () {
                    this.x = Math.floor(this.x);
                    this.y = Math.floor(this.y);
                    return this;
                },

                // @method ceil(): Point
                // Returns a copy of the current point with ceiled coordinates (rounded up).
                ceil: function () {
                    return this.clone()._ceil();
                },

                _ceil: function () {
                    this.x = Math.ceil(this.x);
                    this.y = Math.ceil(this.y);
                    return this;
                },

                // @method distanceTo(otherPoint: Point): Number
                // Returns the cartesian distance between the current and the given points.
                distanceTo: function (point) {
                    point = L.point(point);

                    var x = point.x - this.x,
                        y = point.y - this.y;

                    return Math.sqrt(x * x + y * y);
                },

                // @method equals(otherPoint: Point): Boolean
                // Returns `true` if the given point has the same coordinates.
                equals: function (point) {
                    point = L.point(point);

                    return point.x === this.x && point.y === this.y;
                },

                // @method contains(otherPoint: Point): Boolean
                // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
                contains: function (point) {
                    point = L.point(point);

                    return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
                },

                // @method toString(): String
                // Returns a string representation of the point for debugging purposes.
                toString: function () {
                    return 'Point(' + L.Util.formatNum(this.x) + ', ' + L.Util.formatNum(this.y) + ')';
                }
            };

            // @factory L.point(x: Number, y: Number, round?: Boolean)
            // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

            // @alternative
            // @factory L.point(coords: Number[])
            // Expects an array of the form `[x, y]` instead.

            // @alternative
            // @factory L.point(coords: Object)
            // Expects a plain object of the form `{x: Number, y: Number}` instead.
            L.point = function (x, y, round) {
                if (x instanceof L.Point) {
                    return x;
                }
                if (L.Util.isArray(x)) {
                    return new L.Point(x[0], x[1]);
                }
                if (x === undefined || x === null) {
                    return x;
                }
                if (typeof x === 'object' && 'x' in x && 'y' in x) {
                    return new L.Point(x.x, x.y);
                }
                return new L.Point(x, y, round);
            };

            /*
             * @class Bounds
             * @aka L.Bounds
             *
             * Represents a rectangular area in pixel coordinates.
             *
             * @example
             *
             * ```js
             * var p1 = L.point(10, 10),
             * p2 = L.point(40, 60),
             * bounds = L.bounds(p1, p2);
             * ```
             *
             * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
             *
             * ```js
             * otherBounds.intersects([[10, 10], [40, 60]]);
             * ```
             */

            L.Bounds = function (a, b) {
                if (!a) {
                    return;
                }

                var points = b ? [a, b] : a;

                for (var i = 0, len = points.length; i < len; i++) {
                    this.extend(points[i]);
                }
            };

            L.Bounds.prototype = {
                // @method extend(point: Point): this
                // Extends the bounds to contain the given point.
                extend: function (point) {
                    // (Point)
                    point = L.point(point);

                    // @property min: Point
                    // The top left corner of the rectangle.
                    // @property max: Point
                    // The bottom right corner of the rectangle.
                    if (!this.min && !this.max) {
                        this.min = point.clone();
                        this.max = point.clone();
                    } else {
                        this.min.x = Math.min(point.x, this.min.x);
                        this.max.x = Math.max(point.x, this.max.x);
                        this.min.y = Math.min(point.y, this.min.y);
                        this.max.y = Math.max(point.y, this.max.y);
                    }
                    return this;
                },

                // @method getCenter(round?: Boolean): Point
                // Returns the center point of the bounds.
                getCenter: function (round) {
                    return new L.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
                },

                // @method getBottomLeft(): Point
                // Returns the bottom-left point of the bounds.
                getBottomLeft: function () {
                    return new L.Point(this.min.x, this.max.y);
                },

                // @method getTopRight(): Point
                // Returns the top-right point of the bounds.
                getTopRight: function () {
                    // -> Point
                    return new L.Point(this.max.x, this.min.y);
                },

                // @method getSize(): Point
                // Returns the size of the given bounds
                getSize: function () {
                    return this.max.subtract(this.min);
                },

                // @method contains(otherBounds: Bounds): Boolean
                // Returns `true` if the rectangle contains the given one.
                // @alternative
                // @method contains(point: Point): Boolean
                // Returns `true` if the rectangle contains the given point.
                contains: function (obj) {
                    var min, max;

                    if (typeof obj[0] === 'number' || obj instanceof L.Point) {
                        obj = L.point(obj);
                    } else {
                        obj = L.bounds(obj);
                    }

                    if (obj instanceof L.Bounds) {
                        min = obj.min;
                        max = obj.max;
                    } else {
                        min = max = obj;
                    }

                    return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
                },

                // @method intersects(otherBounds: Bounds): Boolean
                // Returns `true` if the rectangle intersects the given bounds. Two bounds
                // intersect if they have at least one point in common.
                intersects: function (bounds) {
                    // (Bounds) -> Boolean
                    bounds = L.bounds(bounds);

                    var min = this.min,
                        max = this.max,
                        min2 = bounds.min,
                        max2 = bounds.max,
                        xIntersects = max2.x >= min.x && min2.x <= max.x,
                        yIntersects = max2.y >= min.y && min2.y <= max.y;

                    return xIntersects && yIntersects;
                },

                // @method overlaps(otherBounds: Bounds): Boolean
                // Returns `true` if the rectangle overlaps the given bounds. Two bounds
                // overlap if their intersection is an area.
                overlaps: function (bounds) {
                    // (Bounds) -> Boolean
                    bounds = L.bounds(bounds);

                    var min = this.min,
                        max = this.max,
                        min2 = bounds.min,
                        max2 = bounds.max,
                        xOverlaps = max2.x > min.x && min2.x < max.x,
                        yOverlaps = max2.y > min.y && min2.y < max.y;

                    return xOverlaps && yOverlaps;
                },

                isValid: function () {
                    return !!(this.min && this.max);
                }
            };

            // @factory L.bounds(topLeft: Point, bottomRight: Point)
            // Creates a Bounds object from two coordinates (usually top-left and bottom-right corners).
            // @alternative
            // @factory L.bounds(points: Point[])
            // Creates a Bounds object from the points it contains
            L.bounds = function (a, b) {
                if (!a || a instanceof L.Bounds) {
                    return a;
                }
                return new L.Bounds(a, b);
            };

            /*
             * @class Transformation
             * @aka L.Transformation
             *
             * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
             * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
             * the reverse. Used by Leaflet in its projections code.
             *
             * @example
             *
             * ```js
             * var transformation = new L.Transformation(2, 5, -1, 10),
             * 	p = L.point(1, 2),
             * 	p2 = transformation.transform(p), //  L.point(7, 8)
             * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
             * ```
             */

            // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
            // Creates a `Transformation` object with the given coefficients.
            L.Transformation = function (a, b, c, d) {
                this._a = a;
                this._b = b;
                this._c = c;
                this._d = d;
            };

            L.Transformation.prototype = {
                // @method transform(point: Point, scale?: Number): Point
                // Returns a transformed point, optionally multiplied by the given scale.
                // Only accepts real `L.Point` instances, not arrays.
                transform: function (point, scale) {
                    // (Point, Number) -> Point
                    return this._transform(point.clone(), scale);
                },

                // destructive transform (faster)
                _transform: function (point, scale) {
                    scale = scale || 1;
                    point.x = scale * (this._a * point.x + this._b);
                    point.y = scale * (this._c * point.y + this._d);
                    return point;
                },

                // @method untransform(point: Point, scale?: Number): Point
                // Returns the reverse transformation of the given point, optionally divided
                // by the given scale. Only accepts real `L.Point` instances, not arrays.
                untransform: function (point, scale) {
                    scale = scale || 1;
                    return new L.Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);
                }
            };

            /*
             * @namespace DomUtil
             *
             * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
             * tree, used by Leaflet internally.
             *
             * Most functions expecting or returning a `HTMLElement` also work for
             * SVG elements. The only difference is that classes refer to CSS classes
             * in HTML and SVG classes in SVG.
             */

            L.DomUtil = {

                // @function get(id: String|HTMLElement): HTMLElement
                // Returns an element given its DOM id, or returns the element itself
                // if it was passed directly.
                get: function (id) {
                    return typeof id === 'string' ? document.getElementById(id) : id;
                },

                // @function getStyle(el: HTMLElement, styleAttrib: String): String
                // Returns the value for a certain style attribute on an element,
                // including computed values or values set through CSS.
                getStyle: function (el, style) {

                    var value = el.style[style] || el.currentStyle && el.currentStyle[style];

                    if ((!value || value === 'auto') && document.defaultView) {
                        var css = document.defaultView.getComputedStyle(el, null);
                        value = css ? css[style] : null;
                    }

                    return value === 'auto' ? null : value;
                },

                // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
                // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
                create: function (tagName, className, container) {

                    var el = document.createElement(tagName);
                    el.className = className || '';

                    if (container) {
                        container.appendChild(el);
                    }

                    return el;
                },

                // @function remove(el: HTMLElement)
                // Removes `el` from its parent element
                remove: function (el) {
                    var parent = el.parentNode;
                    if (parent) {
                        parent.removeChild(el);
                    }
                },

                // @function empty(el: HTMLElement)
                // Removes all of `el`'s children elements from `el`
                empty: function (el) {
                    while (el.firstChild) {
                        el.removeChild(el.firstChild);
                    }
                },

                // @function toFront(el: HTMLElement)
                // Makes `el` the last children of its parent, so it renders in front of the other children.
                toFront: function (el) {
                    el.parentNode.appendChild(el);
                },

                // @function toBack(el: HTMLElement)
                // Makes `el` the first children of its parent, so it renders back from the other children.
                toBack: function (el) {
                    var parent = el.parentNode;
                    parent.insertBefore(el, parent.firstChild);
                },

                // @function hasClass(el: HTMLElement, name: String): Boolean
                // Returns `true` if the element's class attribute contains `name`.
                hasClass: function (el, name) {
                    if (el.classList !== undefined) {
                        return el.classList.contains(name);
                    }
                    var className = L.DomUtil.getClass(el);
                    return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
                },

                // @function addClass(el: HTMLElement, name: String)
                // Adds `name` to the element's class attribute.
                addClass: function (el, name) {
                    if (el.classList !== undefined) {
                        var classes = L.Util.splitWords(name);
                        for (var i = 0, len = classes.length; i < len; i++) {
                            el.classList.add(classes[i]);
                        }
                    } else if (!L.DomUtil.hasClass(el, name)) {
                        var className = L.DomUtil.getClass(el);
                        L.DomUtil.setClass(el, (className ? className + ' ' : '') + name);
                    }
                },

                // @function removeClass(el: HTMLElement, name: String)
                // Removes `name` from the element's class attribute.
                removeClass: function (el, name) {
                    if (el.classList !== undefined) {
                        el.classList.remove(name);
                    } else {
                        L.DomUtil.setClass(el, L.Util.trim((' ' + L.DomUtil.getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
                    }
                },

                // @function setClass(el: HTMLElement, name: String)
                // Sets the element's class.
                setClass: function (el, name) {
                    if (el.className.baseVal === undefined) {
                        el.className = name;
                    } else {
                        // in case of SVG element
                        el.className.baseVal = name;
                    }
                },

                // @function getClass(el: HTMLElement): String
                // Returns the element's class.
                getClass: function (el) {
                    return el.className.baseVal === undefined ? el.className : el.className.baseVal;
                },

                // @function setOpacity(el: HTMLElement, opacity: Number)
                // Set the opacity of an element (including old IE support).
                // `opacity` must be a number from `0` to `1`.
                setOpacity: function (el, value) {

                    if ('opacity' in el.style) {
                        el.style.opacity = value;
                    } else if ('filter' in el.style) {
                        L.DomUtil._setOpacityIE(el, value);
                    }
                },

                _setOpacityIE: function (el, value) {
                    var filter = false,
                        filterName = 'DXImageTransform.Microsoft.Alpha';

                    // filters collection throws an error if we try to retrieve a filter that doesn't exist
                    try {
                        filter = el.filters.item(filterName);
                    } catch (e) {
                        // don't set opacity to 1 if we haven't already set an opacity,
                        // it isn't needed and breaks transparent pngs.
                        if (value === 1) {
                            return;
                        }
                    }

                    value = Math.round(value * 100);

                    if (filter) {
                        filter.Enabled = value !== 100;
                        filter.Opacity = value;
                    } else {
                        el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
                    }
                },

                // @function testProp(props: String[]): String|false
                // Goes through the array of style names and returns the first name
                // that is a valid style name for an element. If no such name is found,
                // it returns false. Useful for vendor-prefixed styles like `transform`.
                testProp: function (props) {

                    var style = document.documentElement.style;

                    for (var i = 0; i < props.length; i++) {
                        if (props[i] in style) {
                            return props[i];
                        }
                    }
                    return false;
                },

                // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
                // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
                // and optionally scaled by `scale`. Does not have an effect if the
                // browser doesn't support 3D CSS transforms.
                setTransform: function (el, offset, scale) {
                    var pos = offset || new L.Point(0, 0);

                    el.style[L.DomUtil.TRANSFORM] = (L.Browser.ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');
                },

                // @function setPosition(el: HTMLElement, position: Point)
                // Sets the position of `el` to coordinates specified by `position`,
                // using CSS translate or top/left positioning depending on the browser
                // (used by Leaflet internally to position its layers).
                setPosition: function (el, point) {
                    // (HTMLElement, Point[, Boolean])

                    /*eslint-disable */
                    el._leaflet_pos = point;
                    /*eslint-enable */

                    if (L.Browser.any3d) {
                        L.DomUtil.setTransform(el, point);
                    } else {
                        el.style.left = point.x + 'px';
                        el.style.top = point.y + 'px';
                    }
                },

                // @function getPosition(el: HTMLElement): Point
                // Returns the coordinates of an element previously positioned with setPosition.
                getPosition: function (el) {
                    // this method is only used for elements previously positioned using setPosition,
                    // so it's safe to cache the position for performance

                    return el._leaflet_pos || new L.Point(0, 0);
                }
            };

            (function () {
                // prefix style property names

                // @property TRANSFORM: String
                // Vendor-prefixed fransform style name (e.g. `'webkitTransform'` for WebKit).
                L.DomUtil.TRANSFORM = L.DomUtil.testProp(['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

                // webkitTransition comes first because some browser versions that drop vendor prefix don't do
                // the same for the transitionend event, in particular the Android 4.1 stock browser

                // @property TRANSITION: String
                // Vendor-prefixed transform style name.
                var transition = L.DomUtil.TRANSITION = L.DomUtil.testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

                L.DomUtil.TRANSITION_END = transition === 'webkitTransition' || transition === 'OTransition' ? transition + 'End' : 'transitionend';

                // @function disableTextSelection()
                // Prevents the user from generating `selectstart` DOM events, usually generated
                // when the user drags the mouse through a page with text. Used internally
                // by Leaflet to override the behaviour of any click-and-drag interaction on
                // the map. Affects drag interactions on the whole document.

                // @function enableTextSelection()
                // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
                if ('onselectstart' in document) {
                    L.DomUtil.disableTextSelection = function () {
                        L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
                    };
                    L.DomUtil.enableTextSelection = function () {
                        L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
                    };
                } else {
                    var userSelectProperty = L.DomUtil.testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

                    L.DomUtil.disableTextSelection = function () {
                        if (userSelectProperty) {
                            var style = document.documentElement.style;
                            this._userSelect = style[userSelectProperty];
                            style[userSelectProperty] = 'none';
                        }
                    };
                    L.DomUtil.enableTextSelection = function () {
                        if (userSelectProperty) {
                            document.documentElement.style[userSelectProperty] = this._userSelect;
                            delete this._userSelect;
                        }
                    };
                }

                // @function disableImageDrag()
                // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
                // for `dragstart` DOM events, usually generated when the user drags an image.
                L.DomUtil.disableImageDrag = function () {
                    L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
                };

                // @function enableImageDrag()
                // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
                L.DomUtil.enableImageDrag = function () {
                    L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
                };

                // @function preventOutline(el: HTMLElement)
                // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
                // of the element `el` invisible. Used internally by Leaflet to prevent
                // focusable elements from displaying an outline when the user performs a
                // drag interaction on them.
                L.DomUtil.preventOutline = function (element) {
                    while (element.tabIndex === -1) {
                        element = element.parentNode;
                    }
                    if (!element || !element.style) {
                        return;
                    }
                    L.DomUtil.restoreOutline();
                    this._outlineElement = element;
                    this._outlineStyle = element.style.outline;
                    element.style.outline = 'none';
                    L.DomEvent.on(window, 'keydown', L.DomUtil.restoreOutline, this);
                };

                // @function restoreOutline()
                // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
                L.DomUtil.restoreOutline = function () {
                    if (!this._outlineElement) {
                        return;
                    }
                    this._outlineElement.style.outline = this._outlineStyle;
                    delete this._outlineElement;
                    delete this._outlineStyle;
                    L.DomEvent.off(window, 'keydown', L.DomUtil.restoreOutline, this);
                };
            })();

            /* @class LatLng
             * @aka L.LatLng
             *
             * Represents a geographical point with a certain latitude and longitude.
             *
             * @example
             *
             * ```
             * var latlng = L.latLng(50.5, 30.5);
             * ```
             *
             * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
             *
             * ```
             * map.panTo([50, 30]);
             * map.panTo({lon: 30, lat: 50});
             * map.panTo({lat: 50, lng: 30});
             * map.panTo(L.latLng(50, 30));
             * ```
             */

            L.LatLng = function (lat, lng, alt) {
                if (isNaN(lat) || isNaN(lng)) {
                    throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
                }

                // @property lat: Number
                // Latitude in degrees
                this.lat = +lat;

                // @property lng: Number
                // Longitude in degrees
                this.lng = +lng;

                // @property alt: Number
                // Altitude in meters (optional)
                if (alt !== undefined) {
                    this.alt = +alt;
                }
            };

            L.LatLng.prototype = {
                // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
                // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overriden by setting `maxMargin` to a small number.
                equals: function (obj, maxMargin) {
                    if (!obj) {
                        return false;
                    }

                    obj = L.latLng(obj);

                    var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));

                    return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
                },

                // @method toString(): String
                // Returns a string representation of the point (for debugging purposes).
                toString: function (precision) {
                    return 'LatLng(' + L.Util.formatNum(this.lat, precision) + ', ' + L.Util.formatNum(this.lng, precision) + ')';
                },

                // @method distanceTo(otherLatLng: LatLng): Number
                // Returns the distance (in meters) to the given `LatLng` calculated using the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula).
                distanceTo: function (other) {
                    return L.CRS.Earth.distance(this, L.latLng(other));
                },

                // @method wrap(): LatLng
                // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
                wrap: function () {
                    return L.CRS.Earth.wrapLatLng(this);
                },

                // @method toBounds(sizeInMeters: Number): LatLngBounds
                // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters` meters apart from the `LatLng`.
                toBounds: function (sizeInMeters) {
                    var latAccuracy = 180 * sizeInMeters / 40075017,
                        lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);

                    return L.latLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);
                },

                clone: function () {
                    return new L.LatLng(this.lat, this.lng, this.alt);
                }
            };

            // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
            // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

            // @alternative
            // @factory L.latLng(coords: Array): LatLng
            // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

            // @alternative
            // @factory L.latLng(coords: Object): LatLng
            // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

            L.latLng = function (a, b, c) {
                if (a instanceof L.LatLng) {
                    return a;
                }
                if (L.Util.isArray(a) && typeof a[0] !== 'object') {
                    if (a.length === 3) {
                        return new L.LatLng(a[0], a[1], a[2]);
                    }
                    if (a.length === 2) {
                        return new L.LatLng(a[0], a[1]);
                    }
                    return null;
                }
                if (a === undefined || a === null) {
                    return a;
                }
                if (typeof a === 'object' && 'lat' in a) {
                    return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
                }
                if (b === undefined) {
                    return null;
                }
                return new L.LatLng(a, b, c);
            };

            /*
             * @class LatLngBounds
             * @aka L.LatLngBounds
             *
             * Represents a rectangular geographical area on a map.
             *
             * @example
             *
             * ```js
             * var southWest = L.latLng(40.712, -74.227),
             * northEast = L.latLng(40.774, -74.125),
             * bounds = L.latLngBounds(southWest, northEast);
             * ```
             *
             * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
             *
             * ```js
             * map.fitBounds([
             * 	[40.712, -74.227],
             * 	[40.774, -74.125]
             * ]);
             * ```
             */

            L.LatLngBounds = function (southWest, northEast) {
                // (LatLng, LatLng) or (LatLng[])
                if (!southWest) {
                    return;
                }

                var latlngs = northEast ? [southWest, northEast] : southWest;

                for (var i = 0, len = latlngs.length; i < len; i++) {
                    this.extend(latlngs[i]);
                }
            };

            L.LatLngBounds.prototype = {

                // @method extend(latlng: LatLng): this
                // Extend the bounds to contain the given point

                // @alternative
                // @method extend(otherBounds: LatLngBounds): this
                // Extend the bounds to contain the given bounds
                extend: function (obj) {
                    var sw = this._southWest,
                        ne = this._northEast,
                        sw2,
                        ne2;

                    if (obj instanceof L.LatLng) {
                        sw2 = obj;
                        ne2 = obj;
                    } else if (obj instanceof L.LatLngBounds) {
                        sw2 = obj._southWest;
                        ne2 = obj._northEast;

                        if (!sw2 || !ne2) {
                            return this;
                        }
                    } else {
                        return obj ? this.extend(L.latLng(obj) || L.latLngBounds(obj)) : this;
                    }

                    if (!sw && !ne) {
                        this._southWest = new L.LatLng(sw2.lat, sw2.lng);
                        this._northEast = new L.LatLng(ne2.lat, ne2.lng);
                    } else {
                        sw.lat = Math.min(sw2.lat, sw.lat);
                        sw.lng = Math.min(sw2.lng, sw.lng);
                        ne.lat = Math.max(ne2.lat, ne.lat);
                        ne.lng = Math.max(ne2.lng, ne.lng);
                    }

                    return this;
                },

                // @method pad(bufferRatio: Number): LatLngBounds
                // Returns bigger bounds created by extending the current bounds by a given percentage in each direction.
                pad: function (bufferRatio) {
                    var sw = this._southWest,
                        ne = this._northEast,
                        heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
                        widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

                    return new L.LatLngBounds(new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
                },

                // @method getCenter(): LatLng
                // Returns the center point of the bounds.
                getCenter: function () {
                    return new L.LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
                },

                // @method getSouthWest(): LatLng
                // Returns the south-west point of the bounds.
                getSouthWest: function () {
                    return this._southWest;
                },

                // @method getNorthEast(): LatLng
                // Returns the north-east point of the bounds.
                getNorthEast: function () {
                    return this._northEast;
                },

                // @method getNorthWest(): LatLng
                // Returns the north-west point of the bounds.
                getNorthWest: function () {
                    return new L.LatLng(this.getNorth(), this.getWest());
                },

                // @method getSouthEast(): LatLng
                // Returns the south-east point of the bounds.
                getSouthEast: function () {
                    return new L.LatLng(this.getSouth(), this.getEast());
                },

                // @method getWest(): Number
                // Returns the west longitude of the bounds
                getWest: function () {
                    return this._southWest.lng;
                },

                // @method getSouth(): Number
                // Returns the south latitude of the bounds
                getSouth: function () {
                    return this._southWest.lat;
                },

                // @method getEast(): Number
                // Returns the east longitude of the bounds
                getEast: function () {
                    return this._northEast.lng;
                },

                // @method getNorth(): Number
                // Returns the north latitude of the bounds
                getNorth: function () {
                    return this._northEast.lat;
                },

                // @method contains(otherBounds: LatLngBounds): Boolean
                // Returns `true` if the rectangle contains the given one.

                // @alternative
                // @method contains (latlng: LatLng): Boolean
                // Returns `true` if the rectangle contains the given point.
                contains: function (obj) {
                    // (LatLngBounds) or (LatLng) -> Boolean
                    if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {
                        obj = L.latLng(obj);
                    } else {
                        obj = L.latLngBounds(obj);
                    }

                    var sw = this._southWest,
                        ne = this._northEast,
                        sw2,
                        ne2;

                    if (obj instanceof L.LatLngBounds) {
                        sw2 = obj.getSouthWest();
                        ne2 = obj.getNorthEast();
                    } else {
                        sw2 = ne2 = obj;
                    }

                    return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
                },

                // @method intersects(otherBounds: LatLngBounds): Boolean
                // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
                intersects: function (bounds) {
                    bounds = L.latLngBounds(bounds);

                    var sw = this._southWest,
                        ne = this._northEast,
                        sw2 = bounds.getSouthWest(),
                        ne2 = bounds.getNorthEast(),
                        latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,
                        lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;

                    return latIntersects && lngIntersects;
                },

                // @method overlaps(otherBounds: Bounds): Boolean
                // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
                overlaps: function (bounds) {
                    bounds = L.latLngBounds(bounds);

                    var sw = this._southWest,
                        ne = this._northEast,
                        sw2 = bounds.getSouthWest(),
                        ne2 = bounds.getNorthEast(),
                        latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,
                        lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;

                    return latOverlaps && lngOverlaps;
                },

                // @method toBBoxString(): String
                // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
                toBBoxString: function () {
                    return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
                },

                // @method equals(otherBounds: LatLngBounds): Boolean
                // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds.
                equals: function (bounds) {
                    if (!bounds) {
                        return false;
                    }

                    bounds = L.latLngBounds(bounds);

                    return this._southWest.equals(bounds.getSouthWest()) && this._northEast.equals(bounds.getNorthEast());
                },

                // @method isValid(): Boolean
                // Returns `true` if the bounds are properly initialized.
                isValid: function () {
                    return !!(this._southWest && this._northEast);
                }
            };

            // TODO International date line?

            // @factory L.latLngBounds(southWest: LatLng, northEast: LatLng)
            // Creates a `LatLngBounds` object by defining south-west and north-east corners of the rectangle.

            // @alternative
            // @factory L.latLngBounds(latlngs: LatLng[])
            // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
            L.latLngBounds = function (a, b) {
                if (a instanceof L.LatLngBounds) {
                    return a;
                }
                return new L.LatLngBounds(a, b);
            };

            /*
             * @namespace Projection
             * @section
             * Leaflet comes with a set of already defined Projections out of the box:
             *
             * @projection L.Projection.LonLat
             *
             * Equirectangular, or Plate Carree projection — the most simple projection,
             * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
             * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
             * `EPSG:3395` and `Simple` CRS.
             */

            L.Projection = {};

            L.Projection.LonLat = {
                project: function (latlng) {
                    return new L.Point(latlng.lng, latlng.lat);
                },

                unproject: function (point) {
                    return new L.LatLng(point.y, point.x);
                },

                bounds: L.bounds([-180, -90], [180, 90])
            };

            /*
             * @namespace Projection
             * @projection L.Projection.SphericalMercator
             *
             * Spherical Mercator projection — the most common projection for online maps,
             * used by almost all free and commercial tile providers. Assumes that Earth is
             * a sphere. Used by the `EPSG:3857` CRS.
             */

            L.Projection.SphericalMercator = {

                R: 6378137,
                MAX_LATITUDE: 85.0511287798,

                project: function (latlng) {
                    var d = Math.PI / 180,
                        max = this.MAX_LATITUDE,
                        lat = Math.max(Math.min(max, latlng.lat), -max),
                        sin = Math.sin(lat * d);

                    return new L.Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);
                },

                unproject: function (point) {
                    var d = 180 / Math.PI;

                    return new L.LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);
                },

                bounds: function () {
                    var d = 6378137 * Math.PI;
                    return L.bounds([-d, -d], [d, d]);
                }()
            };

            /*
             * @class CRS
             * @aka L.CRS
             * Abstract class that defines coordinate reference systems for projecting
             * geographical points into pixel (screen) coordinates and back (and to
             * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
             * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
             *
             * Leaflet defines the most usual CRSs by default. If you want to use a
             * CRS not defined by default, take a look at the
             * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
             */

            L.CRS = {
                // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
                // Projects geographical coordinates into pixel coordinates for a given zoom.
                latLngToPoint: function (latlng, zoom) {
                    var projectedPoint = this.projection.project(latlng),
                        scale = this.scale(zoom);

                    return this.transformation._transform(projectedPoint, scale);
                },

                // @method pointToLatLng(point: Point, zoom: Number): LatLng
                // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
                // zoom into geographical coordinates.
                pointToLatLng: function (point, zoom) {
                    var scale = this.scale(zoom),
                        untransformedPoint = this.transformation.untransform(point, scale);

                    return this.projection.unproject(untransformedPoint);
                },

                // @method project(latlng: LatLng): Point
                // Projects geographical coordinates into coordinates in units accepted for
                // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
                project: function (latlng) {
                    return this.projection.project(latlng);
                },

                // @method unproject(point: Point): LatLng
                // Given a projected coordinate returns the corresponding LatLng.
                // The inverse of `project`.
                unproject: function (point) {
                    return this.projection.unproject(point);
                },

                // @method scale(zoom: Number): Number
                // Returns the scale used when transforming projected coordinates into
                // pixel coordinates for a particular zoom. For example, it returns
                // `256 * 2^zoom` for Mercator-based CRS.
                scale: function (zoom) {
                    return 256 * Math.pow(2, zoom);
                },

                // @method zoom(scale: Number): Number
                // Inverse of `scale()`, returns the zoom level corresponding to a scale
                // factor of `scale`.
                zoom: function (scale) {
                    return Math.log(scale / 256) / Math.LN2;
                },

                // @method getProjectedBounds(zoom: Number): Bounds
                // Returns the projection's bounds scaled and transformed for the provided `zoom`.
                getProjectedBounds: function (zoom) {
                    if (this.infinite) {
                        return null;
                    }

                    var b = this.projection.bounds,
                        s = this.scale(zoom),
                        min = this.transformation.transform(b.min, s),
                        max = this.transformation.transform(b.max, s);

                    return L.bounds(min, max);
                },

                // @method distance(latlng1: LatLng, latlng2: LatLng): Number
                // Returns the distance between two geographical coordinates.

                // @property code: String
                // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
                //
                // @property wrapLng: Number[]
                // An array of two numbers defining whether the longitude (horizontal) coordinate
                // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
                // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
                //
                // @property wrapLat: Number[]
                // Like `wrapLng`, but for the latitude (vertical) axis.

                // wrapLng: [min, max],
                // wrapLat: [min, max],

                // @property infinite: Boolean
                // If true, the coordinate space will be unbounded (infinite in both axes)
                infinite: false,

                // @method wrapLatLng(latlng: LatLng): LatLng
                // Returns a `LatLng` where lat and lng has been wrapped according to the
                // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
                wrapLatLng: function (latlng) {
                    var lng = this.wrapLng ? L.Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
                        lat = this.wrapLat ? L.Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
                        alt = latlng.alt;

                    return L.latLng(lat, lng, alt);
                }
            };

            /*
             * @namespace CRS
             * @crs L.CRS.Simple
             *
             * A simple CRS that maps longitude and latitude into `x` and `y` directly.
             * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
             * axis should still be inverted (going from bottom to top). `distance()` returns
             * simple euclidean distance.
             */

            L.CRS.Simple = L.extend({}, L.CRS, {
                projection: L.Projection.LonLat,
                transformation: new L.Transformation(1, 0, -1, 0),

                scale: function (zoom) {
                    return Math.pow(2, zoom);
                },

                zoom: function (scale) {
                    return Math.log(scale) / Math.LN2;
                },

                distance: function (latlng1, latlng2) {
                    var dx = latlng2.lng - latlng1.lng,
                        dy = latlng2.lat - latlng1.lat;

                    return Math.sqrt(dx * dx + dy * dy);
                },

                infinite: true
            });

            /*
             * @namespace CRS
             * @crs L.CRS.Earth
             *
             * Serves as the base for CRS that are global such that they cover the earth.
             * Can only be used as the base for other CRS and cannot be used directly,
             * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
             * meters.
             */

            L.CRS.Earth = L.extend({}, L.CRS, {
                wrapLng: [-180, 180],

                // Mean Earth Radius, as recommended for use by
                // the International Union of Geodesy and Geophysics,
                // see http://rosettacode.org/wiki/Haversine_formula
                R: 6371000,

                // distance between two geographical points using spherical law of cosines approximation
                distance: function (latlng1, latlng2) {
                    var rad = Math.PI / 180,
                        lat1 = latlng1.lat * rad,
                        lat2 = latlng2.lat * rad,
                        a = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);

                    return this.R * Math.acos(Math.min(a, 1));
                }
            });

            /*
             * @namespace CRS
             * @crs L.CRS.EPSG3857
             *
             * The most common CRS for online maps, used by almost all free and commercial
             * tile providers. Uses Spherical Mercator projection. Set in by default in
             * Map's `crs` option.
             */

            L.CRS.EPSG3857 = L.extend({}, L.CRS.Earth, {
                code: 'EPSG:3857',
                projection: L.Projection.SphericalMercator,

                transformation: function () {
                    var scale = 0.5 / (Math.PI * L.Projection.SphericalMercator.R);
                    return new L.Transformation(scale, 0.5, -scale, 0.5);
                }()
            });

            L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
                code: 'EPSG:900913'
            });

            /*
             * @namespace CRS
             * @crs L.CRS.EPSG4326
             *
             * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
             */

            L.CRS.EPSG4326 = L.extend({}, L.CRS.Earth, {
                code: 'EPSG:4326',
                projection: L.Projection.LonLat,
                transformation: new L.Transformation(1 / 180, 1, -1 / 180, 0.5)
            });

            /*
             * @class Map
             * @aka L.Map
             * @inherits Evented
             *
             * The central class of the API — it is used to create a map on a page and manipulate it.
             *
             * @example
             *
             * ```js
             * // initialize the map on the "map" div with a given center and zoom
             * var map = L.map('map', {
             * 	center: [51.505, -0.09],
             * 	zoom: 13
             * });
             * ```
             *
             */

            L.Map = L.Evented.extend({

                options: {
                    // @section Map State Options
                    // @option crs: CRS = L.CRS.EPSG3857
                    // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
                    // sure what it means.
                    crs: L.CRS.EPSG3857,

                    // @option center: LatLng = undefined
                    // Initial geographic center of the map
                    center: undefined,

                    // @option zoom: Number = undefined
                    // Initial map zoom level
                    zoom: undefined,

                    // @option minZoom: Number = undefined
                    // Minimum zoom level of the map. Overrides any `minZoom` option set on map layers.
                    minZoom: undefined,

                    // @option maxZoom: Number = undefined
                    // Maximum zoom level of the map. Overrides any `maxZoom` option set on map layers.
                    maxZoom: undefined,

                    // @option layers: Layer[] = []
                    // Array of layers that will be added to the map initially
                    layers: [],

                    // @option maxBounds: LatLngBounds = null
                    // When this option is set, the map restricts the view to the given
                    // geographical bounds, bouncing the user back when he tries to pan
                    // outside the view. To set the restriction dynamically, use
                    // [`setMaxBounds`](#map-setmaxbounds) method.
                    maxBounds: undefined,

                    // @option renderer: Renderer = *
                    // The default method for drawing vector layers on the map. `L.SVG`
                    // or `L.Canvas` by default depending on browser support.
                    renderer: undefined,

                    // @section Animation Options
                    // @option fadeAnimation: Boolean = true
                    // Whether the tile fade animation is enabled. By default it's enabled
                    // in all browsers that support CSS3 Transitions except Android.
                    fadeAnimation: true,

                    // @option markerZoomAnimation: Boolean = true
                    // Whether markers animate their zoom with the zoom animation, if disabled
                    // they will disappear for the length of the animation. By default it's
                    // enabled in all browsers that support CSS3 Transitions except Android.
                    markerZoomAnimation: true,

                    // @option transform3DLimit: Number = 2^23
                    // Defines the maximum size of a CSS translation transform. The default
                    // value should not be changed unless a web browser positions layers in
                    // the wrong place after doing a large `panBy`.
                    transform3DLimit: 8388608, // Precision limit of a 32-bit float

                    // @section Interaction Options
                    // @option zoomSnap: Number = 1
                    // Forces the map's zoom level to always be a multiple of this, particularly
                    // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
                    // By default, the zoom level snaps to the nearest integer; lower values
                    // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
                    // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
                    zoomSnap: 1,

                    // @option zoomDelta: Number = 1
                    // Controls how much the map's zoom level will change after a
                    // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
                    // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
                    // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
                    zoomDelta: 1,

                    // @option trackResize: Boolean = true
                    // Whether the map automatically handles browser window resize to update itself.
                    trackResize: true
                },

                initialize: function (id, options) {
                    // (HTMLElement or String, Object)
                    options = L.setOptions(this, options);

                    this._initContainer(id);
                    this._initLayout();

                    // hack for https://github.com/Leaflet/Leaflet/issues/1980
                    this._onResize = L.bind(this._onResize, this);

                    this._initEvents();

                    if (options.maxBounds) {
                        this.setMaxBounds(options.maxBounds);
                    }

                    if (options.zoom !== undefined) {
                        this._zoom = this._limitZoom(options.zoom);
                    }

                    if (options.center && options.zoom !== undefined) {
                        this.setView(L.latLng(options.center), options.zoom, { reset: true });
                    }

                    this._handlers = [];
                    this._layers = {};
                    this._zoomBoundLayers = {};
                    this._sizeChanged = true;

                    this.callInitHooks();

                    this._addLayers(this.options.layers);
                },

                // @section Methods for modifying map state

                // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
                // Sets the view of the map (geographical center and zoom) with the given
                // animation options.
                setView: function (center, zoom) {
                    // replaced by animation-powered implementation in Map.PanAnimation.js
                    zoom = zoom === undefined ? this.getZoom() : zoom;
                    this._resetView(L.latLng(center), zoom);
                    return this;
                },

                // @method setZoom(zoom: Number, options: Zoom/pan options): this
                // Sets the zoom of the map.
                setZoom: function (zoom, options) {
                    if (!this._loaded) {
                        this._zoom = zoom;
                        return this;
                    }
                    return this.setView(this.getCenter(), zoom, { zoom: options });
                },

                // @method zoomIn(delta?: Number, options?: Zoom options): this
                // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
                zoomIn: function (delta, options) {
                    delta = delta || (L.Browser.any3d ? this.options.zoomDelta : 1);
                    return this.setZoom(this._zoom + delta, options);
                },

                // @method zoomOut(delta?: Number, options?: Zoom options): this
                // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
                zoomOut: function (delta, options) {
                    delta = delta || (L.Browser.any3d ? this.options.zoomDelta : 1);
                    return this.setZoom(this._zoom - delta, options);
                },

                // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
                // Zooms the map while keeping a specified geographical point on the map
                // stationary (e.g. used internally for scroll zoom and double-click zoom).
                // @alternative
                // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
                // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
                setZoomAround: function (latlng, zoom, options) {
                    var scale = this.getZoomScale(zoom),
                        viewHalf = this.getSize().divideBy(2),
                        containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),
                        centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
                        newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

                    return this.setView(newCenter, zoom, { zoom: options });
                },

                _getBoundsCenterZoom: function (bounds, options) {

                    options = options || {};
                    bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);

                    var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
                        paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),
                        zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

                    zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;

                    var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),
                        swPoint = this.project(bounds.getSouthWest(), zoom),
                        nePoint = this.project(bounds.getNorthEast(), zoom),
                        center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

                    return {
                        center: center,
                        zoom: zoom
                    };
                },

                // @method fitBounds(bounds: LatLngBounds, options: fitBounds options): this
                // Sets a map view that contains the given geographical bounds with the
                // maximum zoom level possible.
                fitBounds: function (bounds, options) {

                    bounds = L.latLngBounds(bounds);

                    if (!bounds.isValid()) {
                        throw new Error('Bounds are not valid.');
                    }

                    var target = this._getBoundsCenterZoom(bounds, options);
                    return this.setView(target.center, target.zoom, options);
                },

                // @method fitWorld(options?: fitBounds options): this
                // Sets a map view that mostly contains the whole world with the maximum
                // zoom level possible.
                fitWorld: function (options) {
                    return this.fitBounds([[-90, -180], [90, 180]], options);
                },

                // @method panTo(latlng: LatLng, options?: Pan options): this
                // Pans the map to a given center.
                panTo: function (center, options) {
                    // (LatLng)
                    return this.setView(center, this._zoom, { pan: options });
                },

                // @method panBy(offset: Point): this
                // Pans the map by a given number of pixels (animated).
                panBy: function (offset) {
                    // (Point)
                    // replaced with animated panBy in Map.PanAnimation.js
                    this.fire('movestart');

                    this._rawPanBy(L.point(offset));

                    this.fire('move');
                    return this.fire('moveend');
                },

                // @method setMaxBounds(bounds: Bounds): this
                // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
                setMaxBounds: function (bounds) {
                    bounds = L.latLngBounds(bounds);

                    if (!bounds.isValid()) {
                        this.options.maxBounds = null;
                        return this.off('moveend', this._panInsideMaxBounds);
                    } else if (this.options.maxBounds) {
                        this.off('moveend', this._panInsideMaxBounds);
                    }

                    this.options.maxBounds = bounds;

                    if (this._loaded) {
                        this._panInsideMaxBounds();
                    }

                    return this.on('moveend', this._panInsideMaxBounds);
                },

                // @method setMinZoom(zoom: Number): this
                // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
                setMinZoom: function (zoom) {
                    this.options.minZoom = zoom;

                    if (this._loaded && this.getZoom() < this.options.minZoom) {
                        return this.setZoom(zoom);
                    }

                    return this;
                },

                // @method setMaxZoom(zoom: Number): this
                // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
                setMaxZoom: function (zoom) {
                    this.options.maxZoom = zoom;

                    if (this._loaded && this.getZoom() > this.options.maxZoom) {
                        return this.setZoom(zoom);
                    }

                    return this;
                },

                // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
                // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
                panInsideBounds: function (bounds, options) {
                    this._enforcingBounds = true;
                    var center = this.getCenter(),
                        newCenter = this._limitCenter(center, this._zoom, L.latLngBounds(bounds));

                    if (!center.equals(newCenter)) {
                        this.panTo(newCenter, options);
                    }

                    this._enforcingBounds = false;
                    return this;
                },

                // @method invalidateSize(options: Zoom/Pan options): this
                // Checks if the map container size changed and updates the map if so —
                // call it after you've changed the map size dynamically, also animating
                // pan by default. If `options.pan` is `false`, panning will not occur.
                // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
                // that it doesn't happen often even if the method is called many
                // times in a row.

                // @alternative
                // @method invalidateSize(animate: Boolean): this
                // Checks if the map container size changed and updates the map if so —
                // call it after you've changed the map size dynamically, also animating
                // pan by default.
                invalidateSize: function (options) {
                    if (!this._loaded) {
                        return this;
                    }

                    options = L.extend({
                        animate: false,
                        pan: true
                    }, options === true ? { animate: true } : options);

                    var oldSize = this.getSize();
                    this._sizeChanged = true;
                    this._lastCenter = null;

                    var newSize = this.getSize(),
                        oldCenter = oldSize.divideBy(2).round(),
                        newCenter = newSize.divideBy(2).round(),
                        offset = oldCenter.subtract(newCenter);

                    if (!offset.x && !offset.y) {
                        return this;
                    }

                    if (options.animate && options.pan) {
                        this.panBy(offset);
                    } else {
                        if (options.pan) {
                            this._rawPanBy(offset);
                        }

                        this.fire('move');

                        if (options.debounceMoveend) {
                            clearTimeout(this._sizeTimer);
                            this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
                        } else {
                            this.fire('moveend');
                        }
                    }

                    // @section Map state change events
                    // @event resize: ResizeEvent
                    // Fired when the map is resized.
                    return this.fire('resize', {
                        oldSize: oldSize,
                        newSize: newSize
                    });
                },

                // @section Methods for modifying map state
                // @method stop(): this
                // Stops the currently running `panTo` or `flyTo` animation, if any.
                stop: function () {
                    this.setZoom(this._limitZoom(this._zoom));
                    if (!this.options.zoomSnap) {
                        this.fire('viewreset');
                    }
                    return this._stop();
                },

                // TODO handler.addTo
                // TODO Appropiate docs section?
                // @section Other Methods
                // @method addHandler(name: String, HandlerClass: Function): this
                // Adds a new `Handler` to the map, given its name and constructor function.
                addHandler: function (name, HandlerClass) {
                    if (!HandlerClass) {
                        return this;
                    }

                    var handler = this[name] = new HandlerClass(this);

                    this._handlers.push(handler);

                    if (this.options[name]) {
                        handler.enable();
                    }

                    return this;
                },

                // @method remove(): this
                // Destroys the map and clears all related event listeners.
                remove: function () {

                    this._initEvents(true);

                    if (this._containerId !== this._container._leaflet_id) {
                        throw new Error('Map container is being reused by another instance');
                    }

                    try {
                        // throws error in IE6-8
                        delete this._container._leaflet_id;
                        delete this._containerId;
                    } catch (e) {
                        /*eslint-disable */
                        this._container._leaflet_id = undefined;
                        /*eslint-enable */
                        this._containerId = undefined;
                    }

                    L.DomUtil.remove(this._mapPane);

                    if (this._clearControlPos) {
                        this._clearControlPos();
                    }

                    this._clearHandlers();

                    if (this._loaded) {
                        // @section Map state change events
                        // @event unload: Event
                        // Fired when the map is destroyed with [remove](#map-remove) method.
                        this.fire('unload');
                    }

                    for (var i in this._layers) {
                        this._layers[i].remove();
                    }

                    return this;
                },

                // @section Other Methods
                // @method createPane(name: String, container?: HTMLElement): HTMLElement
                // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
                // then returns it. The pane is created as a children of `container`, or
                // as a children of the main map pane if not set.
                createPane: function (name, container) {
                    var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
                        pane = L.DomUtil.create('div', className, container || this._mapPane);

                    if (name) {
                        this._panes[name] = pane;
                    }
                    return pane;
                },

                // @section Methods for Getting Map State

                // @method getCenter(): LatLng
                // Returns the geographical center of the map view
                getCenter: function () {
                    this._checkIfLoaded();

                    if (this._lastCenter && !this._moved()) {
                        return this._lastCenter;
                    }
                    return this.layerPointToLatLng(this._getCenterLayerPoint());
                },

                // @method getZoom(): Number
                // Returns the current zoom level of the map view
                getZoom: function () {
                    return this._zoom;
                },

                // @method getBounds(): LatLngBounds
                // Returns the geographical bounds visible in the current map view
                getBounds: function () {
                    var bounds = this.getPixelBounds(),
                        sw = this.unproject(bounds.getBottomLeft()),
                        ne = this.unproject(bounds.getTopRight());

                    return new L.LatLngBounds(sw, ne);
                },

                // @method getMinZoom(): Number
                // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
                getMinZoom: function () {
                    return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
                },

                // @method getMaxZoom(): Number
                // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
                getMaxZoom: function () {
                    return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;
                },

                // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean): Number
                // Returns the maximum zoom level on which the given bounds fit to the map
                // view in its entirety. If `inside` (optional) is set to `true`, the method
                // instead returns the minimum zoom level on which the map view fits into
                // the given bounds in its entirety.
                getBoundsZoom: function (bounds, inside, padding) {
                    // (LatLngBounds[, Boolean, Point]) -> Number
                    bounds = L.latLngBounds(bounds);
                    padding = L.point(padding || [0, 0]);

                    var zoom = this.getZoom() || 0,
                        min = this.getMinZoom(),
                        max = this.getMaxZoom(),
                        nw = bounds.getNorthWest(),
                        se = bounds.getSouthEast(),
                        size = this.getSize().subtract(padding),
                        boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)),
                        snap = L.Browser.any3d ? this.options.zoomSnap : 1;

                    var scale = Math.min(size.x / boundsSize.x, size.y / boundsSize.y);
                    zoom = this.getScaleZoom(scale, zoom);

                    if (snap) {
                        zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
                        zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
                    }

                    return Math.max(min, Math.min(max, zoom));
                },

                // @method getSize(): Point
                // Returns the current size of the map container (in pixels).
                getSize: function () {
                    if (!this._size || this._sizeChanged) {
                        this._size = new L.Point(this._container.clientWidth, this._container.clientHeight);

                        this._sizeChanged = false;
                    }
                    return this._size.clone();
                },

                // @method getPixelBounds(): Bounds
                // Returns the bounds of the current map view in projected pixel
                // coordinates (sometimes useful in layer and overlay implementations).
                getPixelBounds: function (center, zoom) {
                    var topLeftPoint = this._getTopLeftPoint(center, zoom);
                    return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
                },

                // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
                // the map pane? "left point of the map layer" can be confusing, specially
                // since there can be negative offsets.
                // @method getPixelOrigin(): Point
                // Returns the projected pixel coordinates of the top left point of
                // the map layer (useful in custom layer and overlay implementations).
                getPixelOrigin: function () {
                    this._checkIfLoaded();
                    return this._pixelOrigin;
                },

                // @method getPixelWorldBounds(zoom?: Number): Bounds
                // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
                // If `zoom` is omitted, the map's current zoom level is used.
                getPixelWorldBounds: function (zoom) {
                    return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
                },

                // @section Other Methods

                // @method getPane(pane: String|HTMLElement): HTMLElement
                // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
                getPane: function (pane) {
                    return typeof pane === 'string' ? this._panes[pane] : pane;
                },

                // @method getPanes(): Object
                // Returns a plain object containing the names of all [panes](#map-pane) as keys and
                // the panes as values.
                getPanes: function () {
                    return this._panes;
                },

                // @method getContainer: HTMLElement
                // Returns the HTML element that contains the map.
                getContainer: function () {
                    return this._container;
                },

                // @section Conversion Methods

                // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
                // Returns the scale factor to be applied to a map transition from zoom level
                // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
                getZoomScale: function (toZoom, fromZoom) {
                    // TODO replace with universal implementation after refactoring projections
                    var crs = this.options.crs;
                    fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
                    return crs.scale(toZoom) / crs.scale(fromZoom);
                },

                // @method getScaleZoom(scale: Number, fromZoom: Number): Number
                // Returns the zoom level that the map would end up at, if it is at `fromZoom`
                // level and everything is scaled by a factor of `scale`. Inverse of
                // [`getZoomScale`](#map-getZoomScale).
                getScaleZoom: function (scale, fromZoom) {
                    var crs = this.options.crs;
                    fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
                    var zoom = crs.zoom(scale * crs.scale(fromZoom));
                    return isNaN(zoom) ? Infinity : zoom;
                },

                // @method project(latlng: LatLng, zoom: Number): Point
                // Projects a geographical coordinate `LatLng` according to the projection
                // of the map's CRS, then scales it according to `zoom` and the CRS's
                // `Transformation`. The result is pixel coordinate relative to
                // the CRS origin.
                project: function (latlng, zoom) {
                    zoom = zoom === undefined ? this._zoom : zoom;
                    return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
                },

                // @method unproject(point: Point, zoom: Number): LatLng
                // Inverse of [`project`](#map-project).
                unproject: function (point, zoom) {
                    zoom = zoom === undefined ? this._zoom : zoom;
                    return this.options.crs.pointToLatLng(L.point(point), zoom);
                },

                // @method layerPointToLatLng(point: Point): LatLng
                // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
                // returns the corresponding geographical coordinate (for the current zoom level).
                layerPointToLatLng: function (point) {
                    var projectedPoint = L.point(point).add(this.getPixelOrigin());
                    return this.unproject(projectedPoint);
                },

                // @method latLngToLayerPoint(latlng: LatLng): Point
                // Given a geographical coordinate, returns the corresponding pixel coordinate
                // relative to the [origin pixel](#map-getpixelorigin).
                latLngToLayerPoint: function (latlng) {
                    var projectedPoint = this.project(L.latLng(latlng))._round();
                    return projectedPoint._subtract(this.getPixelOrigin());
                },

                // @method wrapLatLng(latlng: LatLng): LatLng
                // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
                // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
                // CRS's bounds.
                // By default this means longitude is wrapped around the dateline so its
                // value is between -180 and +180 degrees.
                wrapLatLng: function (latlng) {
                    return this.options.crs.wrapLatLng(L.latLng(latlng));
                },

                // @method distance(latlng1: LatLng, latlng2: LatLng): Number
                // Returns the distance between two geographical coordinates according to
                // the map's CRS. By default this measures distance in meters.
                distance: function (latlng1, latlng2) {
                    return this.options.crs.distance(L.latLng(latlng1), L.latLng(latlng2));
                },

                // @method containerPointToLayerPoint(point: Point): Point
                // Given a pixel coordinate relative to the map container, returns the corresponding
                // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
                containerPointToLayerPoint: function (point) {
                    // (Point)
                    return L.point(point).subtract(this._getMapPanePos());
                },

                // @method layerPointToContainerPoint(point: Point): Point
                // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
                // returns the corresponding pixel coordinate relative to the map container.
                layerPointToContainerPoint: function (point) {
                    // (Point)
                    return L.point(point).add(this._getMapPanePos());
                },

                // @method containerPointToLatLng(point: Point): Point
                // Given a pixel coordinate relative to the map container, returns
                // the corresponding geographical coordinate (for the current zoom level).
                containerPointToLatLng: function (point) {
                    var layerPoint = this.containerPointToLayerPoint(L.point(point));
                    return this.layerPointToLatLng(layerPoint);
                },

                // @method latLngToContainerPoint(latlng: LatLng): Point
                // Given a geographical coordinate, returns the corresponding pixel coordinate
                // relative to the map container.
                latLngToContainerPoint: function (latlng) {
                    return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
                },

                // @method mouseEventToContainerPoint(ev: MouseEvent): Point
                // Given a MouseEvent object, returns the pixel coordinate relative to the
                // map container where the event took place.
                mouseEventToContainerPoint: function (e) {
                    return L.DomEvent.getMousePosition(e, this._container);
                },

                // @method mouseEventToLayerPoint(ev: MouseEvent): Point
                // Given a MouseEvent object, returns the pixel coordinate relative to
                // the [origin pixel](#map-getpixelorigin) where the event took place.
                mouseEventToLayerPoint: function (e) {
                    return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
                },

                // @method mouseEventToLatLng(ev: MouseEvent): LatLng
                // Given a MouseEvent object, returns geographical coordinate where the
                // event took place.
                mouseEventToLatLng: function (e) {
                    // (MouseEvent)
                    return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
                },

                // map initialization methods

                _initContainer: function (id) {
                    var container = this._container = L.DomUtil.get(id);

                    if (!container) {
                        throw new Error('Map container not found.');
                    } else if (container._leaflet_id) {
                        throw new Error('Map container is already initialized.');
                    }

                    L.DomEvent.addListener(container, 'scroll', this._onScroll, this);
                    this._containerId = L.Util.stamp(container);
                },

                _initLayout: function () {
                    var container = this._container;

                    this._fadeAnimated = this.options.fadeAnimation && L.Browser.any3d;

                    L.DomUtil.addClass(container, 'leaflet-container' + (L.Browser.touch ? ' leaflet-touch' : '') + (L.Browser.retina ? ' leaflet-retina' : '') + (L.Browser.ielt9 ? ' leaflet-oldie' : '') + (L.Browser.safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));

                    var position = L.DomUtil.getStyle(container, 'position');

                    if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
                        container.style.position = 'relative';
                    }

                    this._initPanes();

                    if (this._initControlPos) {
                        this._initControlPos();
                    }
                },

                _initPanes: function () {
                    var panes = this._panes = {};
                    this._paneRenderers = {};

                    // @section
                    //
                    // Panes are DOM elements used to control the ordering of layers on the map. You
                    // can access panes with [`map.getPane`](#map-getpane) or
                    // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
                    // [`map.createPane`](#map-createpane) method.
                    //
                    // Every map has the following default panes that differ only in zIndex.
                    //
                    // @pane mapPane: HTMLElement = 'auto'
                    // Pane that contains all other map panes

                    this._mapPane = this.createPane('mapPane', this._container);
                    L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));

                    // @pane tilePane: HTMLElement = 200
                    // Pane for `GridLayer`s and `TileLayer`s
                    this.createPane('tilePane');
                    // @pane overlayPane: HTMLElement = 400
                    // Pane for vector overlays (`Path`s), like `Polyline`s and `Polygon`s
                    this.createPane('shadowPane');
                    // @pane shadowPane: HTMLElement = 500
                    // Pane for overlay shadows (e.g. `Marker` shadows)
                    this.createPane('overlayPane');
                    // @pane markerPane: HTMLElement = 600
                    // Pane for `Icon`s of `Marker`s
                    this.createPane('markerPane');
                    // @pane tooltipPane: HTMLElement = 650
                    // Pane for tooltip.
                    this.createPane('tooltipPane');
                    // @pane popupPane: HTMLElement = 700
                    // Pane for `Popup`s.
                    this.createPane('popupPane');

                    if (!this.options.markerZoomAnimation) {
                        L.DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');
                        L.DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');
                    }
                },

                // private methods that modify map state

                // @section Map state change events
                _resetView: function (center, zoom) {
                    L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));

                    var loading = !this._loaded;
                    this._loaded = true;
                    zoom = this._limitZoom(zoom);

                    this.fire('viewprereset');

                    var zoomChanged = this._zoom !== zoom;
                    this._moveStart(zoomChanged)._move(center, zoom)._moveEnd(zoomChanged);

                    // @event viewreset: Event
                    // Fired when the map needs to redraw its content (this usually happens
                    // on map zoom or load). Very useful for creating custom overlays.
                    this.fire('viewreset');

                    // @event load: Event
                    // Fired when the map is initialized (when its center and zoom are set
                    // for the first time).
                    if (loading) {
                        this.fire('load');
                    }
                },

                _moveStart: function (zoomChanged) {
                    // @event zoomstart: Event
                    // Fired when the map zoom is about to change (e.g. before zoom animation).
                    // @event movestart: Event
                    // Fired when the view of the map starts changing (e.g. user starts dragging the map).
                    if (zoomChanged) {
                        this.fire('zoomstart');
                    }
                    return this.fire('movestart');
                },

                _move: function (center, zoom, data) {
                    if (zoom === undefined) {
                        zoom = this._zoom;
                    }
                    var zoomChanged = this._zoom !== zoom;

                    this._zoom = zoom;
                    this._lastCenter = center;
                    this._pixelOrigin = this._getNewPixelOrigin(center);

                    // @event zoom: Event
                    // Fired repeatedly during any change in zoom level, including zoom
                    // and fly animations.
                    if (zoomChanged || data && data.pinch) {
                        // Always fire 'zoom' if pinching because #3530
                        this.fire('zoom', data);
                    }

                    // @event move: Event
                    // Fired repeatedly during any movement of the map, including pan and
                    // fly animations.
                    return this.fire('move', data);
                },

                _moveEnd: function (zoomChanged) {
                    // @event zoomend: Event
                    // Fired when the map has changed, after any animations.
                    if (zoomChanged) {
                        this.fire('zoomend');
                    }

                    // @event moveend: Event
                    // Fired when the center of the map stops changing (e.g. user stopped
                    // dragging the map).
                    return this.fire('moveend');
                },

                _stop: function () {
                    L.Util.cancelAnimFrame(this._flyToFrame);
                    if (this._panAnim) {
                        this._panAnim.stop();
                    }
                    return this;
                },

                _rawPanBy: function (offset) {
                    L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
                },

                _getZoomSpan: function () {
                    return this.getMaxZoom() - this.getMinZoom();
                },

                _panInsideMaxBounds: function () {
                    if (!this._enforcingBounds) {
                        this.panInsideBounds(this.options.maxBounds);
                    }
                },

                _checkIfLoaded: function () {
                    if (!this._loaded) {
                        throw new Error('Set map center and zoom first.');
                    }
                },

                // DOM event handling

                // @section Interaction events
                _initEvents: function (remove) {
                    if (!L.DomEvent) {
                        return;
                    }

                    this._targets = {};
                    this._targets[L.stamp(this._container)] = this;

                    var onOff = remove ? 'off' : 'on';

                    // @event click: MouseEvent
                    // Fired when the user clicks (or taps) the map.
                    // @event dblclick: MouseEvent
                    // Fired when the user double-clicks (or double-taps) the map.
                    // @event mousedown: MouseEvent
                    // Fired when the user pushes the mouse button on the map.
                    // @event mouseup: MouseEvent
                    // Fired when the user releases the mouse button on the map.
                    // @event mouseover: MouseEvent
                    // Fired when the mouse enters the map.
                    // @event mouseout: MouseEvent
                    // Fired when the mouse leaves the map.
                    // @event mousemove: MouseEvent
                    // Fired while the mouse moves over the map.
                    // @event contextmenu: MouseEvent
                    // Fired when the user pushes the right mouse button on the map, prevents
                    // default browser context menu from showing if there are listeners on
                    // this event. Also fired on mobile when the user holds a single touch
                    // for a second (also called long press).
                    // @event keypress: KeyboardEvent
                    // Fired when the user presses a key from the keyboard while the map is focused.
                    L.DomEvent[onOff](this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

                    if (this.options.trackResize) {
                        L.DomEvent[onOff](window, 'resize', this._onResize, this);
                    }

                    if (L.Browser.any3d && this.options.transform3DLimit) {
                        this[onOff]('moveend', this._onMoveEnd);
                    }
                },

                _onResize: function () {
                    L.Util.cancelAnimFrame(this._resizeRequest);
                    this._resizeRequest = L.Util.requestAnimFrame(function () {
                        this.invalidateSize({ debounceMoveend: true });
                    }, this);
                },

                _onScroll: function () {
                    this._container.scrollTop = 0;
                    this._container.scrollLeft = 0;
                },

                _onMoveEnd: function () {
                    var pos = this._getMapPanePos();
                    if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
                        // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
                        // a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
                        this._resetView(this.getCenter(), this.getZoom());
                    }
                },

                _findEventTargets: function (e, type) {
                    var targets = [],
                        target,
                        isHover = type === 'mouseout' || type === 'mouseover',
                        src = e.target || e.srcElement,
                        dragging = false;

                    while (src) {
                        target = this._targets[L.stamp(src)];
                        if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
                            // Prevent firing click after you just dragged an object.
                            dragging = true;
                            break;
                        }
                        if (target && target.listens(type, true)) {
                            if (isHover && !L.DomEvent._isExternalTarget(src, e)) {
                                break;
                            }
                            targets.push(target);
                            if (isHover) {
                                break;
                            }
                        }
                        if (src === this._container) {
                            break;
                        }
                        src = src.parentNode;
                    }
                    if (!targets.length && !dragging && !isHover && L.DomEvent._isExternalTarget(src, e)) {
                        targets = [this];
                    }
                    return targets;
                },

                _handleDOMEvent: function (e) {
                    if (!this._loaded || L.DomEvent._skipped(e)) {
                        return;
                    }

                    var type = e.type === 'keypress' && e.keyCode === 13 ? 'click' : e.type;

                    if (type === 'mousedown') {
                        // prevents outline when clicking on keyboard-focusable element
                        L.DomUtil.preventOutline(e.target || e.srcElement);
                    }

                    this._fireDOMEvent(e, type);
                },

                _fireDOMEvent: function (e, type, targets) {

                    if (e.type === 'click') {
                        // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
                        // @event preclick: MouseEvent
                        // Fired before mouse click on the map (sometimes useful when you
                        // want something to happen on click before any existing click
                        // handlers start running).
                        var synth = L.Util.extend({}, e);
                        synth.type = 'preclick';
                        this._fireDOMEvent(synth, synth.type, targets);
                    }

                    if (e._stopped) {
                        return;
                    }

                    // Find the layer the event is propagating from and its parents.
                    targets = (targets || []).concat(this._findEventTargets(e, type));

                    if (!targets.length) {
                        return;
                    }

                    var target = targets[0];
                    if (type === 'contextmenu' && target.listens(type, true)) {
                        L.DomEvent.preventDefault(e);
                    }

                    var data = {
                        originalEvent: e
                    };

                    if (e.type !== 'keypress') {
                        var isMarker = target instanceof L.Marker;
                        data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
                        data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
                        data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
                    }

                    for (var i = 0; i < targets.length; i++) {
                        targets[i].fire(type, data, true);
                        if (data.originalEvent._stopped || targets[i].options.nonBubblingEvents && L.Util.indexOf(targets[i].options.nonBubblingEvents, type) !== -1) {
                            return;
                        }
                    }
                },

                _draggableMoved: function (obj) {
                    obj = obj.dragging && obj.dragging.enabled() ? obj : this;
                    return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
                },

                _clearHandlers: function () {
                    for (var i = 0, len = this._handlers.length; i < len; i++) {
                        this._handlers[i].disable();
                    }
                },

                // @section Other Methods

                // @method whenReady(fn: Function, context?: Object): this
                // Runs the given function `fn` when the map gets initialized with
                // a view (center and zoom) and at least one layer, or immediately
                // if it's already initialized, optionally passing a function context.
                whenReady: function (callback, context) {
                    if (this._loaded) {
                        callback.call(context || this, { target: this });
                    } else {
                        this.on('load', callback, context);
                    }
                    return this;
                },

                // private methods for getting map state

                _getMapPanePos: function () {
                    return L.DomUtil.getPosition(this._mapPane) || new L.Point(0, 0);
                },

                _moved: function () {
                    var pos = this._getMapPanePos();
                    return pos && !pos.equals([0, 0]);
                },

                _getTopLeftPoint: function (center, zoom) {
                    var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();
                    return pixelOrigin.subtract(this._getMapPanePos());
                },

                _getNewPixelOrigin: function (center, zoom) {
                    var viewHalf = this.getSize()._divideBy(2);
                    return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
                },

                _latLngToNewLayerPoint: function (latlng, zoom, center) {
                    var topLeft = this._getNewPixelOrigin(center, zoom);
                    return this.project(latlng, zoom)._subtract(topLeft);
                },

                // layer point of the current center
                _getCenterLayerPoint: function () {
                    return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
                },

                // offset of the specified place to the current center in pixels
                _getCenterOffset: function (latlng) {
                    return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
                },

                // adjust center for view to get inside bounds
                _limitCenter: function (center, zoom, bounds) {

                    if (!bounds) {
                        return center;
                    }

                    var centerPoint = this.project(center, zoom),
                        viewHalf = this.getSize().divideBy(2),
                        viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
                        offset = this._getBoundsOffset(viewBounds, bounds, zoom);

                    // If offset is less than a pixel, ignore.
                    // This prevents unstable projections from getting into
                    // an infinite loop of tiny offsets.
                    if (offset.round().equals([0, 0])) {
                        return center;
                    }

                    return this.unproject(centerPoint.add(offset), zoom);
                },

                // adjust offset for view to get inside bounds
                _limitOffset: function (offset, bounds) {
                    if (!bounds) {
                        return offset;
                    }

                    var viewBounds = this.getPixelBounds(),
                        newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

                    return offset.add(this._getBoundsOffset(newBounds, bounds));
                },

                // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
                _getBoundsOffset: function (pxBounds, maxBounds, zoom) {
                    var projectedMaxBounds = L.bounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),
                        minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
                        maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),
                        dx = this._rebound(minOffset.x, -maxOffset.x),
                        dy = this._rebound(minOffset.y, -maxOffset.y);

                    return new L.Point(dx, dy);
                },

                _rebound: function (left, right) {
                    return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
                },

                _limitZoom: function (zoom) {
                    var min = this.getMinZoom(),
                        max = this.getMaxZoom(),
                        snap = L.Browser.any3d ? this.options.zoomSnap : 1;
                    if (snap) {
                        zoom = Math.round(zoom / snap) * snap;
                    }
                    return Math.max(min, Math.min(max, zoom));
                }
            });

            // @section

            // @factory L.map(id: String, options?: Map options)
            // Instantiates a map object given the DOM ID of a `<div>` element
            // and optionally an object literal with `Map options`.
            //
            // @alternative
            // @factory L.map(el: HTMLElement, options?: Map options)
            // Instantiates a map object given an instance of a `<div>` HTML element
            // and optionally an object literal with `Map options`.
            L.map = function (id, options) {
                return new L.Map(id, options);
            };

            /*
             * @class Layer
             * @inherits Evented
             * @aka L.Layer
             * @aka ILayer
             *
             * A set of methods from the Layer base class that all Leaflet layers use.
             * Inherits all methods, options and events from `L.Evented`.
             *
             * @example
             *
             * ```js
             * var layer = L.Marker(latlng).addTo(map);
             * layer.addTo(map);
             * layer.remove();
             * ```
             *
             * @event add: Event
             * Fired after the layer is added to a map
             *
             * @event remove: Event
             * Fired after the layer is removed from a map
             */

            L.Layer = L.Evented.extend({

                // Classes extending `L.Layer` will inherit the following options:
                options: {
                    // @option pane: String = 'overlayPane'
                    // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
                    pane: 'overlayPane',
                    nonBubblingEvents: [] // Array of events that should not be bubbled to DOM parents (like the map)
                },

                /* @section
                 * Classes extending `L.Layer` will inherit the following methods:
                 *
                 * @method addTo(map: Map): this
                 * Adds the layer to the given map
                 */
                addTo: function (map) {
                    map.addLayer(this);
                    return this;
                },

                // @method remove: this
                // Removes the layer from the map it is currently active on.
                remove: function () {
                    return this.removeFrom(this._map || this._mapToAdd);
                },

                // @method removeFrom(map: Map): this
                // Removes the layer from the given map
                removeFrom: function (obj) {
                    if (obj) {
                        obj.removeLayer(this);
                    }
                    return this;
                },

                // @method getPane(name? : String): HTMLElement
                // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
                getPane: function (name) {
                    return this._map.getPane(name ? this.options[name] || name : this.options.pane);
                },

                addInteractiveTarget: function (targetEl) {
                    this._map._targets[L.stamp(targetEl)] = this;
                    return this;
                },

                removeInteractiveTarget: function (targetEl) {
                    delete this._map._targets[L.stamp(targetEl)];
                    return this;
                },

                _layerAdd: function (e) {
                    var map = e.target;

                    // check in case layer gets added and then removed before the map is ready
                    if (!map.hasLayer(this)) {
                        return;
                    }

                    this._map = map;
                    this._zoomAnimated = map._zoomAnimated;

                    if (this.getEvents) {
                        var events = this.getEvents();
                        map.on(events, this);
                        this.once('remove', function () {
                            map.off(events, this);
                        }, this);
                    }

                    this.onAdd(map);

                    if (this.getAttribution && this._map.attributionControl) {
                        this._map.attributionControl.addAttribution(this.getAttribution());
                    }

                    this.fire('add');
                    map.fire('layeradd', { layer: this });
                }
            });

            /* @section Extension methods
             * @uninheritable
             *
             * Every layer should extend from `L.Layer` and (re-)implement the following methods.
             *
             * @method onAdd(map: Map): this
             * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
             *
             * @method onRemove(map: Map): this
             * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
             *
             * @method getEvents(): Object
             * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
             *
             * @method getAttribution(): String
             * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
             *
             * @method beforeAdd(map: Map): this
             * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
             */

            /* @namespace Map
             * @section Layer events
             *
             * @event layeradd: LayerEvent
             * Fired when a new layer is added to the map.
             *
             * @event layerremove: LayerEvent
             * Fired when some layer is removed from the map
             *
             * @section Methods for Layers and Controls
             */
            L.Map.include({
                // @method addLayer(layer: Layer): this
                // Adds the given layer to the map
                addLayer: function (layer) {
                    var id = L.stamp(layer);
                    if (this._layers[id]) {
                        return this;
                    }
                    this._layers[id] = layer;

                    layer._mapToAdd = this;

                    if (layer.beforeAdd) {
                        layer.beforeAdd(this);
                    }

                    this.whenReady(layer._layerAdd, layer);

                    return this;
                },

                // @method removeLayer(layer: Layer): this
                // Removes the given layer from the map.
                removeLayer: function (layer) {
                    var id = L.stamp(layer);

                    if (!this._layers[id]) {
                        return this;
                    }

                    if (this._loaded) {
                        layer.onRemove(this);
                    }

                    if (layer.getAttribution && this.attributionControl) {
                        this.attributionControl.removeAttribution(layer.getAttribution());
                    }

                    delete this._layers[id];

                    if (this._loaded) {
                        this.fire('layerremove', { layer: layer });
                        layer.fire('remove');
                    }

                    layer._map = layer._mapToAdd = null;

                    return this;
                },

                // @method hasLayer(layer: Layer): Boolean
                // Returns `true` if the given layer is currently added to the map
                hasLayer: function (layer) {
                    return !!layer && L.stamp(layer) in this._layers;
                },

                /* @method eachLayer(fn: Function, context?: Object): this
                 * Iterates over the layers of the map, optionally specifying context of the iterator function.
                 * ```
                 * map.eachLayer(function(layer){
                 *     layer.bindPopup('Hello');
                 * });
                 * ```
                 */
                eachLayer: function (method, context) {
                    for (var i in this._layers) {
                        method.call(context, this._layers[i]);
                    }
                    return this;
                },

                _addLayers: function (layers) {
                    layers = layers ? L.Util.isArray(layers) ? layers : [layers] : [];

                    for (var i = 0, len = layers.length; i < len; i++) {
                        this.addLayer(layers[i]);
                    }
                },

                _addZoomLimit: function (layer) {
                    if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
                        this._zoomBoundLayers[L.stamp(layer)] = layer;
                        this._updateZoomLevels();
                    }
                },

                _removeZoomLimit: function (layer) {
                    var id = L.stamp(layer);

                    if (this._zoomBoundLayers[id]) {
                        delete this._zoomBoundLayers[id];
                        this._updateZoomLevels();
                    }
                },

                _updateZoomLevels: function () {
                    var minZoom = Infinity,
                        maxZoom = -Infinity,
                        oldZoomSpan = this._getZoomSpan();

                    for (var i in this._zoomBoundLayers) {
                        var options = this._zoomBoundLayers[i].options;

                        minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
                        maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
                    }

                    this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
                    this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

                    // @section Map state change events
                    // @event zoomlevelschange: Event
                    // Fired when the number of zoomlevels on the map is changed due
                    // to adding or removing a layer.
                    if (oldZoomSpan !== this._getZoomSpan()) {
                        this.fire('zoomlevelschange');
                    }
                }
            });

            /*
             * @namespace Projection
             * @projection L.Projection.Mercator
             *
             * Elliptical Mercator projection — more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the EPSG:3395 CRS.
             */

            L.Projection.Mercator = {
                R: 6378137,
                R_MINOR: 6356752.314245179,

                bounds: L.bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

                project: function (latlng) {
                    var d = Math.PI / 180,
                        r = this.R,
                        y = latlng.lat * d,
                        tmp = this.R_MINOR / r,
                        e = Math.sqrt(1 - tmp * tmp),
                        con = e * Math.sin(y);

                    var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
                    y = -r * Math.log(Math.max(ts, 1E-10));

                    return new L.Point(latlng.lng * d * r, y);
                },

                unproject: function (point) {
                    var d = 180 / Math.PI,
                        r = this.R,
                        tmp = this.R_MINOR / r,
                        e = Math.sqrt(1 - tmp * tmp),
                        ts = Math.exp(-point.y / r),
                        phi = Math.PI / 2 - 2 * Math.atan(ts);

                    for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
                        con = e * Math.sin(phi);
                        con = Math.pow((1 - con) / (1 + con), e / 2);
                        dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
                        phi += dphi;
                    }

                    return new L.LatLng(phi * d, point.x * d / r);
                }
            };

            /*
             * @namespace CRS
             * @crs L.CRS.EPSG3395
             *
             * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
             */

            L.CRS.EPSG3395 = L.extend({}, L.CRS.Earth, {
                code: 'EPSG:3395',
                projection: L.Projection.Mercator,

                transformation: function () {
                    var scale = 0.5 / (Math.PI * L.Projection.Mercator.R);
                    return new L.Transformation(scale, 0.5, -scale, 0.5);
                }()
            });

            /*
             * @class GridLayer
             * @inherits Layer
             * @aka L.GridLayer
             *
             * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
             * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
             *
             *
             * @section Synchronous usage
             * @example
             *
             * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
             *
             * ```js
             * var CanvasLayer = L.GridLayer.extend({
             *     createTile: function(coords){
             *         // create a <canvas> element for drawing
             *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
             *
             *         // setup tile width and height according to the options
             *         var size = this.getTileSize();
             *         tile.width = size.x;
             *         tile.height = size.y;
             *
             *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
             *         var ctx = tile.getContext('2d');
             *
             *         // return the tile so it can be rendered on screen
             *         return tile;
             *     }
             * });
             * ```
             *
             * @section Asynchronous usage
             * @example
             *
             * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
             *
             * ```js
             * var CanvasLayer = L.GridLayer.extend({
             *     createTile: function(coords, done){
             *         var error;
             *
             *         // create a <canvas> element for drawing
             *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
             *
             *         // setup tile width and height according to the options
             *         var size = this.getTileSize();
             *         tile.width = size.x;
             *         tile.height = size.y;
             *
             *         // draw something asynchronously and pass the tile to the done() callback
             *         setTimeout(function() {
             *             done(error, tile);
             *         }, 1000);
             *
             *         return tile;
             *     }
             * });
             * ```
             *
             * @section
             */

            L.GridLayer = L.Layer.extend({

                // @section
                // @aka GridLayer options
                options: {
                    // @option tileSize: Number|Point = 256
                    // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
                    tileSize: 256,

                    // @option opacity: Number = 1.0
                    // Opacity of the tiles. Can be used in the `createTile()` function.
                    opacity: 1,

                    // @option updateWhenIdle: Boolean = depends
                    // If `false`, new tiles are loaded during panning, otherwise only after it (for better performance). `true` by default on mobile browsers, otherwise `false`.
                    updateWhenIdle: L.Browser.mobile,

                    // @option updateWhenZooming: Boolean = true
                    // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
                    updateWhenZooming: true,

                    // @option updateInterval: Number = 200
                    // Tiles will not update more than once every `updateInterval` milliseconds when panning.
                    updateInterval: 200,

                    // @option attribution: String = null
                    // String to be shown in the attribution control, describes the layer data, e.g. "© Mapbox".
                    attribution: null,

                    // @option zIndex: Number = 1
                    // The explicit zIndex of the tile layer.
                    zIndex: 1,

                    // @option bounds: LatLngBounds = undefined
                    // If set, tiles will only be loaded inside the set `LatLngBounds`.
                    bounds: null,

                    // @option minZoom: Number = 0
                    // The minimum zoom level that tiles will be loaded at. By default the entire map.
                    minZoom: 0,

                    // @option maxZoom: Number = undefined
                    // The maximum zoom level that tiles will be loaded at.
                    maxZoom: undefined,

                    // @option noWrap: Boolean = false
                    // Whether the layer is wrapped around the antimeridian. If `true`, the
                    // GridLayer will only be displayed once at low zoom levels. Has no
                    // effect when the [map CRS](#map-crs) doesn't wrap around.
                    noWrap: false,

                    // @option pane: String = 'tilePane'
                    // `Map pane` where the grid layer will be added.
                    pane: 'tilePane',

                    // @option className: String = ''
                    // A custom class name to assign to the tile layer. Empty by default.
                    className: '',

                    // @option keepBuffer: Number = 2
                    // When panning the map, keep this many rows and columns of tiles before unloading them.
                    keepBuffer: 2
                },

                initialize: function (options) {
                    L.setOptions(this, options);
                },

                onAdd: function () {
                    this._initContainer();

                    this._levels = {};
                    this._tiles = {};

                    this._resetView();
                    this._update();
                },

                beforeAdd: function (map) {
                    map._addZoomLimit(this);
                },

                onRemove: function (map) {
                    this._removeAllTiles();
                    L.DomUtil.remove(this._container);
                    map._removeZoomLimit(this);
                    this._container = null;
                    this._tileZoom = null;
                },

                // @method bringToFront: this
                // Brings the tile layer to the top of all tile layers.
                bringToFront: function () {
                    if (this._map) {
                        L.DomUtil.toFront(this._container);
                        this._setAutoZIndex(Math.max);
                    }
                    return this;
                },

                // @method bringToBack: this
                // Brings the tile layer to the bottom of all tile layers.
                bringToBack: function () {
                    if (this._map) {
                        L.DomUtil.toBack(this._container);
                        this._setAutoZIndex(Math.min);
                    }
                    return this;
                },

                // @method getAttribution: String
                // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
                getAttribution: function () {
                    return this.options.attribution;
                },

                // @method getContainer: HTMLElement
                // Returns the HTML element that contains the tiles for this layer.
                getContainer: function () {
                    return this._container;
                },

                // @method setOpacity(opacity: Number): this
                // Changes the [opacity](#gridlayer-opacity) of the grid layer.
                setOpacity: function (opacity) {
                    this.options.opacity = opacity;
                    this._updateOpacity();
                    return this;
                },

                // @method setZIndex(zIndex: Number): this
                // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
                setZIndex: function (zIndex) {
                    this.options.zIndex = zIndex;
                    this._updateZIndex();

                    return this;
                },

                // @method isLoading: Boolean
                // Returns `true` if any tile in the grid layer has not finished loading.
                isLoading: function () {
                    return this._loading;
                },

                // @method redraw: this
                // Causes the layer to clear all the tiles and request them again.
                redraw: function () {
                    if (this._map) {
                        this._removeAllTiles();
                        this._update();
                    }
                    return this;
                },

                getEvents: function () {
                    var events = {
                        viewprereset: this._invalidateAll,
                        viewreset: this._resetView,
                        zoom: this._resetView,
                        moveend: this._onMoveEnd
                    };

                    if (!this.options.updateWhenIdle) {
                        // update tiles on move, but not more often than once per given interval
                        if (!this._onMove) {
                            this._onMove = L.Util.throttle(this._onMoveEnd, this.options.updateInterval, this);
                        }

                        events.move = this._onMove;
                    }

                    if (this._zoomAnimated) {
                        events.zoomanim = this._animateZoom;
                    }

                    return events;
                },

                // @section Extension methods
                // Layers extending `GridLayer` shall reimplement the following method.
                // @method createTile(coords: Object, done?: Function): HTMLElement
                // Called only internally, must be overriden by classes extending `GridLayer`.
                // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
                // is specified, it must be called when the tile has finished loading and drawing.
                createTile: function () {
                    return document.createElement('div');
                },

                // @section
                // @method getTileSize: Point
                // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
                getTileSize: function () {
                    var s = this.options.tileSize;
                    return s instanceof L.Point ? s : new L.Point(s, s);
                },

                _updateZIndex: function () {
                    if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
                        this._container.style.zIndex = this.options.zIndex;
                    }
                },

                _setAutoZIndex: function (compare) {
                    // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

                    var layers = this.getPane().children,
                        edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

                    for (var i = 0, len = layers.length, zIndex; i < len; i++) {

                        zIndex = layers[i].style.zIndex;

                        if (layers[i] !== this._container && zIndex) {
                            edgeZIndex = compare(edgeZIndex, +zIndex);
                        }
                    }

                    if (isFinite(edgeZIndex)) {
                        this.options.zIndex = edgeZIndex + compare(-1, 1);
                        this._updateZIndex();
                    }
                },

                _updateOpacity: function () {
                    if (!this._map) {
                        return;
                    }

                    // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
                    if (L.Browser.ielt9) {
                        return;
                    }

                    L.DomUtil.setOpacity(this._container, this.options.opacity);

                    var now = +new Date(),
                        nextFrame = false,
                        willPrune = false;

                    for (var key in this._tiles) {
                        var tile = this._tiles[key];
                        if (!tile.current || !tile.loaded) {
                            continue;
                        }

                        var fade = Math.min(1, (now - tile.loaded) / 200);

                        L.DomUtil.setOpacity(tile.el, fade);
                        if (fade < 1) {
                            nextFrame = true;
                        } else {
                            if (tile.active) {
                                willPrune = true;
                            }
                            tile.active = true;
                        }
                    }

                    if (willPrune && !this._noPrune) {
                        this._pruneTiles();
                    }

                    if (nextFrame) {
                        L.Util.cancelAnimFrame(this._fadeFrame);
                        this._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);
                    }
                },

                _initContainer: function () {
                    if (this._container) {
                        return;
                    }

                    this._container = L.DomUtil.create('div', 'leaflet-layer ' + (this.options.className || ''));
                    this._updateZIndex();

                    if (this.options.opacity < 1) {
                        this._updateOpacity();
                    }

                    this.getPane().appendChild(this._container);
                },

                _updateLevels: function () {

                    var zoom = this._tileZoom,
                        maxZoom = this.options.maxZoom;

                    if (zoom === undefined) {
                        return undefined;
                    }

                    for (var z in this._levels) {
                        if (this._levels[z].el.children.length || z === zoom) {
                            this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
                        } else {
                            L.DomUtil.remove(this._levels[z].el);
                            this._removeTilesAtZoom(z);
                            delete this._levels[z];
                        }
                    }

                    var level = this._levels[zoom],
                        map = this._map;

                    if (!level) {
                        level = this._levels[zoom] = {};

                        level.el = L.DomUtil.create('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
                        level.el.style.zIndex = maxZoom;

                        level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
                        level.zoom = zoom;

                        this._setZoomTransform(level, map.getCenter(), map.getZoom());

                        // force the browser to consider the newly added element for transition
                        L.Util.falseFn(level.el.offsetWidth);
                    }

                    this._level = level;

                    return level;
                },

                _pruneTiles: function () {
                    if (!this._map) {
                        return;
                    }

                    var key, tile;

                    var zoom = this._map.getZoom();
                    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
                        this._removeAllTiles();
                        return;
                    }

                    for (key in this._tiles) {
                        tile = this._tiles[key];
                        tile.retain = tile.current;
                    }

                    for (key in this._tiles) {
                        tile = this._tiles[key];
                        if (tile.current && !tile.active) {
                            var coords = tile.coords;
                            if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                                this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
                            }
                        }
                    }

                    for (key in this._tiles) {
                        if (!this._tiles[key].retain) {
                            this._removeTile(key);
                        }
                    }
                },

                _removeTilesAtZoom: function (zoom) {
                    for (var key in this._tiles) {
                        if (this._tiles[key].coords.z !== zoom) {
                            continue;
                        }
                        this._removeTile(key);
                    }
                },

                _removeAllTiles: function () {
                    for (var key in this._tiles) {
                        this._removeTile(key);
                    }
                },

                _invalidateAll: function () {
                    for (var z in this._levels) {
                        L.DomUtil.remove(this._levels[z].el);
                        delete this._levels[z];
                    }
                    this._removeAllTiles();

                    this._tileZoom = null;
                },

                _retainParent: function (x, y, z, minZoom) {
                    var x2 = Math.floor(x / 2),
                        y2 = Math.floor(y / 2),
                        z2 = z - 1,
                        coords2 = new L.Point(+x2, +y2);
                    coords2.z = +z2;

                    var key = this._tileCoordsToKey(coords2),
                        tile = this._tiles[key];

                    if (tile && tile.active) {
                        tile.retain = true;
                        return true;
                    } else if (tile && tile.loaded) {
                        tile.retain = true;
                    }

                    if (z2 > minZoom) {
                        return this._retainParent(x2, y2, z2, minZoom);
                    }

                    return false;
                },

                _retainChildren: function (x, y, z, maxZoom) {

                    for (var i = 2 * x; i < 2 * x + 2; i++) {
                        for (var j = 2 * y; j < 2 * y + 2; j++) {

                            var coords = new L.Point(i, j);
                            coords.z = z + 1;

                            var key = this._tileCoordsToKey(coords),
                                tile = this._tiles[key];

                            if (tile && tile.active) {
                                tile.retain = true;
                                continue;
                            } else if (tile && tile.loaded) {
                                tile.retain = true;
                            }

                            if (z + 1 < maxZoom) {
                                this._retainChildren(i, j, z + 1, maxZoom);
                            }
                        }
                    }
                },

                _resetView: function (e) {
                    var animating = e && (e.pinch || e.flyTo);
                    this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
                },

                _animateZoom: function (e) {
                    this._setView(e.center, e.zoom, true, e.noUpdate);
                },

                _setView: function (center, zoom, noPrune, noUpdate) {
                    var tileZoom = Math.round(zoom);
                    if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {
                        tileZoom = undefined;
                    }

                    var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;

                    if (!noUpdate || tileZoomChanged) {

                        this._tileZoom = tileZoom;

                        if (this._abortLoading) {
                            this._abortLoading();
                        }

                        this._updateLevels();
                        this._resetGrid();

                        if (tileZoom !== undefined) {
                            this._update(center);
                        }

                        if (!noPrune) {
                            this._pruneTiles();
                        }

                        // Flag to prevent _updateOpacity from pruning tiles during
                        // a zoom anim or a pinch gesture
                        this._noPrune = !!noPrune;
                    }

                    this._setZoomTransforms(center, zoom);
                },

                _setZoomTransforms: function (center, zoom) {
                    for (var i in this._levels) {
                        this._setZoomTransform(this._levels[i], center, zoom);
                    }
                },

                _setZoomTransform: function (level, center, zoom) {
                    var scale = this._map.getZoomScale(zoom, level.zoom),
                        translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();

                    if (L.Browser.any3d) {
                        L.DomUtil.setTransform(level.el, translate, scale);
                    } else {
                        L.DomUtil.setPosition(level.el, translate);
                    }
                },

                _resetGrid: function () {
                    var map = this._map,
                        crs = map.options.crs,
                        tileSize = this._tileSize = this.getTileSize(),
                        tileZoom = this._tileZoom;

                    var bounds = this._map.getPixelWorldBounds(this._tileZoom);
                    if (bounds) {
                        this._globalTileRange = this._pxBoundsToTileRange(bounds);
                    }

                    this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];
                    this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];
                },

                _onMoveEnd: function () {
                    if (!this._map || this._map._animatingZoom) {
                        return;
                    }

                    this._update();
                },

                _getTiledPixelBounds: function (center) {
                    var map = this._map,
                        mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
                        scale = map.getZoomScale(mapZoom, this._tileZoom),
                        pixelCenter = map.project(center, this._tileZoom).floor(),
                        halfSize = map.getSize().divideBy(scale * 2);

                    return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
                },

                // Private method to load tiles in the grid's active zoom level according to map bounds
                _update: function (center) {
                    var map = this._map;
                    if (!map) {
                        return;
                    }
                    var zoom = map.getZoom();

                    if (center === undefined) {
                        center = map.getCenter();
                    }
                    if (this._tileZoom === undefined) {
                        return;
                    } // if out of minzoom/maxzoom

                    var pixelBounds = this._getTiledPixelBounds(center),
                        tileRange = this._pxBoundsToTileRange(pixelBounds),
                        tileCenter = tileRange.getCenter(),
                        queue = [],
                        margin = this.options.keepBuffer,
                        noPruneRange = new L.Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));

                    for (var key in this._tiles) {
                        var c = this._tiles[key].coords;
                        if (c.z !== this._tileZoom || !noPruneRange.contains(L.point(c.x, c.y))) {
                            this._tiles[key].current = false;
                        }
                    }

                    // _update just loads more tiles. If the tile zoom level differs too much
                    // from the map's, let _setView reset levels and prune old tiles.
                    if (Math.abs(zoom - this._tileZoom) > 1) {
                        this._setView(center, zoom);return;
                    }

                    // create a queue of coordinates to load tiles from
                    for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
                        for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
                            var coords = new L.Point(i, j);
                            coords.z = this._tileZoom;

                            if (!this._isValidTile(coords)) {
                                continue;
                            }

                            var tile = this._tiles[this._tileCoordsToKey(coords)];
                            if (tile) {
                                tile.current = true;
                            } else {
                                queue.push(coords);
                            }
                        }
                    }

                    // sort tile queue to load tiles in order of their distance to center
                    queue.sort(function (a, b) {
                        return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
                    });

                    if (queue.length !== 0) {
                        // if it's the first batch of tiles to load
                        if (!this._loading) {
                            this._loading = true;
                            // @event loading: Event
                            // Fired when the grid layer starts loading tiles.
                            this.fire('loading');
                        }

                        // create DOM fragment to append tiles in one batch
                        var fragment = document.createDocumentFragment();

                        for (i = 0; i < queue.length; i++) {
                            this._addTile(queue[i], fragment);
                        }

                        this._level.el.appendChild(fragment);
                    }
                },

                _isValidTile: function (coords) {
                    var crs = this._map.options.crs;

                    if (!crs.infinite) {
                        // don't load tile if it's out of bounds and not wrapped
                        var bounds = this._globalTileRange;
                        if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
                            return false;
                        }
                    }

                    if (!this.options.bounds) {
                        return true;
                    }

                    // don't load tile if it doesn't intersect the bounds in options
                    var tileBounds = this._tileCoordsToBounds(coords);
                    return L.latLngBounds(this.options.bounds).overlaps(tileBounds);
                },

                _keyToBounds: function (key) {
                    return this._tileCoordsToBounds(this._keyToTileCoords(key));
                },

                // converts tile coordinates to its geographical bounds
                _tileCoordsToBounds: function (coords) {

                    var map = this._map,
                        tileSize = this.getTileSize(),
                        nwPoint = coords.scaleBy(tileSize),
                        sePoint = nwPoint.add(tileSize),
                        nw = map.unproject(nwPoint, coords.z),
                        se = map.unproject(sePoint, coords.z);

                    if (!this.options.noWrap) {
                        nw = map.wrapLatLng(nw);
                        se = map.wrapLatLng(se);
                    }

                    return new L.LatLngBounds(nw, se);
                },

                // converts tile coordinates to key for the tile cache
                _tileCoordsToKey: function (coords) {
                    return coords.x + ':' + coords.y + ':' + coords.z;
                },

                // converts tile cache key to coordinates
                _keyToTileCoords: function (key) {
                    var k = key.split(':'),
                        coords = new L.Point(+k[0], +k[1]);
                    coords.z = +k[2];
                    return coords;
                },

                _removeTile: function (key) {
                    var tile = this._tiles[key];
                    if (!tile) {
                        return;
                    }

                    L.DomUtil.remove(tile.el);

                    delete this._tiles[key];

                    // @event tileunload: TileEvent
                    // Fired when a tile is removed (e.g. when a tile goes off the screen).
                    this.fire('tileunload', {
                        tile: tile.el,
                        coords: this._keyToTileCoords(key)
                    });
                },

                _initTile: function (tile) {
                    L.DomUtil.addClass(tile, 'leaflet-tile');

                    var tileSize = this.getTileSize();
                    tile.style.width = tileSize.x + 'px';
                    tile.style.height = tileSize.y + 'px';

                    tile.onselectstart = L.Util.falseFn;
                    tile.onmousemove = L.Util.falseFn;

                    // update opacity on tiles in IE7-8 because of filter inheritance problems
                    if (L.Browser.ielt9 && this.options.opacity < 1) {
                        L.DomUtil.setOpacity(tile, this.options.opacity);
                    }

                    // without this hack, tiles disappear after zoom on Chrome for Android
                    // https://github.com/Leaflet/Leaflet/issues/2078
                    if (L.Browser.android && !L.Browser.android23) {
                        tile.style.WebkitBackfaceVisibility = 'hidden';
                    }
                },

                _addTile: function (coords, container) {
                    var tilePos = this._getTilePos(coords),
                        key = this._tileCoordsToKey(coords);

                    var tile = this.createTile(this._wrapCoords(coords), L.bind(this._tileReady, this, coords));

                    this._initTile(tile);

                    // if createTile is defined with a second argument ("done" callback),
                    // we know that tile is async and will be ready later; otherwise
                    if (this.createTile.length < 2) {
                        // mark tile as ready, but delay one frame for opacity animation to happen
                        L.Util.requestAnimFrame(L.bind(this._tileReady, this, coords, null, tile));
                    }

                    L.DomUtil.setPosition(tile, tilePos);

                    // save tile in cache
                    this._tiles[key] = {
                        el: tile,
                        coords: coords,
                        current: true
                    };

                    container.appendChild(tile);
                    // @event tileloadstart: TileEvent
                    // Fired when a tile is requested and starts loading.
                    this.fire('tileloadstart', {
                        tile: tile,
                        coords: coords
                    });
                },

                _tileReady: function (coords, err, tile) {
                    if (!this._map) {
                        return;
                    }

                    if (err) {
                        // @event tileerror: TileErrorEvent
                        // Fired when there is an error loading a tile.
                        this.fire('tileerror', {
                            error: err,
                            tile: tile,
                            coords: coords
                        });
                    }

                    var key = this._tileCoordsToKey(coords);

                    tile = this._tiles[key];
                    if (!tile) {
                        return;
                    }

                    tile.loaded = +new Date();
                    if (this._map._fadeAnimated) {
                        L.DomUtil.setOpacity(tile.el, 0);
                        L.Util.cancelAnimFrame(this._fadeFrame);
                        this._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);
                    } else {
                        tile.active = true;
                        this._pruneTiles();
                    }

                    if (!err) {
                        L.DomUtil.addClass(tile.el, 'leaflet-tile-loaded');

                        // @event tileload: TileEvent
                        // Fired when a tile loads.
                        this.fire('tileload', {
                            tile: tile.el,
                            coords: coords
                        });
                    }

                    if (this._noTilesToLoad()) {
                        this._loading = false;
                        // @event load: Event
                        // Fired when the grid layer loaded all visible tiles.
                        this.fire('load');

                        if (L.Browser.ielt9 || !this._map._fadeAnimated) {
                            L.Util.requestAnimFrame(this._pruneTiles, this);
                        } else {
                            // Wait a bit more than 0.2 secs (the duration of the tile fade-in)
                            // to trigger a pruning.
                            setTimeout(L.bind(this._pruneTiles, this), 250);
                        }
                    }
                },

                _getTilePos: function (coords) {
                    return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
                },

                _wrapCoords: function (coords) {
                    var newCoords = new L.Point(this._wrapX ? L.Util.wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? L.Util.wrapNum(coords.y, this._wrapY) : coords.y);
                    newCoords.z = coords.z;
                    return newCoords;
                },

                _pxBoundsToTileRange: function (bounds) {
                    var tileSize = this.getTileSize();
                    return new L.Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
                },

                _noTilesToLoad: function () {
                    for (var key in this._tiles) {
                        if (!this._tiles[key].loaded) {
                            return false;
                        }
                    }
                    return true;
                }
            });

            // @factory L.gridLayer(options?: GridLayer options)
            // Creates a new instance of GridLayer with the supplied options.
            L.gridLayer = function (options) {
                return new L.GridLayer(options);
            };

            /*
             * @class TileLayer
             * @inherits GridLayer
             * @aka L.TileLayer
             * Used to load and display tile layers on the map. Extends `GridLayer`.
             *
             * @example
             *
             * ```js
             * L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar'}).addTo(map);
             * ```
             *
             * @section URL template
             * @example
             *
             * A string of the following form:
             *
             * ```
             * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
             * ```
             *
             * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add @2x to the URL to load retina tiles.
             *
             * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
             *
             * ```
             * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
             * ```
             */

            L.TileLayer = L.GridLayer.extend({

                // @section
                // @aka TileLayer options
                options: {
                    // @option minZoom: Number = 0
                    // Minimum zoom number.
                    minZoom: 0,

                    // @option maxZoom: Number = 18
                    // Maximum zoom number.
                    maxZoom: 18,

                    // @option maxNativeZoom: Number = null
                    // Maximum zoom number the tile source has available. If it is specified,
                    // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
                    // from `maxNativeZoom` level and auto-scaled.
                    maxNativeZoom: null,

                    // @option subdomains: String|String[] = 'abc'
                    // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
                    subdomains: 'abc',

                    // @option errorTileUrl: String = ''
                    // URL to the tile image to show in place of the tile that failed to load.
                    errorTileUrl: '',

                    // @option zoomOffset: Number = 0
                    // The zoom number used in tile URLs will be offset with this value.
                    zoomOffset: 0,

                    // @option tms: Boolean = false
                    // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
                    tms: false,

                    // @option zoomReverse: Boolean = false
                    // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
                    zoomReverse: false,

                    // @option detectRetina: Boolean = false
                    // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
                    detectRetina: false,

                    // @option crossOrigin: Boolean = false
                    // If true, all tiles will have their crossOrigin attribute set to ''. This is needed if you want to access tile pixel data.
                    crossOrigin: false
                },

                initialize: function (url, options) {

                    this._url = url;

                    options = L.setOptions(this, options);

                    // detecting retina displays, adjusting tileSize and zoom levels
                    if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

                        options.tileSize = Math.floor(options.tileSize / 2);

                        if (!options.zoomReverse) {
                            options.zoomOffset++;
                            options.maxZoom--;
                        } else {
                            options.zoomOffset--;
                            options.minZoom++;
                        }

                        options.minZoom = Math.max(0, options.minZoom);
                    }

                    if (typeof options.subdomains === 'string') {
                        options.subdomains = options.subdomains.split('');
                    }

                    // for https://github.com/Leaflet/Leaflet/issues/137
                    if (!L.Browser.android) {
                        this.on('tileunload', this._onTileRemove);
                    }
                },

                // @method setUrl(url: String, noRedraw?: Boolean): this
                // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
                setUrl: function (url, noRedraw) {
                    this._url = url;

                    if (!noRedraw) {
                        this.redraw();
                    }
                    return this;
                },

                // @method createTile(coords: Object, done?: Function): HTMLElement
                // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
                // to return an `<img>` HTML element with the appropiate image URL given `coords`. The `done`
                // callback is called when the tile has been loaded.
                createTile: function (coords, done) {
                    var tile = document.createElement('img');

                    L.DomEvent.on(tile, 'load', L.bind(this._tileOnLoad, this, done, tile));
                    L.DomEvent.on(tile, 'error', L.bind(this._tileOnError, this, done, tile));

                    if (this.options.crossOrigin) {
                        tile.crossOrigin = '';
                    }

                    /*
                     Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
                     http://www.w3.org/TR/WCAG20-TECHS/H67
                    */
                    tile.alt = '';

                    tile.src = this.getTileUrl(coords);

                    return tile;
                },

                // @section Extension methods
                // @uninheritable
                // Layers extending `TileLayer` might reimplement the following method.
                // @method getTileUrl(coords: Object): String
                // Called only internally, returns the URL for a tile given its coordinates.
                // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
                getTileUrl: function (coords) {
                    var data = {
                        r: L.Browser.retina ? '@2x' : '',
                        s: this._getSubdomain(coords),
                        x: coords.x,
                        y: coords.y,
                        z: this._getZoomForUrl()
                    };
                    if (this._map && !this._map.options.crs.infinite) {
                        var invertedY = this._globalTileRange.max.y - coords.y;
                        if (this.options.tms) {
                            data['y'] = invertedY;
                        }
                        data['-y'] = invertedY;
                    }

                    return L.Util.template(this._url, L.extend(data, this.options));
                },

                _tileOnLoad: function (done, tile) {
                    // For https://github.com/Leaflet/Leaflet/issues/3332
                    if (L.Browser.ielt9) {
                        setTimeout(L.bind(done, this, null, tile), 0);
                    } else {
                        done(null, tile);
                    }
                },

                _tileOnError: function (done, tile, e) {
                    var errorUrl = this.options.errorTileUrl;
                    if (errorUrl) {
                        tile.src = errorUrl;
                    }
                    done(e, tile);
                },

                getTileSize: function () {
                    var map = this._map,
                        tileSize = L.GridLayer.prototype.getTileSize.call(this),
                        zoom = this._tileZoom + this.options.zoomOffset,
                        zoomN = this.options.maxNativeZoom;

                    // increase tile size when overscaling
                    return zoomN !== null && zoom > zoomN ? tileSize.divideBy(map.getZoomScale(zoomN, zoom)).round() : tileSize;
                },

                _onTileRemove: function (e) {
                    e.tile.onload = null;
                },

                _getZoomForUrl: function () {

                    var options = this.options,
                        zoom = this._tileZoom;

                    if (options.zoomReverse) {
                        zoom = options.maxZoom - zoom;
                    }

                    zoom += options.zoomOffset;

                    return options.maxNativeZoom !== null ? Math.min(zoom, options.maxNativeZoom) : zoom;
                },

                _getSubdomain: function (tilePoint) {
                    var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
                    return this.options.subdomains[index];
                },

                // stops loading all tiles in the background layer
                _abortLoading: function () {
                    var i, tile;
                    for (i in this._tiles) {
                        if (this._tiles[i].coords.z !== this._tileZoom) {
                            tile = this._tiles[i].el;

                            tile.onload = L.Util.falseFn;
                            tile.onerror = L.Util.falseFn;

                            if (!tile.complete) {
                                tile.src = L.Util.emptyImageUrl;
                                L.DomUtil.remove(tile);
                            }
                        }
                    }
                }
            });

            // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
            // Instantiates a tile layer object given a `URL template` and optionally an options object.

            L.tileLayer = function (url, options) {
                return new L.TileLayer(url, options);
            };

            /*
             * @class TileLayer.WMS
             * @inherits TileLayer
             * @aka L.TileLayer.WMS
             * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
             *
             * @example
             *
             * ```js
             * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
             * 	layers: 'nexrad-n0r-900913',
             * 	format: 'image/png',
             * 	transparent: true,
             * 	attribution: "Weather data © 2012 IEM Nexrad"
             * });
             * ```
             */

            L.TileLayer.WMS = L.TileLayer.extend({

                // @section
                // @aka TileLayer.WMS options
                // If any custom options not documented here are used, they will be sent to the
                // WMS server as extra parameters in each request URL. This can be useful for
                // [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
                defaultWmsParams: {
                    service: 'WMS',
                    request: 'GetMap',

                    // @option layers: String = ''
                    // **(required)** Comma-separated list of WMS layers to show.
                    layers: '',

                    // @option styles: String = ''
                    // Comma-separated list of WMS styles.
                    styles: '',

                    // @option format: String = 'image/jpeg'
                    // WMS image format (use `'image/png'` for layers with transparency).
                    format: 'image/jpeg',

                    // @option transparent: Boolean = false
                    // If `true`, the WMS service will return images with transparency.
                    transparent: false,

                    // @option version: String = '1.1.1'
                    // Version of the WMS service to use
                    version: '1.1.1'
                },

                options: {
                    // @option crs: CRS = null
                    // Coordinate Reference System to use for the WMS requests, defaults to
                    // map CRS. Don't change this if you're not sure what it means.
                    crs: null,

                    // @option uppercase: Boolean = false
                    // If `true`, WMS request parameter keys will be uppercase.
                    uppercase: false
                },

                initialize: function (url, options) {

                    this._url = url;

                    var wmsParams = L.extend({}, this.defaultWmsParams);

                    // all keys that are not TileLayer options go to WMS params
                    for (var i in options) {
                        if (!(i in this.options)) {
                            wmsParams[i] = options[i];
                        }
                    }

                    options = L.setOptions(this, options);

                    wmsParams.width = wmsParams.height = options.tileSize * (options.detectRetina && L.Browser.retina ? 2 : 1);

                    this.wmsParams = wmsParams;
                },

                onAdd: function (map) {

                    this._crs = this.options.crs || map.options.crs;
                    this._wmsVersion = parseFloat(this.wmsParams.version);

                    var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
                    this.wmsParams[projectionKey] = this._crs.code;

                    L.TileLayer.prototype.onAdd.call(this, map);
                },

                getTileUrl: function (coords) {

                    var tileBounds = this._tileCoordsToBounds(coords),
                        nw = this._crs.project(tileBounds.getNorthWest()),
                        se = this._crs.project(tileBounds.getSouthEast()),
                        bbox = (this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ? [se.y, nw.x, nw.y, se.x] : [nw.x, se.y, se.x, nw.y]).join(','),
                        url = L.TileLayer.prototype.getTileUrl.call(this, coords);

                    return url + L.Util.getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
                },

                // @method setParams(params: Object, noRedraw?: Boolean): this
                // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
                setParams: function (params, noRedraw) {

                    L.extend(this.wmsParams, params);

                    if (!noRedraw) {
                        this.redraw();
                    }

                    return this;
                }
            });

            // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
            // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
            L.tileLayer.wms = function (url, options) {
                return new L.TileLayer.WMS(url, options);
            };

            /*
             * @class ImageOverlay
             * @aka L.ImageOverlay
             * @inherits Interactive layer
             *
             * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
             *
             * @example
             *
             * ```js
             * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
             * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
             * L.imageOverlay(imageUrl, imageBounds).addTo(map);
             * ```
             */

            L.ImageOverlay = L.Layer.extend({

                // @section
                // @aka ImageOverlay options
                options: {
                    // @option opacity: Number = 1.0
                    // The opacity of the image overlay.
                    opacity: 1,

                    // @option alt: String = ''
                    // Text for the `alt` attribute of the image (useful for accessibility).
                    alt: '',

                    // @option interactive: Boolean = false
                    // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
                    interactive: false,

                    // @option attribution: String = null
                    // An optional string containing HTML to be shown on the `Attribution control`
                    attribution: null,

                    // @option crossOrigin: Boolean = false
                    // If true, the image will have its crossOrigin attribute set to ''. This is needed if you want to access image pixel data.
                    crossOrigin: false
                },

                initialize: function (url, bounds, options) {
                    // (String, LatLngBounds, Object)
                    this._url = url;
                    this._bounds = L.latLngBounds(bounds);

                    L.setOptions(this, options);
                },

                onAdd: function () {
                    if (!this._image) {
                        this._initImage();

                        if (this.options.opacity < 1) {
                            this._updateOpacity();
                        }
                    }

                    if (this.options.interactive) {
                        L.DomUtil.addClass(this._image, 'leaflet-interactive');
                        this.addInteractiveTarget(this._image);
                    }

                    this.getPane().appendChild(this._image);
                    this._reset();
                },

                onRemove: function () {
                    L.DomUtil.remove(this._image);
                    if (this.options.interactive) {
                        this.removeInteractiveTarget(this._image);
                    }
                },

                // @method setOpacity(opacity: Number): this
                // Sets the opacity of the overlay.
                setOpacity: function (opacity) {
                    this.options.opacity = opacity;

                    if (this._image) {
                        this._updateOpacity();
                    }
                    return this;
                },

                setStyle: function (styleOpts) {
                    if (styleOpts.opacity) {
                        this.setOpacity(styleOpts.opacity);
                    }
                    return this;
                },

                // @method bringToFront(): this
                // Brings the layer to the top of all overlays.
                bringToFront: function () {
                    if (this._map) {
                        L.DomUtil.toFront(this._image);
                    }
                    return this;
                },

                // @method bringToBack(): this
                // Brings the layer to the bottom of all overlays.
                bringToBack: function () {
                    if (this._map) {
                        L.DomUtil.toBack(this._image);
                    }
                    return this;
                },

                // @method setUrl(url: String): this
                // Changes the URL of the image.
                setUrl: function (url) {
                    this._url = url;

                    if (this._image) {
                        this._image.src = url;
                    }
                    return this;
                },

                setBounds: function (bounds) {
                    this._bounds = bounds;

                    if (this._map) {
                        this._reset();
                    }
                    return this;
                },

                getAttribution: function () {
                    return this.options.attribution;
                },

                getEvents: function () {
                    var events = {
                        zoom: this._reset,
                        viewreset: this._reset
                    };

                    if (this._zoomAnimated) {
                        events.zoomanim = this._animateZoom;
                    }

                    return events;
                },

                getBounds: function () {
                    return this._bounds;
                },

                getElement: function () {
                    return this._image;
                },

                _initImage: function () {
                    var img = this._image = L.DomUtil.create('img', 'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : ''));

                    img.onselectstart = L.Util.falseFn;
                    img.onmousemove = L.Util.falseFn;

                    img.onload = L.bind(this.fire, this, 'load');

                    if (this.options.crossOrigin) {
                        img.crossOrigin = '';
                    }

                    img.src = this._url;
                    img.alt = this.options.alt;
                },

                _animateZoom: function (e) {
                    var scale = this._map.getZoomScale(e.zoom),
                        offset = this._map._latLngToNewLayerPoint(this._bounds.getNorthWest(), e.zoom, e.center);

                    L.DomUtil.setTransform(this._image, offset, scale);
                },

                _reset: function () {
                    var image = this._image,
                        bounds = new L.Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
                        size = bounds.getSize();

                    L.DomUtil.setPosition(image, bounds.min);

                    image.style.width = size.x + 'px';
                    image.style.height = size.y + 'px';
                },

                _updateOpacity: function () {
                    L.DomUtil.setOpacity(this._image, this.options.opacity);
                }
            });

            // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
            // Instantiates an image overlay object given the URL of the image and the
            // geographical bounds it is tied to.
            L.imageOverlay = function (url, bounds, options) {
                return new L.ImageOverlay(url, bounds, options);
            };

            /*
             * @class Icon
             * @aka L.Icon
             * @inherits Layer
             *
             * Represents an icon to provide when creating a marker.
             *
             * @example
             *
             * ```js
             * var myIcon = L.icon({
             *     iconUrl: 'my-icon.png',
             *     iconRetinaUrl: 'my-icon@2x.png',
             *     iconSize: [38, 95],
             *     iconAnchor: [22, 94],
             *     popupAnchor: [-3, -76],
             *     shadowUrl: 'my-icon-shadow.png',
             *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
             *     shadowSize: [68, 95],
             *     shadowAnchor: [22, 94]
             * });
             *
             * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
             * ```
             *
             * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
             *
             */

            L.Icon = L.Class.extend({

                /* @section
                 * @aka Icon options
                 *
                 * @option iconUrl: String = null
                 * **(required)** The URL to the icon image (absolute or relative to your script path).
                 *
                 * @option iconRetinaUrl: String = null
                 * The URL to a retina sized version of the icon image (absolute or relative to your
                 * script path). Used for Retina screen devices.
                 *
                 * @option iconSize: Point = null
                 * Size of the icon image in pixels.
                 *
                 * @option iconAnchor: Point = null
                 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
                 * will be aligned so that this point is at the marker's geographical location. Centered
                 * by default if size is specified, also can be set in CSS with negative margins.
                 *
                 * @option popupAnchor: Point = null
                 * The coordinates of the point from which popups will "open", relative to the icon anchor.
                 *
                 * @option shadowUrl: String = null
                 * The URL to the icon shadow image. If not specified, no shadow image will be created.
                 *
                 * @option shadowRetinaUrl: String = null
                 *
                 * @option shadowSize: Point = null
                 * Size of the shadow image in pixels.
                 *
                 * @option shadowAnchor: Point = null
                 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
                 * as iconAnchor if not specified).
                 *
                 * @option className: String = ''
                 * A custom class name to assign to both icon and shadow images. Empty by default.
                 */

                initialize: function (options) {
                    L.setOptions(this, options);
                },

                // @method createIcon(oldIcon?: HTMLElement): HTMLElement
                // Called internally when the icon has to be shown, returns a `<img>` HTML element
                // styled according to the options.
                createIcon: function (oldIcon) {
                    return this._createIcon('icon', oldIcon);
                },

                // @method createShadow(oldIcon?: HTMLElement): HTMLElement
                // As `createIcon`, but for the shadow beneath it.
                createShadow: function (oldIcon) {
                    return this._createIcon('shadow', oldIcon);
                },

                _createIcon: function (name, oldIcon) {
                    var src = this._getIconUrl(name);

                    if (!src) {
                        if (name === 'icon') {
                            throw new Error('iconUrl not set in Icon options (see the docs).');
                        }
                        return null;
                    }

                    var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
                    this._setIconStyles(img, name);

                    return img;
                },

                _setIconStyles: function (img, name) {
                    var options = this.options;
                    var sizeOption = options[name + 'Size'];

                    if (typeof sizeOption === 'number') {
                        sizeOption = [sizeOption, sizeOption];
                    }

                    var size = L.point(sizeOption),
                        anchor = L.point(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));

                    img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

                    if (anchor) {
                        img.style.marginLeft = -anchor.x + 'px';
                        img.style.marginTop = -anchor.y + 'px';
                    }

                    if (size) {
                        img.style.width = size.x + 'px';
                        img.style.height = size.y + 'px';
                    }
                },

                _createImg: function (src, el) {
                    el = el || document.createElement('img');
                    el.src = src;
                    return el;
                },

                _getIconUrl: function (name) {
                    return L.Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
                }
            });

            // @factory L.icon(options: Icon options)
            // Creates an icon instance with the given options.
            L.icon = function (options) {
                return new L.Icon(options);
            };

            /*
             * @miniclass Icon.Default (Icon)
             * @aka L.Icon.Default
             * @section
             *
             * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
             * no icon is specified. Points to the blue marker image distributed with Leaflet
             * releases.
             *
             * In order to change the default icon, just change the properties of `L.Icon.Default.prototype.options`
             * (which is a set of `Icon options`).
             */

            L.Icon.Default = L.Icon.extend({

                options: {
                    iconUrl: 'marker-icon.png',
                    iconRetinaUrl: 'marker-icon-2x.png',
                    shadowUrl: 'marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    tooltipAnchor: [16, -28],
                    shadowSize: [41, 41]
                },

                _getIconUrl: function (name) {
                    if (!L.Icon.Default.imagePath) {
                        // Deprecated, backwards-compatibility only
                        L.Icon.Default.imagePath = this._detectIconPath();
                    }

                    // @option imagePath: String
                    // `L.Icon.Default` will try to auto-detect the absolute location of the
                    // blue icon images. If you are placing these images in a non-standard
                    // way, set this option to point to the right absolute path.
                    return (this.options.imagePath || L.Icon.Default.imagePath) + L.Icon.prototype._getIconUrl.call(this, name);
                },

                _detectIconPath: function () {
                    var el = L.DomUtil.create('div', 'leaflet-default-icon-path', document.body);
                    var path = L.DomUtil.getStyle(el, 'background-image') || L.DomUtil.getStyle(el, 'backgroundImage'); // IE8

                    document.body.removeChild(el);

                    return path.indexOf('url') === 0 ? path.replace(/^url\([\"\']?/, '').replace(/marker-icon\.png[\"\']?\)$/, '') : '';
                }
            });

            /*
             * @class Marker
             * @inherits Interactive layer
             * @aka L.Marker
             * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
             *
             * @example
             *
             * ```js
             * L.marker([50.5, 30.5]).addTo(map);
             * ```
             */

            L.Marker = L.Layer.extend({

                // @section
                // @aka Marker options
                options: {
                    // @option icon: Icon = *
                    // Icon class to use for rendering the marker. See [Icon documentation](#L.Icon) for details on how to customize the marker icon. If not specified, a new `L.Icon.Default` is used.
                    icon: new L.Icon.Default(),

                    // Option inherited from "Interactive layer" abstract class
                    interactive: true,

                    // @option draggable: Boolean = false
                    // Whether the marker is draggable with mouse/touch or not.
                    draggable: false,

                    // @option keyboard: Boolean = true
                    // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
                    keyboard: true,

                    // @option title: String = ''
                    // Text for the browser tooltip that appear on marker hover (no tooltip by default).
                    title: '',

                    // @option alt: String = ''
                    // Text for the `alt` attribute of the icon image (useful for accessibility).
                    alt: '',

                    // @option zIndexOffset: Number = 0
                    // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
                    zIndexOffset: 0,

                    // @option opacity: Number = 1.0
                    // The opacity of the marker.
                    opacity: 1,

                    // @option riseOnHover: Boolean = false
                    // If `true`, the marker will get on top of others when you hover the mouse over it.
                    riseOnHover: false,

                    // @option riseOffset: Number = 250
                    // The z-index offset used for the `riseOnHover` feature.
                    riseOffset: 250,

                    // @option pane: String = 'markerPane'
                    // `Map pane` where the markers icon will be added.
                    pane: 'markerPane',

                    // FIXME: shadowPane is no longer a valid option
                    nonBubblingEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu']
                },

                /* @section
                 *
                 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
                 */

                initialize: function (latlng, options) {
                    L.setOptions(this, options);
                    this._latlng = L.latLng(latlng);
                },

                onAdd: function (map) {
                    this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

                    if (this._zoomAnimated) {
                        map.on('zoomanim', this._animateZoom, this);
                    }

                    this._initIcon();
                    this.update();
                },

                onRemove: function (map) {
                    if (this.dragging && this.dragging.enabled()) {
                        this.options.draggable = true;
                        this.dragging.removeHooks();
                    }

                    if (this._zoomAnimated) {
                        map.off('zoomanim', this._animateZoom, this);
                    }

                    this._removeIcon();
                    this._removeShadow();
                },

                getEvents: function () {
                    return {
                        zoom: this.update,
                        viewreset: this.update
                    };
                },

                // @method getLatLng: LatLng
                // Returns the current geographical position of the marker.
                getLatLng: function () {
                    return this._latlng;
                },

                // @method setLatLng(latlng: LatLng): this
                // Changes the marker position to the given point.
                setLatLng: function (latlng) {
                    var oldLatLng = this._latlng;
                    this._latlng = L.latLng(latlng);
                    this.update();

                    // @event move: Event
                    // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
                    return this.fire('move', { oldLatLng: oldLatLng, latlng: this._latlng });
                },

                // @method setZIndexOffset(offset: Number): this
                // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
                setZIndexOffset: function (offset) {
                    this.options.zIndexOffset = offset;
                    return this.update();
                },

                // @method setIcon(icon: Icon): this
                // Changes the marker icon.
                setIcon: function (icon) {

                    this.options.icon = icon;

                    if (this._map) {
                        this._initIcon();
                        this.update();
                    }

                    if (this._popup) {
                        this.bindPopup(this._popup, this._popup.options);
                    }

                    return this;
                },

                getElement: function () {
                    return this._icon;
                },

                update: function () {

                    if (this._icon) {
                        var pos = this._map.latLngToLayerPoint(this._latlng).round();
                        this._setPos(pos);
                    }

                    return this;
                },

                _initIcon: function () {
                    var options = this.options,
                        classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

                    var icon = options.icon.createIcon(this._icon),
                        addIcon = false;

                    // if we're not reusing the icon, remove the old one and init new one
                    if (icon !== this._icon) {
                        if (this._icon) {
                            this._removeIcon();
                        }
                        addIcon = true;

                        if (options.title) {
                            icon.title = options.title;
                        }
                        if (options.alt) {
                            icon.alt = options.alt;
                        }
                    }

                    L.DomUtil.addClass(icon, classToAdd);

                    if (options.keyboard) {
                        icon.tabIndex = '0';
                    }

                    this._icon = icon;

                    if (options.riseOnHover) {
                        this.on({
                            mouseover: this._bringToFront,
                            mouseout: this._resetZIndex
                        });
                    }

                    var newShadow = options.icon.createShadow(this._shadow),
                        addShadow = false;

                    if (newShadow !== this._shadow) {
                        this._removeShadow();
                        addShadow = true;
                    }

                    if (newShadow) {
                        L.DomUtil.addClass(newShadow, classToAdd);
                    }
                    this._shadow = newShadow;

                    if (options.opacity < 1) {
                        this._updateOpacity();
                    }

                    if (addIcon) {
                        this.getPane().appendChild(this._icon);
                    }
                    this._initInteraction();
                    if (newShadow && addShadow) {
                        this.getPane('shadowPane').appendChild(this._shadow);
                    }
                },

                _removeIcon: function () {
                    if (this.options.riseOnHover) {
                        this.off({
                            mouseover: this._bringToFront,
                            mouseout: this._resetZIndex
                        });
                    }

                    L.DomUtil.remove(this._icon);
                    this.removeInteractiveTarget(this._icon);

                    this._icon = null;
                },

                _removeShadow: function () {
                    if (this._shadow) {
                        L.DomUtil.remove(this._shadow);
                    }
                    this._shadow = null;
                },

                _setPos: function (pos) {
                    L.DomUtil.setPosition(this._icon, pos);

                    if (this._shadow) {
                        L.DomUtil.setPosition(this._shadow, pos);
                    }

                    this._zIndex = pos.y + this.options.zIndexOffset;

                    this._resetZIndex();
                },

                _updateZIndex: function (offset) {
                    this._icon.style.zIndex = this._zIndex + offset;
                },

                _animateZoom: function (opt) {
                    var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

                    this._setPos(pos);
                },

                _initInteraction: function () {

                    if (!this.options.interactive) {
                        return;
                    }

                    L.DomUtil.addClass(this._icon, 'leaflet-interactive');

                    this.addInteractiveTarget(this._icon);

                    if (L.Handler.MarkerDrag) {
                        var draggable = this.options.draggable;
                        if (this.dragging) {
                            draggable = this.dragging.enabled();
                            this.dragging.disable();
                        }

                        this.dragging = new L.Handler.MarkerDrag(this);

                        if (draggable) {
                            this.dragging.enable();
                        }
                    }
                },

                // @method setOpacity(opacity: Number): this
                // Changes the opacity of the marker.
                setOpacity: function (opacity) {
                    this.options.opacity = opacity;
                    if (this._map) {
                        this._updateOpacity();
                    }

                    return this;
                },

                _updateOpacity: function () {
                    var opacity = this.options.opacity;

                    L.DomUtil.setOpacity(this._icon, opacity);

                    if (this._shadow) {
                        L.DomUtil.setOpacity(this._shadow, opacity);
                    }
                },

                _bringToFront: function () {
                    this._updateZIndex(this.options.riseOffset);
                },

                _resetZIndex: function () {
                    this._updateZIndex(0);
                }
            });

            // factory L.marker(latlng: LatLng, options? : Marker options)

            // @factory L.marker(latlng: LatLng, options? : Marker options)
            // Instantiates a Marker object given a geographical point and optionally an options object.
            L.marker = function (latlng, options) {
                return new L.Marker(latlng, options);
            };

            /*
             * @class DivIcon
             * @aka L.DivIcon
             * @inherits Icon
             *
             * Represents a lightweight icon for markers that uses a simple `<div>`
             * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
             *
             * @example
             * ```js
             * var myIcon = L.divIcon({className: 'my-div-icon'});
             * // you can set .my-div-icon styles in CSS
             *
             * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
             * ```
             *
             * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
             */

            L.DivIcon = L.Icon.extend({
                options: {
                    // @section
                    // @aka DivIcon options
                    iconSize: [12, 12], // also can be set through CSS

                    // iconAnchor: (Point),
                    // popupAnchor: (Point),

                    // @option html: String = ''
                    // Custom HTML code to put inside the div element, empty by default.
                    html: false,

                    // @option bgPos: Point = [0, 0]
                    // Optional relative position of the background, in pixels
                    bgPos: null,

                    className: 'leaflet-div-icon'
                },

                createIcon: function (oldIcon) {
                    var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),
                        options = this.options;

                    div.innerHTML = options.html !== false ? options.html : '';

                    if (options.bgPos) {
                        var bgPos = L.point(options.bgPos);
                        div.style.backgroundPosition = -bgPos.x + 'px ' + -bgPos.y + 'px';
                    }
                    this._setIconStyles(div, 'icon');

                    return div;
                },

                createShadow: function () {
                    return null;
                }
            });

            // @factory L.divIcon(options: DivIcon options)
            // Creates a `DivIcon` instance with the given options.
            L.divIcon = function (options) {
                return new L.DivIcon(options);
            };

            /*
             * @class DivOverlay
             * @inherits Layer
             * @aka L.DivOverlay
             * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
             */

            // @namespace DivOverlay
            L.DivOverlay = L.Layer.extend({

                // @section
                // @aka DivOverlay options
                options: {
                    // @option offset: Point = Point(0, 7)
                    // The offset of the popup position. Useful to control the anchor
                    // of the popup when opening it on some overlays.
                    offset: [0, 7],

                    // @option className: String = ''
                    // A custom CSS class name to assign to the popup.
                    className: '',

                    // @option pane: String = 'popupPane'
                    // `Map pane` where the popup will be added.
                    pane: 'popupPane'
                },

                initialize: function (options, source) {
                    L.setOptions(this, options);

                    this._source = source;
                },

                onAdd: function (map) {
                    this._zoomAnimated = map._zoomAnimated;

                    if (!this._container) {
                        this._initLayout();
                    }

                    if (map._fadeAnimated) {
                        L.DomUtil.setOpacity(this._container, 0);
                    }

                    clearTimeout(this._removeTimeout);
                    this.getPane().appendChild(this._container);
                    this.update();

                    if (map._fadeAnimated) {
                        L.DomUtil.setOpacity(this._container, 1);
                    }

                    this.bringToFront();
                },

                onRemove: function (map) {
                    if (map._fadeAnimated) {
                        L.DomUtil.setOpacity(this._container, 0);
                        this._removeTimeout = setTimeout(L.bind(L.DomUtil.remove, L.DomUtil, this._container), 200);
                    } else {
                        L.DomUtil.remove(this._container);
                    }
                },

                // @namespace Popup
                // @method getLatLng: LatLng
                // Returns the geographical point of popup.
                getLatLng: function () {
                    return this._latlng;
                },

                // @method setLatLng(latlng: LatLng): this
                // Sets the geographical point where the popup will open.
                setLatLng: function (latlng) {
                    this._latlng = L.latLng(latlng);
                    if (this._map) {
                        this._updatePosition();
                        this._adjustPan();
                    }
                    return this;
                },

                // @method getContent: String|HTMLElement
                // Returns the content of the popup.
                getContent: function () {
                    return this._content;
                },

                // @method setContent(htmlContent: String|HTMLElement|Function): this
                // Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
                setContent: function (content) {
                    this._content = content;
                    this.update();
                    return this;
                },

                // @method getElement: String|HTMLElement
                // Alias for [getContent()](#popup-getcontent)
                getElement: function () {
                    return this._container;
                },

                // @method update: null
                // Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
                update: function () {
                    if (!this._map) {
                        return;
                    }

                    this._container.style.visibility = 'hidden';

                    this._updateContent();
                    this._updateLayout();
                    this._updatePosition();

                    this._container.style.visibility = '';

                    this._adjustPan();
                },

                getEvents: function () {
                    var events = {
                        zoom: this._updatePosition,
                        viewreset: this._updatePosition
                    };

                    if (this._zoomAnimated) {
                        events.zoomanim = this._animateZoom;
                    }
                    return events;
                },

                // @method isOpen: Boolean
                // Returns `true` when the popup is visible on the map.
                isOpen: function () {
                    return !!this._map && this._map.hasLayer(this);
                },

                // @method bringToFront: this
                // Brings this popup in front of other popups (in the same map pane).
                bringToFront: function () {
                    if (this._map) {
                        L.DomUtil.toFront(this._container);
                    }
                    return this;
                },

                // @method bringToBack: this
                // Brings this popup to the back of other popups (in the same map pane).
                bringToBack: function () {
                    if (this._map) {
                        L.DomUtil.toBack(this._container);
                    }
                    return this;
                },

                _updateContent: function () {
                    if (!this._content) {
                        return;
                    }

                    var node = this._contentNode;
                    var content = typeof this._content === 'function' ? this._content(this._source || this) : this._content;

                    if (typeof content === 'string') {
                        node.innerHTML = content;
                    } else {
                        while (node.hasChildNodes()) {
                            node.removeChild(node.firstChild);
                        }
                        node.appendChild(content);
                    }
                    this.fire('contentupdate');
                },

                _updatePosition: function () {
                    if (!this._map) {
                        return;
                    }

                    var pos = this._map.latLngToLayerPoint(this._latlng),
                        offset = L.point(this.options.offset),
                        anchor = this._getAnchor();

                    if (this._zoomAnimated) {
                        L.DomUtil.setPosition(this._container, pos.add(anchor));
                    } else {
                        offset = offset.add(pos).add(anchor);
                    }

                    var bottom = this._containerBottom = -offset.y,
                        left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

                    // bottom position the popup in case the height of the popup changes (images loading etc)
                    this._container.style.bottom = bottom + 'px';
                    this._container.style.left = left + 'px';
                },

                _getAnchor: function () {
                    return [0, 0];
                }

            });

            /*
             * @class Popup
             * @inherits DivOverlay
             * @aka L.Popup
             * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
             * open popups while making sure that only one popup is open at one time
             * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
             *
             * @example
             *
             * If you want to just bind a popup to marker click and then open it, it's really easy:
             *
             * ```js
             * marker.bindPopup(popupContent).openPopup();
             * ```
             * Path overlays like polylines also have a `bindPopup` method.
             * Here's a more complicated way to open a popup on a map:
             *
             * ```js
             * var popup = L.popup()
             * 	.setLatLng(latlng)
             * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
             * 	.openOn(map);
             * ```
             */

            // @namespace Popup
            L.Popup = L.DivOverlay.extend({

                // @section
                // @aka Popup options
                options: {
                    // @option maxWidth: Number = 300
                    // Max width of the popup, in pixels.
                    maxWidth: 300,

                    // @option minWidth: Number = 50
                    // Min width of the popup, in pixels.
                    minWidth: 50,

                    // @option maxHeight: Number = null
                    // If set, creates a scrollable container of the given height
                    // inside a popup if its content exceeds it.
                    maxHeight: null,

                    // @option autoPan: Boolean = true
                    // Set it to `false` if you don't want the map to do panning animation
                    // to fit the opened popup.
                    autoPan: true,

                    // @option autoPanPaddingTopLeft: Point = null
                    // The margin between the popup and the top left corner of the map
                    // view after autopanning was performed.
                    autoPanPaddingTopLeft: null,

                    // @option autoPanPaddingBottomRight: Point = null
                    // The margin between the popup and the bottom right corner of the map
                    // view after autopanning was performed.
                    autoPanPaddingBottomRight: null,

                    // @option autoPanPadding: Point = Point(5, 5)
                    // Equivalent of setting both top left and bottom right autopan padding to the same value.
                    autoPanPadding: [5, 5],

                    // @option keepInView: Boolean = false
                    // Set it to `true` if you want to prevent users from panning the popup
                    // off of the screen while it is open.
                    keepInView: false,

                    // @option closeButton: Boolean = true
                    // Controls the presence of a close button in the popup.
                    closeButton: true,

                    // @option autoClose: Boolean = true
                    // Set it to `false` if you want to override the default behavior of
                    // the popup closing when user clicks the map (set globally by
                    // the Map's [closePopupOnClick](#map-closepopuponclick) option).
                    autoClose: true,

                    // @option className: String = ''
                    // A custom CSS class name to assign to the popup.
                    className: ''
                },

                // @namespace Popup
                // @method openOn(map: Map): this
                // Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
                openOn: function (map) {
                    map.openPopup(this);
                    return this;
                },

                onAdd: function (map) {
                    L.DivOverlay.prototype.onAdd.call(this, map);

                    // @namespace Map
                    // @section Popup events
                    // @event popupopen: PopupEvent
                    // Fired when a popup is opened in the map
                    map.fire('popupopen', { popup: this });

                    if (this._source) {
                        // @namespace Layer
                        // @section Popup events
                        // @event popupopen: PopupEvent
                        // Fired when a popup bound to this layer is opened
                        this._source.fire('popupopen', { popup: this }, true);
                        // For non-path layers, we toggle the popup when clicking
                        // again the layer, so prevent the map to reopen it.
                        if (!(this._source instanceof L.Path)) {
                            this._source.on('preclick', L.DomEvent.stopPropagation);
                        }
                    }
                },

                onRemove: function (map) {
                    L.DivOverlay.prototype.onRemove.call(this, map);

                    // @namespace Map
                    // @section Popup events
                    // @event popupclose: PopupEvent
                    // Fired when a popup in the map is closed
                    map.fire('popupclose', { popup: this });

                    if (this._source) {
                        // @namespace Layer
                        // @section Popup events
                        // @event popupclose: PopupEvent
                        // Fired when a popup bound to this layer is closed
                        this._source.fire('popupclose', { popup: this }, true);
                        if (!(this._source instanceof L.Path)) {
                            this._source.off('preclick', L.DomEvent.stopPropagation);
                        }
                    }
                },

                getEvents: function () {
                    var events = L.DivOverlay.prototype.getEvents.call(this);

                    if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
                        events.preclick = this._close;
                    }

                    if (this.options.keepInView) {
                        events.moveend = this._adjustPan;
                    }

                    return events;
                },

                _close: function () {
                    if (this._map) {
                        this._map.closePopup(this);
                    }
                },

                _initLayout: function () {
                    var prefix = 'leaflet-popup',
                        container = this._container = L.DomUtil.create('div', prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-animated');

                    if (this.options.closeButton) {
                        var closeButton = this._closeButton = L.DomUtil.create('a', prefix + '-close-button', container);
                        closeButton.href = '#close';
                        closeButton.innerHTML = '&#215;';

                        L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
                    }

                    var wrapper = this._wrapper = L.DomUtil.create('div', prefix + '-content-wrapper', container);
                    this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);

                    L.DomEvent.disableClickPropagation(wrapper).disableScrollPropagation(this._contentNode).on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

                    this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
                    this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
                },

                _updateLayout: function () {
                    var container = this._contentNode,
                        style = container.style;

                    style.width = '';
                    style.whiteSpace = 'nowrap';

                    var width = container.offsetWidth;
                    width = Math.min(width, this.options.maxWidth);
                    width = Math.max(width, this.options.minWidth);

                    style.width = width + 1 + 'px';
                    style.whiteSpace = '';

                    style.height = '';

                    var height = container.offsetHeight,
                        maxHeight = this.options.maxHeight,
                        scrolledClass = 'leaflet-popup-scrolled';

                    if (maxHeight && height > maxHeight) {
                        style.height = maxHeight + 'px';
                        L.DomUtil.addClass(container, scrolledClass);
                    } else {
                        L.DomUtil.removeClass(container, scrolledClass);
                    }

                    this._containerWidth = this._container.offsetWidth;
                },

                _animateZoom: function (e) {
                    var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
                        anchor = this._getAnchor();
                    L.DomUtil.setPosition(this._container, pos.add(anchor));
                },

                _adjustPan: function () {
                    if (!this.options.autoPan || this._map._panAnim && this._map._panAnim._inProgress) {
                        return;
                    }

                    var map = this._map,
                        marginBottom = parseInt(L.DomUtil.getStyle(this._container, 'marginBottom'), 10) || 0,
                        containerHeight = this._container.offsetHeight + marginBottom,
                        containerWidth = this._containerWidth,
                        layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

                    layerPos._add(L.DomUtil.getPosition(this._container));

                    var containerPos = map.layerPointToContainerPoint(layerPos),
                        padding = L.point(this.options.autoPanPadding),
                        paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
                        paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
                        size = map.getSize(),
                        dx = 0,
                        dy = 0;

                    if (containerPos.x + containerWidth + paddingBR.x > size.x) {
                        // right
                        dx = containerPos.x + containerWidth - size.x + paddingBR.x;
                    }
                    if (containerPos.x - dx - paddingTL.x < 0) {
                        // left
                        dx = containerPos.x - paddingTL.x;
                    }
                    if (containerPos.y + containerHeight + paddingBR.y > size.y) {
                        // bottom
                        dy = containerPos.y + containerHeight - size.y + paddingBR.y;
                    }
                    if (containerPos.y - dy - paddingTL.y < 0) {
                        // top
                        dy = containerPos.y - paddingTL.y;
                    }

                    // @namespace Map
                    // @section Popup events
                    // @event autopanstart: Event
                    // Fired when the map starts autopanning when opening a popup.
                    if (dx || dy) {
                        map.fire('autopanstart').panBy([dx, dy]);
                    }
                },

                _onCloseButtonClick: function (e) {
                    this._close();
                    L.DomEvent.stop(e);
                },

                _getAnchor: function () {
                    // Where should we anchor the popup on the source layer?
                    return L.point(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
                }

            });

            // @namespace Popup
            // @factory L.popup(options?: Popup options, source?: Layer)
            // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
            L.popup = function (options, source) {
                return new L.Popup(options, source);
            };

            /* @namespace Map
             * @section Interaction Options
             * @option closePopupOnClick: Boolean = true
             * Set it to `false` if you don't want popups to close when user clicks the map.
             */
            L.Map.mergeOptions({
                closePopupOnClick: true
            });

            // @namespace Map
            // @section Methods for Layers and Controls
            L.Map.include({
                // @method openPopup(popup: Popup): this
                // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
                // @alternative
                // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
                // Creates a popup with the specified content and options and opens it in the given point on a map.
                openPopup: function (popup, latlng, options) {
                    if (!(popup instanceof L.Popup)) {
                        popup = new L.Popup(options).setContent(popup);
                    }

                    if (latlng) {
                        popup.setLatLng(latlng);
                    }

                    if (this.hasLayer(popup)) {
                        return this;
                    }

                    if (this._popup && this._popup.options.autoClose) {
                        this.closePopup();
                    }

                    this._popup = popup;
                    return this.addLayer(popup);
                },

                // @method closePopup(popup?: Popup): this
                // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
                closePopup: function (popup) {
                    if (!popup || popup === this._popup) {
                        popup = this._popup;
                        this._popup = null;
                    }
                    if (popup) {
                        this.removeLayer(popup);
                    }
                    return this;
                }
            });

            /*
             * @namespace Layer
             * @section Popup methods example
             *
             * All layers share a set of methods convenient for binding popups to it.
             *
             * ```js
             * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
             * layer.openPopup();
             * layer.closePopup();
             * ```
             *
             * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
             */

            // @section Popup methods
            L.Layer.include({

                // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
                // Binds a popup to the layer with the passed `content` and sets up the
                // neccessary event listeners. If a `Function` is passed it will receive
                // the layer as the first argument and should return a `String` or `HTMLElement`.
                bindPopup: function (content, options) {

                    if (content instanceof L.Popup) {
                        L.setOptions(content, options);
                        this._popup = content;
                        content._source = this;
                    } else {
                        if (!this._popup || options) {
                            this._popup = new L.Popup(options, this);
                        }
                        this._popup.setContent(content);
                    }

                    if (!this._popupHandlersAdded) {
                        this.on({
                            click: this._openPopup,
                            remove: this.closePopup,
                            move: this._movePopup
                        });
                        this._popupHandlersAdded = true;
                    }

                    return this;
                },

                // @method unbindPopup(): this
                // Removes the popup previously bound with `bindPopup`.
                unbindPopup: function () {
                    if (this._popup) {
                        this.off({
                            click: this._openPopup,
                            remove: this.closePopup,
                            move: this._movePopup
                        });
                        this._popupHandlersAdded = false;
                        this._popup = null;
                    }
                    return this;
                },

                // @method openPopup(latlng?: LatLng): this
                // Opens the bound popup at the specificed `latlng` or at the default popup anchor if no `latlng` is passed.
                openPopup: function (layer, latlng) {
                    if (!(layer instanceof L.Layer)) {
                        latlng = layer;
                        layer = this;
                    }

                    if (layer instanceof L.FeatureGroup) {
                        for (var id in this._layers) {
                            layer = this._layers[id];
                            break;
                        }
                    }

                    if (!latlng) {
                        latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
                    }

                    if (this._popup && this._map) {
                        // set popup source to this layer
                        this._popup._source = layer;

                        // update the popup (content, layout, ect...)
                        this._popup.update();

                        // open the popup on the map
                        this._map.openPopup(this._popup, latlng);
                    }

                    return this;
                },

                // @method closePopup(): this
                // Closes the popup bound to this layer if it is open.
                closePopup: function () {
                    if (this._popup) {
                        this._popup._close();
                    }
                    return this;
                },

                // @method togglePopup(): this
                // Opens or closes the popup bound to this layer depending on its current state.
                togglePopup: function (target) {
                    if (this._popup) {
                        if (this._popup._map) {
                            this.closePopup();
                        } else {
                            this.openPopup(target);
                        }
                    }
                    return this;
                },

                // @method isPopupOpen(): boolean
                // Returns `true` if the popup bound to this layer is currently open.
                isPopupOpen: function () {
                    return this._popup.isOpen();
                },

                // @method setPopupContent(content: String|HTMLElement|Popup): this
                // Sets the content of the popup bound to this layer.
                setPopupContent: function (content) {
                    if (this._popup) {
                        this._popup.setContent(content);
                    }
                    return this;
                },

                // @method getPopup(): Popup
                // Returns the popup bound to this layer.
                getPopup: function () {
                    return this._popup;
                },

                _openPopup: function (e) {
                    var layer = e.layer || e.target;

                    if (!this._popup) {
                        return;
                    }

                    if (!this._map) {
                        return;
                    }

                    // prevent map click
                    L.DomEvent.stop(e);

                    // if this inherits from Path its a vector and we can just
                    // open the popup at the new location
                    if (layer instanceof L.Path) {
                        this.openPopup(e.layer || e.target, e.latlng);
                        return;
                    }

                    // otherwise treat it like a marker and figure out
                    // if we should toggle it open/closed
                    if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
                        this.closePopup();
                    } else {
                        this.openPopup(layer, e.latlng);
                    }
                },

                _movePopup: function (e) {
                    this._popup.setLatLng(e.latlng);
                }
            });

            /*
             * Popup extension to L.Marker, adding popup-related methods.
             */

            L.Marker.include({
                _getPopupAnchor: function () {
                    return this.options.icon.options.popupAnchor || [0, 0];
                }
            });

            /*
             * @class Tooltip
             * @inherits DivOverlay
             * @aka L.Tooltip
             * Used to display small texts on top of map layers.
             *
             * @example
             *
             * ```js
             * marker.bindTooltip("my tooltip text").openTooltip();
             * ```
             * Note about tooltip offset. Leaflet takes two options in consideration
             * for computing tooltip offseting:
             * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
             *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
             *   move it to the bottom. Negatives will move to the left and top.
             * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
             *   should adapt this value if you use a custom icon.
             */

            // @namespace Tooltip
            L.Tooltip = L.DivOverlay.extend({

                // @section
                // @aka Tooltip options
                options: {
                    // @option pane: String = 'tooltipPane'
                    // `Map pane` where the tooltip will be added.
                    pane: 'tooltipPane',

                    // @option offset: Point = Point(0, 0)
                    // Optional offset of the tooltip position.
                    offset: [0, 0],

                    // @option direction: String = 'auto'
                    // Direction where to open the tooltip. Possible values are: `right`, `left`,
                    // `top`, `bottom`, `center`, `auto`.
                    // `auto` will dynamicaly switch between `right` and `left` according to the tooltip
                    // position on the map.
                    direction: 'auto',

                    // @option permanent: Boolean = false
                    // Whether to open the tooltip permanently or only on mouseover.
                    permanent: false,

                    // @option sticky: Boolean = false
                    // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
                    sticky: false,

                    // @option interactive: Boolean = false
                    // If true, the tooltip will listen to the feature events.
                    interactive: false,

                    // @option opacity: Number = 0.9
                    // Tooltip container opacity.
                    opacity: 0.9
                },

                onAdd: function (map) {
                    L.DivOverlay.prototype.onAdd.call(this, map);
                    this.setOpacity(this.options.opacity);

                    // @namespace Map
                    // @section Tooltip events
                    // @event tooltipopen: TooltipEvent
                    // Fired when a tooltip is opened in the map.
                    map.fire('tooltipopen', { tooltip: this });

                    if (this._source) {
                        // @namespace Layer
                        // @section Tooltip events
                        // @event tooltipopen: TooltipEvent
                        // Fired when a tooltip bound to this layer is opened.
                        this._source.fire('tooltipopen', { tooltip: this }, true);
                    }
                },

                onRemove: function (map) {
                    L.DivOverlay.prototype.onRemove.call(this, map);

                    // @namespace Map
                    // @section Tooltip events
                    // @event tooltipclose: TooltipEvent
                    // Fired when a tooltip in the map is closed.
                    map.fire('tooltipclose', { tooltip: this });

                    if (this._source) {
                        // @namespace Layer
                        // @section Tooltip events
                        // @event tooltipclose: TooltipEvent
                        // Fired when a tooltip bound to this layer is closed.
                        this._source.fire('tooltipclose', { tooltip: this }, true);
                    }
                },

                getEvents: function () {
                    var events = L.DivOverlay.prototype.getEvents.call(this);

                    if (L.Browser.touch && !this.options.permanent) {
                        events.preclick = this._close;
                    }

                    return events;
                },

                _close: function () {
                    if (this._map) {
                        this._map.closeTooltip(this);
                    }
                },

                _initLayout: function () {
                    var prefix = 'leaflet-tooltip',
                        className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

                    this._contentNode = this._container = L.DomUtil.create('div', className);
                },

                _updateLayout: function () {},

                _adjustPan: function () {},

                _setPosition: function (pos) {
                    var map = this._map,
                        container = this._container,
                        centerPoint = map.latLngToContainerPoint(map.getCenter()),
                        tooltipPoint = map.layerPointToContainerPoint(pos),
                        direction = this.options.direction,
                        tooltipWidth = container.offsetWidth,
                        tooltipHeight = container.offsetHeight,
                        offset = L.point(this.options.offset),
                        anchor = this._getAnchor();

                    if (direction === 'top') {
                        pos = pos.add(L.point(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y));
                    } else if (direction === 'bottom') {
                        pos = pos.subtract(L.point(tooltipWidth / 2 - offset.x, -offset.y));
                    } else if (direction === 'center') {
                        pos = pos.subtract(L.point(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y));
                    } else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
                        direction = 'right';
                        pos = pos.add([offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y]);
                    } else {
                        direction = 'left';
                        pos = pos.subtract(L.point(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y));
                    }

                    L.DomUtil.removeClass(container, 'leaflet-tooltip-right');
                    L.DomUtil.removeClass(container, 'leaflet-tooltip-left');
                    L.DomUtil.removeClass(container, 'leaflet-tooltip-top');
                    L.DomUtil.removeClass(container, 'leaflet-tooltip-bottom');
                    L.DomUtil.addClass(container, 'leaflet-tooltip-' + direction);
                    L.DomUtil.setPosition(container, pos);
                },

                _updatePosition: function () {
                    var pos = this._map.latLngToLayerPoint(this._latlng);
                    this._setPosition(pos);
                },

                setOpacity: function (opacity) {
                    this.options.opacity = opacity;

                    if (this._container) {
                        L.DomUtil.setOpacity(this._container, opacity);
                    }
                },

                _animateZoom: function (e) {
                    var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
                    this._setPosition(pos);
                },

                _getAnchor: function () {
                    // Where should we anchor the tooltip on the source layer?
                    return L.point(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
                }

            });

            // @namespace Tooltip
            // @factory L.tooltip(options?: Tooltip options, source?: Layer)
            // Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
            L.tooltip = function (options, source) {
                return new L.Tooltip(options, source);
            };

            // @namespace Map
            // @section Methods for Layers and Controls
            L.Map.include({

                // @method openTooltip(tooltip: Tooltip): this
                // Opens the specified tooltip.
                // @alternative
                // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
                // Creates a tooltip with the specified content and options and open it.
                openTooltip: function (tooltip, latlng, options) {
                    if (!(tooltip instanceof L.Tooltip)) {
                        tooltip = new L.Tooltip(options).setContent(tooltip);
                    }

                    if (latlng) {
                        tooltip.setLatLng(latlng);
                    }

                    if (this.hasLayer(tooltip)) {
                        return this;
                    }

                    return this.addLayer(tooltip);
                },

                // @method closeTooltip(tooltip?: Tooltip): this
                // Closes the tooltip given as parameter.
                closeTooltip: function (tooltip) {
                    if (tooltip) {
                        this.removeLayer(tooltip);
                    }
                    return this;
                }

            });

            /*
             * @namespace Layer
             * @section Tooltip methods example
             *
             * All layers share a set of methods convenient for binding tooltips to it.
             *
             * ```js
             * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
             * layer.openTooltip();
             * layer.closeTooltip();
             * ```
             */

            // @section Tooltip methods
            L.Layer.include({

                // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
                // Binds a tooltip to the layer with the passed `content` and sets up the
                // neccessary event listeners. If a `Function` is passed it will receive
                // the layer as the first argument and should return a `String` or `HTMLElement`.
                bindTooltip: function (content, options) {

                    if (content instanceof L.Tooltip) {
                        L.setOptions(content, options);
                        this._tooltip = content;
                        content._source = this;
                    } else {
                        if (!this._tooltip || options) {
                            this._tooltip = L.tooltip(options, this);
                        }
                        this._tooltip.setContent(content);
                    }

                    this._initTooltipInteractions();

                    if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
                        this.openTooltip();
                    }

                    return this;
                },

                // @method unbindTooltip(): this
                // Removes the tooltip previously bound with `bindTooltip`.
                unbindTooltip: function () {
                    if (this._tooltip) {
                        this._initTooltipInteractions(true);
                        this.closeTooltip();
                        this._tooltip = null;
                    }
                    return this;
                },

                _initTooltipInteractions: function (remove) {
                    if (!remove && this._tooltipHandlersAdded) {
                        return;
                    }
                    var onOff = remove ? 'off' : 'on',
                        events = {
                        remove: this.closeTooltip,
                        move: this._moveTooltip
                    };
                    if (!this._tooltip.options.permanent) {
                        events.mouseover = this._openTooltip;
                        events.mouseout = this.closeTooltip;
                        if (this._tooltip.options.sticky) {
                            events.mousemove = this._moveTooltip;
                        }
                        if (L.Browser.touch) {
                            events.click = this._openTooltip;
                        }
                    } else {
                        events.add = this._openTooltip;
                    }
                    this[onOff](events);
                    this._tooltipHandlersAdded = !remove;
                },

                // @method openTooltip(latlng?: LatLng): this
                // Opens the bound tooltip at the specificed `latlng` or at the default tooltip anchor if no `latlng` is passed.
                openTooltip: function (layer, latlng) {
                    if (!(layer instanceof L.Layer)) {
                        latlng = layer;
                        layer = this;
                    }

                    if (layer instanceof L.FeatureGroup) {
                        for (var id in this._layers) {
                            layer = this._layers[id];
                            break;
                        }
                    }

                    if (!latlng) {
                        latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
                    }

                    if (this._tooltip && this._map) {

                        // set tooltip source to this layer
                        this._tooltip._source = layer;

                        // update the tooltip (content, layout, ect...)
                        this._tooltip.update();

                        // open the tooltip on the map
                        this._map.openTooltip(this._tooltip, latlng);

                        // Tooltip container may not be defined if not permanent and never
                        // opened.
                        if (this._tooltip.options.interactive && this._tooltip._container) {
                            L.DomUtil.addClass(this._tooltip._container, 'leaflet-clickable');
                            this.addInteractiveTarget(this._tooltip._container);
                        }
                    }

                    return this;
                },

                // @method closeTooltip(): this
                // Closes the tooltip bound to this layer if it is open.
                closeTooltip: function () {
                    if (this._tooltip) {
                        this._tooltip._close();
                        if (this._tooltip.options.interactive && this._tooltip._container) {
                            L.DomUtil.removeClass(this._tooltip._container, 'leaflet-clickable');
                            this.removeInteractiveTarget(this._tooltip._container);
                        }
                    }
                    return this;
                },

                // @method toggleTooltip(): this
                // Opens or closes the tooltip bound to this layer depending on its current state.
                toggleTooltip: function (target) {
                    if (this._tooltip) {
                        if (this._tooltip._map) {
                            this.closeTooltip();
                        } else {
                            this.openTooltip(target);
                        }
                    }
                    return this;
                },

                // @method isTooltipOpen(): boolean
                // Returns `true` if the tooltip bound to this layer is currently open.
                isTooltipOpen: function () {
                    return this._tooltip.isOpen();
                },

                // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
                // Sets the content of the tooltip bound to this layer.
                setTooltipContent: function (content) {
                    if (this._tooltip) {
                        this._tooltip.setContent(content);
                    }
                    return this;
                },

                // @method getTooltip(): Tooltip
                // Returns the tooltip bound to this layer.
                getTooltip: function () {
                    return this._tooltip;
                },

                _openTooltip: function (e) {
                    var layer = e.layer || e.target;

                    if (!this._tooltip || !this._map) {
                        return;
                    }
                    this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
                },

                _moveTooltip: function (e) {
                    var latlng = e.latlng,
                        containerPoint,
                        layerPoint;
                    if (this._tooltip.options.sticky && e.originalEvent) {
                        containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
                        layerPoint = this._map.containerPointToLayerPoint(containerPoint);
                        latlng = this._map.layerPointToLatLng(layerPoint);
                    }
                    this._tooltip.setLatLng(latlng);
                }
            });

            /*
             * Tooltip extension to L.Marker, adding tooltip-related methods.
             */

            L.Marker.include({
                _getTooltipAnchor: function () {
                    return this.options.icon.options.tooltipAnchor || [0, 0];
                }
            });

            /*
             * @class LayerGroup
             * @aka L.LayerGroup
             * @inherits Layer
             *
             * Used to group several layers and handle them as one. If you add it to the map,
             * any layers added or removed from the group will be added/removed on the map as
             * well. Extends `Layer`.
             *
             * @example
             *
             * ```js
             * L.layerGroup([marker1, marker2])
             * 	.addLayer(polyline)
             * 	.addTo(map);
             * ```
             */

            L.LayerGroup = L.Layer.extend({

                initialize: function (layers) {
                    this._layers = {};

                    var i, len;

                    if (layers) {
                        for (i = 0, len = layers.length; i < len; i++) {
                            this.addLayer(layers[i]);
                        }
                    }
                },

                // @method addLayer(layer: Layer): this
                // Adds the given layer to the group.
                addLayer: function (layer) {
                    var id = this.getLayerId(layer);

                    this._layers[id] = layer;

                    if (this._map) {
                        this._map.addLayer(layer);
                    }

                    return this;
                },

                // @method removeLayer(layer: Layer): this
                // Removes the given layer from the group.
                // @alternative
                // @method removeLayer(id: Number): this
                // Removes the layer with the given internal ID from the group.
                removeLayer: function (layer) {
                    var id = layer in this._layers ? layer : this.getLayerId(layer);

                    if (this._map && this._layers[id]) {
                        this._map.removeLayer(this._layers[id]);
                    }

                    delete this._layers[id];

                    return this;
                },

                // @method hasLayer(layer: Layer): Boolean
                // Returns `true` if the given layer is currently added to the group.
                hasLayer: function (layer) {
                    return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
                },

                // @method clearLayers(): this
                // Removes all the layers from the group.
                clearLayers: function () {
                    for (var i in this._layers) {
                        this.removeLayer(this._layers[i]);
                    }
                    return this;
                },

                // @method invoke(methodName: String, …): this
                // Calls `methodName` on every layer contained in this group, passing any
                // additional parameters. Has no effect if the layers contained do not
                // implement `methodName`.
                invoke: function (methodName) {
                    var args = Array.prototype.slice.call(arguments, 1),
                        i,
                        layer;

                    for (i in this._layers) {
                        layer = this._layers[i];

                        if (layer[methodName]) {
                            layer[methodName].apply(layer, args);
                        }
                    }

                    return this;
                },

                onAdd: function (map) {
                    for (var i in this._layers) {
                        map.addLayer(this._layers[i]);
                    }
                },

                onRemove: function (map) {
                    for (var i in this._layers) {
                        map.removeLayer(this._layers[i]);
                    }
                },

                // @method eachLayer(fn: Function, context?: Object): this
                // Iterates over the layers of the group, optionally specifying context of the iterator function.
                // ```js
                // group.eachLayer(function (layer) {
                // 	layer.bindPopup('Hello');
                // });
                // ```
                eachLayer: function (method, context) {
                    for (var i in this._layers) {
                        method.call(context, this._layers[i]);
                    }
                    return this;
                },

                // @method getLayer(id: Number): Layer
                // Returns the layer with the given internal ID.
                getLayer: function (id) {
                    return this._layers[id];
                },

                // @method getLayers(): Layer[]
                // Returns an array of all the layers added to the group.
                getLayers: function () {
                    var layers = [];

                    for (var i in this._layers) {
                        layers.push(this._layers[i]);
                    }
                    return layers;
                },

                // @method setZIndex(zIndex: Number): this
                // Calls `setZIndex` on every layer contained in this group, passing the z-index.
                setZIndex: function (zIndex) {
                    return this.invoke('setZIndex', zIndex);
                },

                // @method getLayerId(layer: Layer): Number
                // Returns the internal ID for a layer
                getLayerId: function (layer) {
                    return L.stamp(layer);
                }
            });

            // @factory L.layerGroup(layers: Layer[])
            // Create a layer group, optionally given an initial set of layers.
            L.layerGroup = function (layers) {
                return new L.LayerGroup(layers);
            };

            /*
             * @class FeatureGroup
             * @aka L.FeatureGroup
             * @inherits LayerGroup
             *
             * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
             *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
             *  * Events are propagated to the `FeatureGroup`, so if the group has an event
             * handler, it will handle events from any of the layers. This includes mouse events
             * and custom events.
             *  * Has `layeradd` and `layerremove` events
             *
             * @example
             *
             * ```js
             * L.featureGroup([marker1, marker2, polyline])
             * 	.bindPopup('Hello world!')
             * 	.on('click', function() { alert('Clicked on a member of the group!'); })
             * 	.addTo(map);
             * ```
             */

            L.FeatureGroup = L.LayerGroup.extend({

                addLayer: function (layer) {
                    if (this.hasLayer(layer)) {
                        return this;
                    }

                    layer.addEventParent(this);

                    L.LayerGroup.prototype.addLayer.call(this, layer);

                    // @event layeradd: LayerEvent
                    // Fired when a layer is added to this `FeatureGroup`
                    return this.fire('layeradd', { layer: layer });
                },

                removeLayer: function (layer) {
                    if (!this.hasLayer(layer)) {
                        return this;
                    }
                    if (layer in this._layers) {
                        layer = this._layers[layer];
                    }

                    layer.removeEventParent(this);

                    L.LayerGroup.prototype.removeLayer.call(this, layer);

                    // @event layerremove: LayerEvent
                    // Fired when a layer is removed from this `FeatureGroup`
                    return this.fire('layerremove', { layer: layer });
                },

                // @method setStyle(style: Path options): this
                // Sets the given path options to each layer of the group that has a `setStyle` method.
                setStyle: function (style) {
                    return this.invoke('setStyle', style);
                },

                // @method bringToFront(): this
                // Brings the layer group to the top of all other layers
                bringToFront: function () {
                    return this.invoke('bringToFront');
                },

                // @method bringToBack(): this
                // Brings the layer group to the top of all other layers
                bringToBack: function () {
                    return this.invoke('bringToBack');
                },

                // @method getBounds(): LatLngBounds
                // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
                getBounds: function () {
                    var bounds = new L.LatLngBounds();

                    for (var id in this._layers) {
                        var layer = this._layers[id];
                        bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
                    }
                    return bounds;
                }
            });

            // @factory L.featureGroup(layers: Layer[])
            // Create a feature group, optionally given an initial set of layers.
            L.featureGroup = function (layers) {
                return new L.FeatureGroup(layers);
            };

            /*
             * @class Renderer
             * @inherits Layer
             * @aka L.Renderer
             *
             * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
             * DOM container of the renderer, its bounds, and its zoom animation.
             *
             * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
             * itself can be added or removed to the map. All paths use a renderer, which can
             * be implicit (the map will decide the type of renderer and use it automatically)
             * or explicit (using the [`renderer`](#path-renderer) option of the path).
             *
             * Do not use this class directly, use `SVG` and `Canvas` instead.
             *
             * @event update: Event
             * Fired when the renderer updates its bounds, center and zoom, for example when
             * its map has moved
             */

            L.Renderer = L.Layer.extend({

                // @section
                // @aka Renderer options
                options: {
                    // @option padding: Number = 0.1
                    // How much to extend the clip area around the map view (relative to its size)
                    // e.g. 0.1 would be 10% of map view in each direction
                    padding: 0.1
                },

                initialize: function (options) {
                    L.setOptions(this, options);
                    L.stamp(this);
                },

                onAdd: function () {
                    if (!this._container) {
                        this._initContainer(); // defined by renderer implementations

                        if (this._zoomAnimated) {
                            L.DomUtil.addClass(this._container, 'leaflet-zoom-animated');
                        }
                    }

                    this.getPane().appendChild(this._container);
                    this._update();
                },

                onRemove: function () {
                    L.DomUtil.remove(this._container);
                },

                getEvents: function () {
                    var events = {
                        viewreset: this._reset,
                        zoom: this._onZoom,
                        moveend: this._update
                    };
                    if (this._zoomAnimated) {
                        events.zoomanim = this._onAnimZoom;
                    }
                    return events;
                },

                _onAnimZoom: function (ev) {
                    this._updateTransform(ev.center, ev.zoom);
                },

                _onZoom: function () {
                    this._updateTransform(this._map.getCenter(), this._map.getZoom());
                },

                _updateTransform: function (center, zoom) {
                    var scale = this._map.getZoomScale(zoom, this._zoom),
                        position = L.DomUtil.getPosition(this._container),
                        viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
                        currentCenterPoint = this._map.project(this._center, zoom),
                        destCenterPoint = this._map.project(center, zoom),
                        centerOffset = destCenterPoint.subtract(currentCenterPoint),
                        topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

                    if (L.Browser.any3d) {
                        L.DomUtil.setTransform(this._container, topLeftOffset, scale);
                    } else {
                        L.DomUtil.setPosition(this._container, topLeftOffset);
                    }
                },

                _reset: function () {
                    this._update();
                    this._updateTransform(this._center, this._zoom);
                },

                _update: function () {
                    // Update pixel bounds of renderer container (for positioning/sizing/clipping later)
                    // Subclasses are responsible of firing the 'update' event.
                    var p = this.options.padding,
                        size = this._map.getSize(),
                        min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

                    this._bounds = new L.Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

                    this._center = this._map.getCenter();
                    this._zoom = this._map.getZoom();
                }
            });

            L.Map.include({
                // @namespace Map; @method getRenderer(layer: Path): Renderer
                // Returns the instance of `Renderer` that should be used to render the given
                // `Path`. It will ensure that the `renderer` options of the map and paths
                // are respected, and that the renderers do exist on the map.
                getRenderer: function (layer) {
                    // @namespace Path; @option renderer: Renderer
                    // Use this specific instance of `Renderer` for this path. Takes
                    // precedence over the map's [default renderer](#map-renderer).
                    var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

                    if (!renderer) {
                        // @namespace Map; @option preferCanvas: Boolean = false
                        // Whether `Path`s should be rendered on a `Canvas` renderer.
                        // By default, all `Path`s are rendered in a `SVG` renderer.
                        renderer = this._renderer = this.options.preferCanvas && L.canvas() || L.svg();
                    }

                    if (!this.hasLayer(renderer)) {
                        this.addLayer(renderer);
                    }
                    return renderer;
                },

                _getPaneRenderer: function (name) {
                    if (name === 'overlayPane' || name === undefined) {
                        return false;
                    }

                    var renderer = this._paneRenderers[name];
                    if (renderer === undefined) {
                        renderer = L.SVG && L.svg({ pane: name }) || L.Canvas && L.canvas({ pane: name });
                        this._paneRenderers[name] = renderer;
                    }
                    return renderer;
                }
            });

            /*
             * @class Path
             * @aka L.Path
             * @inherits Interactive layer
             *
             * An abstract class that contains options and constants shared between vector
             * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
             */

            L.Path = L.Layer.extend({

                // @section
                // @aka Path options
                options: {
                    // @option stroke: Boolean = true
                    // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
                    stroke: true,

                    // @option color: String = '#3388ff'
                    // Stroke color
                    color: '#3388ff',

                    // @option weight: Number = 3
                    // Stroke width in pixels
                    weight: 3,

                    // @option opacity: Number = 1.0
                    // Stroke opacity
                    opacity: 1,

                    // @option lineCap: String= 'round'
                    // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
                    lineCap: 'round',

                    // @option lineJoin: String = 'round'
                    // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
                    lineJoin: 'round',

                    // @option dashArray: String = null
                    // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
                    dashArray: null,

                    // @option dashOffset: String = null
                    // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
                    dashOffset: null,

                    // @option fill: Boolean = depends
                    // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
                    fill: false,

                    // @option fillColor: String = *
                    // Fill color. Defaults to the value of the [`color`](#path-color) option
                    fillColor: null,

                    // @option fillOpacity: Number = 0.2
                    // Fill opacity.
                    fillOpacity: 0.2,

                    // @option fillRule: String = 'evenodd'
                    // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
                    fillRule: 'evenodd',

                    // className: '',

                    // Option inherited from "Interactive layer" abstract class
                    interactive: true
                },

                beforeAdd: function (map) {
                    // Renderer is set here because we need to call renderer.getEvents
                    // before this.getEvents.
                    this._renderer = map.getRenderer(this);
                },

                onAdd: function () {
                    this._renderer._initPath(this);
                    this._reset();
                    this._renderer._addPath(this);
                    this._renderer.on('update', this._update, this);
                },

                onRemove: function () {
                    this._renderer._removePath(this);
                    this._renderer.off('update', this._update, this);
                },

                getEvents: function () {
                    return {
                        zoomend: this._project,
                        viewreset: this._reset
                    };
                },

                // @method redraw(): this
                // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
                redraw: function () {
                    if (this._map) {
                        this._renderer._updatePath(this);
                    }
                    return this;
                },

                // @method setStyle(style: Path options): this
                // Changes the appearance of a Path based on the options in the `Path options` object.
                setStyle: function (style) {
                    L.setOptions(this, style);
                    if (this._renderer) {
                        this._renderer._updateStyle(this);
                    }
                    return this;
                },

                // @method bringToFront(): this
                // Brings the layer to the top of all path layers.
                bringToFront: function () {
                    if (this._renderer) {
                        this._renderer._bringToFront(this);
                    }
                    return this;
                },

                // @method bringToBack(): this
                // Brings the layer to the bottom of all path layers.
                bringToBack: function () {
                    if (this._renderer) {
                        this._renderer._bringToBack(this);
                    }
                    return this;
                },

                getElement: function () {
                    return this._path;
                },

                _reset: function () {
                    // defined in children classes
                    this._project();
                    this._update();
                },

                _clickTolerance: function () {
                    // used when doing hit detection for Canvas layers
                    return (this.options.stroke ? this.options.weight / 2 : 0) + (L.Browser.touch ? 10 : 0);
                }
            });

            /*
             * @namespace LineUtil
             *
             * Various utility functions for polyine points processing, used by Leaflet internally to make polylines lightning-fast.
             */

            L.LineUtil = {

                // Simplify polyline with vertex reduction and Douglas-Peucker simplification.
                // Improves rendering performance dramatically by lessening the number of points to draw.

                // @function simplify(points: Point[], tolerance: Number): Point[]
                // Dramatically reduces the number of points in a polyline while retaining
                // its shape and returns a new array of simplified points, using the
                // [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
                // Used for a huge performance boost when processing/displaying Leaflet polylines for
                // each zoom level and also reducing visual noise. tolerance affects the amount of
                // simplification (lesser value means higher quality but slower and with more points).
                // Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
                simplify: function (points, tolerance) {
                    if (!tolerance || !points.length) {
                        return points.slice();
                    }

                    var sqTolerance = tolerance * tolerance;

                    // stage 1: vertex reduction
                    points = this._reducePoints(points, sqTolerance);

                    // stage 2: Douglas-Peucker simplification
                    points = this._simplifyDP(points, sqTolerance);

                    return points;
                },

                // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
                // Returns the distance between point `p` and segment `p1` to `p2`.
                pointToSegmentDistance: function (p, p1, p2) {
                    return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
                },

                // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
                // Returns the closest point from a point `p` on a segment `p1` to `p2`.
                closestPointOnSegment: function (p, p1, p2) {
                    return this._sqClosestPointOnSegment(p, p1, p2);
                },

                // Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
                _simplifyDP: function (points, sqTolerance) {

                    var len = points.length,
                        ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
                        markers = new ArrayConstructor(len);

                    markers[0] = markers[len - 1] = 1;

                    this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

                    var i,
                        newPoints = [];

                    for (i = 0; i < len; i++) {
                        if (markers[i]) {
                            newPoints.push(points[i]);
                        }
                    }

                    return newPoints;
                },

                _simplifyDPStep: function (points, markers, sqTolerance, first, last) {

                    var maxSqDist = 0,
                        index,
                        i,
                        sqDist;

                    for (i = first + 1; i <= last - 1; i++) {
                        sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

                        if (sqDist > maxSqDist) {
                            index = i;
                            maxSqDist = sqDist;
                        }
                    }

                    if (maxSqDist > sqTolerance) {
                        markers[index] = 1;

                        this._simplifyDPStep(points, markers, sqTolerance, first, index);
                        this._simplifyDPStep(points, markers, sqTolerance, index, last);
                    }
                },

                // reduce points that are too close to each other to a single point
                _reducePoints: function (points, sqTolerance) {
                    var reducedPoints = [points[0]];

                    for (var i = 1, prev = 0, len = points.length; i < len; i++) {
                        if (this._sqDist(points[i], points[prev]) > sqTolerance) {
                            reducedPoints.push(points[i]);
                            prev = i;
                        }
                    }
                    if (prev < len - 1) {
                        reducedPoints.push(points[len - 1]);
                    }
                    return reducedPoints;
                },

                // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
                // Clips the segment a to b by rectangular bounds with the
                // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
                // (modifying the segment points directly!). Used by Leaflet to only show polyline
                // points that are on the screen or near, increasing performance.
                clipSegment: function (a, b, bounds, useLastCode, round) {
                    var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
                        codeB = this._getBitCode(b, bounds),
                        codeOut,
                        p,
                        newCode;

                    // save 2nd code to avoid calculating it on the next segment
                    this._lastCode = codeB;

                    while (true) {
                        // if a,b is inside the clip window (trivial accept)
                        if (!(codeA | codeB)) {
                            return [a, b];
                        }

                        // if a,b is outside the clip window (trivial reject)
                        if (codeA & codeB) {
                            return false;
                        }

                        // other cases
                        codeOut = codeA || codeB;
                        p = this._getEdgeIntersection(a, b, codeOut, bounds, round);
                        newCode = this._getBitCode(p, bounds);

                        if (codeOut === codeA) {
                            a = p;
                            codeA = newCode;
                        } else {
                            b = p;
                            codeB = newCode;
                        }
                    }
                },

                _getEdgeIntersection: function (a, b, code, bounds, round) {
                    var dx = b.x - a.x,
                        dy = b.y - a.y,
                        min = bounds.min,
                        max = bounds.max,
                        x,
                        y;

                    if (code & 8) {
                        // top
                        x = a.x + dx * (max.y - a.y) / dy;
                        y = max.y;
                    } else if (code & 4) {
                        // bottom
                        x = a.x + dx * (min.y - a.y) / dy;
                        y = min.y;
                    } else if (code & 2) {
                        // right
                        x = max.x;
                        y = a.y + dy * (max.x - a.x) / dx;
                    } else if (code & 1) {
                        // left
                        x = min.x;
                        y = a.y + dy * (min.x - a.x) / dx;
                    }

                    return new L.Point(x, y, round);
                },

                _getBitCode: function (p, bounds) {
                    var code = 0;

                    if (p.x < bounds.min.x) {
                        // left
                        code |= 1;
                    } else if (p.x > bounds.max.x) {
                        // right
                        code |= 2;
                    }

                    if (p.y < bounds.min.y) {
                        // bottom
                        code |= 4;
                    } else if (p.y > bounds.max.y) {
                        // top
                        code |= 8;
                    }

                    return code;
                },

                // square distance (to avoid unnecessary Math.sqrt calls)
                _sqDist: function (p1, p2) {
                    var dx = p2.x - p1.x,
                        dy = p2.y - p1.y;
                    return dx * dx + dy * dy;
                },

                // return closest point on segment or distance to that point
                _sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
                    var x = p1.x,
                        y = p1.y,
                        dx = p2.x - x,
                        dy = p2.y - y,
                        dot = dx * dx + dy * dy,
                        t;

                    if (dot > 0) {
                        t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

                        if (t > 1) {
                            x = p2.x;
                            y = p2.y;
                        } else if (t > 0) {
                            x += dx * t;
                            y += dy * t;
                        }
                    }

                    dx = p.x - x;
                    dy = p.y - y;

                    return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
                }
            };

            /*
             * @class Polyline
             * @aka L.Polyline
             * @inherits Path
             *
             * A class for drawing polyline overlays on a map. Extends `Path`.
             *
             * @example
             *
             * ```js
             * // create a red polyline from an array of LatLng points
             * var latlngs = [
             * 	[-122.68, 45.51],
             * 	[-122.43, 37.77],
             * 	[-118.2, 34.04]
             * ];
             *
             * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
             *
             * // zoom the map to the polyline
             * map.fitBounds(polyline.getBounds());
             * ```
             *
             * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
             *
             * ```js
             * // create a red polyline from an array of arrays of LatLng points
             * var latlngs = [
             * 	[[-122.68, 45.51],
             * 	 [-122.43, 37.77],
             * 	 [-118.2, 34.04]],
             * 	[[-73.91, 40.78],
             * 	 [-87.62, 41.83],
             * 	 [-96.72, 32.76]]
             * ];
             * ```
             */

            L.Polyline = L.Path.extend({

                // @section
                // @aka Polyline options
                options: {
                    // @option smoothFactor: Number = 1.0
                    // How much to simplify the polyline on each zoom level. More means
                    // better performance and smoother look, and less means more accurate representation.
                    smoothFactor: 1.0,

                    // @option noClip: Boolean = false
                    // Disable polyline clipping.
                    noClip: false
                },

                initialize: function (latlngs, options) {
                    L.setOptions(this, options);
                    this._setLatLngs(latlngs);
                },

                // @method getLatLngs(): LatLng[]
                // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
                getLatLngs: function () {
                    return this._latlngs;
                },

                // @method setLatLngs(latlngs: LatLng[]): this
                // Replaces all the points in the polyline with the given array of geographical points.
                setLatLngs: function (latlngs) {
                    this._setLatLngs(latlngs);
                    return this.redraw();
                },

                // @method isEmpty(): Boolean
                // Returns `true` if the Polyline has no LatLngs.
                isEmpty: function () {
                    return !this._latlngs.length;
                },

                closestLayerPoint: function (p) {
                    var minDistance = Infinity,
                        minPoint = null,
                        closest = L.LineUtil._sqClosestPointOnSegment,
                        p1,
                        p2;

                    for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
                        var points = this._parts[j];

                        for (var i = 1, len = points.length; i < len; i++) {
                            p1 = points[i - 1];
                            p2 = points[i];

                            var sqDist = closest(p, p1, p2, true);

                            if (sqDist < minDistance) {
                                minDistance = sqDist;
                                minPoint = closest(p, p1, p2);
                            }
                        }
                    }
                    if (minPoint) {
                        minPoint.distance = Math.sqrt(minDistance);
                    }
                    return minPoint;
                },

                // @method getCenter(): LatLng
                // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
                getCenter: function () {
                    // throws error when not yet added to map as this center calculation requires projected coordinates
                    if (!this._map) {
                        throw new Error('Must add layer to map before using getCenter()');
                    }

                    var i,
                        halfDist,
                        segDist,
                        dist,
                        p1,
                        p2,
                        ratio,
                        points = this._rings[0],
                        len = points.length;

                    if (!len) {
                        return null;
                    }

                    // polyline centroid algorithm; only uses the first ring if there are multiple

                    for (i = 0, halfDist = 0; i < len - 1; i++) {
                        halfDist += points[i].distanceTo(points[i + 1]) / 2;
                    }

                    // The line is so small in the current view that all points are on the same pixel.
                    if (halfDist === 0) {
                        return this._map.layerPointToLatLng(points[0]);
                    }

                    for (i = 0, dist = 0; i < len - 1; i++) {
                        p1 = points[i];
                        p2 = points[i + 1];
                        segDist = p1.distanceTo(p2);
                        dist += segDist;

                        if (dist > halfDist) {
                            ratio = (dist - halfDist) / segDist;
                            return this._map.layerPointToLatLng([p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)]);
                        }
                    }
                },

                // @method getBounds(): LatLngBounds
                // Returns the `LatLngBounds` of the path.
                getBounds: function () {
                    return this._bounds;
                },

                // @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
                // Adds a given point to the polyline. By default, adds to the first ring of
                // the polyline in case of a multi-polyline, but can be overridden by passing
                // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
                addLatLng: function (latlng, latlngs) {
                    latlngs = latlngs || this._defaultShape();
                    latlng = L.latLng(latlng);
                    latlngs.push(latlng);
                    this._bounds.extend(latlng);
                    return this.redraw();
                },

                _setLatLngs: function (latlngs) {
                    this._bounds = new L.LatLngBounds();
                    this._latlngs = this._convertLatLngs(latlngs);
                },

                _defaultShape: function () {
                    return L.Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0];
                },

                // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
                _convertLatLngs: function (latlngs) {
                    var result = [],
                        flat = L.Polyline._flat(latlngs);

                    for (var i = 0, len = latlngs.length; i < len; i++) {
                        if (flat) {
                            result[i] = L.latLng(latlngs[i]);
                            this._bounds.extend(result[i]);
                        } else {
                            result[i] = this._convertLatLngs(latlngs[i]);
                        }
                    }

                    return result;
                },

                _project: function () {
                    var pxBounds = new L.Bounds();
                    this._rings = [];
                    this._projectLatlngs(this._latlngs, this._rings, pxBounds);

                    var w = this._clickTolerance(),
                        p = new L.Point(w, w);

                    if (this._bounds.isValid() && pxBounds.isValid()) {
                        pxBounds.min._subtract(p);
                        pxBounds.max._add(p);
                        this._pxBounds = pxBounds;
                    }
                },

                // recursively turns latlngs into a set of rings with projected coordinates
                _projectLatlngs: function (latlngs, result, projectedBounds) {
                    var flat = latlngs[0] instanceof L.LatLng,
                        len = latlngs.length,
                        i,
                        ring;

                    if (flat) {
                        ring = [];
                        for (i = 0; i < len; i++) {
                            ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
                            projectedBounds.extend(ring[i]);
                        }
                        result.push(ring);
                    } else {
                        for (i = 0; i < len; i++) {
                            this._projectLatlngs(latlngs[i], result, projectedBounds);
                        }
                    }
                },

                // clip polyline by renderer bounds so that we have less to render for performance
                _clipPoints: function () {
                    var bounds = this._renderer._bounds;

                    this._parts = [];
                    if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
                        return;
                    }

                    if (this.options.noClip) {
                        this._parts = this._rings;
                        return;
                    }

                    var parts = this._parts,
                        i,
                        j,
                        k,
                        len,
                        len2,
                        segment,
                        points;

                    for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
                        points = this._rings[i];

                        for (j = 0, len2 = points.length; j < len2 - 1; j++) {
                            segment = L.LineUtil.clipSegment(points[j], points[j + 1], bounds, j, true);

                            if (!segment) {
                                continue;
                            }

                            parts[k] = parts[k] || [];
                            parts[k].push(segment[0]);

                            // if segment goes out of screen, or it's the last one, it's the end of the line part
                            if (segment[1] !== points[j + 1] || j === len2 - 2) {
                                parts[k].push(segment[1]);
                                k++;
                            }
                        }
                    }
                },

                // simplify each clipped part of the polyline for performance
                _simplifyPoints: function () {
                    var parts = this._parts,
                        tolerance = this.options.smoothFactor;

                    for (var i = 0, len = parts.length; i < len; i++) {
                        parts[i] = L.LineUtil.simplify(parts[i], tolerance);
                    }
                },

                _update: function () {
                    if (!this._map) {
                        return;
                    }

                    this._clipPoints();
                    this._simplifyPoints();
                    this._updatePath();
                },

                _updatePath: function () {
                    this._renderer._updatePoly(this);
                }
            });

            // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
            // Instantiates a polyline object given an array of geographical points and
            // optionally an options object. You can create a `Polyline` object with
            // multiple separate lines (`MultiPolyline`) by passing an array of arrays
            // of geographic points.
            L.polyline = function (latlngs, options) {
                return new L.Polyline(latlngs, options);
            };

            L.Polyline._flat = function (latlngs) {
                // true if it's a flat array of latlngs; false if nested
                return !L.Util.isArray(latlngs[0]) || typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined';
            };

            /*
             * @namespace PolyUtil
             * Various utility functions for polygon geometries.
             */

            L.PolyUtil = {};

            /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
             * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgeman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
             * Used by Leaflet to only show polygon points that are on the screen or near, increasing
             * performance. Note that polygon points needs different algorithm for clipping
             * than polyline, so there's a seperate method for it.
             */
            L.PolyUtil.clipPolygon = function (points, bounds, round) {
                var clippedPoints,
                    edges = [1, 4, 2, 8],
                    i,
                    j,
                    k,
                    a,
                    b,
                    len,
                    edge,
                    p,
                    lu = L.LineUtil;

                for (i = 0, len = points.length; i < len; i++) {
                    points[i]._code = lu._getBitCode(points[i], bounds);
                }

                // for each edge (left, bottom, right, top)
                for (k = 0; k < 4; k++) {
                    edge = edges[k];
                    clippedPoints = [];

                    for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
                        a = points[i];
                        b = points[j];

                        // if a is inside the clip window
                        if (!(a._code & edge)) {
                            // if b is outside the clip window (a->b goes out of screen)
                            if (b._code & edge) {
                                p = lu._getEdgeIntersection(b, a, edge, bounds, round);
                                p._code = lu._getBitCode(p, bounds);
                                clippedPoints.push(p);
                            }
                            clippedPoints.push(a);

                            // else if b is inside the clip window (a->b enters the screen)
                        } else if (!(b._code & edge)) {
                            p = lu._getEdgeIntersection(b, a, edge, bounds, round);
                            p._code = lu._getBitCode(p, bounds);
                            clippedPoints.push(p);
                        }
                    }
                    points = clippedPoints;
                }

                return points;
            };

            /*
             * @class Polygon
             * @aka L.Polygon
             * @inherits Polyline
             *
             * A class for drawing polygon overlays on a map. Extends `Polyline`.
             *
             * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
             *
             *
             * @example
             *
             * ```js
             * // create a red polygon from an array of LatLng points
             * var latlngs = [[-111.03, 41],[-111.04, 45],[-104.05, 45],[-104.05, 41]];
             *
             * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
             *
             * // zoom the map to the polygon
             * map.fitBounds(polygon.getBounds());
             * ```
             *
             * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
             *
             * ```js
             * var latlngs = [
             *   [[-111.03, 41],[-111.04, 45],[-104.05, 45],[-104.05, 41]], // outer ring
             *   [[-108.58,37.29],[-108.58,40.71],[-102.50,40.71],[-102.50,37.29]] // hole
             * ];
             * ```
             *
             * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
             *
             * ```js
             * var latlngs = [
             *   [ // first polygon
             *     [[-111.03, 41],[-111.04, 45],[-104.05, 45],[-104.05, 41]], // outer ring
             *     [[-108.58,37.29],[-108.58,40.71],[-102.50,40.71],[-102.50,37.29]] // hole
             *   ],
             *   [ // second polygon
             *     [[-109.05, 37],[-109.03, 41],[-102.05, 41],[-102.04, 37],[-109.05, 38]]
             *   ]
             * ];
             * ```
             */

            L.Polygon = L.Polyline.extend({

                options: {
                    fill: true
                },

                isEmpty: function () {
                    return !this._latlngs.length || !this._latlngs[0].length;
                },

                getCenter: function () {
                    // throws error when not yet added to map as this center calculation requires projected coordinates
                    if (!this._map) {
                        throw new Error('Must add layer to map before using getCenter()');
                    }

                    var i,
                        j,
                        p1,
                        p2,
                        f,
                        area,
                        x,
                        y,
                        center,
                        points = this._rings[0],
                        len = points.length;

                    if (!len) {
                        return null;
                    }

                    // polygon centroid algorithm; only uses the first ring if there are multiple

                    area = x = y = 0;

                    for (i = 0, j = len - 1; i < len; j = i++) {
                        p1 = points[i];
                        p2 = points[j];

                        f = p1.y * p2.x - p2.y * p1.x;
                        x += (p1.x + p2.x) * f;
                        y += (p1.y + p2.y) * f;
                        area += f * 3;
                    }

                    if (area === 0) {
                        // Polygon is so small that all points are on same pixel.
                        center = points[0];
                    } else {
                        center = [x / area, y / area];
                    }
                    return this._map.layerPointToLatLng(center);
                },

                _convertLatLngs: function (latlngs) {
                    var result = L.Polyline.prototype._convertLatLngs.call(this, latlngs),
                        len = result.length;

                    // remove last point if it equals first one
                    if (len >= 2 && result[0] instanceof L.LatLng && result[0].equals(result[len - 1])) {
                        result.pop();
                    }
                    return result;
                },

                _setLatLngs: function (latlngs) {
                    L.Polyline.prototype._setLatLngs.call(this, latlngs);
                    if (L.Polyline._flat(this._latlngs)) {
                        this._latlngs = [this._latlngs];
                    }
                },

                _defaultShape: function () {
                    return L.Polyline._flat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
                },

                _clipPoints: function () {
                    // polygons need a different clipping algorithm so we redefine that

                    var bounds = this._renderer._bounds,
                        w = this.options.weight,
                        p = new L.Point(w, w);

                    // increase clip padding by stroke width to avoid stroke on clip edges
                    bounds = new L.Bounds(bounds.min.subtract(p), bounds.max.add(p));

                    this._parts = [];
                    if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
                        return;
                    }

                    if (this.options.noClip) {
                        this._parts = this._rings;
                        return;
                    }

                    for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
                        clipped = L.PolyUtil.clipPolygon(this._rings[i], bounds, true);
                        if (clipped.length) {
                            this._parts.push(clipped);
                        }
                    }
                },

                _updatePath: function () {
                    this._renderer._updatePoly(this, true);
                }
            });

            // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
            L.polygon = function (latlngs, options) {
                return new L.Polygon(latlngs, options);
            };

            /*
             * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
             */

            /*
             * @class Rectangle
             * @aka L.Retangle
             * @inherits Polygon
             *
             * A class for drawing rectangle overlays on a map. Extends `Polygon`.
             *
             * @example
             *
             * ```js
             * // define rectangle geographical bounds
             * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
             *
             * // create an orange rectangle
             * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
             *
             * // zoom the map to the rectangle bounds
             * map.fitBounds(bounds);
             * ```
             *
             */

            L.Rectangle = L.Polygon.extend({
                initialize: function (latLngBounds, options) {
                    L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
                },

                // @method setBounds(latLngBounds: LatLngBounds): this
                // Redraws the rectangle with the passed bounds.
                setBounds: function (latLngBounds) {
                    return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
                },

                _boundsToLatLngs: function (latLngBounds) {
                    latLngBounds = L.latLngBounds(latLngBounds);
                    return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];
                }
            });

            // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
            L.rectangle = function (latLngBounds, options) {
                return new L.Rectangle(latLngBounds, options);
            };

            /*
             * @class CircleMarker
             * @aka L.CircleMarker
             * @inherits Path
             *
             * A circle of a fixed size with radius specified in pixels. Extends `Path`.
             */

            L.CircleMarker = L.Path.extend({

                // @section
                // @aka CircleMarker options
                options: {
                    fill: true,

                    // @option radius: Number = 10
                    // Radius of the circle marker, in pixels
                    radius: 10
                },

                initialize: function (latlng, options) {
                    L.setOptions(this, options);
                    this._latlng = L.latLng(latlng);
                    this._radius = this.options.radius;
                },

                // @method setLatLng(latLng: LatLng): this
                // Sets the position of a circle marker to a new location.
                setLatLng: function (latlng) {
                    this._latlng = L.latLng(latlng);
                    this.redraw();
                    return this.fire('move', { latlng: this._latlng });
                },

                // @method getLatLng(): LatLng
                // Returns the current geographical position of the circle marker
                getLatLng: function () {
                    return this._latlng;
                },

                // @method setRadius(radius: Number): this
                // Sets the radius of a circle marker. Units are in pixels.
                setRadius: function (radius) {
                    this.options.radius = this._radius = radius;
                    return this.redraw();
                },

                // @method getRadius(): Number
                // Returns the current radius of the circle
                getRadius: function () {
                    return this._radius;
                },

                setStyle: function (options) {
                    var radius = options && options.radius || this._radius;
                    L.Path.prototype.setStyle.call(this, options);
                    this.setRadius(radius);
                    return this;
                },

                _project: function () {
                    this._point = this._map.latLngToLayerPoint(this._latlng);
                    this._updateBounds();
                },

                _updateBounds: function () {
                    var r = this._radius,
                        r2 = this._radiusY || r,
                        w = this._clickTolerance(),
                        p = [r + w, r2 + w];
                    this._pxBounds = new L.Bounds(this._point.subtract(p), this._point.add(p));
                },

                _update: function () {
                    if (this._map) {
                        this._updatePath();
                    }
                },

                _updatePath: function () {
                    this._renderer._updateCircle(this);
                },

                _empty: function () {
                    return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
                }
            });

            // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
            // Instantiates a circle marker object given a geographical point, and an optional options object.
            L.circleMarker = function (latlng, options) {
                return new L.CircleMarker(latlng, options);
            };

            /*
             * @class Circle
             * @aka L.Circle
             * @inherits CircleMarker
             *
             * A class for drawing circle overlays on a map. Extends `CircleMarker`.
             *
             * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
             *
             * @example
             *
             * ```js
             * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
             * ```
             */

            L.Circle = L.CircleMarker.extend({

                initialize: function (latlng, options, legacyOptions) {
                    if (typeof options === 'number') {
                        // Backwards compatibility with 0.7.x factory (latlng, radius, options?)
                        options = L.extend({}, legacyOptions, { radius: options });
                    }
                    L.setOptions(this, options);
                    this._latlng = L.latLng(latlng);

                    if (isNaN(this.options.radius)) {
                        throw new Error('Circle radius cannot be NaN');
                    }

                    // @section
                    // @aka Circle options
                    // @option radius: Number; Radius of the circle, in meters.
                    this._mRadius = this.options.radius;
                },

                // @method setRadius(radius: Number): this
                // Sets the radius of a circle. Units are in meters.
                setRadius: function (radius) {
                    this._mRadius = radius;
                    return this.redraw();
                },

                // @method getRadius(): Number
                // Returns the current radius of a circle. Units are in meters.
                getRadius: function () {
                    return this._mRadius;
                },

                // @method getBounds(): LatLngBounds
                // Returns the `LatLngBounds` of the path.
                getBounds: function () {
                    var half = [this._radius, this._radiusY || this._radius];

                    return new L.LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));
                },

                setStyle: L.Path.prototype.setStyle,

                _project: function () {

                    var lng = this._latlng.lng,
                        lat = this._latlng.lat,
                        map = this._map,
                        crs = map.options.crs;

                    if (crs.distance === L.CRS.Earth.distance) {
                        var d = Math.PI / 180,
                            latR = this._mRadius / L.CRS.Earth.R / d,
                            top = map.project([lat + latR, lng]),
                            bottom = map.project([lat - latR, lng]),
                            p = top.add(bottom).divideBy(2),
                            lat2 = map.unproject(p).lat,
                            lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

                        if (isNaN(lngR) || lngR === 0) {
                            lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
                        }

                        this._point = p.subtract(map.getPixelOrigin());
                        this._radius = isNaN(lngR) ? 0 : Math.max(Math.round(p.x - map.project([lat2, lng - lngR]).x), 1);
                        this._radiusY = Math.max(Math.round(p.y - top.y), 1);
                    } else {
                        var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

                        this._point = map.latLngToLayerPoint(this._latlng);
                        this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
                    }

                    this._updateBounds();
                }
            });

            // @factory L.circle(latlng: LatLng, options?: Circle options)
            // Instantiates a circle object given a geographical point, and an options object
            // which contains the circle radius.
            // @alternative
            // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
            // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
            // Do not use in new applications or plugins.
            L.circle = function (latlng, options, legacyOptions) {
                return new L.Circle(latlng, options, legacyOptions);
            };

            /*
             * @class SVG
             * @inherits Renderer
             * @aka L.SVG
             *
             * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
             * Inherits `Renderer`.
             *
             * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
             * available in all web browsers, notably Android 2.x and 3.x.
             *
             * Although SVG is not available on IE7 and IE8, these browsers support
             * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
             * (a now deprecated technology), and the SVG renderer will fall back to VML in
             * this case.
             *
             * @example
             *
             * Use SVG by default for all paths in the map:
             *
             * ```js
             * var map = L.map('map', {
             * 	renderer: L.svg()
             * });
             * ```
             *
             * Use a SVG renderer with extra padding for specific vector geometries:
             *
             * ```js
             * var map = L.map('map');
             * var myRenderer = L.svg({ padding: 0.5 });
             * var line = L.polyline( coordinates, { renderer: myRenderer } );
             * var circle = L.circle( center, { renderer: myRenderer } );
             * ```
             */

            L.SVG = L.Renderer.extend({

                getEvents: function () {
                    var events = L.Renderer.prototype.getEvents.call(this);
                    events.zoomstart = this._onZoomStart;
                    return events;
                },

                _initContainer: function () {
                    this._container = L.SVG.create('svg');

                    // makes it possible to click through svg root; we'll reset it back in individual paths
                    this._container.setAttribute('pointer-events', 'none');

                    this._rootGroup = L.SVG.create('g');
                    this._container.appendChild(this._rootGroup);
                },

                _onZoomStart: function () {
                    // Drag-then-pinch interactions might mess up the center and zoom.
                    // In this case, the easiest way to prevent this is re-do the renderer
                    //   bounds and padding when the zooming starts.
                    this._update();
                },

                _update: function () {
                    if (this._map._animatingZoom && this._bounds) {
                        return;
                    }

                    L.Renderer.prototype._update.call(this);

                    var b = this._bounds,
                        size = b.getSize(),
                        container = this._container;

                    // set size of svg-container if changed
                    if (!this._svgSize || !this._svgSize.equals(size)) {
                        this._svgSize = size;
                        container.setAttribute('width', size.x);
                        container.setAttribute('height', size.y);
                    }

                    // movement: update container viewBox so that we don't have to change coordinates of individual layers
                    L.DomUtil.setPosition(container, b.min);
                    container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

                    this.fire('update');
                },

                // methods below are called by vector layers implementations

                _initPath: function (layer) {
                    var path = layer._path = L.SVG.create('path');

                    // @namespace Path
                    // @option className: String = null
                    // Custom class name set on an element. Only for SVG renderer.
                    if (layer.options.className) {
                        L.DomUtil.addClass(path, layer.options.className);
                    }

                    if (layer.options.interactive) {
                        L.DomUtil.addClass(path, 'leaflet-interactive');
                    }

                    this._updateStyle(layer);
                },

                _addPath: function (layer) {
                    this._rootGroup.appendChild(layer._path);
                    layer.addInteractiveTarget(layer._path);
                },

                _removePath: function (layer) {
                    L.DomUtil.remove(layer._path);
                    layer.removeInteractiveTarget(layer._path);
                },

                _updatePath: function (layer) {
                    layer._project();
                    layer._update();
                },

                _updateStyle: function (layer) {
                    var path = layer._path,
                        options = layer.options;

                    if (!path) {
                        return;
                    }

                    if (options.stroke) {
                        path.setAttribute('stroke', options.color);
                        path.setAttribute('stroke-opacity', options.opacity);
                        path.setAttribute('stroke-width', options.weight);
                        path.setAttribute('stroke-linecap', options.lineCap);
                        path.setAttribute('stroke-linejoin', options.lineJoin);

                        if (options.dashArray) {
                            path.setAttribute('stroke-dasharray', options.dashArray);
                        } else {
                            path.removeAttribute('stroke-dasharray');
                        }

                        if (options.dashOffset) {
                            path.setAttribute('stroke-dashoffset', options.dashOffset);
                        } else {
                            path.removeAttribute('stroke-dashoffset');
                        }
                    } else {
                        path.setAttribute('stroke', 'none');
                    }

                    if (options.fill) {
                        path.setAttribute('fill', options.fillColor || options.color);
                        path.setAttribute('fill-opacity', options.fillOpacity);
                        path.setAttribute('fill-rule', options.fillRule || 'evenodd');
                    } else {
                        path.setAttribute('fill', 'none');
                    }
                },

                _updatePoly: function (layer, closed) {
                    this._setPath(layer, L.SVG.pointsToPath(layer._parts, closed));
                },

                _updateCircle: function (layer) {
                    var p = layer._point,
                        r = layer._radius,
                        r2 = layer._radiusY || r,
                        arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

                    // drawing a circle with two half-arcs
                    var d = layer._empty() ? 'M0 0' : 'M' + (p.x - r) + ',' + p.y + arc + r * 2 + ',0 ' + arc + -r * 2 + ',0 ';

                    this._setPath(layer, d);
                },

                _setPath: function (layer, path) {
                    layer._path.setAttribute('d', path);
                },

                // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
                _bringToFront: function (layer) {
                    L.DomUtil.toFront(layer._path);
                },

                _bringToBack: function (layer) {
                    L.DomUtil.toBack(layer._path);
                }
            });

            // @namespace SVG; @section
            // There are several static functions which can be called without instantiating L.SVG:
            L.extend(L.SVG, {
                // @function create(name: String): SVGElement
                // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
                // corresponding to the class name passed. For example, using 'line' will return
                // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
                create: function (name) {
                    return document.createElementNS('http://www.w3.org/2000/svg', name);
                },

                // @function pointsToPath(rings: Point[], closed: Boolean): String
                // Generates a SVG path string for multiple rings, with each ring turning
                // into "M..L..L.." instructions
                pointsToPath: function (rings, closed) {
                    var str = '',
                        i,
                        j,
                        len,
                        len2,
                        points,
                        p;

                    for (i = 0, len = rings.length; i < len; i++) {
                        points = rings[i];

                        for (j = 0, len2 = points.length; j < len2; j++) {
                            p = points[j];
                            str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
                        }

                        // closes the ring for polygons; "x" is VML syntax
                        str += closed ? L.Browser.svg ? 'z' : 'x' : '';
                    }

                    // SVG complains about empty path strings
                    return str || 'M0 0';
                }
            });

            // @namespace Browser; @property svg: Boolean
            // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
            L.Browser.svg = !!(document.createElementNS && L.SVG.create('svg').createSVGRect);

            // @namespace SVG
            // @factory L.svg(options?: Renderer options)
            // Creates a SVG renderer with the given options.
            L.svg = function (options) {
                return L.Browser.svg || L.Browser.vml ? new L.SVG(options) : null;
            };

            /*
             * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
             */

            /*
             * @class SVG
             *
             * Although SVG is not available on IE7 and IE8, these browsers support [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language), and the SVG renderer will fall back to VML in this case.
             *
             * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
             * with old versions of Internet Explorer.
             */

            // @namespace Browser; @property vml: Boolean
            // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
            L.Browser.vml = !L.Browser.svg && function () {
                try {
                    var div = document.createElement('div');
                    div.innerHTML = '<v:shape adj="1"/>';

                    var shape = div.firstChild;
                    shape.style.behavior = 'url(#default#VML)';

                    return shape && typeof shape.adj === 'object';
                } catch (e) {
                    return false;
                }
            }();

            // redefine some SVG methods to handle VML syntax which is similar but with some differences
            L.SVG.include(!L.Browser.vml ? {} : {

                _initContainer: function () {
                    this._container = L.DomUtil.create('div', 'leaflet-vml-container');
                },

                _update: function () {
                    if (this._map._animatingZoom) {
                        return;
                    }
                    L.Renderer.prototype._update.call(this);
                    this.fire('update');
                },

                _initPath: function (layer) {
                    var container = layer._container = L.SVG.create('shape');

                    L.DomUtil.addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

                    container.coordsize = '1 1';

                    layer._path = L.SVG.create('path');
                    container.appendChild(layer._path);

                    this._updateStyle(layer);
                },

                _addPath: function (layer) {
                    var container = layer._container;
                    this._container.appendChild(container);

                    if (layer.options.interactive) {
                        layer.addInteractiveTarget(container);
                    }
                },

                _removePath: function (layer) {
                    var container = layer._container;
                    L.DomUtil.remove(container);
                    layer.removeInteractiveTarget(container);
                },

                _updateStyle: function (layer) {
                    var stroke = layer._stroke,
                        fill = layer._fill,
                        options = layer.options,
                        container = layer._container;

                    container.stroked = !!options.stroke;
                    container.filled = !!options.fill;

                    if (options.stroke) {
                        if (!stroke) {
                            stroke = layer._stroke = L.SVG.create('stroke');
                        }
                        container.appendChild(stroke);
                        stroke.weight = options.weight + 'px';
                        stroke.color = options.color;
                        stroke.opacity = options.opacity;

                        if (options.dashArray) {
                            stroke.dashStyle = L.Util.isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');
                        } else {
                            stroke.dashStyle = '';
                        }
                        stroke.endcap = options.lineCap.replace('butt', 'flat');
                        stroke.joinstyle = options.lineJoin;
                    } else if (stroke) {
                        container.removeChild(stroke);
                        layer._stroke = null;
                    }

                    if (options.fill) {
                        if (!fill) {
                            fill = layer._fill = L.SVG.create('fill');
                        }
                        container.appendChild(fill);
                        fill.color = options.fillColor || options.color;
                        fill.opacity = options.fillOpacity;
                    } else if (fill) {
                        container.removeChild(fill);
                        layer._fill = null;
                    }
                },

                _updateCircle: function (layer) {
                    var p = layer._point.round(),
                        r = Math.round(layer._radius),
                        r2 = Math.round(layer._radiusY || r);

                    this._setPath(layer, layer._empty() ? 'M0 0' : 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + 65535 * 360);
                },

                _setPath: function (layer, path) {
                    layer._path.v = path;
                },

                _bringToFront: function (layer) {
                    L.DomUtil.toFront(layer._container);
                },

                _bringToBack: function (layer) {
                    L.DomUtil.toBack(layer._container);
                }
            });

            if (L.Browser.vml) {
                L.SVG.create = function () {
                    try {
                        document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
                        return function (name) {
                            return document.createElement('<lvml:' + name + ' class="lvml">');
                        };
                    } catch (e) {
                        return function (name) {
                            return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
                        };
                    }
                }();
            }

            /*
             * @class Canvas
             * @inherits Renderer
             * @aka L.Canvas
             *
             * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
             * Inherits `Renderer`.
             *
             * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
             * available in all web browsers, notably IE8, and overlapping geometries might
             * not display properly in some edge cases.
             *
             * @example
             *
             * Use Canvas by default for all paths in the map:
             *
             * ```js
             * var map = L.map('map', {
             * 	renderer: L.canvas()
             * });
             * ```
             *
             * Use a Canvas renderer with extra padding for specific vector geometries:
             *
             * ```js
             * var map = L.map('map');
             * var myRenderer = L.canvas({ padding: 0.5 });
             * var line = L.polyline( coordinates, { renderer: myRenderer } );
             * var circle = L.circle( center, { renderer: myRenderer } );
             * ```
             */

            L.Canvas = L.Renderer.extend({

                onAdd: function () {
                    L.Renderer.prototype.onAdd.call(this);

                    this._layers = this._layers || {};

                    // Redraw vectors since canvas is cleared upon removal,
                    // in case of removing the renderer itself from the map.
                    this._draw();
                },

                _initContainer: function () {
                    var container = this._container = document.createElement('canvas');

                    L.DomEvent.on(container, 'mousemove', L.Util.throttle(this._onMouseMove, 32, this), this).on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this).on(container, 'mouseout', this._handleMouseOut, this);

                    this._ctx = container.getContext('2d');
                },

                _update: function () {
                    if (this._map._animatingZoom && this._bounds) {
                        return;
                    }

                    this._drawnLayers = {};

                    L.Renderer.prototype._update.call(this);

                    var b = this._bounds,
                        container = this._container,
                        size = b.getSize(),
                        m = L.Browser.retina ? 2 : 1;

                    L.DomUtil.setPosition(container, b.min);

                    // set canvas size (also clearing it); use double size on retina
                    container.width = m * size.x;
                    container.height = m * size.y;
                    container.style.width = size.x + 'px';
                    container.style.height = size.y + 'px';

                    if (L.Browser.retina) {
                        this._ctx.scale(2, 2);
                    }

                    // translate so we use the same path coordinates after canvas element moves
                    this._ctx.translate(-b.min.x, -b.min.y);

                    // Tell paths to redraw themselves
                    this.fire('update');
                },

                _initPath: function (layer) {
                    this._updateDashArray(layer);
                    this._layers[L.stamp(layer)] = layer;
                },

                _addPath: L.Util.falseFn,

                _removePath: function (layer) {
                    layer._removed = true;
                    this._requestRedraw(layer);
                },

                _updatePath: function (layer) {
                    this._redrawBounds = layer._pxBounds;
                    this._draw(true);
                    layer._project();
                    layer._update();
                    this._draw();
                    this._redrawBounds = null;
                },

                _updateStyle: function (layer) {
                    this._updateDashArray(layer);
                    this._requestRedraw(layer);
                },

                _updateDashArray: function (layer) {
                    if (layer.options.dashArray) {
                        var parts = layer.options.dashArray.split(','),
                            dashArray = [],
                            i;
                        for (i = 0; i < parts.length; i++) {
                            dashArray.push(Number(parts[i]));
                        }
                        layer.options._dashArray = dashArray;
                    }
                },

                _requestRedraw: function (layer) {
                    if (!this._map) {
                        return;
                    }

                    var padding = (layer.options.weight || 0) + 1;
                    this._redrawBounds = this._redrawBounds || new L.Bounds();
                    this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
                    this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));

                    this._redrawRequest = this._redrawRequest || L.Util.requestAnimFrame(this._redraw, this);
                },

                _redraw: function () {
                    this._redrawRequest = null;

                    this._draw(true); // clear layers in redraw bounds
                    this._draw(); // draw layers

                    this._redrawBounds = null;
                },

                _draw: function (clear) {
                    this._clear = clear;
                    var layer,
                        bounds = this._redrawBounds;
                    this._ctx.save();
                    if (bounds) {
                        this._ctx.beginPath();
                        this._ctx.rect(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);
                        this._ctx.clip();
                    }

                    for (var id in this._layers) {
                        layer = this._layers[id];
                        if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
                            layer._updatePath();
                        }
                        if (clear && layer._removed) {
                            delete layer._removed;
                            delete this._layers[id];
                        }
                    }
                    this._ctx.restore(); // Restore state before clipping.
                },

                _updatePoly: function (layer, closed) {

                    var i,
                        j,
                        len2,
                        p,
                        parts = layer._parts,
                        len = parts.length,
                        ctx = this._ctx;

                    if (!len) {
                        return;
                    }

                    this._drawnLayers[layer._leaflet_id] = layer;

                    ctx.beginPath();

                    if (ctx.setLineDash) {
                        ctx.setLineDash(layer.options && layer.options._dashArray || []);
                    }

                    for (i = 0; i < len; i++) {
                        for (j = 0, len2 = parts[i].length; j < len2; j++) {
                            p = parts[i][j];
                            ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
                        }
                        if (closed) {
                            ctx.closePath();
                        }
                    }

                    this._fillStroke(ctx, layer);

                    // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
                },

                _updateCircle: function (layer) {

                    if (layer._empty()) {
                        return;
                    }

                    var p = layer._point,
                        ctx = this._ctx,
                        r = layer._radius,
                        s = (layer._radiusY || r) / r;

                    this._drawnLayers[layer._leaflet_id] = layer;

                    if (s !== 1) {
                        ctx.save();
                        ctx.scale(1, s);
                    }

                    ctx.beginPath();
                    ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

                    if (s !== 1) {
                        ctx.restore();
                    }

                    this._fillStroke(ctx, layer);
                },

                _fillStroke: function (ctx, layer) {
                    var clear = this._clear,
                        options = layer.options;

                    ctx.globalCompositeOperation = clear ? 'destination-out' : 'source-over';

                    if (options.fill) {
                        ctx.globalAlpha = clear ? 1 : options.fillOpacity;
                        ctx.fillStyle = options.fillColor || options.color;
                        ctx.fill(options.fillRule || 'evenodd');
                    }

                    if (options.stroke && options.weight !== 0) {
                        ctx.globalAlpha = clear ? 1 : options.opacity;

                        // if clearing shape, do it with the previously drawn line width
                        layer._prevWeight = ctx.lineWidth = clear ? layer._prevWeight + 1 : options.weight;

                        ctx.strokeStyle = options.color;
                        ctx.lineCap = options.lineCap;
                        ctx.lineJoin = options.lineJoin;
                        ctx.stroke();
                    }
                },

                // Canvas obviously doesn't have mouse events for individual drawn objects,
                // so we emulate that by calculating what's under the mouse on mousemove/click manually

                _onClick: function (e) {
                    var point = this._map.mouseEventToLayerPoint(e),
                        layers = [],
                        layer;

                    for (var id in this._layers) {
                        layer = this._layers[id];
                        if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
                            L.DomEvent._fakeStop(e);
                            layers.push(layer);
                        }
                    }
                    if (layers.length) {
                        this._fireEvent(layers, e);
                    }
                },

                _onMouseMove: function (e) {
                    if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
                        return;
                    }

                    var point = this._map.mouseEventToLayerPoint(e);
                    this._handleMouseOut(e, point);
                    this._handleMouseHover(e, point);
                },

                _handleMouseOut: function (e, point) {
                    var layer = this._hoveredLayer;
                    if (layer && (e.type === 'mouseout' || !layer._containsPoint(point))) {
                        // if we're leaving the layer, fire mouseout
                        L.DomUtil.removeClass(this._container, 'leaflet-interactive');
                        this._fireEvent([layer], e, 'mouseout');
                        this._hoveredLayer = null;
                    }
                },

                _handleMouseHover: function (e, point) {
                    var id, layer;

                    for (id in this._drawnLayers) {
                        layer = this._drawnLayers[id];
                        if (layer.options.interactive && layer._containsPoint(point)) {
                            L.DomUtil.addClass(this._container, 'leaflet-interactive'); // change cursor
                            this._fireEvent([layer], e, 'mouseover');
                            this._hoveredLayer = layer;
                        }
                    }

                    if (this._hoveredLayer) {
                        this._fireEvent([this._hoveredLayer], e);
                    }
                },

                _fireEvent: function (layers, e, type) {
                    this._map._fireDOMEvent(e, type || e.type, layers);
                },

                // TODO _bringToFront & _bringToBack, pretty tricky

                _bringToFront: L.Util.falseFn,
                _bringToBack: L.Util.falseFn
            });

            // @namespace Browser; @property canvas: Boolean
            // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
            L.Browser.canvas = function () {
                return !!document.createElement('canvas').getContext;
            }();

            // @namespace Canvas
            // @factory L.canvas(options?: Renderer options)
            // Creates a Canvas renderer with the given options.
            L.canvas = function (options) {
                return L.Browser.canvas ? new L.Canvas(options) : null;
            };

            L.Polyline.prototype._containsPoint = function (p, closed) {
                var i,
                    j,
                    k,
                    len,
                    len2,
                    part,
                    w = this._clickTolerance();

                if (!this._pxBounds.contains(p)) {
                    return false;
                }

                // hit detection for polylines
                for (i = 0, len = this._parts.length; i < len; i++) {
                    part = this._parts[i];

                    for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                        if (!closed && j === 0) {
                            continue;
                        }

                        if (L.LineUtil.pointToSegmentDistance(p, part[k], part[j]) <= w) {
                            return true;
                        }
                    }
                }
                return false;
            };

            L.Polygon.prototype._containsPoint = function (p) {
                var inside = false,
                    part,
                    p1,
                    p2,
                    i,
                    j,
                    k,
                    len,
                    len2;

                if (!this._pxBounds.contains(p)) {
                    return false;
                }

                // ray casting algorithm for detecting if point is in polygon
                for (i = 0, len = this._parts.length; i < len; i++) {
                    part = this._parts[i];

                    for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                        p1 = part[j];
                        p2 = part[k];

                        if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
                            inside = !inside;
                        }
                    }
                }

                // also check if it's on polygon stroke
                return inside || L.Polyline.prototype._containsPoint.call(this, p, true);
            };

            L.CircleMarker.prototype._containsPoint = function (p) {
                return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
            };

            /*
             * @class GeoJSON
             * @aka L.GeoJSON
             * @inherits FeatureGroup
             *
             * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
             * GeoJSON data and display it on the map. Extends `FeatureGroup`.
             *
             * @example
             *
             * ```js
             * L.geoJSON(data, {
             * 	style: function (feature) {
             * 		return {color: feature.properties.color};
             * 	}
             * }).bindPopup(function (layer) {
             * 	return layer.feature.properties.description;
             * }).addTo(map);
             * ```
             */

            L.GeoJSON = L.FeatureGroup.extend({

                /* @section
                 * @aka GeoJSON options
                 *
                 * @option pointToLayer: Function = *
                 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
                 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
                 * The default is to spawn a default `Marker`:
                 * ```js
                 * function(geoJsonPoint, latlng) {
                 * 	return L.marker(latlng);
                 * }
                 * ```
                 *
                 * @option style: Function = *
                 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
                 * called internally when data is added.
                 * The default value is to not override any defaults:
                 * ```js
                 * function (geoJsonFeature) {
                 * 	return {}
                 * }
                 * ```
                 *
                 * @option onEachFeature: Function = *
                 * A `Function` that will be called once for each created `Feature`, after it has
                 * been created and styled. Useful for attaching events and popups to features.
                 * The default is to do nothing with the newly created layers:
                 * ```js
                 * function (feature, layer) {}
                 * ```
                 *
                 * @option filter: Function = *
                 * A `Function` that will be used to decide whether to include a feature or not.
                 * The default is to include all features:
                 * ```js
                 * function (geoJsonFeature) {
                 * 	return true;
                 * }
                 * ```
                 * Note: dynamically changing the `filter` option will have effect only on newly
                 * added data. It will _not_ re-evaluate already included features.
                 *
                 * @option coordsToLatLng: Function = *
                 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
                 * The default is the `coordsToLatLng` static method.
                 */

                initialize: function (geojson, options) {
                    L.setOptions(this, options);

                    this._layers = {};

                    if (geojson) {
                        this.addData(geojson);
                    }
                },

                // @method addData( <GeoJSON> data ): Layer
                // Adds a GeoJSON object to the layer.
                addData: function (geojson) {
                    var features = L.Util.isArray(geojson) ? geojson : geojson.features,
                        i,
                        len,
                        feature;

                    if (features) {
                        for (i = 0, len = features.length; i < len; i++) {
                            // only add this if geometry or geometries are set and not null
                            feature = features[i];
                            if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                                this.addData(feature);
                            }
                        }
                        return this;
                    }

                    var options = this.options;

                    if (options.filter && !options.filter(geojson)) {
                        return this;
                    }

                    var layer = L.GeoJSON.geometryToLayer(geojson, options);
                    if (!layer) {
                        return this;
                    }
                    layer.feature = L.GeoJSON.asFeature(geojson);

                    layer.defaultOptions = layer.options;
                    this.resetStyle(layer);

                    if (options.onEachFeature) {
                        options.onEachFeature(geojson, layer);
                    }

                    return this.addLayer(layer);
                },

                // @method resetStyle( <Path> layer ): Layer
                // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
                resetStyle: function (layer) {
                    // reset any custom styles
                    layer.options = L.Util.extend({}, layer.defaultOptions);
                    this._setLayerStyle(layer, this.options.style);
                    return this;
                },

                // @method setStyle( <Function> style ): Layer
                // Changes styles of GeoJSON vector layers with the given style function.
                setStyle: function (style) {
                    return this.eachLayer(function (layer) {
                        this._setLayerStyle(layer, style);
                    }, this);
                },

                _setLayerStyle: function (layer, style) {
                    if (typeof style === 'function') {
                        style = style(layer.feature);
                    }
                    if (layer.setStyle) {
                        layer.setStyle(style);
                    }
                }
            });

            // @section
            // There are several static functions which can be called without instantiating L.GeoJSON:
            L.extend(L.GeoJSON, {
                // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
                // Creates a `Layer` from a given GeoJSON feature. Can use a custom
                // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
                // functions if provided as options.
                geometryToLayer: function (geojson, options) {

                    var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
                        coords = geometry ? geometry.coordinates : null,
                        layers = [],
                        pointToLayer = options && options.pointToLayer,
                        coordsToLatLng = options && options.coordsToLatLng || this.coordsToLatLng,
                        latlng,
                        latlngs,
                        i,
                        len;

                    if (!coords && !geometry) {
                        return null;
                    }

                    switch (geometry.type) {
                        case 'Point':
                            latlng = coordsToLatLng(coords);
                            return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

                        case 'MultiPoint':
                            for (i = 0, len = coords.length; i < len; i++) {
                                latlng = coordsToLatLng(coords[i]);
                                layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
                            }
                            return new L.FeatureGroup(layers);

                        case 'LineString':
                        case 'MultiLineString':
                            latlngs = this.coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, coordsToLatLng);
                            return new L.Polyline(latlngs, options);

                        case 'Polygon':
                        case 'MultiPolygon':
                            latlngs = this.coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, coordsToLatLng);
                            return new L.Polygon(latlngs, options);

                        case 'GeometryCollection':
                            for (i = 0, len = geometry.geometries.length; i < len; i++) {
                                var layer = this.geometryToLayer({
                                    geometry: geometry.geometries[i],
                                    type: 'Feature',
                                    properties: geojson.properties
                                }, options);

                                if (layer) {
                                    layers.push(layer);
                                }
                            }
                            return new L.FeatureGroup(layers);

                        default:
                            throw new Error('Invalid GeoJSON object.');
                    }
                },

                // @function coordsToLatLng(coords: Array): LatLng
                // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
                // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
                coordsToLatLng: function (coords) {
                    return new L.LatLng(coords[1], coords[0], coords[2]);
                },

                // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
                // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
                // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
                // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
                coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) {
                    var latlngs = [];

                    for (var i = 0, len = coords.length, latlng; i < len; i++) {
                        latlng = levelsDeep ? this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) : (coordsToLatLng || this.coordsToLatLng)(coords[i]);

                        latlngs.push(latlng);
                    }

                    return latlngs;
                },

                // @function latLngToCoords(latlng: LatLng): Array
                // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
                latLngToCoords: function (latlng) {
                    return latlng.alt !== undefined ? [latlng.lng, latlng.lat, latlng.alt] : [latlng.lng, latlng.lat];
                },

                // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
                // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
                // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
                latLngsToCoords: function (latlngs, levelsDeep, closed) {
                    var coords = [];

                    for (var i = 0, len = latlngs.length; i < len; i++) {
                        coords.push(levelsDeep ? L.GeoJSON.latLngsToCoords(latlngs[i], levelsDeep - 1, closed) : L.GeoJSON.latLngToCoords(latlngs[i]));
                    }

                    if (!levelsDeep && closed) {
                        coords.push(coords[0]);
                    }

                    return coords;
                },

                getFeature: function (layer, newGeometry) {
                    return layer.feature ? L.extend({}, layer.feature, { geometry: newGeometry }) : L.GeoJSON.asFeature(newGeometry);
                },

                // @function asFeature(geojson: Object): Object
                // Normalize GeoJSON geometries/features into GeoJSON features.
                asFeature: function (geojson) {
                    if (geojson.type === 'Feature') {
                        return geojson;
                    }

                    return {
                        type: 'Feature',
                        properties: {},
                        geometry: geojson
                    };
                }
            });

            var PointToGeoJSON = {
                toGeoJSON: function () {
                    return L.GeoJSON.getFeature(this, {
                        type: 'Point',
                        coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
                    });
                }
            };

            L.Marker.include(PointToGeoJSON);

            // @namespace CircleMarker
            // @method toGeoJSON(): Object
            // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
            L.Circle.include(PointToGeoJSON);
            L.CircleMarker.include(PointToGeoJSON);

            // @namespace Polyline
            // @method toGeoJSON(): Object
            // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
            L.Polyline.prototype.toGeoJSON = function () {
                var multi = !L.Polyline._flat(this._latlngs);

                var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 1 : 0);

                return L.GeoJSON.getFeature(this, {
                    type: (multi ? 'Multi' : '') + 'LineString',
                    coordinates: coords
                });
            };

            // @namespace Polygon
            // @method toGeoJSON(): Object
            // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
            L.Polygon.prototype.toGeoJSON = function () {
                var holes = !L.Polyline._flat(this._latlngs),
                    multi = holes && !L.Polyline._flat(this._latlngs[0]);

                var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true);

                if (!holes) {
                    coords = [coords];
                }

                return L.GeoJSON.getFeature(this, {
                    type: (multi ? 'Multi' : '') + 'Polygon',
                    coordinates: coords
                });
            };

            // @namespace LayerGroup
            L.LayerGroup.include({
                toMultiPoint: function () {
                    var coords = [];

                    this.eachLayer(function (layer) {
                        coords.push(layer.toGeoJSON().geometry.coordinates);
                    });

                    return L.GeoJSON.getFeature(this, {
                        type: 'MultiPoint',
                        coordinates: coords
                    });
                },

                // @method toGeoJSON(): Object
                // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `GeometryCollection`).
                toGeoJSON: function () {

                    var type = this.feature && this.feature.geometry && this.feature.geometry.type;

                    if (type === 'MultiPoint') {
                        return this.toMultiPoint();
                    }

                    var isGeometryCollection = type === 'GeometryCollection',
                        jsons = [];

                    this.eachLayer(function (layer) {
                        if (layer.toGeoJSON) {
                            var json = layer.toGeoJSON();
                            jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
                        }
                    });

                    if (isGeometryCollection) {
                        return L.GeoJSON.getFeature(this, {
                            geometries: jsons,
                            type: 'GeometryCollection'
                        });
                    }

                    return {
                        type: 'FeatureCollection',
                        features: jsons
                    };
                }
            });

            // @namespace GeoJSON
            // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
            // Creates a GeoJSON layer. Optionally accepts an object in
            // [GeoJSON format](http://geojson.org/geojson-spec.html) to display on the map
            // (you can alternatively add it later with `addData` method) and an `options` object.
            L.geoJSON = function (geojson, options) {
                return new L.GeoJSON(geojson, options);
            };
            // Backward compatibility.
            L.geoJson = L.geoJSON;

            /*
             * @namespace DomEvent
             * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
             */

            // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.


            var eventsKey = '_leaflet_events';

            L.DomEvent = {

                // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
                // Adds a listener function (`fn`) to a particular DOM event type of the
                // element `el`. You can optionally specify the context of the listener
                // (object the `this` keyword will point to). You can also pass several
                // space-separated types (e.g. `'click dblclick'`).

                // @alternative
                // @function on(el: HTMLElement, eventMap: Object, context?: Object): this
                // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
                on: function (obj, types, fn, context) {

                    if (typeof types === 'object') {
                        for (var type in types) {
                            this._on(obj, type, types[type], fn);
                        }
                    } else {
                        types = L.Util.splitWords(types);

                        for (var i = 0, len = types.length; i < len; i++) {
                            this._on(obj, types[i], fn, context);
                        }
                    }

                    return this;
                },

                // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
                // Removes a previously added listener function. If no function is specified,
                // it will remove all the listeners of that particular DOM event from the element.
                // Note that if you passed a custom context to on, you must pass the same
                // context to `off` in order to remove the listener.

                // @alternative
                // @function off(el: HTMLElement, eventMap: Object, context?: Object): this
                // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
                off: function (obj, types, fn, context) {

                    if (typeof types === 'object') {
                        for (var type in types) {
                            this._off(obj, type, types[type], fn);
                        }
                    } else {
                        types = L.Util.splitWords(types);

                        for (var i = 0, len = types.length; i < len; i++) {
                            this._off(obj, types[i], fn, context);
                        }
                    }

                    return this;
                },

                _on: function (obj, type, fn, context) {
                    var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : '');

                    if (obj[eventsKey] && obj[eventsKey][id]) {
                        return this;
                    }

                    var handler = function (e) {
                        return fn.call(context || obj, e || window.event);
                    };

                    var originalHandler = handler;

                    if (L.Browser.pointer && type.indexOf('touch') === 0) {
                        this.addPointerListener(obj, type, handler, id);
                    } else if (L.Browser.touch && type === 'dblclick' && this.addDoubleTapListener) {
                        this.addDoubleTapListener(obj, handler, id);
                    } else if ('addEventListener' in obj) {

                        if (type === 'mousewheel') {
                            obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);
                        } else if (type === 'mouseenter' || type === 'mouseleave') {
                            handler = function (e) {
                                e = e || window.event;
                                if (L.DomEvent._isExternalTarget(obj, e)) {
                                    originalHandler(e);
                                }
                            };
                            obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);
                        } else {
                            if (type === 'click' && L.Browser.android) {
                                handler = function (e) {
                                    return L.DomEvent._filterClick(e, originalHandler);
                                };
                            }
                            obj.addEventListener(type, handler, false);
                        }
                    } else if ('attachEvent' in obj) {
                        obj.attachEvent('on' + type, handler);
                    }

                    obj[eventsKey] = obj[eventsKey] || {};
                    obj[eventsKey][id] = handler;

                    return this;
                },

                _off: function (obj, type, fn, context) {

                    var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : ''),
                        handler = obj[eventsKey] && obj[eventsKey][id];

                    if (!handler) {
                        return this;
                    }

                    if (L.Browser.pointer && type.indexOf('touch') === 0) {
                        this.removePointerListener(obj, type, id);
                    } else if (L.Browser.touch && type === 'dblclick' && this.removeDoubleTapListener) {
                        this.removeDoubleTapListener(obj, id);
                    } else if ('removeEventListener' in obj) {

                        if (type === 'mousewheel') {
                            obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);
                        } else {
                            obj.removeEventListener(type === 'mouseenter' ? 'mouseover' : type === 'mouseleave' ? 'mouseout' : type, handler, false);
                        }
                    } else if ('detachEvent' in obj) {
                        obj.detachEvent('on' + type, handler);
                    }

                    obj[eventsKey][id] = null;

                    return this;
                },

                // @function stopPropagation(ev: DOMEvent): this
                // Stop the given event from propagation to parent elements. Used inside the listener functions:
                // ```js
                // L.DomEvent.on(div, 'click', function (ev) {
                // 	L.DomEvent.stopPropagation(ev);
                // });
                // ```
                stopPropagation: function (e) {

                    if (e.stopPropagation) {
                        e.stopPropagation();
                    } else if (e.originalEvent) {
                        // In case of Leaflet event.
                        e.originalEvent._stopped = true;
                    } else {
                        e.cancelBubble = true;
                    }
                    L.DomEvent._skipped(e);

                    return this;
                },

                // @function disableScrollPropagation(el: HTMLElement): this
                // Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
                disableScrollPropagation: function (el) {
                    return L.DomEvent.on(el, 'mousewheel', L.DomEvent.stopPropagation);
                },

                // @function disableClickPropagation(el: HTMLElement): this
                // Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
                // `'mousedown'` and `'touchstart'` events (plus browser variants).
                disableClickPropagation: function (el) {
                    var stop = L.DomEvent.stopPropagation;

                    L.DomEvent.on(el, L.Draggable.START.join(' '), stop);

                    return L.DomEvent.on(el, {
                        click: L.DomEvent._fakeStop,
                        dblclick: stop
                    });
                },

                // @function preventDefault(ev: DOMEvent): this
                // Prevents the default action of the DOM Event `ev` from happening (such as
                // following a link in the href of the a element, or doing a POST request
                // with page reload when a `<form>` is submitted).
                // Use it inside listener functions.
                preventDefault: function (e) {

                    if (e.preventDefault) {
                        e.preventDefault();
                    } else {
                        e.returnValue = false;
                    }
                    return this;
                },

                // @function stop(ev): this
                // Does `stopPropagation` and `preventDefault` at the same time.
                stop: function (e) {
                    return L.DomEvent.preventDefault(e).stopPropagation(e);
                },

                // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
                // Gets normalized mouse position from a DOM event relative to the
                // `container` or to the whole page if not specified.
                getMousePosition: function (e, container) {
                    if (!container) {
                        return new L.Point(e.clientX, e.clientY);
                    }

                    var rect = container.getBoundingClientRect();

                    return new L.Point(e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop);
                },

                // Chrome on Win scrolls double the pixels as in other platforms (see #4538),
                // and Firefox scrolls device pixels, not CSS pixels
                _wheelPxFactor: L.Browser.win && L.Browser.chrome ? 2 : L.Browser.gecko ? window.devicePixelRatio : 1,

                // @function getWheelDelta(ev: DOMEvent): Number
                // Gets normalized wheel delta from a mousewheel DOM event, in vertical
                // pixels scrolled (negative if scrolling down).
                // Events from pointing devices without precise scrolling are mapped to
                // a best guess of 60 pixels.
                getWheelDelta: function (e) {
                    return L.Browser.edge ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
                    e.deltaY && e.deltaMode === 0 ? -e.deltaY / L.DomEvent._wheelPxFactor : // Pixels
                    e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : // Lines
                    e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : // Pages
                    e.deltaX || e.deltaZ ? 0 : // Skip horizontal/depth wheel events
                    e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
                    e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : // Legacy Moz lines
                    e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
                    0;
                },

                _skipEvents: {},

                _fakeStop: function (e) {
                    // fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
                    L.DomEvent._skipEvents[e.type] = true;
                },

                _skipped: function (e) {
                    var skipped = this._skipEvents[e.type];
                    // reset when checking, as it's only used in map container and propagates outside of the map
                    this._skipEvents[e.type] = false;
                    return skipped;
                },

                // check if element really left/entered the event target (for mouseenter/mouseleave)
                _isExternalTarget: function (el, e) {

                    var related = e.relatedTarget;

                    if (!related) {
                        return true;
                    }

                    try {
                        while (related && related !== el) {
                            related = related.parentNode;
                        }
                    } catch (err) {
                        return false;
                    }
                    return related !== el;
                },

                // this is a horrible workaround for a bug in Android where a single touch triggers two click events
                _filterClick: function (e, handler) {
                    var timeStamp = e.timeStamp || e.originalEvent && e.originalEvent.timeStamp,
                        elapsed = L.DomEvent._lastClick && timeStamp - L.DomEvent._lastClick;

                    // are they closer together than 500ms yet more than 100ms?
                    // Android typically triggers them ~300ms apart while multiple listeners
                    // on the same event should be triggered far faster;
                    // or check if click is simulated on the element, and if it is, reject any non-simulated events

                    if (elapsed && elapsed > 100 && elapsed < 500 || e.target._simulatedClick && !e._simulated) {
                        L.DomEvent.stop(e);
                        return;
                    }
                    L.DomEvent._lastClick = timeStamp;

                    handler(e);
                }
            };

            // @function addListener(…): this
            // Alias to [`L.DomEvent.on`](#domevent-on)
            L.DomEvent.addListener = L.DomEvent.on;

            // @function removeListener(…): this
            // Alias to [`L.DomEvent.off`](#domevent-off)
            L.DomEvent.removeListener = L.DomEvent.off;

            /*
             * @class Draggable
             * @aka L.Draggable
             * @inherits Evented
             *
             * A class for making DOM elements draggable (including touch support).
             * Used internally for map and marker dragging. Only works for elements
             * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
             *
             * @example
             * ```js
             * var draggable = new L.Draggable(elementToDrag);
             * draggable.enable();
             * ```
             */

            L.Draggable = L.Evented.extend({

                options: {
                    // @option clickTolerance: Number = 3
                    // The max number of pixels a user can shift the mouse pointer during a click
                    // for it to be considered a valid click (as opposed to a mouse drag).
                    clickTolerance: 3
                },

                statics: {
                    START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
                    END: {
                        mousedown: 'mouseup',
                        touchstart: 'touchend',
                        pointerdown: 'touchend',
                        MSPointerDown: 'touchend'
                    },
                    MOVE: {
                        mousedown: 'mousemove',
                        touchstart: 'touchmove',
                        pointerdown: 'touchmove',
                        MSPointerDown: 'touchmove'
                    }
                },

                // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline: Boolean)
                // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
                initialize: function (element, dragStartTarget, preventOutline) {
                    this._element = element;
                    this._dragStartTarget = dragStartTarget || element;
                    this._preventOutline = preventOutline;
                },

                // @method enable()
                // Enables the dragging ability
                enable: function () {
                    if (this._enabled) {
                        return;
                    }

                    L.DomEvent.on(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

                    this._enabled = true;
                },

                // @method disable()
                // Disables the dragging ability
                disable: function () {
                    if (!this._enabled) {
                        return;
                    }

                    L.DomEvent.off(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

                    this._enabled = false;
                    this._moved = false;
                },

                _onDown: function (e) {
                    // Ignore simulated events, since we handle both touch and
                    // mouse explicitly; otherwise we risk getting duplicates of
                    // touch events, see #4315.
                    // Also ignore the event if disabled; this happens in IE11
                    // under some circumstances, see #3666.
                    if (e._simulated || !this._enabled) {
                        return;
                    }

                    this._moved = false;

                    if (L.DomUtil.hasClass(this._element, 'leaflet-zoom-anim')) {
                        return;
                    }

                    if (L.Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches || !this._enabled) {
                        return;
                    }
                    L.Draggable._dragging = true; // Prevent dragging multiple objects at once.

                    if (this._preventOutline) {
                        L.DomUtil.preventOutline(this._element);
                    }

                    L.DomUtil.disableImageDrag();
                    L.DomUtil.disableTextSelection();

                    if (this._moving) {
                        return;
                    }

                    // @event down: Event
                    // Fired when a drag is about to start.
                    this.fire('down');

                    var first = e.touches ? e.touches[0] : e;

                    this._startPoint = new L.Point(first.clientX, first.clientY);

                    L.DomEvent.on(document, L.Draggable.MOVE[e.type], this._onMove, this).on(document, L.Draggable.END[e.type], this._onUp, this);
                },

                _onMove: function (e) {
                    // Ignore simulated events, since we handle both touch and
                    // mouse explicitly; otherwise we risk getting duplicates of
                    // touch events, see #4315.
                    // Also ignore the event if disabled; this happens in IE11
                    // under some circumstances, see #3666.
                    if (e._simulated || !this._enabled) {
                        return;
                    }

                    if (e.touches && e.touches.length > 1) {
                        this._moved = true;
                        return;
                    }

                    var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,
                        newPoint = new L.Point(first.clientX, first.clientY),
                        offset = newPoint.subtract(this._startPoint);

                    if (!offset.x && !offset.y) {
                        return;
                    }
                    if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
                        return;
                    }

                    L.DomEvent.preventDefault(e);

                    if (!this._moved) {
                        // @event dragstart: Event
                        // Fired when a drag starts
                        this.fire('dragstart');

                        this._moved = true;
                        this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

                        L.DomUtil.addClass(document.body, 'leaflet-dragging');

                        this._lastTarget = e.target || e.srcElement;
                        // IE and Edge do not give the <use> element, so fetch it
                        // if necessary
                        if (window.SVGElementInstance && this._lastTarget instanceof SVGElementInstance) {
                            this._lastTarget = this._lastTarget.correspondingUseElement;
                        }
                        L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
                    }

                    this._newPos = this._startPos.add(offset);
                    this._moving = true;

                    L.Util.cancelAnimFrame(this._animRequest);
                    this._lastEvent = e;
                    this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true);
                },

                _updatePosition: function () {
                    var e = { originalEvent: this._lastEvent };

                    // @event predrag: Event
                    // Fired continuously during dragging *before* each corresponding
                    // update of the element's position.
                    this.fire('predrag', e);
                    L.DomUtil.setPosition(this._element, this._newPos);

                    // @event drag: Event
                    // Fired continuously during dragging.
                    this.fire('drag', e);
                },

                _onUp: function (e) {
                    // Ignore simulated events, since we handle both touch and
                    // mouse explicitly; otherwise we risk getting duplicates of
                    // touch events, see #4315.
                    // Also ignore the event if disabled; this happens in IE11
                    // under some circumstances, see #3666.
                    if (e._simulated || !this._enabled) {
                        return;
                    }

                    L.DomUtil.removeClass(document.body, 'leaflet-dragging');

                    if (this._lastTarget) {
                        L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
                        this._lastTarget = null;
                    }

                    for (var i in L.Draggable.MOVE) {
                        L.DomEvent.off(document, L.Draggable.MOVE[i], this._onMove, this).off(document, L.Draggable.END[i], this._onUp, this);
                    }

                    L.DomUtil.enableImageDrag();
                    L.DomUtil.enableTextSelection();

                    if (this._moved && this._moving) {
                        // ensure drag is not fired after dragend
                        L.Util.cancelAnimFrame(this._animRequest);

                        // @event dragend: DragEndEvent
                        // Fired when the drag ends.
                        this.fire('dragend', {
                            distance: this._newPos.distanceTo(this._startPos)
                        });
                    }

                    this._moving = false;
                    L.Draggable._dragging = false;
                }
            });

            /*
            	L.Handler is a base class for handler classes that are used internally to inject
            	interaction features like dragging to classes like Map and Marker.
            */

            // @class Handler
            // @aka L.Handler
            // Abstract class for map interaction handlers

            L.Handler = L.Class.extend({
                initialize: function (map) {
                    this._map = map;
                },

                // @method enable(): this
                // Enables the handler
                enable: function () {
                    if (this._enabled) {
                        return this;
                    }

                    this._enabled = true;
                    this.addHooks();
                    return this;
                },

                // @method disable(): this
                // Disables the handler
                disable: function () {
                    if (!this._enabled) {
                        return this;
                    }

                    this._enabled = false;
                    this.removeHooks();
                    return this;
                },

                // @method enabled(): Boolean
                // Returns `true` if the handler is enabled
                enabled: function () {
                    return !!this._enabled;
                }

                // @section Extension methods
                // Classes inheriting from `Handler` must implement the two following methods:
                // @method addHooks()
                // Called when the handler is enabled, should add event hooks.
                // @method removeHooks()
                // Called when the handler is disabled, should remove the event hooks added previously.
            });

            /*
             * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
             */

            // @namespace Map
            // @section Interaction Options
            L.Map.mergeOptions({
                // @option dragging: Boolean = true
                // Whether the map be draggable with mouse/touch or not.
                dragging: true,

                // @section Panning Inertia Options
                // @option inertia: Boolean = *
                // If enabled, panning of the map will have an inertia effect where
                // the map builds momentum while dragging and continues moving in
                // the same direction for some time. Feels especially nice on touch
                // devices. Enabled by default unless running on old Android devices.
                inertia: !L.Browser.android23,

                // @option inertiaDeceleration: Number = 3000
                // The rate with which the inertial movement slows down, in pixels/second².
                inertiaDeceleration: 3400, // px/s^2

                // @option inertiaMaxSpeed: Number = Infinity
                // Max speed of the inertial movement, in pixels/second.
                inertiaMaxSpeed: Infinity, // px/s

                // @option easeLinearity: Number = 0.2
                easeLinearity: 0.2,

                // TODO refactor, move to CRS
                // @option worldCopyJump: Boolean = false
                // With this option enabled, the map tracks when you pan to another "copy"
                // of the world and seamlessly jumps to the original one so that all overlays
                // like markers and vector layers are still visible.
                worldCopyJump: false,

                // @option maxBoundsViscosity: Number = 0.0
                // If `maxBounds` is set, this option will control how solid the bounds
                // are when dragging the map around. The default value of `0.0` allows the
                // user to drag outside the bounds at normal speed, higher values will
                // slow down map dragging outside bounds, and `1.0` makes the bounds fully
                // solid, preventing the user from dragging outside the bounds.
                maxBoundsViscosity: 0.0
            });

            L.Map.Drag = L.Handler.extend({
                addHooks: function () {
                    if (!this._draggable) {
                        var map = this._map;

                        this._draggable = new L.Draggable(map._mapPane, map._container);

                        this._draggable.on({
                            down: this._onDown,
                            dragstart: this._onDragStart,
                            drag: this._onDrag,
                            dragend: this._onDragEnd
                        }, this);

                        this._draggable.on('predrag', this._onPreDragLimit, this);
                        if (map.options.worldCopyJump) {
                            this._draggable.on('predrag', this._onPreDragWrap, this);
                            map.on('zoomend', this._onZoomEnd, this);

                            map.whenReady(this._onZoomEnd, this);
                        }
                    }
                    L.DomUtil.addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
                    this._draggable.enable();
                    this._positions = [];
                    this._times = [];
                },

                removeHooks: function () {
                    L.DomUtil.removeClass(this._map._container, 'leaflet-grab');
                    L.DomUtil.removeClass(this._map._container, 'leaflet-touch-drag');
                    this._draggable.disable();
                },

                moved: function () {
                    return this._draggable && this._draggable._moved;
                },

                moving: function () {
                    return this._draggable && this._draggable._moving;
                },

                _onDown: function () {
                    this._map._stop();
                },

                _onDragStart: function () {
                    var map = this._map;

                    if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
                        var bounds = L.latLngBounds(this._map.options.maxBounds);

                        this._offsetLimit = L.bounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));

                        this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
                    } else {
                        this._offsetLimit = null;
                    }

                    map.fire('movestart').fire('dragstart');

                    if (map.options.inertia) {
                        this._positions = [];
                        this._times = [];
                    }
                },

                _onDrag: function (e) {
                    if (this._map.options.inertia) {
                        var time = this._lastTime = +new Date(),
                            pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

                        this._positions.push(pos);
                        this._times.push(time);

                        if (time - this._times[0] > 50) {
                            this._positions.shift();
                            this._times.shift();
                        }
                    }

                    this._map.fire('move', e).fire('drag', e);
                },

                _onZoomEnd: function () {
                    var pxCenter = this._map.getSize().divideBy(2),
                        pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

                    this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
                    this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
                },

                _viscousLimit: function (value, threshold) {
                    return value - (value - threshold) * this._viscosity;
                },

                _onPreDragLimit: function () {
                    if (!this._viscosity || !this._offsetLimit) {
                        return;
                    }

                    var offset = this._draggable._newPos.subtract(this._draggable._startPos);

                    var limit = this._offsetLimit;
                    if (offset.x < limit.min.x) {
                        offset.x = this._viscousLimit(offset.x, limit.min.x);
                    }
                    if (offset.y < limit.min.y) {
                        offset.y = this._viscousLimit(offset.y, limit.min.y);
                    }
                    if (offset.x > limit.max.x) {
                        offset.x = this._viscousLimit(offset.x, limit.max.x);
                    }
                    if (offset.y > limit.max.y) {
                        offset.y = this._viscousLimit(offset.y, limit.max.y);
                    }

                    this._draggable._newPos = this._draggable._startPos.add(offset);
                },

                _onPreDragWrap: function () {
                    // TODO refactor to be able to adjust map pane position after zoom
                    var worldWidth = this._worldWidth,
                        halfWidth = Math.round(worldWidth / 2),
                        dx = this._initialWorldOffset,
                        x = this._draggable._newPos.x,
                        newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
                        newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
                        newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

                    this._draggable._absPos = this._draggable._newPos.clone();
                    this._draggable._newPos.x = newX;
                },

                _onDragEnd: function (e) {
                    var map = this._map,
                        options = map.options,
                        noInertia = !options.inertia || this._times.length < 2;

                    map.fire('dragend', e);

                    if (noInertia) {
                        map.fire('moveend');
                    } else {

                        var direction = this._lastPos.subtract(this._positions[0]),
                            duration = (this._lastTime - this._times[0]) / 1000,
                            ease = options.easeLinearity,
                            speedVector = direction.multiplyBy(ease / duration),
                            speed = speedVector.distanceTo([0, 0]),
                            limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
                            limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),
                            decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
                            offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

                        if (!offset.x && !offset.y) {
                            map.fire('moveend');
                        } else {
                            offset = map._limitOffset(offset, map.options.maxBounds);

                            L.Util.requestAnimFrame(function () {
                                map.panBy(offset, {
                                    duration: decelerationDuration,
                                    easeLinearity: ease,
                                    noMoveStart: true,
                                    animate: true
                                });
                            });
                        }
                    }
                }
            });

            // @section Handlers
            // @property dragging: Handler
            // Map dragging handler (by both mouse and touch).
            L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);

            /*
             * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
             */

            // @namespace Map
            // @section Interaction Options

            L.Map.mergeOptions({
                // @option doubleClickZoom: Boolean|String = true
                // Whether the map can be zoomed in by double clicking on it and
                // zoomed out by double clicking while holding shift. If passed
                // `'center'`, double-click zoom will zoom to the center of the
                //  view regardless of where the mouse was.
                doubleClickZoom: true
            });

            L.Map.DoubleClickZoom = L.Handler.extend({
                addHooks: function () {
                    this._map.on('dblclick', this._onDoubleClick, this);
                },

                removeHooks: function () {
                    this._map.off('dblclick', this._onDoubleClick, this);
                },

                _onDoubleClick: function (e) {
                    var map = this._map,
                        oldZoom = map.getZoom(),
                        delta = map.options.zoomDelta,
                        zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

                    if (map.options.doubleClickZoom === 'center') {
                        map.setZoom(zoom);
                    } else {
                        map.setZoomAround(e.containerPoint, zoom);
                    }
                }
            });

            // @section Handlers
            //
            // Map properties include interaction handlers that allow you to control
            // interaction behavior in runtime, enabling or disabling certain features such
            // as dragging or touch zoom (see `Handler` methods). For example:
            //
            // ```js
            // map.doubleClickZoom.disable();
            // ```
            //
            // @property doubleClickZoom: Handler
            // Double click zoom handler.
            L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);

            /*
             * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
             */

            // @namespace Map
            // @section Interaction Options
            L.Map.mergeOptions({
                // @section Mousewheel options
                // @option scrollWheelZoom: Boolean|String = true
                // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
                // it will zoom to the center of the view regardless of where the mouse was.
                scrollWheelZoom: true,

                // @option wheelDebounceTime: Number = 40
                // Limits the rate at which a wheel can fire (in milliseconds). By default
                // user can't zoom via wheel more often than once per 40 ms.
                wheelDebounceTime: 40,

                // @option wheelPxPerZoomLevel: Number = 60
                // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
                // mean a change of one full zoom level. Smaller values will make wheel-zooming
                // faster (and vice versa).
                wheelPxPerZoomLevel: 60
            });

            L.Map.ScrollWheelZoom = L.Handler.extend({
                addHooks: function () {
                    L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);

                    this._delta = 0;
                },

                removeHooks: function () {
                    L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll, this);
                },

                _onWheelScroll: function (e) {
                    var delta = L.DomEvent.getWheelDelta(e);

                    var debounce = this._map.options.wheelDebounceTime;

                    this._delta += delta;
                    this._lastMousePos = this._map.mouseEventToContainerPoint(e);

                    if (!this._startTime) {
                        this._startTime = +new Date();
                    }

                    var left = Math.max(debounce - (+new Date() - this._startTime), 0);

                    clearTimeout(this._timer);
                    this._timer = setTimeout(L.bind(this._performZoom, this), left);

                    L.DomEvent.stop(e);
                },

                _performZoom: function () {
                    var map = this._map,
                        zoom = map.getZoom(),
                        snap = this._map.options.zoomSnap || 0;

                    map._stop(); // stop panning and fly animations if any

                    // map the delta with a sigmoid function to -4..4 range leaning on -1..1
                    var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
                        d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
                        d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
                        delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

                    this._delta = 0;
                    this._startTime = null;

                    if (!delta) {
                        return;
                    }

                    if (map.options.scrollWheelZoom === 'center') {
                        map.setZoom(zoom + delta);
                    } else {
                        map.setZoomAround(this._lastMousePos, zoom + delta);
                    }
                }
            });

            // @section Handlers
            // @property scrollWheelZoom: Handler
            // Scroll wheel zoom handler.
            L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);

            /*
             * @class PosAnimation
             * @aka L.PosAnimation
             * @inherits Evented
             * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
             *
             * @example
             * ```js
             * var fx = new L.PosAnimation();
             * fx.run(el, [300, 500], 0.5);
             * ```
             *
             * @constructor L.PosAnimation()
             * Creates a `PosAnimation` object.
             *
             */

            L.PosAnimation = L.Evented.extend({

                // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
                // Run an animation of a given element to a new position, optionally setting
                // duration in seconds (`0.25` by default) and easing linearity factor (3rd
                // argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
                // `0.5` by default).
                run: function (el, newPos, duration, easeLinearity) {
                    this.stop();

                    this._el = el;
                    this._inProgress = true;
                    this._duration = duration || 0.25;
                    this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

                    this._startPos = L.DomUtil.getPosition(el);
                    this._offset = newPos.subtract(this._startPos);
                    this._startTime = +new Date();

                    // @event start: Event
                    // Fired when the animation starts
                    this.fire('start');

                    this._animate();
                },

                // @method stop()
                // Stops the animation (if currently running).
                stop: function () {
                    if (!this._inProgress) {
                        return;
                    }

                    this._step(true);
                    this._complete();
                },

                _animate: function () {
                    // animation loop
                    this._animId = L.Util.requestAnimFrame(this._animate, this);
                    this._step();
                },

                _step: function (round) {
                    var elapsed = +new Date() - this._startTime,
                        duration = this._duration * 1000;

                    if (elapsed < duration) {
                        this._runFrame(this._easeOut(elapsed / duration), round);
                    } else {
                        this._runFrame(1);
                        this._complete();
                    }
                },

                _runFrame: function (progress, round) {
                    var pos = this._startPos.add(this._offset.multiplyBy(progress));
                    if (round) {
                        pos._round();
                    }
                    L.DomUtil.setPosition(this._el, pos);

                    // @event step: Event
                    // Fired continuously during the animation.
                    this.fire('step');
                },

                _complete: function () {
                    L.Util.cancelAnimFrame(this._animId);

                    this._inProgress = false;
                    // @event end: Event
                    // Fired when the animation ends.
                    this.fire('end');
                },

                _easeOut: function (t) {
                    return 1 - Math.pow(1 - t, this._easeOutPower);
                }
            });

            /*
             * Extends L.Map to handle panning animations.
             */

            L.Map.include({

                setView: function (center, zoom, options) {

                    zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
                    center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
                    options = options || {};

                    this._stop();

                    if (this._loaded && !options.reset && options !== true) {

                        if (options.animate !== undefined) {
                            options.zoom = L.extend({ animate: options.animate }, options.zoom);
                            options.pan = L.extend({ animate: options.animate, duration: options.duration }, options.pan);
                        }

                        // try animating pan or zoom
                        var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);

                        if (moved) {
                            // prevent resize handler call, the view will refresh after animation anyway
                            clearTimeout(this._sizeTimer);
                            return this;
                        }
                    }

                    // animation didn't start, just reset the map view
                    this._resetView(center, zoom);

                    return this;
                },

                panBy: function (offset, options) {
                    offset = L.point(offset).round();
                    options = options || {};

                    if (!offset.x && !offset.y) {
                        return this.fire('moveend');
                    }
                    // If we pan too far, Chrome gets issues with tiles
                    // and makes them disappear or appear in the wrong place (slightly offset) #2602
                    if (options.animate !== true && !this.getSize().contains(offset)) {
                        this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
                        return this;
                    }

                    if (!this._panAnim) {
                        this._panAnim = new L.PosAnimation();

                        this._panAnim.on({
                            'step': this._onPanTransitionStep,
                            'end': this._onPanTransitionEnd
                        }, this);
                    }

                    // don't fire movestart if animating inertia
                    if (!options.noMoveStart) {
                        this.fire('movestart');
                    }

                    // animate pan unless animate: false specified
                    if (options.animate !== false) {
                        L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

                        var newPos = this._getMapPanePos().subtract(offset).round();
                        this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
                    } else {
                        this._rawPanBy(offset);
                        this.fire('move').fire('moveend');
                    }

                    return this;
                },

                _onPanTransitionStep: function () {
                    this.fire('move');
                },

                _onPanTransitionEnd: function () {
                    L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
                    this.fire('moveend');
                },

                _tryAnimatedPan: function (center, options) {
                    // difference between the new and current centers in pixels
                    var offset = this._getCenterOffset(center)._floor();

                    // don't animate too far unless animate: true specified in options
                    if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
                        return false;
                    }

                    this.panBy(offset, options);

                    return true;
                }
            });

            /*
             * Extends L.Map to handle zoom animations.
             */

            // @namespace Map
            // @section Animation Options
            L.Map.mergeOptions({
                // @option zoomAnimation: Boolean = true
                // Whether the map zoom animation is enabled. By default it's enabled
                // in all browsers that support CSS3 Transitions except Android.
                zoomAnimation: true,

                // @option zoomAnimationThreshold: Number = 4
                // Won't animate zoom if the zoom difference exceeds this value.
                zoomAnimationThreshold: 4
            });

            var zoomAnimated = L.DomUtil.TRANSITION && L.Browser.any3d && !L.Browser.mobileOpera;

            if (zoomAnimated) {

                L.Map.addInitHook(function () {
                    // don't animate on browsers without hardware-accelerated transitions or old Android/Opera
                    this._zoomAnimated = this.options.zoomAnimation;

                    // zoom transitions run with the same duration for all layers, so if one of transitionend events
                    // happens after starting zoom animation (propagating to the map pane), we know that it ended globally
                    if (this._zoomAnimated) {

                        this._createAnimProxy();

                        L.DomEvent.on(this._proxy, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
                    }
                });
            }

            L.Map.include(!zoomAnimated ? {} : {

                _createAnimProxy: function () {

                    var proxy = this._proxy = L.DomUtil.create('div', 'leaflet-proxy leaflet-zoom-animated');
                    this._panes.mapPane.appendChild(proxy);

                    this.on('zoomanim', function (e) {
                        var prop = L.DomUtil.TRANSFORM,
                            transform = proxy.style[prop];

                        L.DomUtil.setTransform(proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

                        // workaround for case when transform is the same and so transitionend event is not fired
                        if (transform === proxy.style[prop] && this._animatingZoom) {
                            this._onZoomTransitionEnd();
                        }
                    }, this);

                    this.on('load moveend', function () {
                        var c = this.getCenter(),
                            z = this.getZoom();
                        L.DomUtil.setTransform(proxy, this.project(c, z), this.getZoomScale(z, 1));
                    }, this);
                },

                _catchTransitionEnd: function (e) {
                    if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
                        this._onZoomTransitionEnd();
                    }
                },

                _nothingToAnimate: function () {
                    return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
                },

                _tryAnimatedZoom: function (center, zoom, options) {

                    if (this._animatingZoom) {
                        return true;
                    }

                    options = options || {};

                    // don't animate if disabled, not supported or zoom difference is too large
                    if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {
                        return false;
                    }

                    // offset is the pixel coords of the zoom origin relative to the current center
                    var scale = this.getZoomScale(zoom),
                        offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

                    // don't animate if the zoom origin isn't within one screen from the current center, unless forced
                    if (options.animate !== true && !this.getSize().contains(offset)) {
                        return false;
                    }

                    L.Util.requestAnimFrame(function () {
                        this._moveStart(true)._animateZoom(center, zoom, true);
                    }, this);

                    return true;
                },

                _animateZoom: function (center, zoom, startAnim, noUpdate) {
                    if (startAnim) {
                        this._animatingZoom = true;

                        // remember what center/zoom to set after animation
                        this._animateToCenter = center;
                        this._animateToZoom = zoom;

                        L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');
                    }

                    // @event zoomanim: ZoomAnimEvent
                    // Fired on every frame of a zoom animation
                    this.fire('zoomanim', {
                        center: center,
                        zoom: zoom,
                        noUpdate: noUpdate
                    });

                    // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
                    setTimeout(L.bind(this._onZoomTransitionEnd, this), 250);
                },

                _onZoomTransitionEnd: function () {
                    if (!this._animatingZoom) {
                        return;
                    }

                    L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

                    this._animatingZoom = false;

                    this._move(this._animateToCenter, this._animateToZoom);

                    // This anim frame should prevent an obscure iOS webkit tile loading race condition.
                    L.Util.requestAnimFrame(function () {
                        this._moveEnd(true);
                    }, this);
                }
            });

            // @namespace Map
            // @section Methods for modifying map state
            L.Map.include({

                // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
                // Sets the view of the map (geographical center and zoom) performing a smooth
                // pan-zoom animation.
                flyTo: function (targetCenter, targetZoom, options) {

                    options = options || {};
                    if (options.animate === false || !L.Browser.any3d) {
                        return this.setView(targetCenter, targetZoom, options);
                    }

                    this._stop();

                    var from = this.project(this.getCenter()),
                        to = this.project(targetCenter),
                        size = this.getSize(),
                        startZoom = this._zoom;

                    targetCenter = L.latLng(targetCenter);
                    targetZoom = targetZoom === undefined ? startZoom : targetZoom;

                    var w0 = Math.max(size.x, size.y),
                        w1 = w0 * this.getZoomScale(startZoom, targetZoom),
                        u1 = to.distanceTo(from) || 1,
                        rho = 1.42,
                        rho2 = rho * rho;

                    function r(i) {
                        var s1 = i ? -1 : 1,
                            s2 = i ? w1 : w0,
                            t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
                            b1 = 2 * s2 * rho2 * u1,
                            b = t1 / b1,
                            sq = Math.sqrt(b * b + 1) - b;

                        // workaround for floating point precision bug when sq = 0, log = -Infinite,
                        // thus triggering an infinite loop in flyTo
                        var log = sq < 0.000000001 ? -18 : Math.log(sq);

                        return log;
                    }

                    function sinh(n) {
                        return (Math.exp(n) - Math.exp(-n)) / 2;
                    }
                    function cosh(n) {
                        return (Math.exp(n) + Math.exp(-n)) / 2;
                    }
                    function tanh(n) {
                        return sinh(n) / cosh(n);
                    }

                    var r0 = r(0);

                    function w(s) {
                        return w0 * (cosh(r0) / cosh(r0 + rho * s));
                    }
                    function u(s) {
                        return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
                    }

                    function easeOut(t) {
                        return 1 - Math.pow(1 - t, 1.5);
                    }

                    var start = Date.now(),
                        S = (r(1) - r0) / rho,
                        duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

                    function frame() {
                        var t = (Date.now() - start) / duration,
                            s = easeOut(t) * S;

                        if (t <= 1) {
                            this._flyToFrame = L.Util.requestAnimFrame(frame, this);

                            this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), { flyTo: true });
                        } else {
                            this._move(targetCenter, targetZoom)._moveEnd(true);
                        }
                    }

                    this._moveStart(true);

                    frame.call(this);
                    return this;
                },

                // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
                // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
                // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
                flyToBounds: function (bounds, options) {
                    var target = this._getBoundsCenterZoom(bounds, options);
                    return this.flyTo(target.center, target.zoom, options);
                }
            });

            /*
             * Extends the event handling code with double tap support for mobile browsers.
             */

            L.extend(L.DomEvent, {

                _touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
                _touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',

                // inspired by Zepto touch code by Thomas Fuchs
                addDoubleTapListener: function (obj, handler, id) {
                    var last,
                        touch,
                        doubleTap = false,
                        delay = 250;

                    function onTouchStart(e) {
                        var count;

                        if (L.Browser.pointer) {
                            count = L.DomEvent._pointersCount;
                        } else {
                            count = e.touches.length;
                        }

                        if (count > 1) {
                            return;
                        }

                        var now = Date.now(),
                            delta = now - (last || now);

                        touch = e.touches ? e.touches[0] : e;
                        doubleTap = delta > 0 && delta <= delay;
                        last = now;
                    }

                    function onTouchEnd() {
                        if (doubleTap && !touch.cancelBubble) {
                            if (L.Browser.pointer) {
                                // work around .type being readonly with MSPointer* events
                                var newTouch = {},
                                    prop,
                                    i;

                                for (i in touch) {
                                    prop = touch[i];
                                    newTouch[i] = prop && prop.bind ? prop.bind(touch) : prop;
                                }
                                touch = newTouch;
                            }
                            touch.type = 'dblclick';
                            handler(touch);
                            last = null;
                        }
                    }

                    var pre = '_leaflet_',
                        touchstart = this._touchstart,
                        touchend = this._touchend;

                    obj[pre + touchstart + id] = onTouchStart;
                    obj[pre + touchend + id] = onTouchEnd;
                    obj[pre + 'dblclick' + id] = handler;

                    obj.addEventListener(touchstart, onTouchStart, false);
                    obj.addEventListener(touchend, onTouchEnd, false);

                    // On some platforms (notably, chrome on win10 + touchscreen + mouse),
                    // the browser doesn't fire touchend/pointerup events but does fire
                    // native dblclicks. See #4127.
                    if (!L.Browser.edge) {
                        obj.addEventListener('dblclick', handler, false);
                    }

                    return this;
                },

                removeDoubleTapListener: function (obj, id) {
                    var pre = '_leaflet_',
                        touchstart = obj[pre + this._touchstart + id],
                        touchend = obj[pre + this._touchend + id],
                        dblclick = obj[pre + 'dblclick' + id];

                    obj.removeEventListener(this._touchstart, touchstart, false);
                    obj.removeEventListener(this._touchend, touchend, false);
                    if (!L.Browser.edge) {
                        obj.removeEventListener('dblclick', dblclick, false);
                    }

                    return this;
                }
            });

            /*
             * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
             */

            L.extend(L.DomEvent, {

                POINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',
                POINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',
                POINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',
                POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',
                TAG_WHITE_LIST: ['INPUT', 'SELECT', 'OPTION'],

                _pointers: {},
                _pointersCount: 0,

                // Provides a touch events wrapper for (ms)pointer events.
                // ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

                addPointerListener: function (obj, type, handler, id) {

                    if (type === 'touchstart') {
                        this._addPointerStart(obj, handler, id);
                    } else if (type === 'touchmove') {
                        this._addPointerMove(obj, handler, id);
                    } else if (type === 'touchend') {
                        this._addPointerEnd(obj, handler, id);
                    }

                    return this;
                },

                removePointerListener: function (obj, type, id) {
                    var handler = obj['_leaflet_' + type + id];

                    if (type === 'touchstart') {
                        obj.removeEventListener(this.POINTER_DOWN, handler, false);
                    } else if (type === 'touchmove') {
                        obj.removeEventListener(this.POINTER_MOVE, handler, false);
                    } else if (type === 'touchend') {
                        obj.removeEventListener(this.POINTER_UP, handler, false);
                        obj.removeEventListener(this.POINTER_CANCEL, handler, false);
                    }

                    return this;
                },

                _addPointerStart: function (obj, handler, id) {
                    var onDown = L.bind(function (e) {
                        if (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
                            // In IE11, some touch events needs to fire for form controls, or
                            // the controls will stop working. We keep a whitelist of tag names that
                            // need these events. For other target tags, we prevent default on the event.
                            if (this.TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
                                L.DomEvent.preventDefault(e);
                            } else {
                                return;
                            }
                        }

                        this._handlePointer(e, handler);
                    }, this);

                    obj['_leaflet_touchstart' + id] = onDown;
                    obj.addEventListener(this.POINTER_DOWN, onDown, false);

                    // need to keep track of what pointers and how many are active to provide e.touches emulation
                    if (!this._pointerDocListener) {
                        var pointerUp = L.bind(this._globalPointerUp, this);

                        // we listen documentElement as any drags that end by moving the touch off the screen get fired there
                        document.documentElement.addEventListener(this.POINTER_DOWN, L.bind(this._globalPointerDown, this), true);
                        document.documentElement.addEventListener(this.POINTER_MOVE, L.bind(this._globalPointerMove, this), true);
                        document.documentElement.addEventListener(this.POINTER_UP, pointerUp, true);
                        document.documentElement.addEventListener(this.POINTER_CANCEL, pointerUp, true);

                        this._pointerDocListener = true;
                    }
                },

                _globalPointerDown: function (e) {
                    this._pointers[e.pointerId] = e;
                    this._pointersCount++;
                },

                _globalPointerMove: function (e) {
                    if (this._pointers[e.pointerId]) {
                        this._pointers[e.pointerId] = e;
                    }
                },

                _globalPointerUp: function (e) {
                    delete this._pointers[e.pointerId];
                    this._pointersCount--;
                },

                _handlePointer: function (e, handler) {
                    e.touches = [];
                    for (var i in this._pointers) {
                        e.touches.push(this._pointers[i]);
                    }
                    e.changedTouches = [e];

                    handler(e);
                },

                _addPointerMove: function (obj, handler, id) {
                    var onMove = L.bind(function (e) {
                        // don't fire touch moves when mouse isn't down
                        if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) {
                            return;
                        }

                        this._handlePointer(e, handler);
                    }, this);

                    obj['_leaflet_touchmove' + id] = onMove;
                    obj.addEventListener(this.POINTER_MOVE, onMove, false);
                },

                _addPointerEnd: function (obj, handler, id) {
                    var onUp = L.bind(function (e) {
                        this._handlePointer(e, handler);
                    }, this);

                    obj['_leaflet_touchend' + id] = onUp;
                    obj.addEventListener(this.POINTER_UP, onUp, false);
                    obj.addEventListener(this.POINTER_CANCEL, onUp, false);
                }
            });

            /*
             * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
             */

            // @namespace Map
            // @section Interaction Options
            L.Map.mergeOptions({
                // @section Touch interaction options
                // @option touchZoom: Boolean|String = *
                // Whether the map can be zoomed by touch-dragging with two fingers. If
                // passed `'center'`, it will zoom to the center of the view regardless of
                // where the touch events (fingers) were. Enabled for touch-capable web
                // browsers except for old Androids.
                touchZoom: L.Browser.touch && !L.Browser.android23,

                // @option bounceAtZoomLimits: Boolean = true
                // Set it to false if you don't want the map to zoom beyond min/max zoom
                // and then bounce back when pinch-zooming.
                bounceAtZoomLimits: true
            });

            L.Map.TouchZoom = L.Handler.extend({
                addHooks: function () {
                    L.DomUtil.addClass(this._map._container, 'leaflet-touch-zoom');
                    L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
                },

                removeHooks: function () {
                    L.DomUtil.removeClass(this._map._container, 'leaflet-touch-zoom');
                    L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
                },

                _onTouchStart: function (e) {
                    var map = this._map;
                    if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
                        return;
                    }

                    var p1 = map.mouseEventToContainerPoint(e.touches[0]),
                        p2 = map.mouseEventToContainerPoint(e.touches[1]);

                    this._centerPoint = map.getSize()._divideBy(2);
                    this._startLatLng = map.containerPointToLatLng(this._centerPoint);
                    if (map.options.touchZoom !== 'center') {
                        this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
                    }

                    this._startDist = p1.distanceTo(p2);
                    this._startZoom = map.getZoom();

                    this._moved = false;
                    this._zooming = true;

                    map._stop();

                    L.DomEvent.on(document, 'touchmove', this._onTouchMove, this).on(document, 'touchend', this._onTouchEnd, this);

                    L.DomEvent.preventDefault(e);
                },

                _onTouchMove: function (e) {
                    if (!e.touches || e.touches.length !== 2 || !this._zooming) {
                        return;
                    }

                    var map = this._map,
                        p1 = map.mouseEventToContainerPoint(e.touches[0]),
                        p2 = map.mouseEventToContainerPoint(e.touches[1]),
                        scale = p1.distanceTo(p2) / this._startDist;

                    this._zoom = map.getScaleZoom(scale, this._startZoom);

                    if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {
                        this._zoom = map._limitZoom(this._zoom);
                    }

                    if (map.options.touchZoom === 'center') {
                        this._center = this._startLatLng;
                        if (scale === 1) {
                            return;
                        }
                    } else {
                        // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
                        var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
                        if (scale === 1 && delta.x === 0 && delta.y === 0) {
                            return;
                        }
                        this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
                    }

                    if (!this._moved) {
                        map._moveStart(true);
                        this._moved = true;
                    }

                    L.Util.cancelAnimFrame(this._animRequest);

                    var moveFn = L.bind(map._move, map, this._center, this._zoom, { pinch: true, round: false });
                    this._animRequest = L.Util.requestAnimFrame(moveFn, this, true);

                    L.DomEvent.preventDefault(e);
                },

                _onTouchEnd: function () {
                    if (!this._moved || !this._zooming) {
                        this._zooming = false;
                        return;
                    }

                    this._zooming = false;
                    L.Util.cancelAnimFrame(this._animRequest);

                    L.DomEvent.off(document, 'touchmove', this._onTouchMove).off(document, 'touchend', this._onTouchEnd);

                    // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
                    if (this._map.options.zoomAnimation) {
                        this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
                    } else {
                        this._map._resetView(this._center, this._map._limitZoom(this._zoom));
                    }
                }
            });

            // @section Handlers
            // @property touchZoom: Handler
            // Touch zoom handler.
            L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);

            /*
             * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
             */

            // @namespace Map
            // @section Interaction Options
            L.Map.mergeOptions({
                // @section Touch interaction options
                // @option tap: Boolean = true
                // Enables mobile hacks for supporting instant taps (fixing 200ms click
                // delay on iOS/Android) and touch holds (fired as `contextmenu` events).
                tap: true,

                // @option tapTolerance: Number = 15
                // The max number of pixels a user can shift his finger during touch
                // for it to be considered a valid tap.
                tapTolerance: 15
            });

            L.Map.Tap = L.Handler.extend({
                addHooks: function () {
                    L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
                },

                removeHooks: function () {
                    L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
                },

                _onDown: function (e) {
                    if (!e.touches) {
                        return;
                    }

                    L.DomEvent.preventDefault(e);

                    this._fireClick = true;

                    // don't simulate click or track longpress if more than 1 touch
                    if (e.touches.length > 1) {
                        this._fireClick = false;
                        clearTimeout(this._holdTimeout);
                        return;
                    }

                    var first = e.touches[0],
                        el = first.target;

                    this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);

                    // if touching a link, highlight it
                    if (el.tagName && el.tagName.toLowerCase() === 'a') {
                        L.DomUtil.addClass(el, 'leaflet-active');
                    }

                    // simulate long hold but setting a timeout
                    this._holdTimeout = setTimeout(L.bind(function () {
                        if (this._isTapValid()) {
                            this._fireClick = false;
                            this._onUp();
                            this._simulateEvent('contextmenu', first);
                        }
                    }, this), 1000);

                    this._simulateEvent('mousedown', first);

                    L.DomEvent.on(document, {
                        touchmove: this._onMove,
                        touchend: this._onUp
                    }, this);
                },

                _onUp: function (e) {
                    clearTimeout(this._holdTimeout);

                    L.DomEvent.off(document, {
                        touchmove: this._onMove,
                        touchend: this._onUp
                    }, this);

                    if (this._fireClick && e && e.changedTouches) {

                        var first = e.changedTouches[0],
                            el = first.target;

                        if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
                            L.DomUtil.removeClass(el, 'leaflet-active');
                        }

                        this._simulateEvent('mouseup', first);

                        // simulate click if the touch didn't move too much
                        if (this._isTapValid()) {
                            this._simulateEvent('click', first);
                        }
                    }
                },

                _isTapValid: function () {
                    return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
                },

                _onMove: function (e) {
                    var first = e.touches[0];
                    this._newPos = new L.Point(first.clientX, first.clientY);
                    this._simulateEvent('mousemove', first);
                },

                _simulateEvent: function (type, e) {
                    var simulatedEvent = document.createEvent('MouseEvents');

                    simulatedEvent._simulated = true;
                    e.target._simulatedClick = true;

                    simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);

                    e.target.dispatchEvent(simulatedEvent);
                }
            });

            // @section Handlers
            // @property tap: Handler
            // Mobile touch hacks (quick tap and touch hold) handler.
            if (L.Browser.touch && !L.Browser.pointer) {
                L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
            }

            /*
             * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
             * (zoom to a selected bounding box), enabled by default.
             */

            // @namespace Map
            // @section Interaction Options
            L.Map.mergeOptions({
                // @option boxZoom: Boolean = true
                // Whether the map can be zoomed to a rectangular area specified by
                // dragging the mouse while pressing the shift key.
                boxZoom: true
            });

            L.Map.BoxZoom = L.Handler.extend({
                initialize: function (map) {
                    this._map = map;
                    this._container = map._container;
                    this._pane = map._panes.overlayPane;
                },

                addHooks: function () {
                    L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
                },

                removeHooks: function () {
                    L.DomEvent.off(this._container, 'mousedown', this._onMouseDown, this);
                },

                moved: function () {
                    return this._moved;
                },

                _resetState: function () {
                    this._moved = false;
                },

                _onMouseDown: function (e) {
                    if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
                        return false;
                    }

                    this._resetState();

                    L.DomUtil.disableTextSelection();
                    L.DomUtil.disableImageDrag();

                    this._startPoint = this._map.mouseEventToContainerPoint(e);

                    L.DomEvent.on(document, {
                        contextmenu: L.DomEvent.stop,
                        mousemove: this._onMouseMove,
                        mouseup: this._onMouseUp,
                        keydown: this._onKeyDown
                    }, this);
                },

                _onMouseMove: function (e) {
                    if (!this._moved) {
                        this._moved = true;

                        this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._container);
                        L.DomUtil.addClass(this._container, 'leaflet-crosshair');

                        this._map.fire('boxzoomstart');
                    }

                    this._point = this._map.mouseEventToContainerPoint(e);

                    var bounds = new L.Bounds(this._point, this._startPoint),
                        size = bounds.getSize();

                    L.DomUtil.setPosition(this._box, bounds.min);

                    this._box.style.width = size.x + 'px';
                    this._box.style.height = size.y + 'px';
                },

                _finish: function () {
                    if (this._moved) {
                        L.DomUtil.remove(this._box);
                        L.DomUtil.removeClass(this._container, 'leaflet-crosshair');
                    }

                    L.DomUtil.enableTextSelection();
                    L.DomUtil.enableImageDrag();

                    L.DomEvent.off(document, {
                        contextmenu: L.DomEvent.stop,
                        mousemove: this._onMouseMove,
                        mouseup: this._onMouseUp,
                        keydown: this._onKeyDown
                    }, this);
                },

                _onMouseUp: function (e) {
                    if (e.which !== 1 && e.button !== 1) {
                        return;
                    }

                    this._finish();

                    if (!this._moved) {
                        return;
                    }
                    // Postpone to next JS tick so internal click event handling
                    // still see it as "moved".
                    setTimeout(L.bind(this._resetState, this), 0);

                    var bounds = new L.LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));

                    this._map.fitBounds(bounds).fire('boxzoomend', { boxZoomBounds: bounds });
                },

                _onKeyDown: function (e) {
                    if (e.keyCode === 27) {
                        this._finish();
                    }
                }
            });

            // @section Handlers
            // @property boxZoom: Handler
            // Box (shift-drag with mouse) zoom handler.
            L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);

            /*
             * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
             */

            // @namespace Map
            // @section Keyboard Navigation Options
            L.Map.mergeOptions({
                // @option keyboard: Boolean = true
                // Makes the map focusable and allows users to navigate the map with keyboard
                // arrows and `+`/`-` keys.
                keyboard: true,

                // @option keyboardPanDelta: Number = 80
                // Amount of pixels to pan when pressing an arrow key.
                keyboardPanDelta: 80
            });

            L.Map.Keyboard = L.Handler.extend({

                keyCodes: {
                    left: [37],
                    right: [39],
                    down: [40],
                    up: [38],
                    zoomIn: [187, 107, 61, 171],
                    zoomOut: [189, 109, 54, 173]
                },

                initialize: function (map) {
                    this._map = map;

                    this._setPanDelta(map.options.keyboardPanDelta);
                    this._setZoomDelta(map.options.zoomDelta);
                },

                addHooks: function () {
                    var container = this._map._container;

                    // make the container focusable by tabbing
                    if (container.tabIndex <= 0) {
                        container.tabIndex = '0';
                    }

                    L.DomEvent.on(container, {
                        focus: this._onFocus,
                        blur: this._onBlur,
                        mousedown: this._onMouseDown
                    }, this);

                    this._map.on({
                        focus: this._addHooks,
                        blur: this._removeHooks
                    }, this);
                },

                removeHooks: function () {
                    this._removeHooks();

                    L.DomEvent.off(this._map._container, {
                        focus: this._onFocus,
                        blur: this._onBlur,
                        mousedown: this._onMouseDown
                    }, this);

                    this._map.off({
                        focus: this._addHooks,
                        blur: this._removeHooks
                    }, this);
                },

                _onMouseDown: function () {
                    if (this._focused) {
                        return;
                    }

                    var body = document.body,
                        docEl = document.documentElement,
                        top = body.scrollTop || docEl.scrollTop,
                        left = body.scrollLeft || docEl.scrollLeft;

                    this._map._container.focus();

                    window.scrollTo(left, top);
                },

                _onFocus: function () {
                    this._focused = true;
                    this._map.fire('focus');
                },

                _onBlur: function () {
                    this._focused = false;
                    this._map.fire('blur');
                },

                _setPanDelta: function (panDelta) {
                    var keys = this._panKeys = {},
                        codes = this.keyCodes,
                        i,
                        len;

                    for (i = 0, len = codes.left.length; i < len; i++) {
                        keys[codes.left[i]] = [-1 * panDelta, 0];
                    }
                    for (i = 0, len = codes.right.length; i < len; i++) {
                        keys[codes.right[i]] = [panDelta, 0];
                    }
                    for (i = 0, len = codes.down.length; i < len; i++) {
                        keys[codes.down[i]] = [0, panDelta];
                    }
                    for (i = 0, len = codes.up.length; i < len; i++) {
                        keys[codes.up[i]] = [0, -1 * panDelta];
                    }
                },

                _setZoomDelta: function (zoomDelta) {
                    var keys = this._zoomKeys = {},
                        codes = this.keyCodes,
                        i,
                        len;

                    for (i = 0, len = codes.zoomIn.length; i < len; i++) {
                        keys[codes.zoomIn[i]] = zoomDelta;
                    }
                    for (i = 0, len = codes.zoomOut.length; i < len; i++) {
                        keys[codes.zoomOut[i]] = -zoomDelta;
                    }
                },

                _addHooks: function () {
                    L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
                },

                _removeHooks: function () {
                    L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
                },

                _onKeyDown: function (e) {
                    if (e.altKey || e.ctrlKey || e.metaKey) {
                        return;
                    }

                    var key = e.keyCode,
                        map = this._map,
                        offset;

                    if (key in this._panKeys) {

                        if (map._panAnim && map._panAnim._inProgress) {
                            return;
                        }

                        offset = this._panKeys[key];
                        if (e.shiftKey) {
                            offset = L.point(offset).multiplyBy(3);
                        }

                        map.panBy(offset);

                        if (map.options.maxBounds) {
                            map.panInsideBounds(map.options.maxBounds);
                        }
                    } else if (key in this._zoomKeys) {
                        map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
                    } else if (key === 27) {
                        map.closePopup();
                    } else {
                        return;
                    }

                    L.DomEvent.stop(e);
                }
            });

            // @section Handlers
            // @section Handlers
            // @property keyboard: Handler
            // Keyboard navigation handler.
            L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);

            /*
             * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
             */

            /* @namespace Marker
             * @section Interaction handlers
             *
             * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
             *
             * ```js
             * marker.dragging.disable();
             * ```
             *
             * @property dragging: Handler
             * Marker dragging handler (by both mouse and touch).
             */

            L.Handler.MarkerDrag = L.Handler.extend({
                initialize: function (marker) {
                    this._marker = marker;
                },

                addHooks: function () {
                    var icon = this._marker._icon;

                    if (!this._draggable) {
                        this._draggable = new L.Draggable(icon, icon, true);
                    }

                    this._draggable.on({
                        dragstart: this._onDragStart,
                        drag: this._onDrag,
                        dragend: this._onDragEnd
                    }, this).enable();

                    L.DomUtil.addClass(icon, 'leaflet-marker-draggable');
                },

                removeHooks: function () {
                    this._draggable.off({
                        dragstart: this._onDragStart,
                        drag: this._onDrag,
                        dragend: this._onDragEnd
                    }, this).disable();

                    if (this._marker._icon) {
                        L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
                    }
                },

                moved: function () {
                    return this._draggable && this._draggable._moved;
                },

                _onDragStart: function () {
                    // @section Dragging events
                    // @event dragstart: Event
                    // Fired when the user starts dragging the marker.

                    // @event movestart: Event
                    // Fired when the marker starts moving (because of dragging).

                    this._oldLatLng = this._marker.getLatLng();
                    this._marker.closePopup().fire('movestart').fire('dragstart');
                },

                _onDrag: function (e) {
                    var marker = this._marker,
                        shadow = marker._shadow,
                        iconPos = L.DomUtil.getPosition(marker._icon),
                        latlng = marker._map.layerPointToLatLng(iconPos);

                    // update shadow position
                    if (shadow) {
                        L.DomUtil.setPosition(shadow, iconPos);
                    }

                    marker._latlng = latlng;
                    e.latlng = latlng;
                    e.oldLatLng = this._oldLatLng;

                    // @event drag: Event
                    // Fired repeatedly while the user drags the marker.
                    marker.fire('move', e).fire('drag', e);
                },

                _onDragEnd: function (e) {
                    // @event dragend: DragEndEvent
                    // Fired when the user stops dragging the marker.

                    // @event moveend: Event
                    // Fired when the marker stops moving (because of dragging).
                    delete this._oldLatLng;
                    this._marker.fire('moveend').fire('dragend', e);
                }
            });

            /*
             * @class Control
             * @aka L.Control
             *
             * L.Control is a base class for implementing map controls. Handles positioning.
             * All other controls extend from this class.
             */

            L.Control = L.Class.extend({
                // @section
                // @aka Control options
                options: {
                    // @option position: String = 'topright'
                    // The position of the control (one of the map corners). Possible values are `'topleft'`,
                    // `'topright'`, `'bottomleft'` or `'bottomright'`
                    position: 'topright'
                },

                initialize: function (options) {
                    L.setOptions(this, options);
                },

                /* @section
                 * Classes extending L.Control will inherit the following methods:
                 *
                 * @method getPosition: string
                 * Returns the position of the control.
                 */
                getPosition: function () {
                    return this.options.position;
                },

                // @method setPosition(position: string): this
                // Sets the position of the control.
                setPosition: function (position) {
                    var map = this._map;

                    if (map) {
                        map.removeControl(this);
                    }

                    this.options.position = position;

                    if (map) {
                        map.addControl(this);
                    }

                    return this;
                },

                // @method getContainer: HTMLElement
                // Returns the HTMLElement that contains the control.
                getContainer: function () {
                    return this._container;
                },

                // @method addTo(map: Map): this
                // Adds the control to the given map.
                addTo: function (map) {
                    this.remove();
                    this._map = map;

                    var container = this._container = this.onAdd(map),
                        pos = this.getPosition(),
                        corner = map._controlCorners[pos];

                    L.DomUtil.addClass(container, 'leaflet-control');

                    if (pos.indexOf('bottom') !== -1) {
                        corner.insertBefore(container, corner.firstChild);
                    } else {
                        corner.appendChild(container);
                    }

                    return this;
                },

                // @method remove: this
                // Removes the control from the map it is currently active on.
                remove: function () {
                    if (!this._map) {
                        return this;
                    }

                    L.DomUtil.remove(this._container);

                    if (this.onRemove) {
                        this.onRemove(this._map);
                    }

                    this._map = null;

                    return this;
                },

                _refocusOnMap: function (e) {
                    // if map exists and event is not a keyboard event
                    if (this._map && e && e.screenX > 0 && e.screenY > 0) {
                        this._map.getContainer().focus();
                    }
                }
            });

            L.control = function (options) {
                return new L.Control(options);
            };

            /* @section Extension methods
             * @uninheritable
             *
             * Every control should extend from `L.Control` and (re-)implement the following methods.
             *
             * @method onAdd(map: Map): HTMLElement
             * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
             *
             * @method onRemove(map: Map)
             * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
             */

            /* @namespace Map
             * @section Methods for Layers and Controls
             */
            L.Map.include({
                // @method addControl(control: Control): this
                // Adds the given control to the map
                addControl: function (control) {
                    control.addTo(this);
                    return this;
                },

                // @method removeControl(control: Control): this
                // Removes the given control from the map
                removeControl: function (control) {
                    control.remove();
                    return this;
                },

                _initControlPos: function () {
                    var corners = this._controlCorners = {},
                        l = 'leaflet-',
                        container = this._controlContainer = L.DomUtil.create('div', l + 'control-container', this._container);

                    function createCorner(vSide, hSide) {
                        var className = l + vSide + ' ' + l + hSide;

                        corners[vSide + hSide] = L.DomUtil.create('div', className, container);
                    }

                    createCorner('top', 'left');
                    createCorner('top', 'right');
                    createCorner('bottom', 'left');
                    createCorner('bottom', 'right');
                },

                _clearControlPos: function () {
                    L.DomUtil.remove(this._controlContainer);
                }
            });

            /*
             * @class Control.Zoom
             * @aka L.Control.Zoom
             * @inherits Control
             *
             * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
             */

            L.Control.Zoom = L.Control.extend({
                // @section
                // @aka Control.Zoom options
                options: {
                    position: 'topleft',

                    // @option zoomInText: String = '+'
                    // The text set on the 'zoom in' button.
                    zoomInText: '+',

                    // @option zoomInTitle: String = 'Zoom in'
                    // The title set on the 'zoom in' button.
                    zoomInTitle: 'Zoom in',

                    // @option zoomOutText: String = '-'
                    // The text set on the 'zoom out' button.
                    zoomOutText: '-',

                    // @option zoomOutTitle: String = 'Zoom out'
                    // The title set on the 'zoom out' button.
                    zoomOutTitle: 'Zoom out'
                },

                onAdd: function (map) {
                    var zoomName = 'leaflet-control-zoom',
                        container = L.DomUtil.create('div', zoomName + ' leaflet-bar'),
                        options = this.options;

                    this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);
                    this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);

                    this._updateDisabled();
                    map.on('zoomend zoomlevelschange', this._updateDisabled, this);

                    return container;
                },

                onRemove: function (map) {
                    map.off('zoomend zoomlevelschange', this._updateDisabled, this);
                },

                disable: function () {
                    this._disabled = true;
                    this._updateDisabled();
                    return this;
                },

                enable: function () {
                    this._disabled = false;
                    this._updateDisabled();
                    return this;
                },

                _zoomIn: function (e) {
                    if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
                        this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
                    }
                },

                _zoomOut: function (e) {
                    if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
                        this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
                    }
                },

                _createButton: function (html, title, className, container, fn) {
                    var link = L.DomUtil.create('a', className, container);
                    link.innerHTML = html;
                    link.href = '#';
                    link.title = title;

                    L.DomEvent.on(link, 'mousedown dblclick', L.DomEvent.stopPropagation).on(link, 'click', L.DomEvent.stop).on(link, 'click', fn, this).on(link, 'click', this._refocusOnMap, this);

                    return link;
                },

                _updateDisabled: function () {
                    var map = this._map,
                        className = 'leaflet-disabled';

                    L.DomUtil.removeClass(this._zoomInButton, className);
                    L.DomUtil.removeClass(this._zoomOutButton, className);

                    if (this._disabled || map._zoom === map.getMinZoom()) {
                        L.DomUtil.addClass(this._zoomOutButton, className);
                    }
                    if (this._disabled || map._zoom === map.getMaxZoom()) {
                        L.DomUtil.addClass(this._zoomInButton, className);
                    }
                }
            });

            // @namespace Map
            // @section Control options
            // @option zoomControl: Boolean = true
            // Whether a [zoom control](#control-zoom) is added to the map by default.
            L.Map.mergeOptions({
                zoomControl: true
            });

            L.Map.addInitHook(function () {
                if (this.options.zoomControl) {
                    this.zoomControl = new L.Control.Zoom();
                    this.addControl(this.zoomControl);
                }
            });

            // @namespace Control.Zoom
            // @factory L.control.zoom(options: Control.Zoom options)
            // Creates a zoom control
            L.control.zoom = function (options) {
                return new L.Control.Zoom(options);
            };

            /*
             * @class Control.Attribution
             * @aka L.Control.Attribution
             * @inherits Control
             *
             * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
             */

            L.Control.Attribution = L.Control.extend({
                // @section
                // @aka Control.Attribution options
                options: {
                    position: 'bottomright',

                    // @option prefix: String = 'Leaflet'
                    // The HTML text shown before the attributions. Pass `false` to disable.
                    prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
                },

                initialize: function (options) {
                    L.setOptions(this, options);

                    this._attributions = {};
                },

                onAdd: function (map) {
                    map.attributionControl = this;
                    this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
                    if (L.DomEvent) {
                        L.DomEvent.disableClickPropagation(this._container);
                    }

                    // TODO ugly, refactor
                    for (var i in map._layers) {
                        if (map._layers[i].getAttribution) {
                            this.addAttribution(map._layers[i].getAttribution());
                        }
                    }

                    this._update();

                    return this._container;
                },

                // @method setPrefix(prefix: String): this
                // Sets the text before the attributions.
                setPrefix: function (prefix) {
                    this.options.prefix = prefix;
                    this._update();
                    return this;
                },

                // @method addAttribution(text: String): this
                // Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
                addAttribution: function (text) {
                    if (!text) {
                        return this;
                    }

                    if (!this._attributions[text]) {
                        this._attributions[text] = 0;
                    }
                    this._attributions[text]++;

                    this._update();

                    return this;
                },

                // @method removeAttribution(text: String): this
                // Removes an attribution text.
                removeAttribution: function (text) {
                    if (!text) {
                        return this;
                    }

                    if (this._attributions[text]) {
                        this._attributions[text]--;
                        this._update();
                    }

                    return this;
                },

                _update: function () {
                    if (!this._map) {
                        return;
                    }

                    var attribs = [];

                    for (var i in this._attributions) {
                        if (this._attributions[i]) {
                            attribs.push(i);
                        }
                    }

                    var prefixAndAttribs = [];

                    if (this.options.prefix) {
                        prefixAndAttribs.push(this.options.prefix);
                    }
                    if (attribs.length) {
                        prefixAndAttribs.push(attribs.join(', '));
                    }

                    this._container.innerHTML = prefixAndAttribs.join(' | ');
                }
            });

            // @namespace Map
            // @section Control options
            // @option attributionControl: Boolean = true
            // Whether a [attribution control](#control-attribution) is added to the map by default.
            L.Map.mergeOptions({
                attributionControl: true
            });

            L.Map.addInitHook(function () {
                if (this.options.attributionControl) {
                    new L.Control.Attribution().addTo(this);
                }
            });

            // @namespace Control.Attribution
            // @factory L.control.attribution(options: Control.Attribution options)
            // Creates an attribution control.
            L.control.attribution = function (options) {
                return new L.Control.Attribution(options);
            };

            /*
             * @class Control.Scale
             * @aka L.Control.Scale
             * @inherits Control
             *
             * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
             *
             * @example
             *
             * ```js
             * L.control.scale().addTo(map);
             * ```
             */

            L.Control.Scale = L.Control.extend({
                // @section
                // @aka Control.Scale options
                options: {
                    position: 'bottomleft',

                    // @option maxWidth: Number = 100
                    // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
                    maxWidth: 100,

                    // @option metric: Boolean = True
                    // Whether to show the metric scale line (m/km).
                    metric: true,

                    // @option imperial: Boolean = True
                    // Whether to show the imperial scale line (mi/ft).
                    imperial: true

                    // @option updateWhenIdle: Boolean = false
                    // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
                },

                onAdd: function (map) {
                    var className = 'leaflet-control-scale',
                        container = L.DomUtil.create('div', className),
                        options = this.options;

                    this._addScales(options, className + '-line', container);

                    map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
                    map.whenReady(this._update, this);

                    return container;
                },

                onRemove: function (map) {
                    map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
                },

                _addScales: function (options, className, container) {
                    if (options.metric) {
                        this._mScale = L.DomUtil.create('div', className, container);
                    }
                    if (options.imperial) {
                        this._iScale = L.DomUtil.create('div', className, container);
                    }
                },

                _update: function () {
                    var map = this._map,
                        y = map.getSize().y / 2;

                    var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));

                    this._updateScales(maxMeters);
                },

                _updateScales: function (maxMeters) {
                    if (this.options.metric && maxMeters) {
                        this._updateMetric(maxMeters);
                    }
                    if (this.options.imperial && maxMeters) {
                        this._updateImperial(maxMeters);
                    }
                },

                _updateMetric: function (maxMeters) {
                    var meters = this._getRoundNum(maxMeters),
                        label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';

                    this._updateScale(this._mScale, label, meters / maxMeters);
                },

                _updateImperial: function (maxMeters) {
                    var maxFeet = maxMeters * 3.2808399,
                        maxMiles,
                        miles,
                        feet;

                    if (maxFeet > 5280) {
                        maxMiles = maxFeet / 5280;
                        miles = this._getRoundNum(maxMiles);
                        this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);
                    } else {
                        feet = this._getRoundNum(maxFeet);
                        this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
                    }
                },

                _updateScale: function (scale, text, ratio) {
                    scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
                    scale.innerHTML = text;
                },

                _getRoundNum: function (num) {
                    var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
                        d = num / pow10;

                    d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;

                    return pow10 * d;
                }
            });

            // @factory L.control.scale(options?: Control.Scale options)
            // Creates an scale control with the given options.
            L.control.scale = function (options) {
                return new L.Control.Scale(options);
            };

            /*
             * @class Control.Layers
             * @aka L.Control.Layers
             * @inherits Control
             *
             * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control.html)). Extends `Control`.
             *
             * @example
             *
             * ```js
             * var baseLayers = {
             * 	"Mapbox": mapbox,
             * 	"OpenStreetMap": osm
             * };
             *
             * var overlays = {
             * 	"Marker": marker,
             * 	"Roads": roadsLayer
             * };
             *
             * L.control.layers(baseLayers, overlays).addTo(map);
             * ```
             *
             * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
             *
             * ```js
             * {
             *     "<someName1>": layer1,
             *     "<someName2>": layer2
             * }
             * ```
             *
             * The layer names can contain HTML, which allows you to add additional styling to the items:
             *
             * ```js
             * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
             * ```
             */

            L.Control.Layers = L.Control.extend({
                // @section
                // @aka Control.Layers options
                options: {
                    // @option collapsed: Boolean = true
                    // If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
                    collapsed: true,
                    position: 'topright',

                    // @option autoZIndex: Boolean = true
                    // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
                    autoZIndex: true,

                    // @option hideSingleBase: Boolean = false
                    // If `true`, the base layers in the control will be hidden when there is only one.
                    hideSingleBase: false
                },

                initialize: function (baseLayers, overlays, options) {
                    L.setOptions(this, options);

                    this._layers = [];
                    this._lastZIndex = 0;
                    this._handlingClick = false;

                    for (var i in baseLayers) {
                        this._addLayer(baseLayers[i], i);
                    }

                    for (i in overlays) {
                        this._addLayer(overlays[i], i, true);
                    }
                },

                onAdd: function (map) {
                    this._initLayout();
                    this._update();

                    this._map = map;
                    map.on('zoomend', this._checkDisabledLayers, this);

                    return this._container;
                },

                onRemove: function () {
                    this._map.off('zoomend', this._checkDisabledLayers, this);

                    for (var i = 0; i < this._layers.length; i++) {
                        this._layers[i].layer.off('add remove', this._onLayerChange, this);
                    }
                },

                // @method addBaseLayer(layer: Layer, name: String): this
                // Adds a base layer (radio button entry) with the given name to the control.
                addBaseLayer: function (layer, name) {
                    this._addLayer(layer, name);
                    return this._map ? this._update() : this;
                },

                // @method addOverlay(layer: Layer, name: String): this
                // Adds an overlay (checkbox entry) with the given name to the control.
                addOverlay: function (layer, name) {
                    this._addLayer(layer, name, true);
                    return this._map ? this._update() : this;
                },

                // @method removeLayer(layer: Layer): this
                // Remove the given layer from the control.
                removeLayer: function (layer) {
                    layer.off('add remove', this._onLayerChange, this);

                    var obj = this._getLayer(L.stamp(layer));
                    if (obj) {
                        this._layers.splice(this._layers.indexOf(obj), 1);
                    }
                    return this._map ? this._update() : this;
                },

                // @method expand(): this
                // Expand the control container if collapsed.
                expand: function () {
                    L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
                    this._form.style.height = null;
                    var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
                    if (acceptableHeight < this._form.clientHeight) {
                        L.DomUtil.addClass(this._form, 'leaflet-control-layers-scrollbar');
                        this._form.style.height = acceptableHeight + 'px';
                    } else {
                        L.DomUtil.removeClass(this._form, 'leaflet-control-layers-scrollbar');
                    }
                    this._checkDisabledLayers();
                    return this;
                },

                // @method collapse(): this
                // Collapse the control container if expanded.
                collapse: function () {
                    L.DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');
                    return this;
                },

                _initLayout: function () {
                    var className = 'leaflet-control-layers',
                        container = this._container = L.DomUtil.create('div', className);

                    // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
                    container.setAttribute('aria-haspopup', true);

                    L.DomEvent.disableClickPropagation(container);
                    if (!L.Browser.touch) {
                        L.DomEvent.disableScrollPropagation(container);
                    }

                    var form = this._form = L.DomUtil.create('form', className + '-list');

                    if (this.options.collapsed) {
                        if (!L.Browser.android) {
                            L.DomEvent.on(container, {
                                mouseenter: this.expand,
                                mouseleave: this.collapse
                            }, this);
                        }

                        var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
                        link.href = '#';
                        link.title = 'Layers';

                        if (L.Browser.touch) {
                            L.DomEvent.on(link, 'click', L.DomEvent.stop).on(link, 'click', this.expand, this);
                        } else {
                            L.DomEvent.on(link, 'focus', this.expand, this);
                        }

                        // work around for Firefox Android issue https://github.com/Leaflet/Leaflet/issues/2033
                        L.DomEvent.on(form, 'click', function () {
                            setTimeout(L.bind(this._onInputClick, this), 0);
                        }, this);

                        this._map.on('click', this.collapse, this);
                        // TODO keyboard accessibility
                    } else {
                        this.expand();
                    }

                    this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
                    this._separator = L.DomUtil.create('div', className + '-separator', form);
                    this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

                    container.appendChild(form);
                },

                _getLayer: function (id) {
                    for (var i = 0; i < this._layers.length; i++) {

                        if (this._layers[i] && L.stamp(this._layers[i].layer) === id) {
                            return this._layers[i];
                        }
                    }
                },

                _addLayer: function (layer, name, overlay) {
                    layer.on('add remove', this._onLayerChange, this);

                    this._layers.push({
                        layer: layer,
                        name: name,
                        overlay: overlay
                    });

                    if (this.options.autoZIndex && layer.setZIndex) {
                        this._lastZIndex++;
                        layer.setZIndex(this._lastZIndex);
                    }
                },

                _update: function () {
                    if (!this._container) {
                        return this;
                    }

                    L.DomUtil.empty(this._baseLayersList);
                    L.DomUtil.empty(this._overlaysList);

                    var baseLayersPresent,
                        overlaysPresent,
                        i,
                        obj,
                        baseLayersCount = 0;

                    for (i = 0; i < this._layers.length; i++) {
                        obj = this._layers[i];
                        this._addItem(obj);
                        overlaysPresent = overlaysPresent || obj.overlay;
                        baseLayersPresent = baseLayersPresent || !obj.overlay;
                        baseLayersCount += !obj.overlay ? 1 : 0;
                    }

                    // Hide base layers section if there's only one layer.
                    if (this.options.hideSingleBase) {
                        baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
                        this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
                    }

                    this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

                    return this;
                },

                _onLayerChange: function (e) {
                    if (!this._handlingClick) {
                        this._update();
                    }

                    var obj = this._getLayer(L.stamp(e.target));

                    // @namespace Map
                    // @section Layer events
                    // @event baselayerchange: LayersControlEvent
                    // Fired when the base layer is changed through the [layer control](#control-layers).
                    // @event overlayadd: LayersControlEvent
                    // Fired when an overlay is selected through the [layer control](#control-layers).
                    // @event overlayremove: LayersControlEvent
                    // Fired when an overlay is deselected through the [layer control](#control-layers).
                    // @namespace Control.Layers
                    var type = obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;

                    if (type) {
                        this._map.fire(type, obj);
                    }
                },

                // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
                _createRadioElement: function (name, checked) {

                    var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : '') + '/>';

                    var radioFragment = document.createElement('div');
                    radioFragment.innerHTML = radioHtml;

                    return radioFragment.firstChild;
                },

                _addItem: function (obj) {
                    var label = document.createElement('label'),
                        checked = this._map.hasLayer(obj.layer),
                        input;

                    if (obj.overlay) {
                        input = document.createElement('input');
                        input.type = 'checkbox';
                        input.className = 'leaflet-control-layers-selector';
                        input.defaultChecked = checked;
                    } else {
                        input = this._createRadioElement('leaflet-base-layers', checked);
                    }

                    input.layerId = L.stamp(obj.layer);

                    L.DomEvent.on(input, 'click', this._onInputClick, this);

                    var name = document.createElement('span');
                    name.innerHTML = ' ' + obj.name;

                    // Helps from preventing layer control flicker when checkboxes are disabled
                    // https://github.com/Leaflet/Leaflet/issues/2771
                    var holder = document.createElement('div');

                    label.appendChild(holder);
                    holder.appendChild(input);
                    holder.appendChild(name);

                    var container = obj.overlay ? this._overlaysList : this._baseLayersList;
                    container.appendChild(label);

                    this._checkDisabledLayers();
                    return label;
                },

                _onInputClick: function () {
                    var inputs = this._form.getElementsByTagName('input'),
                        input,
                        layer,
                        hasLayer;
                    var addedLayers = [],
                        removedLayers = [];

                    this._handlingClick = true;

                    for (var i = inputs.length - 1; i >= 0; i--) {
                        input = inputs[i];
                        layer = this._getLayer(input.layerId).layer;
                        hasLayer = this._map.hasLayer(layer);

                        if (input.checked && !hasLayer) {
                            addedLayers.push(layer);
                        } else if (!input.checked && hasLayer) {
                            removedLayers.push(layer);
                        }
                    }

                    // Bugfix issue 2318: Should remove all old layers before readding new ones
                    for (i = 0; i < removedLayers.length; i++) {
                        this._map.removeLayer(removedLayers[i]);
                    }
                    for (i = 0; i < addedLayers.length; i++) {
                        this._map.addLayer(addedLayers[i]);
                    }

                    this._handlingClick = false;

                    this._refocusOnMap();
                },

                _checkDisabledLayers: function () {
                    var inputs = this._form.getElementsByTagName('input'),
                        input,
                        layer,
                        zoom = this._map.getZoom();

                    for (var i = inputs.length - 1; i >= 0; i--) {
                        input = inputs[i];
                        layer = this._getLayer(input.layerId).layer;
                        input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;
                    }
                },

                _expand: function () {
                    // Backward compatibility, remove me in 1.1.
                    return this.expand();
                },

                _collapse: function () {
                    // Backward compatibility, remove me in 1.1.
                    return this.collapse();
                }

            });

            // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
            // Creates an attribution control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
            L.control.layers = function (baseLayers, overlays, options) {
                return new L.Control.Layers(baseLayers, overlays, options);
            };

            /*
             * Provides L.Map with convenient shortcuts for using browser geolocation features.
             */

            // @namespace Map

            L.Map.include({
                // @section Geolocation methods
                _defaultLocateOptions: {
                    timeout: 10000,
                    watch: false
                    // setView: false
                    // maxZoom: <Number>
                    // maximumAge: 0
                    // enableHighAccuracy: false
                },

                // @method locate(options?: Locate options): this
                // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
                // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
                // and optionally sets the map view to the user's location with respect to
                // detection accuracy (or to the world view if geolocation failed).
                // Note that, if your page doesn't use HTTPS, this method will fail in
                // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
                // See `Locate options` for more details.
                locate: function (options) {

                    options = this._locateOptions = L.extend({}, this._defaultLocateOptions, options);

                    if (!('geolocation' in navigator)) {
                        this._handleGeolocationError({
                            code: 0,
                            message: 'Geolocation not supported.'
                        });
                        return this;
                    }

                    var onResponse = L.bind(this._handleGeolocationResponse, this),
                        onError = L.bind(this._handleGeolocationError, this);

                    if (options.watch) {
                        this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
                    } else {
                        navigator.geolocation.getCurrentPosition(onResponse, onError, options);
                    }
                    return this;
                },

                // @method stopLocate(): this
                // Stops watching location previously initiated by `map.locate({watch: true})`
                // and aborts resetting the map view if map.locate was called with
                // `{setView: true}`.
                stopLocate: function () {
                    if (navigator.geolocation && navigator.geolocation.clearWatch) {
                        navigator.geolocation.clearWatch(this._locationWatchId);
                    }
                    if (this._locateOptions) {
                        this._locateOptions.setView = false;
                    }
                    return this;
                },

                _handleGeolocationError: function (error) {
                    var c = error.code,
                        message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');

                    if (this._locateOptions.setView && !this._loaded) {
                        this.fitWorld();
                    }

                    // @section Location events
                    // @event locationerror: ErrorEvent
                    // Fired when geolocation (using the [`locate`](#map-locate) method) failed.
                    this.fire('locationerror', {
                        code: c,
                        message: 'Geolocation error: ' + message + '.'
                    });
                },

                _handleGeolocationResponse: function (pos) {
                    var lat = pos.coords.latitude,
                        lng = pos.coords.longitude,
                        latlng = new L.LatLng(lat, lng),
                        bounds = latlng.toBounds(pos.coords.accuracy),
                        options = this._locateOptions;

                    if (options.setView) {
                        var zoom = this.getBoundsZoom(bounds);
                        this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
                    }

                    var data = {
                        latlng: latlng,
                        bounds: bounds,
                        timestamp: pos.timestamp
                    };

                    for (var i in pos.coords) {
                        if (typeof pos.coords[i] === 'number') {
                            data[i] = pos.coords[i];
                        }
                    }

                    // @event locationfound: LocationEvent
                    // Fired when geolocation (using the [`locate`](#map-locate) method)
                    // went successfully.
                    this.fire('locationfound', data);
                }
            });
        }, {}], 8: [function (_dereq_, module, exports) {
            // shim for using process in browser
            var process = module.exports = {};

            // cached from whatever global is present so that test runners that stub it
            // don't break things.  But we need to wrap it in a try catch in case it is
            // wrapped in strict mode code which doesn't define any globals.  It's inside a
            // function because try/catches deoptimize in certain engines.

            var cachedSetTimeout;
            var cachedClearTimeout;

            function defaultSetTimout() {
                throw new Error('setTimeout has not been defined');
            }
            function defaultClearTimeout() {
                throw new Error('clearTimeout has not been defined');
            }
            (function () {
                try {
                    if (typeof setTimeout === 'function') {
                        cachedSetTimeout = setTimeout;
                    } else {
                        cachedSetTimeout = defaultSetTimout;
                    }
                } catch (e) {
                    cachedSetTimeout = defaultSetTimout;
                }
                try {
                    if (typeof clearTimeout === 'function') {
                        cachedClearTimeout = clearTimeout;
                    } else {
                        cachedClearTimeout = defaultClearTimeout;
                    }
                } catch (e) {
                    cachedClearTimeout = defaultClearTimeout;
                }
            })();
            function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) {
                    //normal enviroments in sane situations
                    return setTimeout(fun, 0);
                }
                // if setTimeout wasn't available but was latter defined
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                    cachedSetTimeout = setTimeout;
                    return setTimeout(fun, 0);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedSetTimeout(fun, 0);
                } catch (e) {
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                        return cachedSetTimeout.call(null, fun, 0);
                    } catch (e) {
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                        return cachedSetTimeout.call(this, fun, 0);
                    }
                }
            }
            function runClearTimeout(marker) {
                if (cachedClearTimeout === clearTimeout) {
                    //normal enviroments in sane situations
                    return clearTimeout(marker);
                }
                // if clearTimeout wasn't available but was latter defined
                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                    cachedClearTimeout = clearTimeout;
                    return clearTimeout(marker);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedClearTimeout(marker);
                } catch (e) {
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                        return cachedClearTimeout.call(null, marker);
                    } catch (e) {
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                        // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                        return cachedClearTimeout.call(this, marker);
                    }
                }
            }
            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;

            function cleanUpNextTick() {
                if (!draining || !currentQueue) {
                    return;
                }
                draining = false;
                if (currentQueue.length) {
                    queue = currentQueue.concat(queue);
                } else {
                    queueIndex = -1;
                }
                if (queue.length) {
                    drainQueue();
                }
            }

            function drainQueue() {
                if (draining) {
                    return;
                }
                var timeout = runTimeout(cleanUpNextTick);
                draining = true;

                var len = queue.length;
                while (len) {
                    currentQueue = queue;
                    queue = [];
                    while (++queueIndex < len) {
                        if (currentQueue) {
                            currentQueue[queueIndex].run();
                        }
                    }
                    queueIndex = -1;
                    len = queue.length;
                }
                currentQueue = null;
                draining = false;
                runClearTimeout(timeout);
            }

            process.nextTick = function (fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for (var i = 1; i < arguments.length; i++) {
                        args[i - 1] = arguments[i];
                    }
                }
                queue.push(new Item(fun, args));
                if (queue.length === 1 && !draining) {
                    runTimeout(drainQueue);
                }
            };

            // v8 likes predictible objects
            function Item(fun, array) {
                this.fun = fun;
                this.array = array;
            }
            Item.prototype.run = function () {
                this.fun.apply(null, this.array);
            };
            process.title = 'browser';
            process.browser = true;
            process.env = {};
            process.argv = [];
            process.version = ''; // empty string to avoid regexp issues
            process.versions = {};

            function noop() {}

            process.on = noop;
            process.addListener = noop;
            process.once = noop;
            process.off = noop;
            process.removeListener = noop;
            process.removeAllListeners = noop;
            process.emit = noop;
            process.prependListener = noop;
            process.prependOnceListener = noop;

            process.listeners = function (name) {
                return [];
            };

            process.binding = function (name) {
                throw new Error('process.binding is not supported');
            };

            process.cwd = function () {
                return '/';
            };
            process.chdir = function (dir) {
                throw new Error('process.chdir is not supported');
            };
            process.umask = function () {
                return 0;
            };
        }, {}], 9: [function (_dereq_, module, exports) {
            (function (window, undefined) {
                'use strict';

                if (!window) return; // Server side

                var _baron = window.baron,
                    // Stored baron value for noConflict usage
                $ = window.jQuery,
                    // Trying to use jQuery
                origin = {
                    v: { // Vertical
                        x: 'Y', pos: 'top', crossPos: 'left', size: 'height', crossSize: 'width',
                        client: 'clientHeight', crossClient: 'clientWidth', offset: 'offsetHeight', crossOffset: 'offsetWidth', offsetPos: 'offsetTop',
                        scroll: 'scrollTop', scrollSize: 'scrollHeight'
                    },
                    h: { // Horizontal
                        x: 'X', pos: 'left', crossPos: 'top', size: 'width', crossSize: 'height',
                        client: 'clientWidth', crossClient: 'clientHeight', offset: 'offsetWidth', crossOffset: 'offsetHeight', offsetPos: 'offsetLeft',
                        scroll: 'scrollLeft', scrollSize: 'scrollWidth'
                    }
                },
                    each = function (obj, iterator) {
                    var i = 0;

                    if (obj.length === undefined || obj === window) obj = [obj];

                    while (obj[i]) {
                        iterator.call(this, obj[i], i);
                        i++;
                    }
                },
                    baron = function (params) {
                    // this - window or jQuery instance
                    var jQueryMode = false,
                        //(this && this[0] && this[0].nodeType),
                    roots,
                        $;

                    params = params || {};
                    $ = params.$ || window.jQuery;

                    if (jQueryMode) {
                        params.root = roots = this;
                    } else {
                        roots = $(params.root || params.scroller);
                    }

                    return new baron.fn.constructor(roots, params, $);
                };

                baron.fn = {
                    constructor: function (roots, input, $) {
                        var params = validate(input);

                        params.$ = $;
                        each.call(this, roots, function (root, i) {
                            var localParams = clone(params);

                            if (params.root && params.scroller) {
                                localParams.scroller = params.$(params.scroller, root);
                                if (!localParams.scroller.length) {
                                    localParams.scroller = root;
                                }
                            } else {
                                localParams.scroller = root;
                            }

                            localParams.root = root;
                            this[i] = init(localParams);
                            this.length = i + 1;
                        });

                        this.params = params;
                    },

                    dispose: function () {
                        var params = this.params;

                        each(this, function (item) {
                            item.dispose(params);
                        });
                        this.params = null;
                    },

                    update: function () {
                        var i = 0;

                        while (this[i]) {
                            this[i].update.apply(this[i], arguments);
                            i++;
                        }
                    },

                    baron: function (params) {
                        params.root = [];
                        params.scroller = this.params.scroller;

                        each.call(this, this, function (elem) {
                            params.root.push(elem.root);
                        });
                        params.direction = this.params.direction == 'v' ? 'h' : 'v';
                        params._chain = true;

                        return baron(params);
                    }
                };

                function manageEvents(item, eventManager, mode) {
                    item._eventHandlers = item._eventHandlers || [// Creating new functions for one baron item only one time
                    {
                        // onScroll:
                        element: item.scroller,

                        handler: function (e) {
                            item.scroll(e);
                        },

                        type: 'scroll'
                    }, {
                        // onMouseDown:
                        element: item.bar,

                        handler: function (e) {
                            e.preventDefault ? e.preventDefault() : e.returnValue = false; // Text selection disabling in Opera... and all other browsers?
                            item.selection(); // Disable text selection in ie8
                            item.drag.now = 1; // Save private byte
                        },

                        type: 'touchstart mousedown'
                    }, {
                        // onMouseUp:
                        element: document,

                        handler: function () {
                            item.selection(1); // Enable text selection
                            item.drag.now = 0;
                        },

                        type: 'mouseup blur touchend'
                    }, {
                        // onCoordinateReset:
                        element: item.bar,

                        handler: function (e) {
                            if (e.button != 2) {
                                // Not RM
                                item._pos0(e);
                            }
                        },

                        type: 'touchstart mousedown'
                    }, {
                        // onMouseMove:
                        element: document,

                        handler: function (e) {
                            if (item.drag.now) {
                                item.drag(e);
                            }
                        },

                        type: 'mousemove touchmove'
                    }, {
                        // onResize:
                        element: window,

                        handler: function () {
                            item.update();
                        },

                        type: 'resize'
                    }, {
                        // sizeChange:
                        element: item.root,

                        handler: function () {
                            item.update();
                        },

                        type: 'sizeChange'
                    }];

                    each(item._eventHandlers, function (event) {
                        if (event.element) {
                            eventManager(event.element, event.type, event.handler, mode);
                        }
                    });

                    // if (item.scroller) {
                    //     event(item.scroller, 'scroll', item._eventHandlers.onScroll, mode);
                    // }
                    // if (item.bar) {
                    //     event(item.bar, 'touchstart mousedown', item._eventHandlers.onMouseDown, mode);
                    // }
                    // event(document, 'mouseup blur touchend', item._eventHandlers.onMouseUp, mode);
                    // event(document, 'touchstart mousedown', item._eventHandlers.onCoordinateReset, mode);
                    // event(document, 'mousemove touchmove', item._eventHandlers.onMouseMove, mode);
                    // event(window, 'resize', item._eventHandlers.onResize, mode);
                    // if (item.root) {
                    //     event(item.root, 'sizeChange', item._eventHandlers.onResize, mode); // Custon event for alternate baron update mechanism
                    // }
                }

                function manageAttr(node, direction, mode) {
                    var attrName = 'data-baron-' + direction;

                    if (mode == 'on') {
                        node.setAttribute(attrName, 'inited');
                    } else if (mode == 'off') {
                        node.removeAttribute(attrName);
                    } else {
                        return node.getAttribute(attrName);
                    }
                }

                function init(params) {
                    if (manageAttr(params.root, params.direction)) return;

                    var out = new item.prototype.constructor(params); // __proto__ of returning object is baron.prototype

                    manageEvents(out, params.event, 'on');

                    manageAttr(out.root, params.direction, 'on');

                    out.update();

                    return out;
                }

                function clone(input) {
                    var output = {};

                    input = input || {};

                    for (var key in input) {
                        if (input.hasOwnProperty(key)) {
                            output[key] = input[key];
                        }
                    }

                    return output;
                }

                function validate(input) {
                    var output = clone(input);

                    output.direction = output.direction || 'v';

                    var event = input.event || function (elem, event, func, mode) {
                        output.$(elem)[mode || 'on'](event, func);
                    };

                    output.event = function (elems, e, func, mode) {
                        each(elems, function (elem) {
                            event(elem, e, func, mode);
                        });
                    };

                    return output;
                }

                function fire(eventName) {
                    /* jshint validthis:true */
                    if (this.events && this.events[eventName]) {
                        for (var i = 0; i < this.events[eventName].length; i++) {
                            var args = Array.prototype.slice.call(arguments, 1);

                            this.events[eventName][i].apply(this, args);
                        }
                    }
                }

                var item = {};

                item.prototype = {
                    constructor: function (params) {
                        var $, barPos, scrollerPos0, track, resizePauseTimer, scrollPauseTimer, pause, scrollLastFire, resizeLastFire;

                        resizeLastFire = scrollLastFire = new Date().getTime();

                        $ = this.$ = params.$;
                        this.event = params.event;
                        this.events = {};

                        function getNode(sel, context) {
                            return $(sel, context)[0]; // Can be undefined
                        }

                        // DOM elements
                        this.root = params.root; // Always html node, not just selector
                        this.scroller = getNode(params.scroller); // (params.scroller) ? getNode(params.scroller, this.root) : this.root;
                        this.bar = getNode(params.bar, this.root);
                        track = this.track = getNode(params.track, this.root);
                        if (!this.track && this.bar) {
                            track = this.bar.parentNode;
                        }
                        this.clipper = this.scroller.parentNode;

                        // Parameters
                        this.direction = params.direction;
                        this.origin = origin[this.direction];
                        this.barOnCls = params.barOnCls;
                        this.barTopLimit = 0;
                        pause = params.pause * 1000 || 0;

                        // Updating height or width of bar
                        function setBarSize(size) {
                            /* jshint validthis:true */
                            var barMinSize = this.barMinSize || 20;

                            if (size > 0 && size < barMinSize) {
                                size = barMinSize;
                            }

                            if (this.bar) {
                                $(this.bar).css(this.origin.size, parseInt(size, 10) + 'px');
                            }
                        }

                        // Updating top or left bar position
                        function posBar(pos) {
                            /* jshint validthis:true */
                            if (this.bar) {
                                $(this.bar).css(this.origin.pos, +pos + 'px');
                            }
                        }

                        // Free path for bar
                        function k() {
                            /* jshint validthis:true */
                            return track[this.origin.client] - this.barTopLimit - this.bar[this.origin.offset];
                        }

                        // Relative content top position to bar top position
                        function relToPos(r) {
                            /* jshint validthis:true */
                            return r * k.call(this) + this.barTopLimit;
                        }

                        // Bar position to relative content position
                        function posToRel(t) {
                            /* jshint validthis:true */
                            return (t - this.barTopLimit) / k.call(this);
                        }

                        // Cursor position in main direction in px // Now with iOs support
                        this.cursor = function (e) {
                            return e['client' + this.origin.x] || (((e.originalEvent || e).touches || {})[0] || {})['page' + this.origin.x];
                        };

                        // Text selection pos preventing
                        function dontPosSelect() {
                            return false;
                        }

                        this.pos = function (x) {
                            // Absolute scroller position in px
                            var ie = 'page' + this.origin.x + 'Offset',
                                key = this.scroller[ie] ? ie : this.origin.scroll;

                            if (x !== undefined) this.scroller[key] = x;

                            return this.scroller[key];
                        };

                        this.rpos = function (r) {
                            // Relative scroller position (0..1)
                            var free = this.scroller[this.origin.scrollSize] - this.scroller[this.origin.client],
                                x;

                            if (r) x = this.pos(r * free);else x = this.pos();

                            return x / (free || 1);
                        };

                        // Switch on the bar by adding user-defined CSS classname to scroller
                        this.barOn = function (dispose) {
                            if (this.barOnCls) {
                                if (dispose || this.scroller[this.origin.client] >= this.scroller[this.origin.scrollSize]) {
                                    $(this.root).removeClass(this.barOnCls);
                                } else {
                                    $(this.root).addClass(this.barOnCls);
                                }
                            }
                        };

                        this._pos0 = function (e) {
                            scrollerPos0 = this.cursor(e) - barPos;
                        };

                        this.drag = function (e) {
                            this.scroller[this.origin.scroll] = posToRel.call(this, this.cursor(e) - scrollerPos0) * (this.scroller[this.origin.scrollSize] - this.scroller[this.origin.client]);
                        };

                        // Text selection preventing on drag
                        this.selection = function (enable) {
                            this.event(document, 'selectpos selectstart', dontPosSelect, enable ? 'off' : 'on');
                        };

                        // onResize & DOM modified handler
                        this.resize = function () {
                            var self = this,
                                delay = 0;

                            if (new Date().getTime() - resizeLastFire < pause) {
                                clearTimeout(resizePauseTimer);
                                delay = pause;
                            }

                            function upd() {
                                var delta = self.scroller[self.origin.crossOffset] - self.scroller[self.origin.crossClient];

                                if (params.freeze && !self.clipper.style[self.origin.crossSize]) {
                                    // Sould fire only once
                                    $(self.clipper).css(self.origin.crossSize, self.clipper[self.origin.crossClient] - delta + 'px');
                                }
                                $(self.scroller).css(self.origin.crossSize, self.clipper[self.origin.crossClient] + delta + 'px');

                                Array.prototype.unshift.call(arguments, 'resize');
                                fire.apply(self, arguments);

                                resizeLastFire = new Date().getTime();
                            }

                            if (delay) {
                                resizePauseTimer = setTimeout(upd, delay);
                            } else {
                                upd();
                            }
                        };

                        // onScroll handler
                        this.scroll = function () {
                            var oldBarSize,
                                newBarSize,
                                delay = 0,
                                self = this;

                            if (new Date().getTime() - scrollLastFire < pause) {
                                clearTimeout(scrollPauseTimer);
                                delay = pause;
                            }

                            function upd() {
                                if (self.bar) {
                                    newBarSize = (track[self.origin.client] - self.barTopLimit) * self.scroller[self.origin.client] / self.scroller[self.origin.scrollSize];

                                    // Positioning bar
                                    if (oldBarSize != newBarSize) {
                                        setBarSize.call(self, newBarSize);
                                        oldBarSize = newBarSize;
                                    }

                                    barPos = relToPos.call(self, self.rpos());

                                    posBar.call(self, barPos);
                                }

                                Array.prototype.unshift.call(arguments, 'scroll');
                                fire.apply(self, arguments);

                                scrollLastFire = new Date().getTime();
                            }

                            if (delay) {
                                scrollPauseTimer = setTimeout(upd, delay);
                            } else {
                                upd();
                            }
                        };

                        return this;
                    },

                    update: function (params) {
                        fire.call(this, 'upd', params); // Обновляем параметры всех плагинов

                        this.resize(1);
                        this.barOn();
                        this.scroll();

                        return this;
                    },

                    dispose: function (params) {
                        manageEvents(this, this.event, 'off');
                        manageAttr(this.root, params.direction, 'off');
                        $(this.scroller).css(this.origin.crossSize, '');
                        this.barOn(true);
                        fire.call(this, 'dispose');
                    },

                    on: function (eventName, func, arg) {
                        var names = eventName.split(' ');

                        for (var i = 0; i < names.length; i++) {
                            if (names[i] == 'init') {
                                func.call(this, arg);
                            } else {
                                this.events[names[i]] = this.events[names[i]] || [];

                                this.events[names[i]].push(function (userArg) {
                                    func.call(this, userArg || arg);
                                });
                            }
                        }
                    }
                };

                baron.fn.constructor.prototype = baron.fn;
                item.prototype.constructor.prototype = item.prototype;

                // Use when you need "baron" global var for another purposes
                baron.noConflict = function () {
                    window.baron = _baron; // Restoring original value of "baron" global var
                    return baron;
                };

                baron.version = '0.6.6';

                if ($ && $.fn) {
                    // Adding baron to jQuery as plugin
                    $.fn.baron = baron;
                }
                window.baron = baron; // Use noConflict method if you need window.baron var for another purposes

                var fix = function (userParams) {
                    var elements,
                        viewPortSize,
                        params = { // Default params
                        outside: '',
                        before: '',
                        after: '',
                        past: '',
                        future: '',
                        radius: 0,
                        minView: 0
                    },
                        topFixHeights = [],
                        // inline style for element
                    topRealHeights = [],
                        // real offset position when not fixed
                    headerTops = [],
                        scroller = this.scroller,
                        eventManager = this.event,
                        $ = this.$,
                        self = this;

                    function fixElement(i, pos) {
                        if (viewPortSize < (params.minView || 0)) {
                            // No headers fixing when no enought space for viewport
                            pos = undefined;
                        }

                        if (pos !== undefined) {
                            pos += 'px';
                            this.$(elements[i]).css(this.origin.pos, pos).addClass(params.outside);
                        } else {
                            this.$(elements[i]).css(this.origin.pos, '').removeClass(params.outside);
                        }
                    }

                    function bubbleWheel(e) {
                        try {
                            i = document.createEvent('WheelEvent'); // i - for extra byte
                            // evt.initWebKitWheelEvent(deltaX, deltaY, window, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey);
                            i.initWebKitWheelEvent(e.originalEvent.wheelDeltaX, e.originalEvent.wheelDeltaY);
                            scroller.dispatchEvent(i);
                            e.preventDefault();
                        } catch (e) {}
                    }

                    function init(_params) {
                        var pos;

                        for (var key in _params) {
                            params[key] = _params[key];
                        }

                        elements = this.$(params.elements, this.scroller);

                        if (elements) {
                            viewPortSize = this.scroller[this.origin.client];
                            for (var i = 0; i < elements.length; i++) {
                                // Variable header heights
                                pos = {};
                                pos[this.origin.size] = elements[i][this.origin.offset];
                                if (elements[i].parentNode !== this.scroller) {
                                    this.$(elements[i].parentNode).css(pos);
                                }
                                pos = {};
                                pos[this.origin.crossSize] = elements[i].parentNode[this.origin.crossClient];
                                this.$(elements[i]).css(pos);

                                // Between fixed headers
                                viewPortSize -= elements[i][this.origin.offset];

                                headerTops[i] = elements[i].parentNode[this.origin.offsetPos]; // No paddings for parentNode

                                // Summary elements height above current
                                topFixHeights[i] = topFixHeights[i - 1] || 0; // Not zero because of negative margins
                                topRealHeights[i] = topRealHeights[i - 1] || Math.min(headerTops[i], 0);

                                if (elements[i - 1]) {
                                    topFixHeights[i] += elements[i - 1][this.origin.offset];
                                    topRealHeights[i] += elements[i - 1][this.origin.offset];
                                }

                                if (!(i == 0 && headerTops[i] == 0) /* && force */) {
                                        this.event(elements[i], 'mousewheel', bubbleWheel, 'off');
                                        this.event(elements[i], 'mousewheel', bubbleWheel);
                                    }
                            }

                            if (params.limiter && elements[0]) {
                                // Bottom edge of first header as top limit for track
                                if (this.track && this.track != this.scroller) {
                                    pos = {};
                                    pos[this.origin.pos] = elements[0].parentNode[this.origin.offset];
                                    this.$(this.track).css(pos);
                                } else {
                                    this.barTopLimit = elements[0].parentNode[this.origin.offset];
                                }
                                // this.barTopLimit = elements[0].parentNode[this.origin.offset];
                                this.scroll();
                            }

                            if (params.limiter === false) {
                                // undefined (in second fix instance) should have no influence on bar limit
                                this.barTopLimit = 0;
                            }
                        }

                        var event = {
                            element: elements,

                            handler: function () {
                                var parent = $(this)[0].parentNode,
                                    top = parent.offsetTop,
                                    num;

                                // finding num -> elements[num] === this
                                for (var i = 0; i < elements.length; i++) {
                                    if (elements[i] === this) num = i;
                                }

                                var pos = top - topFixHeights[num];

                                if (params.scroll) {
                                    // User defined callback
                                    params.scroll({
                                        x1: self.scroller.scrollTop,
                                        x2: pos
                                    });
                                } else {
                                    self.scroller.scrollTop = pos;
                                }
                            },

                            type: 'click'
                        };

                        if (params.clickable) {
                            this._eventHandlers.push(event); // For auto-dispose
                            eventManager(event.element, event.type, event.handler, 'off');
                            eventManager(event.element, event.type, event.handler, 'on');
                        }
                    }

                    this.on('init', init, userParams);

                    this.on('init scroll', function () {
                        var fixState,
                            hTop,
                            fixFlag = []; // 1 - past, 2 - future, 3 - current (not fixed)

                        if (elements) {
                            var change;

                            // fixFlag update
                            for (var i = 0; i < elements.length; i++) {
                                fixState = 0;
                                if (headerTops[i] - this.pos() < topRealHeights[i] + params.radius) {
                                    // Header trying to go up
                                    fixState = 1;
                                    hTop = topFixHeights[i];
                                } else if (headerTops[i] - this.pos() > topRealHeights[i] + viewPortSize - params.radius) {
                                    // Header trying to go down
                                    fixState = 2;
                                    hTop = topFixHeights[i] + viewPortSize;
                                } else {
                                    // Header in viewport
                                    fixState = 3;
                                    hTop = undefined;
                                }
                                if (fixState != fixFlag[i]) {
                                    fixElement.call(this, i, hTop);
                                    fixFlag[i] = fixState;
                                    change = true;
                                }
                            }

                            // Adding positioning classes (on last top and first bottom header)
                            if (change) {
                                // At leats one change in elements flag structure occured
                                for (i = 0; i < elements.length; i++) {
                                    if (fixFlag[i] == 1 && params.past) {
                                        this.$(elements[i]).addClass(params.past).removeClass(params.future);
                                    }

                                    if (fixFlag[i] == 2 && params.future) {
                                        this.$(elements[i]).addClass(params.future).removeClass(params.past);
                                    }

                                    if (fixFlag[i] == 3 && (params.future || params.past)) {
                                        this.$(elements[i]).removeClass(params.past).removeClass(params.future);
                                    }

                                    if (fixFlag[i] != fixFlag[i + 1] && fixFlag[i] == 1 && params.before) {
                                        this.$(elements[i]).addClass(params.before).removeClass(params.after); // Last top fixed header
                                    } else if (fixFlag[i] != fixFlag[i - 1] && fixFlag[i] == 2 && params.after) {
                                        this.$(elements[i]).addClass(params.after).removeClass(params.before); // First bottom fixed header
                                    } else {
                                        this.$(elements[i]).removeClass(params.before).removeClass(params.after);
                                    }
                                }
                            }
                        }
                    });

                    this.on('resize upd', function (updParams) {
                        init.call(this, updParams && updParams.fix);
                    });
                };

                baron.fn.fix = function (params) {
                    var i = 0;

                    while (this[i]) {
                        fix.call(this[i], params);
                        i++;
                    }

                    return this;
                };

                var controls = function (params) {
                    var forward,
                        backward,
                        track,
                        screen,
                        self = this; // AAAAAA!!!!!11

                    screen = params.screen || 0.9;

                    if (params.forward) {
                        forward = this.$(params.forward, this.clipper);

                        this.event(forward, 'click', function () {
                            var y = self.pos() - params.delta || 30;

                            self.pos(y);
                        });
                    }

                    if (params.backward) {
                        backward = this.$(params.backward, this.clipper);

                        this.event(backward, 'click', function () {
                            var y = self.pos() + params.delta || 30;

                            self.pos(y);
                        });
                    }

                    if (params.track) {
                        if (params.track === true) {
                            track = this.track;
                        } else {
                            track = this.$(params.track, this.clipper)[0];
                        }

                        if (track) {
                            this.event(track, 'mousedown', function (e) {
                                var x = e['offset' + self.origin.x],
                                    xBar = self.bar[self.origin.offsetPos],
                                    sign = 0;

                                if (x < xBar) {
                                    sign = -1;
                                } else if (x > xBar + self.bar[self.origin.offset]) {
                                    sign = 1;
                                }

                                var y = self.pos() + sign * screen * self.scroller[self.origin.client];
                                self.pos(y);
                            });
                        }
                    }
                };

                baron.fn.controls = function (params) {
                    var i = 0;

                    while (this[i]) {
                        controls.call(this[i], params);
                        i++;
                    }

                    return this;
                };

                var pull = function (params) {
                    var block = this.$(params.block),
                        size = params.size || this.origin.size,
                        limit = params.limit || 80,
                        onExpand = params.onExpand,
                        elements = params.elements || [],
                        inProgress = params.inProgress || '',
                        self = this,
                        _insistence = 0,
                        _zeroXCount = 0,
                        _interval,
                        _timer,
                        _x = 0,
                        _onExpandCalled,
                        _waiting = params.waiting || 500,
                        _on;

                    function getSize() {
                        return self.scroller[self.origin.scroll] + self.scroller[self.origin.offset];
                    }

                    // Scroller content height
                    function getContentSize() {
                        return self.scroller[self.origin.scrollSize];
                    }

                    // Scroller height
                    function getScrollerSize() {
                        return self.scroller[self.origin.client];
                    }

                    function step(x, force) {
                        var k = x * 0.0005;

                        return Math.floor(force - k * (x + 550));
                    }

                    function toggle(on) {
                        _on = on;

                        if (on) {
                            update(); // First time with no delay
                            _interval = setInterval(update, 200);
                        } else {
                            clearInterval(_interval);
                        }
                    }

                    function update() {
                        var pos = {},
                            height = getSize(),
                            scrollHeight = getContentSize(),
                            dx,
                            op4,
                            scrollInProgress = _insistence == 1;

                        op4 = 0; // Возвращающая сила
                        if (_insistence > 0) {
                            op4 = 40;
                        }
                        //if (_insistence > -1) {
                        dx = step(_x, op4);
                        if (height >= scrollHeight - _x && _insistence > -1) {
                            if (scrollInProgress) {
                                _x += dx;
                            }
                        } else {
                            _x = 0;
                        }

                        if (_x < 0) _x = 0;

                        pos[size] = _x + 'px';
                        if (getScrollerSize() <= getContentSize()) {
                            self.$(block).css(pos);
                            for (var i = 0; i < elements.length; i++) {
                                self.$(elements[i].self).css(elements[i].property, Math.min(_x / limit * 100, 100) + '%');
                            }
                        }

                        if (inProgress && _x) {
                            self.$(self.root).addClass(inProgress);
                        }

                        if (_x == 0) {
                            if (params.onCollapse) {
                                params.onCollapse();
                            }
                        }

                        _insistence = 0;
                        _timer = setTimeout(function () {
                            _insistence = -1;
                        }, _waiting);
                        //}

                        if (onExpand && _x > limit && !_onExpandCalled) {
                            onExpand();
                            _onExpandCalled = true;
                        }

                        if (_x == 0) {
                            _zeroXCount++;
                        } else {
                            _zeroXCount = 0;
                        }
                        if (_zeroXCount > 1) {
                            toggle(false);
                            _onExpandCalled = false;
                            if (inProgress) {
                                self.$(self.root).removeClass(inProgress);
                            }
                        }
                    }

                    this.on('init', function () {
                        toggle(true);
                    });

                    this.on('dispose', function () {
                        toggle(false);
                    });

                    this.event(this.scroller, 'mousewheel DOMMouseScroll', function (e) {
                        var down = e.wheelDelta < 0 || e.originalEvent && e.originalEvent.wheelDelta < 0 || e.detail > 0;

                        if (down) {
                            _insistence = 1;
                            clearTimeout(_timer);
                            if (!_on && getSize() >= getContentSize()) {
                                toggle(true);
                            }
                        }
                        //  else {
                        //     toggle(false);
                        // }
                    });
                };

                baron.fn.pull = function (params) {
                    var i = 0;

                    while (this[i]) {
                        pull.call(this[i], params);
                        i++;
                    }

                    return this;
                };
            })(window);
        }, {}] }, {}, [2])(2);
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2Nzcy9zdHlsZXMuZnVsbC5kYXJrLmNzcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3ZlbmRvcnMvcG9seWZpbGxzL2VzNS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3ZlbmRvcnMvcG9seWZpbGxzL3Byb21pc2UuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDb3JlL3NyYy9ER0NvcmUuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDb3JlL3NyYy9ER3RoZW4uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDb3JlL3NyYy9ER3BsdWdpbi5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0FqYXgvc3JjL0RHQWpheC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1drdC9ER1drdC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1Byb2plY3REZXRlY3Rvci9zcmMvREdQcm9qZWN0RGV0ZWN0b3IuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdNZXRyaWMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdWZXJ0ZXhUcmFuc2Zvcm0uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdBcnJvd1BhdGhUcmFuc2Zvcm0uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdBcnJvd1RpcFRyYW5zZm9ybS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0VudHJhbmNlL3NyYy9ER0NvbXBsZXhQYXRoLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHRW50cmFuY2Uvc3JjL0RHUmVuZGVyZXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdCZXppZXJDdXJ2ZXMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdBbmltYXRpb24uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdFbnRyYW5jZS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0VudHJhbmNlL3NyYy9ER0VudHJhbmNlQXJyb3cuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdFbnRyYW5jZUFycm93U2hhcGUuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdMYWJlbC9zcmMvREdMYWJlbC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0xhYmVsL3NyYy9NYXJrZXIuREdMYWJlbC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0xhYmVsL3NyYy9QYXRoLkRHTGFiZWwuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdMYWJlbC9zcmMvRW50cmFuY2UuREdMYWJlbC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1BvcHVwL3NraW4vYmFzaWMvc2tpbi5jb25maWcuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdQb3B1cC9zcmMvREdQb3B1cC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0xvY2FsZS9zcmMvREdEaWN0aW9uYXJ5LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHTG9jYWxlL3NyYy9ER0xvY2FsZS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1JvdW5kQ29udHJvbC9zcmMvREdSb3VuZENvbnRyb2wuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdNdXNldW0vc3JjL0RHTXVzZXVtLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHQ3VzdG9taXphdGlvbi9za2luL2Jhc2ljL3NraW4uY29uZmlnLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHQ3VzdG9taXphdGlvbi9zcmMvREdDdXN0b21pemF0aW9uLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHQ3VzdG9taXphdGlvbi9zcmMvREdNYXAuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDdXN0b21pemF0aW9uL3NyYy9ER01hcC5CYXNlTGF5ZXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDdXN0b21pemF0aW9uL3NyYy9ER01hcC5UaWxlc0NoZWNrLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHQ3VzdG9taXphdGlvbi9zcmMvREdNYXAuRHJhZy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0N1c3RvbWl6YXRpb24vc3JjL0RHUG9seVV0aWwuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDdXN0b21pemF0aW9uL3NyYy9ER01vYmlsZUltcHJvdmUuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdab29tQ29udHJvbC9zcmMvREdab29tQ29udHJvbC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1pvb21Db250cm9sL2xhbmcvcnUuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdab29tQ29udHJvbC9sYW5nL2l0LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHWm9vbUNvbnRyb2wvbGFuZy9jcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1pvb21Db250cm9sL2xhbmcvZW4uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdab29tQ29udHJvbC9sYW5nL2VzLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHWm9vbUNvbnRyb2wvbGFuZy9hci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0R1c3Qvc3JjL0RHRHVzdC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0F0dHJpYnV0aW9uL3NyYy9ER0F0dHJpYnV0aW9uLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHQXR0cmlidXRpb24vbGFuZy9ydS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0F0dHJpYnV0aW9uL2xhbmcvaXQuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdBdHRyaWJ1dGlvbi9sYW5nL2NzLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHQXR0cmlidXRpb24vbGFuZy9lbi5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0F0dHJpYnV0aW9uL2xhbmcvZXMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdBdHRyaWJ1dGlvbi9sYW5nL2FyLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHTG9jYXRpb24vc3JjL0RHTG9jYXRpb24uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdMb2NhdGlvbi9sYW5nL3J1LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHTG9jYXRpb24vbGFuZy9pdC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0xvY2F0aW9uL2xhbmcvY3MuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdMb2NhdGlvbi9sYW5nL2VuLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHTG9jYXRpb24vbGFuZy9lcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0xvY2F0aW9uL2xhbmcvYXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdGdWxsU2NyZWVuL3NyYy9ER1NjcmVlbmZ1bGwuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdGdWxsU2NyZWVuL3NyYy9ER0Z1bGxTY3JlZW4uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdGdWxsU2NyZWVuL2xhbmcvcnUuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdGdWxsU2NyZWVuL2xhbmcvaXQuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdGdWxsU2NyZWVuL2xhbmcvY3MuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdGdWxsU2NyZWVuL2xhbmcvZW4uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdGdWxsU2NyZWVuL2xhbmcvZXMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdGdWxsU2NyZWVuL2xhbmcvYXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdNZXRhL3NyYy9ER01ldGEuTGF5ZXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdNZXRhL3NyYy9ER01ldGEuT3JpZ2luLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHUG9pL3NyYy9ER1BvaS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvc3JjL0RHR2VvY2xpY2tlci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvc3JjL0NsYW1wSGVscGVyLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHR2VvY2xpY2tlci9zcmMvcHJvdmlkZXIvUHJvdmlkZXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL3NyYy9wcm92aWRlci9DYXRhbG9nQXBpLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHR2VvY2xpY2tlci9zcmMvaGFuZGxlci9IYW5kbGVyLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHR2VvY2xpY2tlci9zcmMvaGFuZGxlci9EZWZhdWx0LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHR2VvY2xpY2tlci9zcmMvaGFuZGxlci9BcGlFcnJvci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvc3JjL2hhbmRsZXIvQ2l0eUFyZWEuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL3NyYy9oYW5kbGVyL0hvdXNlLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHR2VvY2xpY2tlci9zcmMvaGFuZGxlci9Ib3VzZS5WaWV3LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHR2VvY2xpY2tlci9zcmMvaGFuZGxlci9QT0kuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL3NyYy9oYW5kbGVyL1NpZ2h0LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHR2VvY2xpY2tlci9zcmMvVmlldy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvc3JjL0NvbnRyb2xsZXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL2xhbmcvaXQuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL2xhbmcvcnUuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL2xhbmcvZW4uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL2xhbmcvY3MuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL2xhbmcvZXMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy92ZW5kb3JzL2Zpcm1jYXJkL3NyYy9GaXJtQ2FyZC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3ZlbmRvcnMvZmlybWNhcmQvc3JjL0Zpcm1DYXJkLkRhdGFIZWxwZXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy92ZW5kb3JzL2Zpcm1jYXJkL3NyYy9GaXJtTGlzdC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3ZlbmRvcnMvZmlybWNhcmQvc3JjL1NjaGVkdWxlLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvdmVuZG9ycy9maXJtY2FyZC9zcmMvRGljdGlvbmFyeS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1RyYWZmaWMvc3JjL0RHVHJhZmZpYy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1RyYWZmaWMvbGFuZy9ydS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1RyYWZmaWMvbGFuZy9pdC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1RyYWZmaWMvbGFuZy9jcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1RyYWZmaWMvbGFuZy9lcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1RyYWZmaWMvbGFuZy9lbi5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1RyYWZmaWMvbGFuZy9hci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1RyYWZmaWNDb250cm9sL3NyYy9Db250cm9sLlRyYWZmaWMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdUcmFmZmljQ29udHJvbC9sYW5nL3J1LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHVHJhZmZpY0NvbnRyb2wvbGFuZy9pdC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1RyYWZmaWNDb250cm9sL2xhbmcvY3MuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdUcmFmZmljQ29udHJvbC9sYW5nL2VzLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHVHJhZmZpY0NvbnRyb2wvbGFuZy9lbi5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1RyYWZmaWNDb250cm9sL2xhbmcvYXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdSdWxlci9zcmMvUnVsZXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdSdWxlci9zcmMvTGF5ZXJlZE1hcmtlci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1J1bGVyL3NyYy9HZW9tZXRyeVN0eWxlcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1J1bGVyL2xhbmcvcnUuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdSdWxlci9sYW5nL2l0LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHUnVsZXIvbGFuZy9jcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1J1bGVyL2xhbmcvZXMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdSdWxlci9sYW5nL2VuLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHUnVsZXIvbGFuZy9hci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1J1bGVyQ29udHJvbC9zcmMvQ29udHJvbC5SdWxlci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1J1bGVyQ29udHJvbC9sYW5nL3J1LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHUnVsZXJDb250cm9sL2xhbmcvaXQuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdSdWxlckNvbnRyb2wvbGFuZy9jcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1J1bGVyQ29udHJvbC9sYW5nL2VzLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHUnVsZXJDb250cm9sL2xhbmcvZW4uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdSdWxlckNvbnRyb2wvbGFuZy9hci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL2NvcHlyaWdodC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL2NpdHlhcmVhLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvZmlybUNhcmRBZGRyLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvZmlybUNhcmRDb250YWN0cy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL2Zpcm1DYXJkSGVhZGVyLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvZmlybUNhcmRSdWJyaWMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9maXJtQ2FyZFNjaGVkdWxlLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvZmlybWxpc3RJdGVtLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvZnJpbUNhcmRQYXltZW50cy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL2hvdXNlLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvbG9hZGVyLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvcG9wdXBGb290ZXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9wb3B1cEZvb3RlckJ0bnMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9wb3B1cEhlYWRlci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NpZ2h0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY3NzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZHVzdGpzLWhlbHBlcnMvbGliL2R1c3QtaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9kdXN0anMtbGlua2VkaW4vbGliL2R1c3QuanMiLCJub2RlX21vZHVsZXMvaHRtbDVzaGl2L2Rpc3QvaHRtbDVzaGl2LmpzIiwibm9kZV9tb2R1bGVzL2xlYWZsZXQvZGlzdC9sZWFmbGV0LXNyYy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ2ZW5kb3JzL2Jhcm9uL2Jhcm9uLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDblNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcmRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMxckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDalVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNyZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN2S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JGQTtBQUNBO0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN0tBO0FBQ0E7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbnZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMvT0E7QUFDQTtBQUNBO0FBQ0E7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQ0hBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmxaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJ2YXIgY3NzID0gXCIubGVhZmxldC1pbWFnZS1sYXllciwubGVhZmxldC1sYXllciwubGVhZmxldC1tYXAtcGFuZSBjYW52YXMsLmxlYWZsZXQtbWFwLXBhbmUgc3ZnLC5sZWFmbGV0LW1hcmtlci1pY29uLC5sZWFmbGV0LW1hcmtlci1zaGFkb3csLmxlYWZsZXQtcGFuZSwubGVhZmxldC10aWxlLC5sZWFmbGV0LXRpbGUtY29udGFpbmVyLC5sZWFmbGV0LXpvb20tYm94e3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MH0ubGVhZmxldC1jb250YWluZXJ7b3ZlcmZsb3c6aGlkZGVufS5sZWFmbGV0LW1hcmtlci1pY29uLC5sZWFmbGV0LW1hcmtlci1zaGFkb3csLmxlYWZsZXQtdGlsZXstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7LXdlYmtpdC11c2VyLWRyYWc6bm9uZX0ubGVhZmxldC1zYWZhcmkgLmxlYWZsZXQtdGlsZXtpbWFnZS1yZW5kZXJpbmc6LXdlYmtpdC1vcHRpbWl6ZS1jb250cmFzdH0ubGVhZmxldC1zYWZhcmkgLmxlYWZsZXQtdGlsZS1jb250YWluZXJ7d2lkdGg6MTYwMHB4O2hlaWdodDoxNjAwcHg7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjAgMH0ubGVhZmxldC1tYXJrZXItaWNvbiwubGVhZmxldC1tYXJrZXItc2hhZG93e2Rpc3BsYXk6YmxvY2t9LmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LW1hcmtlci1wYW5lIGltZywubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHN2ZywubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtdGlsZS1wYW5lIGltZywubGVhZmxldC1jb250YWluZXIgaW1nLmxlYWZsZXQtaW1hZ2UtbGF5ZXJ7bWF4LXdpZHRoOm5vbmUhaW1wb3J0YW50fS5sZWFmbGV0LWNvbnRhaW5lci5sZWFmbGV0LXRvdWNoLXpvb217LW1zLXRvdWNoLWFjdGlvbjpwYW4teCBwYW4teTt0b3VjaC1hY3Rpb246cGFuLXggcGFuLXl9LmxlYWZsZXQtY29udGFpbmVyLmxlYWZsZXQtdG91Y2gtZHJhZ3stbXMtdG91Y2gtYWN0aW9uOnBpbmNoLXpvb219LmxlYWZsZXQtY29udGFpbmVyLmxlYWZsZXQtdG91Y2gtZHJhZy5sZWFmbGV0LXRvdWNoLWRyYWd7LW1zLXRvdWNoLWFjdGlvbjpub25lO3RvdWNoLWFjdGlvbjpub25lfS5sZWFmbGV0LXRpbGV7LXdlYmtpdC1maWx0ZXI6aW5oZXJpdDtmaWx0ZXI6aW5oZXJpdDt2aXNpYmlsaXR5OmhpZGRlbn0ubGVhZmxldC10aWxlLWxvYWRlZHt2aXNpYmlsaXR5OmluaGVyaXR9LmxlYWZsZXQtem9vbS1ib3h7d2lkdGg6MDtoZWlnaHQ6MDstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7ei1pbmRleDo4MDB9LmxlYWZsZXQtb3ZlcmxheS1wYW5lIHN2Z3stbW96LXVzZXItc2VsZWN0Om5vbmV9LmxlYWZsZXQtcGFuZXt6LWluZGV4OjQwMH0ubGVhZmxldC10aWxlLXBhbmV7ei1pbmRleDoyMDB9LmxlYWZsZXQtb3ZlcmxheS1wYW5le3otaW5kZXg6NDAwfS5sZWFmbGV0LXNoYWRvdy1wYW5le3otaW5kZXg6NTAwfS5sZWFmbGV0LW1hcmtlci1wYW5le3otaW5kZXg6NjAwfS5sZWFmbGV0LXRvb2x0aXAtcGFuZXt6LWluZGV4OjY1MH0ubGVhZmxldC1wb3B1cC1wYW5le3otaW5kZXg6NzAwfS5sZWFmbGV0LW1hcC1wYW5lIGNhbnZhc3t6LWluZGV4OjEwMH0ubGVhZmxldC1tYXAtcGFuZSBzdmd7ei1pbmRleDoyMDB9LmxlYWZsZXQtdm1sLXNoYXBle3dpZHRoOjFweDtoZWlnaHQ6MXB4fS5sdm1se2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOmFic29sdXRlfS5sZWFmbGV0LWNvbnRyb2x7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDo4MDA7cG9pbnRlci1ldmVudHM6dmlzaWJsZVBhaW50ZWQ7cG9pbnRlci1ldmVudHM6YXV0b30ubGVhZmxldC1ib3R0b20sLmxlYWZsZXQtdG9we3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MTAwMDtwb2ludGVyLWV2ZW50czpub25lfS5sZWFmbGV0LXRvcHt0b3A6MH0ubGVhZmxldC1yaWdodHtyaWdodDowfS5sZWFmbGV0LWJvdHRvbXtib3R0b206MH0ubGVhZmxldC1sZWZ0e2xlZnQ6MH0ubGVhZmxldC1jb250cm9se2Zsb2F0OmxlZnQ7Y2xlYXI6Ym90aH0ubGVhZmxldC1yaWdodCAubGVhZmxldC1jb250cm9se2Zsb2F0OnJpZ2h0fS5sZWFmbGV0LXRvcCAubGVhZmxldC1jb250cm9se21hcmdpbi10b3A6MTBweH0ubGVhZmxldC1ib3R0b20gLmxlYWZsZXQtY29udHJvbHttYXJnaW4tYm90dG9tOjEwcHh9LmxlYWZsZXQtbGVmdCAubGVhZmxldC1jb250cm9se21hcmdpbi1sZWZ0OjEwcHh9LmxlYWZsZXQtcmlnaHQgLmxlYWZsZXQtY29udHJvbHttYXJnaW4tcmlnaHQ6MTBweH0ubGVhZmxldC1mYWRlLWFuaW0gLmxlYWZsZXQtdGlsZXt3aWxsLWNoYW5nZTpvcGFjaXR5fS5sZWFmbGV0LWZhZGUtYW5pbSAubGVhZmxldC1wb3B1cHtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjJzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgLjJzIGxpbmVhcn0ubGVhZmxldC1mYWRlLWFuaW0gLmxlYWZsZXQtbWFwLXBhbmUgLmxlYWZsZXQtcG9wdXB7b3BhY2l0eToxfS5sZWFmbGV0LXpvb20tYW5pbWF0ZWR7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjAgMDstbXMtdHJhbnNmb3JtLW9yaWdpbjowIDA7dHJhbnNmb3JtLW9yaWdpbjowIDB9LmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20tYW5pbWF0ZWR7d2lsbC1jaGFuZ2U6dHJhbnNmb3JtOy13ZWJraXQtdHJhbnNpdGlvbjotd2Via2l0LXRyYW5zZm9ybSAuMjVzIGN1YmljLWJlemllcigwLDAsLjI1LDEpO3RyYW5zaXRpb246LXdlYmtpdC10cmFuc2Zvcm0gLjI1cyBjdWJpYy1iZXppZXIoMCwwLC4yNSwxKTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuMjVzIGN1YmljLWJlemllcigwLDAsLjI1LDEpO3RyYW5zaXRpb246dHJhbnNmb3JtIC4yNXMgY3ViaWMtYmV6aWVyKDAsMCwuMjUsMSksLXdlYmtpdC10cmFuc2Zvcm0gLjI1cyBjdWJpYy1iZXppZXIoMCwwLC4yNSwxKX0ubGVhZmxldC1wYW4tYW5pbSAubGVhZmxldC10aWxlLC5sZWFmbGV0LXpvb20tYW5pbSAubGVhZmxldC10aWxley13ZWJraXQtdHJhbnNpdGlvbjpub25lO3RyYW5zaXRpb246bm9uZX0ubGVhZmxldC16b29tLWFuaW0gLmxlYWZsZXQtem9vbS1oaWRle3Zpc2liaWxpdHk6aGlkZGVufS5sZWFmbGV0LWludGVyYWN0aXZle2N1cnNvcjpwb2ludGVyfS5sZWFmbGV0LWdyYWJ7Y3Vyc29yOi13ZWJraXQtZ3JhYjtjdXJzb3I6LW1vei1ncmFifS5sZWFmbGV0LWNyb3NzaGFpciwubGVhZmxldC1jcm9zc2hhaXIgLmxlYWZsZXQtaW50ZXJhY3RpdmV7Y3Vyc29yOmNyb3NzaGFpcn0ubGVhZmxldC1jb250cm9sLC5sZWFmbGV0LXBvcHVwLXBhbmV7Y3Vyc29yOmF1dG99LmxlYWZsZXQtZHJhZ2dpbmcgLmxlYWZsZXQtZ3JhYiwubGVhZmxldC1kcmFnZ2luZyAubGVhZmxldC1ncmFiIC5sZWFmbGV0LWludGVyYWN0aXZlLC5sZWFmbGV0LWRyYWdnaW5nIC5sZWFmbGV0LW1hcmtlci1kcmFnZ2FibGV7Y3Vyc29yOm1vdmU7Y3Vyc29yOi13ZWJraXQtZ3JhYmJpbmc7Y3Vyc29yOi1tb3otZ3JhYmJpbmd9LmxlYWZsZXQtaW1hZ2UtbGF5ZXIsLmxlYWZsZXQtbWFya2VyLWljb24sLmxlYWZsZXQtbWFya2VyLXNoYWRvdywubGVhZmxldC1wYW5lPnN2ZyBwYXRoLC5sZWFmbGV0LXRpbGUtY29udGFpbmVye3BvaW50ZXItZXZlbnRzOm5vbmV9LmxlYWZsZXQtaW1hZ2UtbGF5ZXIubGVhZmxldC1pbnRlcmFjdGl2ZSwubGVhZmxldC1tYXJrZXItaWNvbi5sZWFmbGV0LWludGVyYWN0aXZlLC5sZWFmbGV0LXBhbmU+c3ZnIHBhdGgubGVhZmxldC1pbnRlcmFjdGl2ZXtwb2ludGVyLWV2ZW50czp2aXNpYmxlUGFpbnRlZDtwb2ludGVyLWV2ZW50czphdXRvfS5sZWFmbGV0LWNvbnRhaW5lcntvdXRsaW5lOjB9LmxlYWZsZXQtY29udGFpbmVyIGF7Y29sb3I6IzAwNzhBOH0ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LWFjdGl2ZXtvdXRsaW5lOm9yYW5nZSBzb2xpZCAycHh9LmxlYWZsZXQtem9vbS1ib3h7Ym9yZGVyOjJweCBkb3R0ZWQgIzM4ZjtiYWNrZ3JvdW5kOnJnYmEoMjU1LDI1NSwyNTUsLjUpfS5sZWFmbGV0LWNvbnRhaW5lcntmb250OjEycHgvMS41IFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsQXJpYWwsSGVsdmV0aWNhLHNhbnMtc2VyaWZ9LmxlYWZsZXQtYmFyey13ZWJraXQtYm94LXNoYWRvdzowIDFweCA1cHggcmdiYSgwLDAsMCwuNjUpO2JveC1zaGFkb3c6MCAxcHggNXB4IHJnYmEoMCwwLDAsLjY1KTtib3JkZXItcmFkaXVzOjRweH0ubGVhZmxldC1iYXIgYSwubGVhZmxldC1iYXIgYTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2NjYzt3aWR0aDoyNnB4O2hlaWdodDoyNnB4O2xpbmUtaGVpZ2h0OjI2cHg7ZGlzcGxheTpibG9jazt0ZXh0LWFsaWduOmNlbnRlcjt0ZXh0LWRlY29yYXRpb246bm9uZTtjb2xvcjojMDAwfS5sZWFmbGV0LWJhciBhLC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjUwJSA1MCU7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2Rpc3BsYXk6YmxvY2t9LmxlYWZsZXQtYmFyIGE6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZjRmNGY0fS5sZWFmbGV0LWJhciBhOmZpcnN0LWNoaWxke2JvcmRlci10b3AtbGVmdC1yYWRpdXM6NHB4O2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjRweH0ubGVhZmxldC1iYXIgYTpsYXN0LWNoaWxke2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6NHB4O2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjRweDtib3JkZXItYm90dG9tOm5vbmV9LmxlYWZsZXQtYmFyIGEubGVhZmxldC1kaXNhYmxlZHtjdXJzb3I6ZGVmYXVsdDtiYWNrZ3JvdW5kLWNvbG9yOiNmNGY0ZjQ7Y29sb3I6I2JiYn0ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIgYXt3aWR0aDozMHB4O2hlaWdodDozMHB4O2xpbmUtaGVpZ2h0OjMwcHh9LmxlYWZsZXQtY29udHJvbC16b29tLWluLC5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXR7Zm9udDo3MDAgMThweCAnTHVjaWRhIENvbnNvbGUnLE1vbmFjbyxtb25vc3BhY2U7dGV4dC1pbmRlbnQ6MXB4fS5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXR7Zm9udC1zaXplOjIwcHh9LmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC16b29tLWlue2ZvbnQtc2l6ZToyMnB4fS5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXR7Zm9udC1zaXplOjI0cHh9LmxlYWZsZXQtY29udHJvbC1sYXllcnN7LXdlYmtpdC1ib3gtc2hhZG93OjAgMXB4IDVweCByZ2JhKDAsMCwwLC40KTtib3gtc2hhZG93OjAgMXB4IDVweCByZ2JhKDAsMCwwLC40KTtiYWNrZ3JvdW5kOiNmZmY7Ym9yZGVyLXJhZGl1czo1cHh9LmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xle2JhY2tncm91bmQtaW1hZ2U6dXJsKGRpc3QvY3NzL2ltYWdlcy9sYXllcnMucG5nKTt3aWR0aDozNnB4O2hlaWdodDozNnB4fS5sZWFmbGV0LXJldGluYSAubGVhZmxldC1jb250cm9sLWxheWVycy10b2dnbGV7YmFja2dyb3VuZC1pbWFnZTp1cmwoZGlzdC9jc3MvaW1hZ2VzL2xheWVycy0yeC5wbmcpO2JhY2tncm91bmQtc2l6ZToyNnB4IDI2cHh9LmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xle3dpZHRoOjQ0cHg7aGVpZ2h0OjQ0cHh9LmxlYWZsZXQtY29udHJvbC1sYXllcnMgLmxlYWZsZXQtY29udHJvbC1sYXllcnMtbGlzdCwubGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCAubGVhZmxldC1jb250cm9sLWxheWVycy10b2dnbGV7ZGlzcGxheTpub25lfS5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWxpc3R7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZX0ubGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZHtwYWRkaW5nOjZweCAxMHB4IDZweCA2cHg7Y29sb3I6IzMzMztiYWNrZ3JvdW5kOiNmZmZ9LmxlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFye292ZXJmbG93LXk6c2Nyb2xsO3BhZGRpbmctcmlnaHQ6NXB4fS5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9ye21hcmdpbi10b3A6MnB4O3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDoxcHh9LmxlYWZsZXQtY29udHJvbC1sYXllcnMgbGFiZWx7ZGlzcGxheTpibG9ja30ubGVhZmxldC1jb250cm9sLWxheWVycy1zZXBhcmF0b3J7aGVpZ2h0OjA7Ym9yZGVyLXRvcDoxcHggc29saWQgI2RkZDttYXJnaW46NXB4IC0xMHB4IDVweCAtNnB4fS5sZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoe2JhY2tncm91bmQtaW1hZ2U6dXJsKGRpc3QvY3NzL2ltYWdlcy9tYXJrZXItaWNvbi5wbmcpfS5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9ue2JhY2tncm91bmQ6I2ZmZjtiYWNrZ3JvdW5kOnJnYmEoMjU1LDI1NSwyNTUsLjcpO21hcmdpbjowfS5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24sLmxlYWZsZXQtY29udHJvbC1zY2FsZS1saW5le3BhZGRpbmc6MCA1cHg7Y29sb3I6IzMzM30ubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uIGF7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbiBhOmhvdmVye3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9LmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24sLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LWNvbnRyb2wtc2NhbGV7Zm9udC1zaXplOjExcHh9LmxlYWZsZXQtbGVmdCAubGVhZmxldC1jb250cm9sLXNjYWxle21hcmdpbi1sZWZ0OjVweH0ubGVhZmxldC1ib3R0b20gLmxlYWZsZXQtY29udHJvbC1zY2FsZXttYXJnaW4tYm90dG9tOjVweH0ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmV7Ym9yZGVyOjJweCBzb2xpZCAjNzc3O2JvcmRlci10b3A6bm9uZTtsaW5lLWhlaWdodDoxLjE7cGFkZGluZzoycHggNXB4IDFweDtmb250LXNpemU6MTFweDt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6aGlkZGVuOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtiYWNrZ3JvdW5kOiNmZmY7YmFja2dyb3VuZDpyZ2JhKDI1NSwyNTUsMjU1LC41KX0ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmU6bm90KDpmaXJzdC1jaGlsZCl7Ym9yZGVyLXRvcDoycHggc29saWQgIzc3Nztib3JkZXItYm90dG9tOm5vbmU7bWFyZ2luLXRvcDotMnB4fS5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZTpub3QoOmZpcnN0LWNoaWxkKTpub3QoOmxhc3QtY2hpbGQpe2JvcmRlci1ib3R0b206MnB4IHNvbGlkICM3Nzd9LmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyLC5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24sLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnN7LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7Ym94LXNoYWRvdzpub25lfS5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWJhciwubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLWxheWVyc3tib3JkZXI6MnB4IHNvbGlkIHJnYmEoMCwwLDAsLjIpO2JhY2tncm91bmQtY2xpcDpwYWRkaW5nLWJveH0ubGVhZmxldC1wb3B1cHtwb3NpdGlvbjphYnNvbHV0ZTt0ZXh0LWFsaWduOmNlbnRlcn0ubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXJ7dGV4dC1hbGlnbjpsZWZ0fS5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXJ7d2lkdGg6NDBweDtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjUwJTttYXJnaW4tbGVmdDotMjBweDtvdmVyZmxvdzpoaWRkZW47cG9pbnRlci1ldmVudHM6bm9uZX0ubGVhZmxldC1wb3B1cC10aXB7d2lkdGg6MTdweDtoZWlnaHQ6MTdweDtwYWRkaW5nOjFweDttYXJnaW46LTEwcHggYXV0byAwOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyk7LW1zLXRyYW5zZm9ybTpyb3RhdGUoNDVkZWcpO3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlciwubGVhZmxldC1wb3B1cC10aXB7YmFja2dyb3VuZDojZmZmO2NvbG9yOiMzMzM7LXdlYmtpdC1ib3gtc2hhZG93OjAgM3B4IDE0cHggcmdiYSgwLDAsMCwuNCk7Ym94LXNoYWRvdzowIDNweCAxNHB4IHJnYmEoMCwwLDAsLjQpfS5sZWFmbGV0LWNvbnRhaW5lciBhLmxlYWZsZXQtcG9wdXAtY2xvc2UtYnV0dG9ue2JvcmRlcjpub25lO2ZvbnQ6MTZweC8xNHB4IFRhaG9tYSxWZXJkYW5hLHNhbnMtc2VyaWY7Y29sb3I6I2MzYzNjMzt0ZXh0LWRlY29yYXRpb246bm9uZTtiYWNrZ3JvdW5kOjAgMH0ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LXBvcHVwLWNsb3NlLWJ1dHRvbjpob3Zlcntjb2xvcjojOTk5fS5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlcnt6b29tOjF9LmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtdGlwe3dpZHRoOjI0cHg7bWFyZ2luOjAgYXV0bzstbXMtZmlsdGVyOlxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT0wLjcwNzEwNjc4LCBNMTI9MC43MDcxMDY3OCwgTTIxPS0wLjcwNzEwNjc4LCBNMjI9MC43MDcxMDY3OClcXFwiO2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT0uNzA3MTA2NzgsIE0xMj0uNzA3MTA2NzgsIE0yMT0tLjcwNzEwNjc4LCBNMjI9LjcwNzEwNjc4KX0ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC10aXAtY29udGFpbmVye21hcmdpbi10b3A6LTFweH0ubGVhZmxldC1vbGRpZSAubGVhZmxldC1jb250cm9sLWxheWVycywubGVhZmxldC1vbGRpZSAubGVhZmxldC1jb250cm9sLXpvb20sLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVyLC5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLXRpcHtib3JkZXI6MXB4IHNvbGlkICM5OTl9LmxlYWZsZXQtZGl2LWljb257YmFja2dyb3VuZDojZmZmO2JvcmRlcjoxcHggc29saWQgIzY2Nn0ubGVhZmxldC10b29sdGlwe3Bvc2l0aW9uOmFic29sdXRlO3BhZGRpbmc6NnB4O2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXI6MXB4IHNvbGlkICNmZmY7Ym9yZGVyLXJhZGl1czozcHg7Y29sb3I6IzIyMjt3aGl0ZS1zcGFjZTpub3dyYXA7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO3BvaW50ZXItZXZlbnRzOm5vbmU7LXdlYmtpdC1ib3gtc2hhZG93OjAgMXB4IDNweCByZ2JhKDAsMCwwLC40KTtib3gtc2hhZG93OjAgMXB4IDNweCByZ2JhKDAsMCwwLC40KX0ubGVhZmxldC10b29sdGlwLmxlYWZsZXQtY2xpY2thYmxle2N1cnNvcjpwb2ludGVyO3BvaW50ZXItZXZlbnRzOmF1dG99LmxlYWZsZXQtdG9vbHRpcC1ib3R0b206YmVmb3JlLC5sZWFmbGV0LXRvb2x0aXAtbGVmdDpiZWZvcmUsLmxlYWZsZXQtdG9vbHRpcC1yaWdodDpiZWZvcmUsLmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3BvaW50ZXItZXZlbnRzOm5vbmU7Ym9yZGVyOjZweCBzb2xpZCB0cmFuc3BhcmVudDtiYWNrZ3JvdW5kOjAgMDtjb250ZW50OlxcXCJcXFwifS5sZWFmbGV0LXRvb2x0aXAtYm90dG9te21hcmdpbi10b3A6NnB4fS5sZWFmbGV0LXRvb2x0aXAtdG9we21hcmdpbi10b3A6LTZweH0ubGVhZmxldC10b29sdGlwLWJvdHRvbTpiZWZvcmUsLmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3Jle2xlZnQ6NTAlO21hcmdpbi1sZWZ0Oi02cHh9LmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3Jle2JvdHRvbTowO21hcmdpbi1ib3R0b206LTEycHg7Ym9yZGVyLXRvcC1jb2xvcjojZmZmfS5sZWFmbGV0LXRvb2x0aXAtYm90dG9tOmJlZm9yZXt0b3A6MDttYXJnaW4tdG9wOi0xMnB4O21hcmdpbi1sZWZ0Oi02cHg7Ym9yZGVyLWJvdHRvbS1jb2xvcjojZmZmfS5sZWFmbGV0LXRvb2x0aXAtbGVmdHttYXJnaW4tbGVmdDotNnB4fS5sZWFmbGV0LXRvb2x0aXAtcmlnaHR7bWFyZ2luLWxlZnQ6NnB4fS5sZWFmbGV0LXRvb2x0aXAtbGVmdDpiZWZvcmUsLmxlYWZsZXQtdG9vbHRpcC1yaWdodDpiZWZvcmV7dG9wOjUwJTttYXJnaW4tdG9wOi02cHh9LmxlYWZsZXQtdG9vbHRpcC1sZWZ0OmJlZm9yZXtyaWdodDowO21hcmdpbi1yaWdodDotMTJweDtib3JkZXItbGVmdC1jb2xvcjojZmZmfS5sZWFmbGV0LXRvb2x0aXAtcmlnaHQ6YmVmb3Jle2xlZnQ6MDttYXJnaW4tbGVmdDotMTJweDtib3JkZXItcmlnaHQtY29sb3I6I2ZmZn1bY2xhc3NePWRnLV0sW2NsYXNzXj1kZy1dOmFmdGVyLFtjbGFzc149ZGctXTpiZWZvcmV7LXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JveC1zaXppbmc6Y29udGVudC1ib3g7bWFyZ2luOjA7cGFkZGluZzowO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lO2ZvbnQtd2VpZ2h0OmluaGVyaXQ7Zm9udC1zdHlsZTppbmhlcml0O2ZvbnQtc2l6ZToxZW07Zm9udC1mYW1pbHk6aW5oZXJpdDtsaW5lLWhlaWdodDoxLjJ9W2NsYXNzXj1kZy1dPltjbGFzc149ZGctXTpsYXN0LWNoaWxke21hcmdpbi1ib3R0b206MH1bY2xhc3NePWRnLV0gYWJicixbY2xhc3NePWRnLV0gZmllbGRzZXQsW2NsYXNzXj1kZy1dIGltZ3tib3JkZXI6MH1bY2xhc3NePWRnLV0gYmxvY2txdW90ZSxbY2xhc3NePWRnLV0gcXtxdW90ZXM6bm9uZX1bY2xhc3NePWRnLV0gYmxvY2txdW90ZTphZnRlcixbY2xhc3NePWRnLV0gYmxvY2txdW90ZTpiZWZvcmUsW2NsYXNzXj1kZy1dIHE6YWZ0ZXIsW2NsYXNzXj1kZy1dIHE6YmVmb3Jle2NvbnRlbnQ6Jyc7Y29udGVudDpub25lfVtjbGFzc149ZGctXSBvbCxbY2xhc3NePWRnLV0gdWx7bGlzdC1zdHlsZTpub25lfVtjbGFzc149ZGctXSB0YWJsZXtib3JkZXItc3BhY2luZzowO2JvcmRlci1jb2xsYXBzZTpjb2xsYXBzZX1bY2xhc3NePWRnLV0gY2FwdGlvbixbY2xhc3NePWRnLV0gdGh7dGV4dC1hbGlnbjpsZWZ0fVtjbGFzc149ZGctXSB0ZCxbY2xhc3NePWRnLV0gdGh7dmVydGljYWwtYWxpZ246bWlkZGxlfVtjbGFzc149ZGctXSBidXR0b246Oi1tb3otZm9jdXMtaW5uZXIsW2NsYXNzXj1kZy1dIGlucHV0OjotbW96LWZvY3VzLWlubmVye3BhZGRpbmc6MDtib3JkZXI6MH0uZGctbGFiZWx7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO21heC13aWR0aDpub25lO21heC1oZWlnaHQ6bm9uZTt3aWR0aDozMDBweDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9LmRnLWxhYmVsX19jb250ZW50e2Rpc3BsYXk6aW5saW5lLWJsb2NrO292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjNweCA3cHg7bWluLXdpZHRoOjMwcHg7bWF4LXdpZHRoOjMwMHB4O3dpZHRoOmF1dG87Ym9yZGVyLXdpZHRoOjFweDtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLXJhZGl1czoycHg7dmVydGljYWwtYWxpZ246dG9wO2ZvbnQtc2l6ZToxMnB4fS5sZWFmbGV0LXRvcCAuZGctbGFiZWxfbmFtZV9sb2NhdGlvbi1lcnJvcnt0b3A6NXB4fS5sZWFmbGV0LXJpZ2h0IC5kZy1sYWJlbF9uYW1lX2xvY2F0aW9uLWVycm9ye3JpZ2h0OjQwcHg7bGVmdDphdXRvO3RleHQtYWxpZ246cmlnaHR9LmxlYWZsZXQtYm90dG9tIC5kZy1sYWJlbF9uYW1lX2xvY2F0aW9uLWVycm9ye3RvcDo0cHh9LmxlYWZsZXQtbGVmdCAuZGctbGFiZWxfbmFtZV9sb2NhdGlvbi1lcnJvcntsZWZ0OjQwcHh9LmRnLWxhYmVsX19jb250ZW50e2JvcmRlci1jb2xvcjojMzIzMjMyO2JvcmRlci1jb2xvcjpyZ2JhKDUwLDUwLDUwLC44NSk7YmFja2dyb3VuZDojMzIzMjMyO2JhY2tncm91bmQ6cmdiYSg1MCw1MCw1MCwuODUpO2NvbG9yOiNmZmQyNmV9LmxlYWZsZXQtcG9wdXB7bWFyZ2luLWJvdHRvbTowfS5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXJ7aGVpZ2h0OjB9LmxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVye292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjA7bWluLXdpZHRoOjYwcHg7bWluLWhlaWdodDo1MHB4O2JvcmRlcjowO2JvcmRlci1yYWRpdXM6M3B4O2JhY2tncm91bmQ6MCAwOy13ZWJraXQtYm94LXNoYWRvdzpub25lO2JveC1zaGFkb3c6bm9uZTtjb2xvcjojZTZlNmU2O2ZvbnQtc2l6ZToxNHB4Oy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IGVhc2Utb3V0IC4ycyxtYXgtaGVpZ2h0IGVhc2Utb3V0IC4ycyxoZWlnaHQgZWFzZS1vdXQgLjJzO3RyYW5zaXRpb246b3BhY2l0eSBlYXNlLW91dCAuMnMsbWF4LWhlaWdodCBlYXNlLW91dCAuMnMsaGVpZ2h0IGVhc2Utb3V0IC4yczstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46NTAlIDEwMCU7LW1zLXRyYW5zZm9ybS1vcmlnaW46NTAlIDEwMCU7dHJhbnNmb3JtLW9yaWdpbjo1MCUgMTAwJX0ubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXI6YmVmb3Jle2Zsb2F0OnJpZ2h0O3dpZHRoOjMwcHg7aGVpZ2h0OjE3cHg7Y29udGVudDonJ30ubGVhZmxldC1wb3B1cC1jb250ZW50e3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbjoxNnB4O3dpZHRoOmF1dG87bGluZS1oZWlnaHQ6MS40fS5sZWFmbGV0LXBvcHVwIGF7b3V0bGluZTowfS5sZWFmbGV0LXBvcHVwLWNvbnRlbnQgcHttYXJnaW46MH0ubGVhZmxldC1wb3B1cC1zY3JvbGxlZHtvdmVyZmxvdzp2aXNpYmxlO2JvcmRlcjowfS5sZWFmbGV0LXBvcHVwLWlubmVye3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MH0ubGVhZmxldC1wb3B1cF9zaG93X3RydWV7LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgZWFzZS1pbi1vdXQgLjJzLGhlaWdodCBlYXNlLW91dCAuMnMsLXdlYmtpdC10cmFuc2Zvcm0gZWFzZS1pbi1vdXQgLjJzO3RyYW5zaXRpb246b3BhY2l0eSBlYXNlLWluLW91dCAuMnMsaGVpZ2h0IGVhc2Utb3V0IC4ycywtd2Via2l0LXRyYW5zZm9ybSBlYXNlLWluLW91dCAuMnM7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gZWFzZS1pbi1vdXQgLjJzLG9wYWNpdHkgZWFzZS1pbi1vdXQgLjJzLGhlaWdodCBlYXNlLW91dCAuMnM7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gZWFzZS1pbi1vdXQgLjJzLG9wYWNpdHkgZWFzZS1pbi1vdXQgLjJzLGhlaWdodCBlYXNlLW91dCAuMnMsLXdlYmtpdC10cmFuc2Zvcm0gZWFzZS1pbi1vdXQgLjJzOy13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKDEpOy1tcy10cmFuc2Zvcm06c2NhbGUoMSk7dHJhbnNmb3JtOnNjYWxlKDEpfS5sZWFmbGV0LXBvcHVwX3Nob3dfZmFsc2V7b3BhY2l0eTowIWltcG9ydGFudDstd2Via2l0LXRyYW5zaXRpb246YWxsIGVhc2UtaW4tb3V0IC4xczt0cmFuc2l0aW9uOmFsbCBlYXNlLWluLW91dCAuMXM7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMC4yKTstbXMtdHJhbnNmb3JtOnNjYWxlKDAuMik7dHJhbnNmb3JtOnNjYWxlKDAuMil9LmxlYWZsZXQtcG9wdXBfcHJlbG9hZGVyX3RydWV7d2lkdGg6Mzg0cHg7aGVpZ2h0OjUycHh9LmxlYWZsZXQtbWFwLXBhbmUgLmxlYWZsZXQtcG9wdXAtdGlwLWNvbnRhaW5lcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6YXV0bztib3R0b206MDtsZWZ0OjUwJTttYXJnaW4tbGVmdDotMjlweDt3aWR0aDo1OHB4O2hlaWdodDo0N3B4O2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDQ3cHgpOy1tcy10cmFuc2Zvcm06dHJhbnNsYXRlWSg0N3B4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSg0N3B4KTtwb2ludGVyLWV2ZW50czpub25lfS5sZWFmbGV0LXBvcHVwLXRpcHtkaXNwbGF5Om5vbmV9LmxlYWZsZXQtcG9wdXAtdGlwLWNvbnRhaW5lcl9zdmd7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKGh0dHBzOi8vbWFwcy5hcGkuMmdpcy5ydS8yLjAvaW1nL0RHUG9wdXBfX3BvcHVwU2hhZG93LnBuZyk7YmFja2dyb3VuZC1wb3NpdGlvbjo1MCUgOTUlO2JhY2tncm91bmQtc2l6ZTozNnB4IDEycHh9LmxlYWZsZXQtcmV0aW5hIC5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXJfc3Zne2JhY2tncm91bmQtaW1hZ2U6dXJsKGh0dHBzOi8vbWFwcy5hcGkuMmdpcy5ydS8yLjAvaW1nL0RHUG9wdXBfX3BvcHVwU2hhZG93QDJ4LnBuZyl9LmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b257cG9zaXRpb246YWJzb2x1dGU7dG9wOjNweDtyaWdodDozcHg7ei1pbmRleDoxO292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjA7d2lkdGg6MzBweDtoZWlnaHQ6MzBweDt0ZXh0LWFsaWduOmNlbnRlcjtmb250LXdlaWdodDo0MDA7Zm9udC1zaXplOjE4cHg7bGluZS1oZWlnaHQ6MzBweDtjdXJzb3I6cG9pbnRlcn0ubm8tdG91Y2ggLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b246aG92ZXJ7Ym9yZGVyLXJhZGl1czoycHg7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuMnM7dHJhbnNpdGlvbjphbGwgLjJzfS5sZWFmbGV0LWNvbnRhaW5lciBhLmxlYWZsZXQtcG9wdXAtY2xvc2UtYnV0dG9uOmFjdGl2ZXtjb2xvcjojNzc3fS5sZWFmbGV0LWNvbnRhaW5lciBhLmxlYWZsZXQtcG9wdXAtY2xvc2UtYnV0dG9uOmFmdGVye3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6Mjtjb250ZW50OicnfS5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlcntiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoNTAsNTAsNTAsLjkpfS5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXJfaW1hZ2V7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjU4JTIyJTIwaGVpZ2h0JTNEJTIyNDclMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0wJTIwMGMxMi42NDMlMjAwJTIwMjglMjA3LjExNSUyMDI4JTIwNDRoMmMwLTM2Ljg4NSUyMDE1LjM1OC00NCUyMDI4LTQ0aC01OHolMjIlMjBmaWxsJTNEJTIycmdiYSg1MCUyQzUwJTJDNTAlMkMuOSklMjIlM0UlM0MlMkZwYXRoJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIil9LmxlYWZsZXQtbWFwLXBhbmUgLmxlYWZsZXQtcG9wdXAtdGlwLWNvbnRhaW5lcl9zdmd7ZmlsbDpyZ2JhKDUwLDUwLDUwLC45KX0ubm8tdG91Y2ggLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMjIyOy13ZWJraXQtYm94LXNoYWRvdzowIDFweCAzcHggcmdiYSgwLDAsMCwuNSk7Ym94LXNoYWRvdzowIDFweCAzcHggcmdiYSgwLDAsMCwuNSl9LmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b246YWZ0ZXJ7dG9wOi0zcHg7cmlnaHQ6LTVweDt3aWR0aDo0MHB4O2hlaWdodDo0MHB4fS5kZy13cmFwcGVye3Bvc2l0aW9uOnJlbGF0aXZlO292ZXJmbG93OmhpZGRlbn0uZGctc2Nyb2xsZXJ7aGVpZ2h0OjEwMCU7b3ZlcmZsb3cteTpzY3JvbGw7Ym9yZGVyOjB9LmRnLXNjcm9sbGVyX19iYXJ7ei1pbmRleDoxO3JpZ2h0OjA7YmFja2dyb3VuZDojOTk5fS5kZy1zY3JvbGxlcl9fYmFyX2h7Ym90dG9tOjJweDtoZWlnaHQ6OHB4fS5kZy1oZWFkZXJfX3RpdGxle3dpZHRoOjEwMCU7bWFyZ2luOjA7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O2JhY2tncm91bmQ6Izk5OX0uZGctaGVhZGVyX190aXRsZV9zdGF0ZV9maXhlZHtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjF9LmRnLXNjcm9sbGVyX2hpZGRlbl90cnVle292ZXJmbG93OmF1dG99LmRnLXNjcm9sbGVyOjotd2Via2l0LXNjcm9sbGJhcnt3aWR0aDowfS5kZy1zY3JvbGxlcl9fd3JhcHBlcntwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdzpoaWRkZW59LmRnLXNjcm9sbGVyX19iYXItd3JhcHBlcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MThweDtyaWdodDozcHg7Ym90dG9tOjRweDt3aWR0aDo3cHg7Ym9yZGVyLXJhZGl1czo1cHh9LmRnLXNjcm9sbGVyX2hpZGRlbl90cnVlIC5kZy1zY3JvbGxlcl9fYmFyLXdyYXBwZXJ7dmlzaWJpbGl0eTpoaWRkZW59LmRnLXBvcHVwX19oZWFkZXIrLmRnLXBvcHVwX19jb250YWluZXItd3JhcHBlciAuZGctc2Nyb2xsZXJfX2Jhci13cmFwcGVye3RvcDo0cHh9LmRnLXNjcm9sbGVyX19iYXJ7cG9zaXRpb246YWJzb2x1dGU7bWluLWhlaWdodDoyMHB4O3dpZHRoOjdweDtib3JkZXItcmFkaXVzOjNweDtwb2ludGVyLWV2ZW50czphdXRvfS5zY3JvbGxlcl9fYmFyLXdyYXBwZXIgLnNjcm9sbGVyX19iYXJ7YmFja2dyb3VuZC1jb2xvcjojNjY1YjRmfS5zY3JvbGxlcl9fYmFyLXdyYXBwZXI6aG92ZXIgLnNjcm9sbGVyX19iYXJ7YmFja2dyb3VuZC1jb2xvcjojODk3YTZifS5kZy1wb3B1cF9fY29udGFpbmVye21hcmdpbjowfS5sZWFmbGV0LXBvcHVwLXNjcm9sbGVkIC5kZy1wb3B1cF9fY29udGFpbmVye3BhZGRpbmc6OHB4IDE0cHggOHB4IDB9LmRnLXBvcHVwX19oZWFkZXJ7cG9zaXRpb246cmVsYXRpdmU7cGFkZGluZy1ib3R0b206MTJweH0ubGVhZmxldC1wb3B1cC1zY3JvbGxlZCAuZGctcG9wdXBfX2hlYWRlcjphZnRlcntwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6MTJweDtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7aGVpZ2h0OjFweDtjb250ZW50OicnfS5kZy1wb3B1cF9fZm9vdGVye3Bvc2l0aW9uOnJlbGF0aXZlO2JvdHRvbTowO292ZXJmbG93OmhpZGRlbn0ubGVhZmxldC1wb3B1cC1zY3JvbGxlZCAuZGctcG9wdXBfX2Zvb3RlcjpiZWZvcmV7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlO2hlaWdodDoxcHg7Y29udGVudDonJ30uZGctcG9wdXBfaGlkZGVuX3RydWV7ZGlzcGxheTpub25lfS5sZWFmbGV0LXBvcHVwLXNjcm9sbGVkIC5kZy1wb3B1cF9fZm9vdGVyOmJlZm9yZSwubGVhZmxldC1wb3B1cC1zY3JvbGxlZCAuZGctcG9wdXBfX2hlYWRlcjphZnRlcntib3JkZXItYm90dG9tOjFweCBzb2xpZCAjNjM2MzYzO2JhY2tncm91bmQtY29sb3I6IzQ5NDk0OX0uZGctY29udHJvbC1yb3VuZHtwb3NpdGlvbjpyZWxhdGl2ZTtwYWRkaW5nOjVweDt3aWR0aDozMHB4O2hlaWdodDozMHB4O2JvcmRlci1yYWRpdXM6NTAlO2N1cnNvcjpkZWZhdWx0fS5kZy1jb250cm9sLXJvdW5kX19pY29ue3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MzBweDtoZWlnaHQ6MzBweDtib3JkZXItcmFkaXVzOjUwJTtiYWNrZ3JvdW5kLWNvbG9yOiNmMGYwZjA7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IHRvcCxsZWZ0IGJvdHRvbSxjb2xvci1zdG9wKDAsI2ZmZiksdG8oI2UwZTBlMCkpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCNmZmYgMCwjZTBlMGUwIDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwjZmZmIDAsI2UwZTBlMCAxMDAlKTtjb2xvcjojMmIyYTI5O3RleHQtYWxpZ246Y2VudGVyO3RleHQtZGVjb3JhdGlvbjpub25lO3RleHQtc2hhZG93OjAgMXB4IDAgI2ZmZjtmb250LXNpemU6MjJweDtsaW5lLWhlaWdodDozMHB4O2N1cnNvcjpwb2ludGVyfS5uby10b3VjaCAuZGctY29udHJvbC1yb3VuZF9faWNvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmNWY1ZjU7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IHRvcCxsZWZ0IGJvdHRvbSxjb2xvci1zdG9wKDAsI2ViZWJlYiksdG8oI2ZmZikpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCNlYmViZWIgMCwjZmZmIDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwjZWJlYmViIDAsI2ZmZiAxMDAlKX0uZGctY29udHJvbC1yb3VuZF9faWNvbjphY3RpdmUsLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfYWN0aXZlLC5uby10b3VjaCAuZGctY29udHJvbC1yb3VuZF9faWNvbjphY3RpdmV7YmFja2dyb3VuZC1jb2xvcjojZWJlYmViO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsbGVmdCB0b3AsbGVmdCBib3R0b20sY29sb3Itc3RvcCgwLCNkNmQ2ZDYpLHRvKCNmZmYpKTtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwjZDZkNmQ2IDAsI2ZmZiAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0byBib3R0b20sI2Q2ZDZkNiAwLCNmZmYgMTAwJSl9LmxlYWZsZXQtZGlzYWJsZWQgLmRnLWNvbnRyb2wtcm91bmRfX2ljb24sLmxlYWZsZXQtZGlzYWJsZWQgLmRnLWNvbnRyb2wtcm91bmRfX2ljb246YWN0aXZlLC5uby10b3VjaCAubGVhZmxldC1kaXNhYmxlZCAuZGctY29udHJvbC1yb3VuZF9faWNvbjpob3ZlcntiYWNrZ3JvdW5kLWltYWdlOm5vbmU7Y3Vyc29yOmRlZmF1bHR9LmxlYWZsZXQtdG91Y2ggLmRnLWNvbnRyb2wtcm91bmRfX2ljb246YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3RvcDotMTBweDtyaWdodDotMTVweDtib3R0b206LTEwcHg7bGVmdDotMTVweDtjb250ZW50OicnfS5kZy1jb250cm9sLXJvdW5kX2lzLWhpZGRlbl90cnVle2Rpc3BsYXk6bm9uZX0uZGctY29udHJvbC1yb3VuZHtiYWNrZ3JvdW5kLWNvbG9yOiMzZDNkM2Q7LXdlYmtpdC1ib3gtc2hhZG93OjAgM3B4IDVweCAwIHJnYmEoMCwwLDAsLjMpO2JveC1zaGFkb3c6MCAzcHggNXB4IDAgcmdiYSgwLDAsMCwuMyl9LmRnLWNvbnRyb2wtcm91bmRfX2ljb257LXdlYmtpdC1ib3gtc2hhZG93OjAgMnB4IDJweCAwIHJnYmEoMCwwLDAsLjQpO2JveC1zaGFkb3c6MCAycHggMnB4IDAgcmdiYSgwLDAsMCwuNCl9Lm5vLXRvdWNoIC5kZy1jb250cm9sLXJvdW5kX19pY29uOmhvdmVyey13ZWJraXQtYm94LXNoYWRvdzppbnNldCAwIDFweCAjZmZmLDAgMCAwIDFweCByZ2JhKDAsMCwwLC4zKSwwIDFweCAwIDFweCByZ2JhKDAsMCwwLC40KTtib3gtc2hhZG93Omluc2V0IDAgMXB4ICNmZmYsMCAwIDAgMXB4IHJnYmEoMCwwLDAsLjMpLDAgMXB4IDAgMXB4IHJnYmEoMCwwLDAsLjQpfS5kZy1jb250cm9sLXJvdW5kX19pY29uOmFjdGl2ZSwuZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUsLm5vLXRvdWNoIC5kZy1jb250cm9sLXJvdW5kX19pY29uOmFjdGl2ZXstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAxcHggMXB4IDFweCByZ2JhKDAsMCwwLC4yKSwwIDAgMCAxcHggcmdiYSgwLDAsMCwuMyksMCAtMXB4IDFweCAwICMwMDA7Ym94LXNoYWRvdzppbnNldCAwIDFweCAxcHggMXB4IHJnYmEoMCwwLDAsLjIpLDAgMCAwIDFweCByZ2JhKDAsMCwwLC4zKSwwIC0xcHggMXB4IDAgIzAwMH0ubGVhZmxldC1kaXNhYmxlZCAuZGctY29udHJvbC1yb3VuZF9faWNvbiwubGVhZmxldC1kaXNhYmxlZCAuZGctY29udHJvbC1yb3VuZF9faWNvbjphY3RpdmUsLm5vLXRvdWNoIC5sZWFmbGV0LWRpc2FibGVkIC5kZy1jb250cm9sLXJvdW5kX19pY29uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2I4YjhiODstd2Via2l0LWJveC1zaGFkb3c6bm9uZTtib3gtc2hhZG93Om5vbmV9LmRnLW11c2V1bXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDt6LWluZGV4OjE1MDA7cGFkZGluZzo0cHggNXB4IDhweDtiYWNrZ3JvdW5kOiMzMzM7Y29sb3I6I2ZmZjtvcGFjaXR5Oi45Nzt0ZXh0LWFsaWduOmNlbnRlcn0uZGctbXVzZXVtLWJyb3dzZXJ7cG9zaXRpb246cmVsYXRpdmU7dG9wOjRweDtkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDoxNnB4O2hlaWdodDoxNnB4O21hcmdpbjowIDRweDtiYWNrZ3JvdW5kOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9ER011c2V1bS5qcGcpIGxlZnQgdG9wIG5vLXJlcGVhdH0uZGctbXVzZXVtX19jaHJvbWV7YmFja2dyb3VuZC1wb3NpdGlvbjowIDB9LmRnLW11c2V1bV9fY2hyb21lOmhvdmVye2JhY2tncm91bmQtcG9zaXRpb246MCAtMTZweH0uZGctbXVzZXVtX19maXJlZm94e2JhY2tncm91bmQtcG9zaXRpb246LTE2cHggMH0uZGctbXVzZXVtX19maXJlZm94OmhvdmVye2JhY2tncm91bmQtcG9zaXRpb246LTE2cHggLTE2cHh9LmRnLW11c2V1bV9fc2FmYXJpe2JhY2tncm91bmQtcG9zaXRpb246LTMycHggMH0uZGctbXVzZXVtX19zYWZhcmk6aG92ZXJ7YmFja2dyb3VuZC1wb3NpdGlvbjotMzJweCAtMTZweH0uZGctbXVzZXVtX19vcGVyYXt3aWR0aDoxNXB4O2JhY2tncm91bmQtcG9zaXRpb246LTQ4cHggMH0uZGctbXVzZXVtX19vcGVyYTpob3ZlcntiYWNrZ3JvdW5kLXBvc2l0aW9uOi00OHB4IC0xNnB4fS5kZy1tdXNldW1fX2lle3dpZHRoOjE3cHg7YmFja2dyb3VuZC1wb3NpdGlvbjotNjNweCAwfS5kZy1tdXNldW1fX2llOmhvdmVye2JhY2tncm91bmQtcG9zaXRpb246LTYzcHggLTE2cHh9LmRnLW11c2V1bV9fY2xvc2V7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luOjAgNHB4O3dpZHRoOjlweDtoZWlnaHQ6OXB4O2JhY2tncm91bmQ6dXJsKGh0dHBzOi8vbWFwcy5hcGkuMmdpcy5ydS8yLjAvaW1nL0RHTXVzZXVtX2Nsb3NlLmdpZikgdG9wIGxlZnQgbm8tcmVwZWF0O2N1cnNvcjpwb2ludGVyfS5kZy1tdXNldW1fX2Nsb3NlOmhvdmVye29wYWNpdHk6LjZ9LmxlYWZsZXQtY29udGFpbmVye3otaW5kZXg6MDtiYWNrZ3JvdW5kOiNmN2YzZGY7Y3Vyc29yOmRlZmF1bHR9LmxlYWZsZXQtY29udGFpbmVyOi13ZWJraXQtZnVsbC1zY3JlZW57d2lkdGg6MTAwJSFpbXBvcnRhbnQ7aGVpZ2h0OjEwMCUhaW1wb3J0YW50fS5sZWFmbGV0LWNvbnRhaW5lcjotbW96LWZ1bGwtc2NyZWVue3dpZHRoOjEwMCUhaW1wb3J0YW50O2hlaWdodDoxMDAlIWltcG9ydGFudH0ubGVhZmxldC1jb250YWluZXI6LW1zLWZ1bGxzY3JlZW57d2lkdGg6MTAwJSFpbXBvcnRhbnQ7aGVpZ2h0OjEwMCUhaW1wb3J0YW50fS5sZWFmbGV0LWNvbnRhaW5lcjpmdWxsc2NyZWVue3dpZHRoOjEwMCUhaW1wb3J0YW50O2hlaWdodDoxMDAlIWltcG9ydGFudH0ubGVhZmxldC1kcmFnZ2luZywubGVhZmxldC1kcmFnZ2luZyAubGVhZmxldC1jbGlja2FibGUsLmxlYWZsZXQtZHJhZ2dpbmcgLmxlYWZsZXQtY29udGFpbmVye2N1cnNvcjptb3ZlfS5sZWFmbGV0LWNvbnRyb2wgYSwubGVhZmxldC1jb250cm9sIGE6Zm9jdXN7b3V0bGluZTowIWltcG9ydGFudH0ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbntiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50Oy13ZWJraXQtYm94LXNoYWRvdzpub25lO2JveC1zaGFkb3c6bm9uZX0uZGctY3VzdG9taXphdGlvbl9fbWFya2Vye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdH0uZGctY3VzdG9taXphdGlvbl9fbWFya2VyOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtiYWNrZ3JvdW5kLWltYWdlOmluaGVyaXQ7YmFja2dyb3VuZC1zaXplOmNvbnRhaW47YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0Oy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IGVhc2UtaW4tb3V0IC4ycywtd2Via2l0LXRyYW5zZm9ybSBlYXNlLWluLW91dCAuMnM7dHJhbnNpdGlvbjpvcGFjaXR5IGVhc2UtaW4tb3V0IC4ycywtd2Via2l0LXRyYW5zZm9ybSBlYXNlLWluLW91dCAuMnM7dHJhbnNpdGlvbjpvcGFjaXR5IGVhc2UtaW4tb3V0IC4ycyx0cmFuc2Zvcm0gZWFzZS1pbi1vdXQgLjJzO3RyYW5zaXRpb246b3BhY2l0eSBlYXNlLWluLW91dCAuMnMsdHJhbnNmb3JtIGVhc2UtaW4tb3V0IC4ycywtd2Via2l0LXRyYW5zZm9ybSBlYXNlLWluLW91dCAuMnM7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMSwxKTstbXMtdHJhbnNmb3JtOnNjYWxlKDEsMSk7dHJhbnNmb3JtOnNjYWxlKDEsMSk7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjUwJSAxMDAlOy1tcy10cmFuc2Zvcm0tb3JpZ2luOjUwJSAxMDAlO3RyYW5zZm9ybS1vcmlnaW46NTAlIDEwMCV9LmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29te2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9ER0N1c3RvbWl6YXRpb25fX21hcmtlci5wbmcpO2JhY2tncm91bmQtc2l6ZToyMnB4IDM0cHg7d2lkdGg6MjJweDtoZWlnaHQ6MzRweDstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46NTAlIDEwMCU7LW1zLXRyYW5zZm9ybS1vcmlnaW46NTAlIDEwMCU7dHJhbnNmb3JtLW9yaWdpbjo1MCUgMTAwJTstd2Via2l0LWFuaW1hdGlvbjpkZy1jdXN0b21pemF0aW9uX19zaG93LW1hcmtlciAuMnM7YW5pbWF0aW9uOmRnLWN1c3RvbWl6YXRpb25fX3Nob3ctbWFya2VyIC4yc30ubGVhZmxldC1yZXRpbmEgLmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29te2JhY2tncm91bmQtaW1hZ2U6dXJsKGh0dHBzOi8vbWFwcy5hcGkuMmdpcy5ydS8yLjAvaW1nL0RHQ3VzdG9taXphdGlvbl9fbWFya2VyQDJ4LnBuZyl9LmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29tOmZvY3Vze291dGxpbmU6MH0ubm8tdG91Y2ggLmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29tOmhvdmVye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9ER0N1c3RvbWl6YXRpb25fX21hcmtlckhvdmVyLnBuZyk7YmFja2dyb3VuZC1zaXplOjIycHggMzRweH0ubGVhZmxldC1yZXRpbmEgLm5vLXRvdWNoIC5kZy1jdXN0b21pemF0aW9uX19tYXJrZXJfdHlwZV9tdXNocm9vbTpob3ZlcntiYWNrZ3JvdW5kLWltYWdlOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9ER0N1c3RvbWl6YXRpb25fX21hcmtlckhvdmVyQDJ4LnBuZyl9LmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29tOmFjdGl2ZSwubm8tdG91Y2ggLmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29tOmFjdGl2ZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoaHR0cHM6Ly9tYXBzLmFwaS4yZ2lzLnJ1LzIuMC9pbWcvREdDdXN0b21pemF0aW9uX19tYXJrZXJBY3RpdmUucG5nKTtiYWNrZ3JvdW5kLXNpemU6MjJweCAzNHB4fS5sZWFmbGV0LXJldGluYSAuZGctY3VzdG9taXphdGlvbl9fbWFya2VyX3R5cGVfbXVzaHJvb206YWN0aXZlLC5sZWFmbGV0LXJldGluYSAubm8tdG91Y2ggLmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29tOmFjdGl2ZXtiYWNrZ3JvdW5kLWltYWdlOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9ER0N1c3RvbWl6YXRpb25fX21hcmtlckFjdGl2ZUAyeC5wbmcpfUAtd2Via2l0LWtleWZyYW1lcyBkZy1jdXN0b21pemF0aW9uX19zaG93LW1hcmtlcntmcm9te29wYWNpdHk6MH10b3tvcGFjaXR5OjF9fUBrZXlmcmFtZXMgZGctY3VzdG9taXphdGlvbl9fc2hvdy1tYXJrZXJ7ZnJvbXtvcGFjaXR5OjB9dG97b3BhY2l0eToxfX0uZGctY3VzdG9taXphdGlvbl9fbWFya2VyX2FwcGVhcntiYWNrZ3JvdW5kLXBvc2l0aW9uOjk5OXB4fS5kZy1jdXN0b21pemF0aW9uX19tYXJrZXJfYXBwZWFyOmJlZm9yZXtjb250ZW50OicnfS5kZy1jdXN0b21pemF0aW9uX19tYXJrZXJfZGlzYXBwZWFye2JhY2tncm91bmQtcG9zaXRpb246OTk5cHg7cG9pbnRlci1ldmVudHM6bm9uZX0uZGctY3VzdG9taXphdGlvbl9fbWFya2VyX2Rpc2FwcGVhcjpiZWZvcmV7dmlzaWJpbGl0eTpoaWRkZW47Y29udGVudDonJztvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMS4yLDEuOCk7LW1zLXRyYW5zZm9ybTpzY2FsZSgxLjIsMS44KTt0cmFuc2Zvcm06c2NhbGUoMS4yLDEuOCk7LXdlYmtpdC1hbmltYXRpb246ZGctY3VzdG9taXphdGlvbl9fbWFya2VyLXRvLWNhbGxvdXQgLjJzO2FuaW1hdGlvbjpkZy1jdXN0b21pemF0aW9uX19tYXJrZXItdG8tY2FsbG91dCAuMnN9QC13ZWJraXQta2V5ZnJhbWVzIGRnLWN1c3RvbWl6YXRpb25fX21hcmtlci10by1jYWxsb3V0ezAle3Zpc2liaWxpdHk6dmlzaWJsZTtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMSwxKTt0cmFuc2Zvcm06c2NhbGUoMSwxKX0xMDAle3Zpc2liaWxpdHk6dmlzaWJsZTtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMS4yLDEuOCk7dHJhbnNmb3JtOnNjYWxlKDEuMiwxLjgpfX1Aa2V5ZnJhbWVzIGRnLWN1c3RvbWl6YXRpb25fX21hcmtlci10by1jYWxsb3V0ezAle3Zpc2liaWxpdHk6dmlzaWJsZTtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMSwxKTt0cmFuc2Zvcm06c2NhbGUoMSwxKX0xMDAle3Zpc2liaWxpdHk6dmlzaWJsZTtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMS4yLDEuOCk7dHJhbnNmb3JtOnNjYWxlKDEuMiwxLjgpfX0uZGctZHJhZ2dpbmctZmFsc2V7dG91Y2gtYWN0aW9uOmF1dG87LW1zLXRvdWNoLWFjdGlvbjphdXRvfS5kZy16b29te3dpZHRoOjQwcHg7aGVpZ2h0Ojc0cHh9LmRnLXpvb21fX2lue3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MH0ubGVhZmxldC10b3VjaCAuZGctem9vbV9faW46YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3RvcDotNXB4O3JpZ2h0Oi0xMHB4O2JvdHRvbTowO2xlZnQ6LTEwcHg7Y29udGVudDonJ30uZGctem9vbV9faW46YWZ0ZXJ7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDtib3R0b206LTFweDtsZWZ0OjA7ei1pbmRleDotMTttYXJnaW46YXV0bzt3aWR0aDoxMnB4O2hlaWdodDoycHg7LXdlYmtpdC1ib3gtc2hhZG93OjAgMCAzcHggMnB4IHJnYmEoMCwwLDAsLjMpO2JveC1zaGFkb3c6MCAwIDNweCAycHggcmdiYSgwLDAsMCwuMyk7Y29udGVudDonJ30uZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YWZ0ZXIsLmRnLXpvb21fX2J1dHRvbl90eXBlX2luOmJlZm9yZSwubGVhZmxldC10b3VjaCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO21hcmdpbjphdXRvO3dpZHRoOjE0cHg7aGVpZ2h0OjJweDtiYWNrZ3JvdW5kLWNvbG9yOiM3YTdhN2E7LXdlYmtpdC1ib3gtc2hhZG93OjAgMXB4ICNmZmY7Ym94LXNoYWRvdzowIDFweCAjZmZmO2NvbnRlbnQ6Jyd9LmRnLXpvb21fX2J1dHRvbl90eXBlX2luOmFmdGVye3dpZHRoOjJweDtoZWlnaHQ6MTRweH0ubm8tdG91Y2ggLmRnLXpvb21fX2J1dHRvbl90eXBlX2luOmhvdmVyOmFmdGVyLC5uby10b3VjaCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46aG92ZXI6YmVmb3Jle2JhY2tncm91bmQtY29sb3I6IzYxNjE2MX0uZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YWN0aXZlOmFmdGVyLC5kZy16b29tX19idXR0b25fdHlwZV9pbjphY3RpdmU6YmVmb3JlLC5uby10b3VjaCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YWN0aXZlOmFmdGVyLC5uby10b3VjaCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YWN0aXZlOmJlZm9yZXtiYWNrZ3JvdW5kLWNvbG9yOiM1NzU3NTd9LmxlYWZsZXQtZGlzYWJsZWQgLmRnLXpvb21fX2J1dHRvbl90eXBlX2luOmFjdGl2ZTphZnRlciwubGVhZmxldC1kaXNhYmxlZCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YWN0aXZlOmJlZm9yZSwubGVhZmxldC1kaXNhYmxlZCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YWZ0ZXIsLmxlYWZsZXQtZGlzYWJsZWQgLmRnLXpvb21fX2J1dHRvbl90eXBlX2luOmJlZm9yZSwubm8tdG91Y2ggLmxlYWZsZXQtZGlzYWJsZWQgLmRnLXpvb21fX2J1dHRvbl90eXBlX2luOmhvdmVyOmFmdGVyLC5uby10b3VjaCAubGVhZmxldC1kaXNhYmxlZCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46aG92ZXI6YmVmb3Jley13ZWJraXQtYm94LXNoYWRvdzpub25lO2JveC1zaGFkb3c6bm9uZX0uZGctem9vbV9fb3V0e3Bvc2l0aW9uOmFic29sdXRlO3RvcDo0MHB4O3JpZ2h0OjA7bGVmdDowO21hcmdpbjphdXRvO3dpZHRoOjIycHg7aGVpZ2h0OjIycHh9LmRnLXpvb21fX291dDphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTFweDtyaWdodDowO2xlZnQ6MDttYXJnaW46YXV0bzt3aWR0aDoxMnB4O2hlaWdodDoycHg7Y29udGVudDonJ30uZGctem9vbV9fYnV0dG9uX3R5cGVfb3V0e3dpZHRoOjIycHg7aGVpZ2h0OjIycHh9LmxlYWZsZXQtdG91Y2ggLmRnLXpvb21fX2J1dHRvbl90eXBlX291dDpiZWZvcmV7dG9wOi01cHg7cmlnaHQ6LTE5cHg7Ym90dG9tOi0xOXB4O2xlZnQ6LTE5cHh9LmRnLXpvb21fX2J1dHRvbl90eXBlX291dDphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDttYXJnaW46YXV0bzt3aWR0aDoxMHB4O2hlaWdodDoycHg7YmFja2dyb3VuZDojN2E3YTdhOy13ZWJraXQtYm94LXNoYWRvdzowIDFweCAjZmZmO2JveC1zaGFkb3c6MCAxcHggI2ZmZjtjb250ZW50OicnfS5uby10b3VjaCAuZGctem9vbV9fYnV0dG9uX3R5cGVfb3V0OmhvdmVyOmFmdGVye2JhY2tncm91bmQ6IzYxNjE2MX0uZGctem9vbV9fYnV0dG9uX3R5cGVfb3V0OmFjdGl2ZTphZnRlciwubm8tdG91Y2ggLmRnLXpvb21fX2J1dHRvbl90eXBlX291dDphY3RpdmU6YWZ0ZXJ7YmFja2dyb3VuZDojNTc1NzU3fS5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9vdXQ6YWN0aXZlOmFmdGVyLC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9vdXQ6YWZ0ZXIsLm5vLXRvdWNoIC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9vdXQ6aG92ZXI6YWZ0ZXJ7LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7Ym94LXNoYWRvdzpub25lfS5kZy16b29tX19vdXR7LXdlYmtpdC1ib3gtc2hhZG93OjAgMnB4IDNweCAwIHJnYmEoMCwwLDAsLjMpO2JveC1zaGFkb3c6MCAycHggM3B4IDAgcmdiYSgwLDAsMCwuMyl9LmRnLXpvb21fX291dDphZnRlcntiYWNrZ3JvdW5kLWNvbG9yOiMzZDNkM2R9LmxlYWZsZXQtZGlzYWJsZWQgLmRnLXpvb21fX2J1dHRvbl90eXBlX2luOmFjdGl2ZTphZnRlciwubGVhZmxldC1kaXNhYmxlZCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YWN0aXZlOmJlZm9yZSwubGVhZmxldC1kaXNhYmxlZCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YWZ0ZXIsLmxlYWZsZXQtZGlzYWJsZWQgLmRnLXpvb21fX2J1dHRvbl90eXBlX2luOmJlZm9yZSwubGVhZmxldC1kaXNhYmxlZCAuZGctem9vbV9fYnV0dG9uX3R5cGVfb3V0OmFjdGl2ZTphZnRlciwubGVhZmxldC1kaXNhYmxlZCAuZGctem9vbV9fYnV0dG9uX3R5cGVfb3V0OmFmdGVyLC5uby10b3VjaCAubGVhZmxldC1kaXNhYmxlZCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46aG92ZXI6YWZ0ZXIsLm5vLXRvdWNoIC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9pbjpob3ZlcjpiZWZvcmUsLm5vLXRvdWNoIC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9vdXQ6aG92ZXI6YWZ0ZXJ7YmFja2dyb3VuZC1jb2xvcjojNzA3MDcwfS5kZy1hdHRyaWJ1dGlvbntiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50IWltcG9ydGFudH0uZGctYXR0cmlidXRpb25fX2NvcHlyaWdodHttYXJnaW46MCA1NXB4IDVweCAwO3RleHQtYWxpZ246cmlnaHQ7d2hpdGUtc3BhY2U6bm93cmFwO2ZvbnQtc2l6ZTo5cHg7Zm9udC1mYW1pbHk6SGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWZ9LmRnLWF0dHJpYnV0aW9uX19saW5rc3tkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW46MDtwYWRkaW5nOjAgNXB4IDAgMH0uZGctYXR0cmlidXRpb25fX2xpbmstaXRlbXtwYWRkaW5nOjA7bGlzdC1zdHlsZS10eXBlOm5vbmV9LmxlYWZsZXQtY29udGFpbmVyIC5kZy1hdHRyaWJ1dGlvbl9fbGlua3tiYWNrZ3JvdW5kOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLGxlZnQgdG9wLHJpZ2h0IHRvcCxmcm9tKHJnYmEoOCw4LDgsLjMpKSx0byhyZ2JhKDgsOCw4LC4zKSkpIDAgOTUlLzEwcHggMXB4IHJlcGVhdC14O2JhY2tncm91bmQ6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQobGVmdCxyZ2JhKDgsOCw4LC4zKSxyZ2JhKDgsOCw4LC4zKSAxMDAlKSAwIDk1JS8xMHB4IDFweCByZXBlYXQteDtiYWNrZ3JvdW5kOmxpbmVhci1ncmFkaWVudCh0byByaWdodCxyZ2JhKDgsOCw4LC4zKSxyZ2JhKDgsOCw4LC4zKSAxMDAlKSAwIDk1JS8xMHB4IDFweCByZXBlYXQteDtjb2xvcjojMzMzO3RleHQtZGVjb3JhdGlvbjpub25lO2ZvbnQtc2l6ZTo5cHg7Zm9udC1mYW1pbHk6SGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWY7Y3Vyc29yOnBvaW50ZXJ9LmxlYWZsZXQtY29udGFpbmVyIC5kZy1hdHRyaWJ1dGlvbl9fbGluazpob3ZlcntiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLGxlZnQgdG9wLHJpZ2h0IHRvcCxmcm9tKCMwODA4MDgpLHRvKCMwODA4MDgpKTtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KGxlZnQsIzA4MDgwOCwjMDgwODA4IDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCMwODA4MDgsIzA4MDgwOCAxMDAlKTtjb2xvcjojMzMzO3RleHQtZGVjb3JhdGlvbjpub25lfS5kZy1hdHRyaWJ1dGlvbl9fbG9nby11cmx7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjBoZWlnaHQlM0QlMjIyNCUyMiUyMHdpZHRoJTNEJTIyNTUlMjIlM0UlMEElMjAlM0NwYXRoJTIwZmlsbCUzRCUyMiUyM2EyYzEyNCUyMiUyMGQlM0QlMjJtMjQuMzk1JTIwMTJjMC0xLjQ1NDUtMC4yMjE3Ny0yLjY1NDUtMC42NjUzMi00LTAuMTQ3ODUlMjA0LjI1NDUtNC44NzklMjA3LjgxODItNy40NjY0JTIwMTBoNi43NjQxYzAuNzAyMjktMiUyMDEuMzY3Ni0zLjkyNzMlMjAxLjM2NzYtNm0tNC43MzEtOS4zNDU1Yy0yLjAzMy0xLjYtNC42Mi0yLjY1NDUtNy40NjYtMi42NTQ1LTYuNzI3NiUyMDAtMTIuMTk4JTIwNS40MTgyLTEyLjE5OCUyMDEyczUuNDcwNCUyMDEyJTIwMTIuMTk4JTIwMTJjMy4xMDQ4JTIwMCUyMDUuOTUwOS0xLjQ1NDUlMjA4LjEzMTctMy4zNDU1aC04Ljc5N3YtMi42NTQ1YzUuMzU5NS00LjU0NTUlMjA4Ljc5Ny03LjM0NTUlMjA4Ljc5Ny0xMCUyMDAtMS4xMjczLTAuODEzMTctMi42NTQ1LTIuNjk4My0yLjY1NDUtMS40Nzg1JTIwMC0yLjY5ODMlMjAxLjM0NTUtMi42OTgzJTIwNC42NTQ1aC0zLjQwMDVjLTAuNzM5MjUtNC4yMTgyJTIwMS44NDgxLTcuNjcyNyUyMDYuMjQ2Ni03LjY3MjclMjAwLjY2NTMyJTIwMCUyMDEuMjU2NyUyMDAuMjE4MTglMjAxLjg4NTElMjAwLjMyNzI3JTIyJTJGJTNFJTBBJTIwJTNDcGF0aCUyMGZpbGwlM0QlMjIlMjMzYzQzNDclMjIlMjBkJTNEJTIybTM2LjU5MyUyMDkuMzQ1NWgxLjM2NzZjMC0yLTAuNjY1MzItNS4xMjczLTQuNzMxMi01LjI3MjctNC43MzItMC4yMTgzLTYuMSUyMDIuNjE4MS02LjElMjA1LjkyNzJ2NS4zNDU1YzAlMjA0LjQlMjAzLjQzNzUlMjA1LjM0NTUlMjA2LjA5ODglMjA1LjM0NTUlMjAxLjU1MjQlMjAwJTIwMy40MDA1LTAuODcyNzMlMjA0LjczMTItMnYtNi42OTA5aC01LjQzMzV2Mi42NTQ1aDIuNjk4M3YyLjY1NDVjLTEuMzY3NiUyMDEuMzQ1NS01LjQzMzUlMjAxLjM0NTUtNS40MzM1LTIuNjU0NXYtNS4zMDkxYzAtNCUyMDUuOTUwOS00LjE0NTUlMjA1LjYxODMlMjAwaDEuMTgyOHptMTguMjk2JTIwNi42NTQ1YzAtNS44MTgyLTYuOTg1OS00LjA3MjctNi45ODU5LTcuNiUyMDAtMS4yJTIwMC44MTMxNy0yJTIwMi4xODA4LTIlMjAxLjQ0MTUlMjAwJTIwMi4yNTQ3JTIwMS4wMTgyJTIwMi4yNTQ3JTIwMi45ODE4aDIuNTg3NGMwLTItMC42NjUzMi01LjM0NTUtNC43MzEyLTUuMzQ1NS0yLjc3MjIlMjAwLTQuODc5JTIwMS40MTgyLTQuODc5JTIwNC4zMjczJTIwMCUyMDYuMDcyNyUyMDcuMTcwNyUyMDQuMDcyNyUyMDcuMDU5OCUyMDcuNjcyNy0wLjA3MzkyJTIwMS40NTQ1LTEuMTQ1OCUyMDIuMDcyNy0yLjM2NTYlMjAyLjA3MjctMS40NDE1JTIwMC0yLjY5ODMtMC43MjcyNy0yLjQzOTUtMy4zODE4aC0yLjY2MTNjLTAuMjU4NzQlMjAzLjM0NTUlMjAxLjQ0MTUlMjA2JTIwNS4zNTk1JTIwNiUyMDIuNjk5JTIwMCUyMDQuNzMyLTIuMTQ1JTIwNC43MzItNS4zNDVsLTAuMTExJTIwMC42MTh6bS0xMi4xOTglMjA0aC0yLjY5ODN2LTE2aDIuNjk4M3YxNnolMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDo1NXB4O2hlaWdodDoyNHB4O2JhY2tncm91bmQtc2l6ZTo1NXB4IDI0cHg7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luOjAgM3B4IDAgMH0uZGctbG9jYXRpb25fX3BpbntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7d2lkdGg6MjBweDtoZWlnaHQ6MjBweDtiYWNrZ3JvdW5kLWltYWdlOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9zcHJpdGUuYmFzaWMucG5nKTtiYWNrZ3JvdW5kLXBvc2l0aW9uOi01NXB4IDA7YmFja2dyb3VuZC1zaXplOjg3cHggNzRweH0ubGVhZmxldC1yZXRpbmEgLmRnLWxvY2F0aW9uX19waW57YmFja2dyb3VuZC1pbWFnZTp1cmwoaHR0cHM6Ly9tYXBzLmFwaS4yZ2lzLnJ1LzIuMC9pbWcvc3ByaXRlQDJ4LmJhc2ljLnBuZyk7YmFja2dyb3VuZC1wb3NpdGlvbjotNTVweCAwO2JhY2tncm91bmQtc2l6ZTo5MXB4IDcxLjVweH0uZGctbG9jYXRpb25fX3Bpbl9zdGF0ZV9mb2xsb3dpbmd7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHg7YmFja2dyb3VuZC1pbWFnZTp1cmwoaHR0cHM6Ly9tYXBzLmFwaS4yZ2lzLnJ1LzIuMC9pbWcvc3ByaXRlLmJhc2ljLnBuZyk7YmFja2dyb3VuZC1wb3NpdGlvbjotMjJweCAtMjRweDtiYWNrZ3JvdW5kLXNpemU6ODdweCA3NHB4fS5sZWFmbGV0LXJldGluYSAuZGctbG9jYXRpb25fX3Bpbl9zdGF0ZV9mb2xsb3dpbmd7YmFja2dyb3VuZC1pbWFnZTp1cmwoaHR0cHM6Ly9tYXBzLmFwaS4yZ2lzLnJ1LzIuMC9pbWcvc3ByaXRlQDJ4LmJhc2ljLnBuZyk7YmFja2dyb3VuZC1wb3NpdGlvbjotMjFweCAtMjRweDtiYWNrZ3JvdW5kLXNpemU6OTFweCA3MS41cHh9LmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9sb2NhdGU6YWZ0ZXJ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7bWFyZ2luOmF1dG87Y29udGVudDonJ30uZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2xvY2F0ZTphY3RpdmU6YWZ0ZXIsLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfYWN0aXZlLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9sb2NhdGU6YWZ0ZXIsLm5vLXRvdWNoIC5kZy1jb250cm9sLXJvdW5kX19pY29uX3N0YXRlX2FjdGl2ZS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfbG9jYXRlOmhvdmVyOmFmdGVye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxOCUyMiUyMGhlaWdodCUzRCUyMjE4JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDZyUyMGZpbGwlM0QlMjIlMjMyM2E1ZDQlMjIlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxNyUyQzglMjBIJTIwMTUuOTIlMjBDJTIwMTUuNDglMkM0LjkzNyUyMDEzLjA2NCUyQzIuNTIlMjAxMCUyQzIuMDglMjBWJTIwMSUyMEMlMjAxMCUyQzAuNDQ4JTIwOS41NTMlMkMwJTIwOSUyQzAlMjA4LjQ0NyUyQzAlMjA4JTJDMC40NDglMjA4JTJDMSUyMFYlMjAyLjA4JTIwQyUyMDQuOTM2JTJDMi41MiUyMDIuNTIlMkM0LjkzNyUyMDIuMDglMkM4JTIwSCUyMDElMjBDJTIwMC40NDclMkM4JTIwMCUyQzguNDQ4JTIwMCUyQzklMjAwJTJDOS41NTMlMjAwLjQ0NyUyQzEwJTIwMSUyQzEwJTIwSCUyMDIuMDglMjBDJTIwMi41MiUyQzEzLjA2MyUyMDQuOTM2JTJDMTUuNDglMjA4JTJDMTUuOTIlMjBWJTIwMTclMjBjJTIwMCUyQzAuNTUzJTIwMC40NDclMkMxJTIwMSUyQzElMjAwLjU1MyUyQzAlMjAxJTJDLTAuNDQ3JTIwMSUyQy0xJTIwViUyMDE1LjkyJTIwQyUyMDEzLjA2NCUyQzE1LjQ4MSUyMDE1LjQ4JTJDMTMuMDY0JTIwMTUuOTIlMkMxMCUyMEglMjAxNyUyMEMlMjAxNy41NTMlMkMxMCUyMDE4JTJDOS41NTMlMjAxOCUyQzklMjAxOCUyQzguNDQ4JTIwMTcuNTUzJTJDOCUyMDE3JTJDOCUyMHolMjBNJTIwOSUyQzE0JTIwQyUyMDYuMjQlMkMxNCUyMDQlMkMxMS43NjIlMjA0JTJDOSUyMDQlMkM2LjIzOCUyMDYuMjQlMkM0JTIwOSUyQzQlMjBjJTIwMi43NjElMkMwJTIwNSUyQzIuMjM4JTIwNSUyQzUlMjAwJTJDMi43NjIlMjAtMi4yMzklMkM1JTIwLTUlMkM1JTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ2NpcmNsZSUyMGN4JTNEJTIyOSUyMiUyMGN5JTNEJTIyOSUyMiUyMHIlM0QlMjIzJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDJTJGZyUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE0JTJDMTAuMDA0JTIwQyUyMDE0JTJDOS44MzQlMjAxMy45OTElMkM5LjY2NyUyMDEzLjk3NSUyQzkuNTAyJTIwMTMuNzIzJTJDMTIuMDI3JTIwMTEuNTkyJTJDMTQlMjA5JTJDMTQlMjA2LjQwOCUyQzE0JTIwNC4yNzclMkMxMi4wMjclMjA0LjAyNSUyQzkuNTAyJTIwNC4wMDklMkM5LjY2NyUyMDQlMkM5LjgzNCUyMDQlMkMxMC4wMDQlMjBjJTIwMCUyQzIuNzYyJTIwMi4yNCUyQzUlMjA1JTJDNSUyMDIuNzYxJTJDMCUyMDUlMkMtMi4yMzglMjA1JTJDLTUlMjB6JTIwTSUyMDEwJTJDMy4wODMlMjBjJTIwMy4wNjQlMkMwLjQzOSUyMDUuNDglMkMyLjg1NiUyMDUuOTIlMkM1LjkyMSUyMEglMjAxNyUyMGMlMjAwLjM2OSUyQzAlMjAwLjY4OCUyQzAuMjAxJTIwMC44NiUyQzAuNDk4JTIwQyUyMDE3Ljk0NyUyQzkuMzU0JTIwMTglMkM5LjE4NCUyMDE4JTJDOSUyMDE4JTJDOC40NDglMjAxNy41NTMlMkM4JTIwMTclMkM4JTIwSCUyMDE1LjkyJTIwQyUyMDE1LjQ4JTJDNC45MzclMjAxMy4wNjQlMkMyLjUyJTIwMTAlMkMyLjA4JTIwViUyMDMuMDgzJTIweiUyME0lMjAxJTJDOS4wMDQlMjBIJTIwMi4wOCUyMEMlMjAyLjUyJTJDNS45MzklMjA0LjkzNiUyQzMuNTIyJTIwOCUyQzMuMDgzJTIwViUyMDIuMDglMjBDJTIwNC45MzYlMkMyLjUyJTIwMi41MiUyQzQuOTM3JTIwMi4wOCUyQzglMjBIJTIwMSUyMEMlMjAwLjQ0NyUyQzglMjAwJTJDOC40NDglMjAwJTJDOSUyMDAlMkM5LjE4NCUyMDAuMDUzJTJDOS4zNTQlMjAwLjE0JTJDOS41MDIlMjAwLjMxMiUyQzkuMjA1JTIwMC42MzElMkM5LjAwNCUyMDElMkM5LjAwNCUyMHolMjBtJTIwOCUyQy04JTIwYyUyMDAuNTUzJTJDMCUyMDElMkMwLjQ0NyUyMDElMkMxJTIwViUyMDElMjBDJTIwMTAlMkMwLjQ0OCUyMDkuNTUzJTJDMCUyMDklMkMwJTIwOC40NDclMkMwJTIwOCUyQzAuNDQ4JTIwOCUyQzElMjB2JTIwMS4wMDQlMjBjJTIwMCUyQy0wLjU1MyUyMDAuNDQ3JTJDLTElMjAxJTJDLTElMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzI2ODVhYSUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDklMkM3JTIwYyUyMDEuNDg2JTJDMCUyMDIuNzE3JTJDMS4wODIlMjAyLjk1NSUyQzIuNSUyMEMlMjAxMS45ODIlMkM5LjMzNyUyMDEyJTJDOS4xNzElMjAxMiUyQzklMjAxMiUyQzcuMzQ0JTIwMTAuNjU2JTJDNiUyMDklMkM2JTIwNy4zNDQlMkM2JTIwNiUyQzcuMzQ0JTIwNiUyQzklMjA2JTJDOS4xNzElMjA2LjAxOCUyQzkuMzM3JTIwNi4wNDUlMkM5LjUlMjA2LjI4MyUyQzguMDgyJTIwNy41MTQlMkM3JTIwOSUyQzclMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzFjODVhYiUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpfUAtd2Via2l0LWtleWZyYW1lcyBER0xvY2F0aW9uX19sb2NhdGVJY29uUmVxdWVzdGluZ0FuaW17dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDM2MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1Aa2V5ZnJhbWVzIERHTG9jYXRpb25fX2xvY2F0ZUljb25SZXF1ZXN0aW5nQW5pbXt0b3std2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfbG9jYXRlOmFmdGVye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxOCUyMiUyMGhlaWdodCUzRCUyMjE4JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDZyUyMGZpbGwlM0QlMjIlMjM2MTYxNjElMjIlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxNyUyQzglMjBIJTIwMTUuOTIlMjBDJTIwMTUuNDglMkM0LjkzNyUyMDEzLjA2NCUyQzIuNTIlMjAxMCUyQzIuMDglMjBWJTIwMSUyMEMlMjAxMCUyQzAuNDQ4JTIwOS41NTMlMkMwJTIwOSUyQzAlMjA4LjQ0NyUyQzAlMjA4JTJDMC40NDglMjA4JTJDMSUyMFYlMjAyLjA4JTIwQyUyMDQuOTM2JTJDMi41MiUyMDIuNTIlMkM0LjkzNyUyMDIuMDglMkM4JTIwSCUyMDElMjBDJTIwMC40NDclMkM4JTIwMCUyQzguNDQ4JTIwMCUyQzklMjAwJTJDOS41NTMlMjAwLjQ0NyUyQzEwJTIwMSUyQzEwJTIwSCUyMDIuMDglMjBDJTIwMi41MiUyQzEzLjA2MyUyMDQuOTM2JTJDMTUuNDglMjA4JTJDMTUuOTIlMjBWJTIwMTclMjBjJTIwMCUyQzAuNTUzJTIwMC40NDclMkMxJTIwMSUyQzElMjAwLjU1MyUyQzAlMjAxJTJDLTAuNDQ3JTIwMSUyQy0xJTIwViUyMDE1LjkyJTIwQyUyMDEzLjA2NCUyQzE1LjQ4MSUyMDE1LjQ4JTJDMTMuMDY0JTIwMTUuOTIlMkMxMCUyMEglMjAxNyUyMEMlMjAxNy41NTMlMkMxMCUyMDE4JTJDOS41NTMlMjAxOCUyQzklMjAxOCUyQzguNDQ4JTIwMTcuNTUzJTJDOCUyMDE3JTJDOCUyMHolMjBNJTIwOSUyQzE0JTIwQyUyMDYuMjQlMkMxNCUyMDQlMkMxMS43NjIlMjA0JTJDOSUyMDQlMkM2LjIzOCUyMDYuMjQlMkM0JTIwOSUyQzQlMjBjJTIwMi43NjElMkMwJTIwNSUyQzIuMjM4JTIwNSUyQzUlMjAwJTJDMi43NjIlMjAtMi4yMzklMkM1JTIwLTUlMkM1JTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ2NpcmNsZSUyMGN4JTNEJTIyOSUyMiUyMGN5JTNEJTIyOSUyMiUyMHIlM0QlMjIzJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDJTJGZyUzRSUwQSUyMCUyMCUyMCUyMCUzQ2clMjBmaWxsJTNEJTIyJTIzNDQ0JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTQlMkMxMC4wMDQlMjBDJTIwMTQlMkM5LjgzNCUyMDEzLjk5MSUyQzkuNjY3JTIwMTMuOTc1JTJDOS41MDIlMjAxMy43MjMlMkMxMi4wMjclMjAxMS41OTIlMkMxNCUyMDklMkMxNCUyMDYuNDA4JTJDMTQlMjA0LjI3NyUyQzEyLjAyNyUyMDQuMDI1JTJDOS41MDIlMjA0LjAwOSUyQzkuNjY3JTIwNCUyQzkuODM0JTIwNCUyQzEwLjAwNCUyMGMlMjAwJTJDMi43NjIlMjAyLjI0JTJDNSUyMDUlMkM1JTIwMi43NjElMkMwJTIwNSUyQy0yLjIzOCUyMDUlMkMtNSUyMHolMjBNJTIwMTAlMkMzLjA4MyUyMGMlMjAzLjA2NCUyQzAuNDM5JTIwNS40OCUyQzIuODU2JTIwNS45MiUyQzUuOTIxJTIwSCUyMDE3JTIwYyUyMDAuMzY5JTJDMCUyMDAuNjg4JTJDMC4yMDElMjAwLjg2JTJDMC40OTglMjBDJTIwMTcuOTQ3JTJDOS4zNTQlMjAxOCUyQzkuMTg0JTIwMTglMkM5JTIwMTglMkM4LjQ0OCUyMDE3LjU1MyUyQzglMjAxNyUyQzglMjBIJTIwMTUuOTIlMjBDJTIwMTUuNDglMkM0LjkzNyUyMDEzLjA2NCUyQzIuNTIlMjAxMCUyQzIuMDglMjBWJTIwMy4wODMlMjB6JTIwTSUyMDElMkM5LjAwNCUyMEglMjAyLjA4JTIwQyUyMDIuNTIlMkM1LjkzOSUyMDQuOTM2JTJDMy41MjIlMjA4JTJDMy4wODMlMjBWJTIwMi4wOCUyMEMlMjA0LjkzNiUyQzIuNTIlMjAyLjUyJTJDNC45MzclMjAyLjA4JTJDOCUyMEglMjAxJTIwQyUyMDAuNDQ3JTJDOCUyMDAlMkM4LjQ0OCUyMDAlMkM5JTIwMCUyQzkuMTg0JTIwMC4wNTMlMkM5LjM1NCUyMDAuMTQlMkM5LjUwMiUyMDAuMzEyJTJDOS4yMDUlMjAwLjYzMSUyQzkuMDA0JTIwMSUyQzkuMDA0JTIweiUyMG0lMjA4JTJDLTglMjBjJTIwMC41NTMlMkMwJTIwMSUyQzAuNDQ3JTIwMSUyQzElMjBWJTIwMSUyMEMlMjAxMCUyQzAuNDQ4JTIwOS41NTMlMkMwJTIwOSUyQzAlMjA4LjQ0NyUyQzAlMjA4JTJDMC40NDglMjA4JTJDMSUyMHYlMjAxLjAwNCUyMGMlMjAwJTJDLTAuNTUzJTIwMC40NDclMkMtMSUyMDElMkMtMSUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0MlMkZnJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwOSUyQzclMjBjJTIwMS40ODYlMkMwJTIwMi43MTclMkMxLjA4MiUyMDIuOTU1JTJDMi41JTIwQyUyMDExLjk4MiUyQzkuMzM3JTIwMTIlMkM5LjE3MSUyMDEyJTJDOSUyMDEyJTJDNy4zNDQlMjAxMC42NTYlMkM2JTIwOSUyQzYlMjA3LjM0NCUyQzYlMjA2JTJDNy4zNDQlMjA2JTJDOSUyMDYlMkM5LjE3MSUyMDYuMDE4JTJDOS4zMzclMjA2LjA0NSUyQzkuNSUyMDYuMjgzJTJDOC4wODIlMjA3LjUxNCUyQzclMjA5JTJDNyUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNDQ0JTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6MThweDtoZWlnaHQ6MThweDtiYWNrZ3JvdW5kLXNpemU6MThweCAxOHB4fS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfbG9jYXRlOmFjdGl2ZTphZnRlciwubm8tdG91Y2ggLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9sb2NhdGU6aG92ZXI6YWZ0ZXJ7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjE4JTIyJTIwaGVpZ2h0JTNEJTIyMTglMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NnJTIwZmlsbCUzRCUyMiUyMzQyNDI0MiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE3JTJDOCUyMEglMjAxNS45MiUyMEMlMjAxNS40OCUyQzQuOTM3JTIwMTMuMDY0JTJDMi41MiUyMDEwJTJDMi4wOCUyMFYlMjAxJTIwQyUyMDEwJTJDMC40NDglMjA5LjU1MyUyQzAlMjA5JTJDMCUyMDguNDQ3JTJDMCUyMDglMkMwLjQ0OCUyMDglMkMxJTIwViUyMDIuMDglMjBDJTIwNC45MzYlMkMyLjUyJTIwMi41MiUyQzQuOTM3JTIwMi4wOCUyQzglMjBIJTIwMSUyMEMlMjAwLjQ0NyUyQzglMjAwJTJDOC40NDglMjAwJTJDOSUyMDAlMkM5LjU1MyUyMDAuNDQ3JTJDMTAlMjAxJTJDMTAlMjBIJTIwMi4wOCUyMEMlMjAyLjUyJTJDMTMuMDYzJTIwNC45MzYlMkMxNS40OCUyMDglMkMxNS45MiUyMFYlMjAxNyUyMGMlMjAwJTJDMC41NTMlMjAwLjQ0NyUyQzElMjAxJTJDMSUyMDAuNTUzJTJDMCUyMDElMkMtMC40NDclMjAxJTJDLTElMjBWJTIwMTUuOTIlMjBDJTIwMTMuMDY0JTJDMTUuNDgxJTIwMTUuNDglMkMxMy4wNjQlMjAxNS45MiUyQzEwJTIwSCUyMDE3JTIwQyUyMDE3LjU1MyUyQzEwJTIwMTglMkM5LjU1MyUyMDE4JTJDOSUyMDE4JTJDOC40NDglMjAxNy41NTMlMkM4JTIwMTclMkM4JTIweiUyME0lMjA5JTJDMTQlMjBDJTIwNi4yNCUyQzE0JTIwNCUyQzExLjc2MiUyMDQlMkM5JTIwNCUyQzYuMjM4JTIwNi4yNCUyQzQlMjA5JTJDNCUyMGMlMjAyLjc2MSUyQzAlMjA1JTJDMi4yMzglMjA1JTJDNSUyMDAlMkMyLjc2MiUyMC0yLjIzOSUyQzUlMjAtNSUyQzUlMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDY2lyY2xlJTIwY3glM0QlMjI5JTIyJTIwY3klM0QlMjI5JTIyJTIwciUzRCUyMjMlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0MlMkZnJTNFJTBBJTIwJTIwJTIwJTIwJTNDZyUyMGZpbGwlM0QlMjIlMjMyZTJlMmUlMjIlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxNCUyQzEwLjAwNCUyMEMlMjAxNCUyQzkuODM0JTIwMTMuOTkxJTJDOS42NjclMjAxMy45NzUlMkM5LjUwMiUyMDEzLjcyMyUyQzEyLjAyNyUyMDExLjU5MiUyQzE0JTIwOSUyQzE0JTIwNi40MDglMkMxNCUyMDQuMjc3JTJDMTIuMDI3JTIwNC4wMjUlMkM5LjUwMiUyMDQuMDA5JTJDOS42NjclMjA0JTJDOS44MzQlMjA0JTJDMTAuMDA0JTIwYyUyMDAlMkMyLjc2MiUyMDIuMjQlMkM1JTIwNSUyQzUlMjAyLjc2MSUyQzAlMjA1JTJDLTIuMjM4JTIwNSUyQy01JTIweiUyME0lMjAxMCUyQzMuMDgzJTIwYyUyMDMuMDY0JTJDMC40MzklMjA1LjQ4JTJDMi44NTYlMjA1LjkyJTJDNS45MjElMjBIJTIwMTclMjBjJTIwMC4zNjklMkMwJTIwMC42ODglMkMwLjIwMSUyMDAuODYlMkMwLjQ5OCUyMEMlMjAxNy45NDclMkM5LjM1NCUyMDE4JTJDOS4xODQlMjAxOCUyQzklMjAxOCUyQzguNDQ4JTIwMTcuNTUzJTJDOCUyMDE3JTJDOCUyMEglMjAxNS45MiUyMEMlMjAxNS40OCUyQzQuOTM3JTIwMTMuMDY0JTJDMi41MiUyMDEwJTJDMi4wOCUyMFYlMjAzLjA4MyUyMHolMjBNJTIwMSUyQzkuMDA0JTIwSCUyMDIuMDglMjBDJTIwMi41MiUyQzUuOTM5JTIwNC45MzYlMkMzLjUyMiUyMDglMkMzLjA4MyUyMFYlMjAyLjA4JTIwQyUyMDQuOTM2JTJDMi41MiUyMDIuNTIlMkM0LjkzNyUyMDIuMDglMkM4JTIwSCUyMDElMjBDJTIwMC40NDclMkM4JTIwMCUyQzguNDQ4JTIwMCUyQzklMjAwJTJDOS4xODQlMjAwLjA1MyUyQzkuMzU0JTIwMC4xNCUyQzkuNTAyJTIwMC4zMTIlMkM5LjIwNSUyMDAuNjMxJTJDOS4wMDQlMjAxJTJDOS4wMDQlMjB6JTIwbSUyMDglMkMtOCUyMGMlMjAwLjU1MyUyQzAlMjAxJTJDMC40NDclMjAxJTJDMSUyMFYlMjAxJTIwQyUyMDEwJTJDMC40NDglMjA5LjU1MyUyQzAlMjA5JTJDMCUyMDguNDQ3JTJDMCUyMDglMkMwLjQ0OCUyMDglMkMxJTIwdiUyMDEuMDA0JTIwYyUyMDAlMkMtMC41NTMlMjAwLjQ0NyUyQy0xJTIwMSUyQy0xJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQyUyRmclM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjA5JTJDNyUyMGMlMjAxLjQ4NiUyQzAlMjAyLjcxNyUyQzEuMDgyJTIwMi45NTUlMkMyLjUlMjBDJTIwMTEuOTgyJTJDOS4zMzclMjAxMiUyQzkuMTcxJTIwMTIlMkM5JTIwMTIlMkM3LjM0NCUyMDEwLjY1NiUyQzYlMjA5JTJDNiUyMDcuMzQ0JTJDNiUyMDYlMkM3LjM0NCUyMDYlMkM5JTIwNiUyQzkuMTcxJTIwNi4wMTglMkM5LjMzNyUyMDYuMDQ1JTJDOS41JTIwNi4yODMlMkM4LjA4MiUyMDcuNTE0JTJDNyUyMDklMkM3JTIweiUyMiUyMGZpbGwlM0QlMjIlMjMyZTJlMmUlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKX0uZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9yZXF1ZXN0aW5nLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9sb2NhdGU6YWN0aXZlOmFmdGVyLC5kZy1jb250cm9sLXJvdW5kX19pY29uX3N0YXRlX3JlcXVlc3RpbmcuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2xvY2F0ZTphZnRlciwubm8tdG91Y2ggLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfcmVxdWVzdGluZy5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfbG9jYXRlOmhvdmVyOmFmdGVye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDt3aWR0aDoyNHB4O2hlaWdodDoyNHB4O2JhY2tncm91bmQtaW1hZ2U6dXJsKGh0dHBzOi8vbWFwcy5hcGkuMmdpcy5ydS8yLjAvaW1nL3Nwcml0ZS5kYXJrLnBuZyk7YmFja2dyb3VuZC1wb3NpdGlvbjowIDA7YmFja2dyb3VuZC1zaXplOjc4cHggNjVweDstd2Via2l0LWFuaW1hdGlvbjpER0xvY2F0aW9uX19sb2NhdGVJY29uUmVxdWVzdGluZ0FuaW0gMXMgbGluZWFyIGluZmluaXRlO2FuaW1hdGlvbjpER0xvY2F0aW9uX19sb2NhdGVJY29uUmVxdWVzdGluZ0FuaW0gMXMgbGluZWFyIGluZmluaXRlO2ltYWdlLXJlbmRlcmluZzpvcHRpbWl6ZVF1YWxpdHl9LmxlYWZsZXQtcmV0aW5hIC5kZy1jb250cm9sLXJvdW5kX19pY29uX3N0YXRlX3JlcXVlc3RpbmcuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2xvY2F0ZTphY3RpdmU6YWZ0ZXIsLmxlYWZsZXQtcmV0aW5hIC5kZy1jb250cm9sLXJvdW5kX19pY29uX3N0YXRlX3JlcXVlc3RpbmcuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2xvY2F0ZTphZnRlciwubGVhZmxldC1yZXRpbmEgLm5vLXRvdWNoIC5kZy1jb250cm9sLXJvdW5kX19pY29uX3N0YXRlX3JlcXVlc3RpbmcuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2xvY2F0ZTpob3ZlcjphZnRlcntiYWNrZ3JvdW5kLWltYWdlOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9zcHJpdGVAMnguZGFyay5wbmcpO2JhY2tncm91bmQtcG9zaXRpb246MCAwO2JhY2tncm91bmQtc2l6ZTo3OHB4IDY1cHh9LmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9mdWxsc2NyZWVuOmFmdGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO21hcmdpbjphdXRvO2NvbnRlbnQ6Jyd9LmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfYWN0aXZlLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9mdWxsc2NyZWVuOmFjdGl2ZTphZnRlciwuZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2Z1bGxzY3JlZW46YWZ0ZXIsLm5vLXRvdWNoIC5kZy1jb250cm9sLXJvdW5kX19pY29uX3N0YXRlX2FjdGl2ZS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfZnVsbHNjcmVlbjpob3ZlcjphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTYlMjIlMjBoZWlnaHQlM0QlMjIxNiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDYlMkMxJTIwSCUyMDElMjBWJTIwNiUyMEglMjAzJTIwViUyMDMlMjBoJTIwMyUyMHolMjBtJTIwNCUyQzE0JTIwaCUyMDUlMjB2JTIwLTUlMjBoJTIwLTIlMjB2JTIwMyUyMEglMjAxMCUyMHolMjBNJTIwMTUlMkM2JTIwViUyMDElMjBoJTIwLTUlMjB2JTIwMiUyMGglMjAzJTIwViUyMDYlMjB6JTIwTSUyMDElMkMxMCUyMHYlMjA1JTIwSCUyMDYlMjBWJTIwMTMlMjBIJTIwMyUyMHYlMjAtMyUyMHolMjIlMjBmaWxsJTNEJTIyJTIzMGRhNGQ0JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMSUyQzElMjBIJTIwNiUyMFYlMjAyJTIwSCUyMDElMjB6JTIwbSUyMDklMkMwJTIwaCUyMDUlMjB2JTIwMSUyMGglMjAtNSUyMHolMjBtJTIwMyUyQzklMjBoJTIwMiUyMHYlMjAxJTIwaCUyMC0yJTIweiUyMG0lMjAtMyUyQzMlMjBoJTIwMyUyMHYlMjAxJTIwaCUyMC0zJTIweiUyMG0lMjAtNyUyQzAlMjBoJTIwMyUyMHYlMjAxJTIwSCUyMDMlMjB6JTIwTSUyMDElMkMxMCUyMGglMjAyJTIwdiUyMDElMjBIJTIwMSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzMGE4NGFiJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMSUyQzYlMjBIJTIwMyUyMFYlMjA3JTIwSCUyMDElMjB6JTIwbSUyMDEyJTJDMCUyMGglMjAyJTIwViUyMDclMjBIJTIwMTMlMjB6JTIwTSUyMDElMkMxNSUyMGglMjA1JTIwdiUyMDElMjBIJTIwMSUyMHolMjBtJTIwOSUyQzAlMjBoJTIwNSUyMHYlMjAxJTIwaCUyMC01JTIweiUyMiUyMGZpbGwlM0QlMjIlMjNmZmYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKX0uZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2Z1bGxzY3JlZW46YWZ0ZXJ7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjE2JTIyJTIwaGVpZ2h0JTNEJTIyMTYlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxJTJDMyUyMEglMjA2JTIwViUyMDQlMjBIJTIwMSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNiUyQzElMjBIJTIwMSUyMFYlMjA2JTIwSCUyMDMlMjBWJTIwMyUyMGglMjAzJTIweiUyMG0lMjA0JTJDMTQlMjBoJTIwNSUyMHYlMjAtNSUyMGglMjAtMiUyMHYlMjAzJTIwaCUyMC0zJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM2YzZjNmMlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAxMCUyQzMlMjBoJTIwNSUyMHYlMjAxJTIwaCUyMC01JTIweiUyMiUyMGZpbGwlM0QlMjIlMjNmZmYlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxNSUyQzYlMjBWJTIwMSUyMGglMjAtNSUyMHYlMjAyJTIwaCUyMDMlMjBWJTIwNiUyMHolMjBNJTIwMSUyQzEwJTIwdiUyMDUlMjBIJTIwNiUyMFYlMjAxMyUyMEglMjAzJTIwdiUyMC0zJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM2YzZjNmMlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxJTJDMSUyMEglMjA2JTIwViUyMDIlMjBIJTIwMSUyMHolMjBtJTIwOSUyQzAlMjBoJTIwNSUyMHYlMjAxJTIwaCUyMC01JTIweiUyMG0lMjAzJTJDOSUyMGglMjAyJTIwdiUyMDElMjBoJTIwLTIlMjB6JTIwbSUyMC0zJTJDMyUyMGglMjAzJTIwdiUyMDElMjBoJTIwLTMlMjB6JTIwbSUyMC03JTJDMCUyMGglMjAzJTIwdiUyMDElMjBIJTIwMyUyMHolMjBNJTIwMSUyQzEwJTIwaCUyMDIlMjB2JTIwMSUyMEglMjAxJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM0YjRiNGIlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxJTJDNiUyMEglMjAzJTIwViUyMDclMjBIJTIwMSUyMHolMjBtJTIwMTIlMkMwJTIwaCUyMDIlMjBWJTIwNyUyMEglMjAxMyUyMHolMjBNJTIwMSUyQzE1JTIwaCUyMDUlMjB2JTIwMSUyMEglMjAxJTIweiUyMG0lMjA5JTJDMCUyMGglMjA1JTIwdiUyMDElMjBoJTIwLTUlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2ZmZiUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjE2cHg7aGVpZ2h0OjE2cHg7YmFja2dyb3VuZC1zaXplOjE2cHggMTZweH0uZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2Z1bGxzY3JlZW46YWN0aXZlOmFmdGVyLC5uby10b3VjaCAuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2Z1bGxzY3JlZW46aG92ZXI6YWZ0ZXJ7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjE2JTIyJTIwaGVpZ2h0JTNEJTIyMTYlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAxMiUyQzklMjBoJTIwNCUyMHYlMjA3JTIwaCUyMC00JTIweiUyMG0lMjAtMyUyQzMlMjBoJTIwNSUyMHYlMjA0JTIwSCUyMDklMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2ZmZiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDEwJTJDMTUlMjBoJTIwNSUyMHYlMjAtNSUyMGglMjAtMiUyMHYlMjAzJTIwaCUyMC0zJTIweiUyMiUyMGZpbGwlM0QlMjIlMjMyODI4MjglMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAwJTJDOSUyMGglMjA0JTIwdiUyMDclMjBIJTIwMCUyMHolMjBtJTIwMiUyQzMlMjBoJTIwNSUyMHYlMjA0JTIwSCUyMDIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2ZmZiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDElMkMxMCUyMHYlMjA1JTIwSCUyMDYlMjBWJTIwMTMlMjBIJTIwMyUyMHYlMjAtMyUyMHolMjIlMjBmaWxsJTNEJTIyJTIzMjgyODI4JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMCUyQzAlMjBIJTIwNCUyMFYlMjA3JTIwSCUyMDAlMjB6JTIwbSUyMDklMkMwJTIwaCUyMDUlMjBWJTIwNCUyMEglMjA5JTIweiUyMG0lMjAzJTJDMCUyMGglMjA0JTIwdiUyMDclMjBoJTIwLTQlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2ZmZiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE1JTJDNiUyMFYlMjAxJTIwaCUyMC01JTIwdiUyMDIlMjBoJTIwMyUyMHYlMjAzJTIweiUyMiUyMGZpbGwlM0QlMjIlMjMyODI4MjglMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAyJTJDMCUyMEglMjA3JTIwViUyMDQlMjBIJTIwMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNiUyQzElMjBIJTIwMSUyMFYlMjA2JTIwSCUyMDMlMjBWJTIwMyUyMGglMjAzJTIweiUyMiUyMGZpbGwlM0QlMjIlMjMyODI4MjglMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKX0uZGctYnVpbGRpbmctY2FsbG91dF9fYm9keXtwb3NpdGlvbjpyZWxhdGl2ZX0uZGctYnVpbGRpbmctY2FsbG91dF9fbGlzdHttYXJnaW4tYm90dG9tOjhweDtwYWRkaW5nLWxlZnQ6MjRweDtjb2xvcjojZmZlNmFhO2xpc3Qtc3R5bGU6bm9uZX0uZGctYnVpbGRpbmctY2FsbG91dF9fbGlzdC1pdGVte3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbi1ib3R0b206NHB4O2ZvbnQtc2l6ZToxMnB4fS5kZy1idWlsZGluZy1jYWxsb3V0X19saXN0LWl0ZW06YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1cHg7bGVmdDotMjFweDtjb250ZW50OicnO2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjI2JTIyJTIwaGVpZ2h0JTNEJTIyNiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDMlMkMtMC4wMDIlMjBDJTIwNC42NTQlMkMtMC4wMDIlMjA1Ljk5NCUyQzEuMzQyJTIwNS45OTQlMkMzJTIwNS45OTQlMkM0LjY1OCUyMDQuNjU1JTJDNi4wMDIlMjAzJTJDNi4wMDIlMjAxLjM0NSUyQzYuMDAyJTIwMC4wMDUlMkM0LjY1OCUyMDAuMDA1JTJDMyUyMDAuMDA1JTJDMS4zNDIlMjAxLjM0NiUyQy0wLjAwMiUyMDMlMkMtMC4wMDIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2FhYSUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDo2cHg7aGVpZ2h0OjZweDtiYWNrZ3JvdW5kLXNpemU6NnB4IDZweH0uZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3N7bWFyZ2luLWJvdHRvbToxMHB4O2ZvbnQtc2l6ZToxNnB4fS5kZy1tYXAtZ2VvY2xpY2tlcl9fcHVycG9zZSsuZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3N7bWFyZ2luLXRvcDotNnB4fS5kZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzcy1oZWFkZXJ7cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luLWJvdHRvbTo0cHg7cGFkZGluZy1sZWZ0OjI0cHh9LmRnLW1hcC1nZW9jbGlja2VyX19hZGRyZXNzLWhlYWRlcjpmaXJzdC1jaGlsZDpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjVweDtsZWZ0OjFweDtjb250ZW50OicnfS5kZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzcy1kcmlsbGRvd257cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luLWJvdHRvbTo0cHg7cGFkZGluZy1sZWZ0OjI0cHg7Y29sb3I6I2FhYTtmb250LXNpemU6MTJweH0uZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3MtZHJpbGxkb3duOmZpcnN0LWNoaWxkOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MnB4O2xlZnQ6MXB4O2NvbnRlbnQ6Jyd9LmRnLW1hcC1nZW9jbGlja2VyX19wdXJwb3Nle3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbi1ib3R0b206MTBweDtwYWRkaW5nLWxlZnQ6MjRweDtmb250LXNpemU6MTZweH0uZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3MrLmRnLW1hcC1nZW9jbGlja2VyX19wdXJwb3Nle21hcmdpbi10b3A6LTZweH0uZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2U6YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3RvcDo0cHg7bGVmdDoycHg7Y29udGVudDonJ30uZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2VfdHlwZV9zdHJlZXQ6YmVmb3Jle3RvcDo0cHh9LmRnLW1hcC1nZW9jbGlja2VyX19zaWdodC1kZXNjcmlwdGlvbntvdmVyZmxvdzpoaWRkZW47cGFkZGluZzouNWVtIDAgMCAyNHB4O21heC1oZWlnaHQ6My42ZW19YS5kZy1tYXAtZ2VvY2xpY2tlcl9fc2hvdy1tb3JlLXNpZ2h0cy1saW5re3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbi1sZWZ0OjI0cHg7Ym9yZGVyLWJvdHRvbToxcHggZG90dGVkO3RleHQtZGVjb3JhdGlvbjpub25lfWEuZGctbWFwLWdlb2NsaWNrZXJfX3Nob3ctbW9yZS1zaWdodHMtbGluazphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NHB4O21hcmdpbi1sZWZ0OjVweDt3aWR0aDo2cHg7aGVpZ2h0OjEwcHg7Y29udGVudDonJztmb250LXdlaWdodDo3MDB9LmRnLW1hcC1nZW9jbGlja2VyX19jbGFtcGVkLWxpbmV7ZGlzcGxheTpibG9jazt3aGl0ZS1zcGFjZTpub3dyYXB9LmRnLW1hcC1nZW9jbGlja2VyX19jbGFtcGVkLWxpbmVfbGFzdHtvdmVyZmxvdzpoaWRkZW47d2lkdGg6MTAwJTt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5kZy1tYXAtZ2VvY2xpY2tlcl9fcHJlbG9hZGVyLXdyYXBwZXJ7ZGlzcGxheTp0YWJsZS1jZWxsO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTt0ZXh0LWFsaWduOmNlbnRlcn0uZGctbWFwLWdlb2NsaWNrZXJfX2RyaWxsZG93bnttYXJnaW4tYm90dG9tOjEwcHh9LmRnLW1hcC1nZW9jbGlja2VyX19hZGRyZXNzLWRyaWxsZG93bjpmaXJzdC1jaGlsZDpiZWZvcmUsLmRnLW1hcC1nZW9jbGlja2VyX19hZGRyZXNzLWhlYWRlcjpmaXJzdC1jaGlsZDpiZWZvcmV7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjklMjIlMjBoZWlnaHQlM0QlMjIxMSUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDQuOTU4JTJDMTElMjBDJTIwNC45NTglMkM5LjAzNiUyMDYuNzU2JTJDNi43NTElMjA4LjcxOSUyQzYuNzUxJTIwOC44ODUlMkM2LjIyMyUyMDklMkM1LjY1NiUyMDklMkM1LjA2MyUyMDklMkMyLjI2NyUyMDYuOTg1JTJDMCUyMDQuNSUyQzAlMjAyLjAxNSUyQzAlMjAwJTJDMi4yNjclMjAwJTJDNS4wNjMlMjAwJTJDNS42NTYlMjAwLjExNCUyQzYuMjIyJTIwMC4yOCUyQzYuNzUxJTIwMi4yNDMlMkM2Ljc1MSUyMDQuMDE4JTJDOS4wMTIlMjA0LjAxOCUyQzExJTIwaCUyMDAuOTQlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2EwYTBhMCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjlweDtoZWlnaHQ6MTFweDtiYWNrZ3JvdW5kLXNpemU6OXB4IDExcHh9LmRnLW1hcC1nZW9jbGlja2VyX19wdXJwb3NlOmJlZm9yZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyOCUyMiUyMGhlaWdodCUzRCUyMjEyJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMy41ODIlMkM4JTIwYyUyMDAuMjExJTJDMCUyMDAuNzk4JTJDMC4wMzUlMjAxJTJDMCUyMHYlMjA0JTIwbCUyMC0yJTJDLTElMjBWJTIwOCUyMGMlMjAwLjM3MiUyQzAuMDY2JTIwMC44NjElMkMwJTIwMSUyQzAlMjB6JTIwTSUyMDAuNDQlMkM1LjM4NCUyMEMlMjAwLjE2MyUyQzQuODY2JTIwMCUyQzQuMjc2JTIwMCUyQzMuNjQ2JTIwMCUyQzEuNjMzJTIwMS42MDQlMkMwLjAwMiUyMDMuNTgyJTJDMC4wMDIlMjBjJTIwMS45NzglMkMwJTIwMy41ODIlMkMxLjYzMSUyMDMuNTgyJTJDMy42NDQlMjAwJTJDMC42NDclMjAtMC4xNjklMkMxLjI1NCUyMC0wLjQ2MSUyQzEuNzgxJTIwTCUyMDYuNjQxJTJDNS40OTUlMjA2LjYxOCUyQzUuNTY3JTIwQyUyMDUuOTU0JTJDNi41NDklMjA0Ljg0NCUyQzcuMTkyJTIwMy41ODQlMkM3LjE5MiUyMDIuMjUlMkM3LjE5MiUyMDEuMDg0JTJDNi40NjclMjAwLjQ0JTJDNS4zODQlMjB6JTIwTSUyMDIuNjEzJTJDMS4yNzYlMjBjJTIwLTAuNTQ5JTJDMCUyMC0wLjk5NSUyQzAuNDUzJTIwLTAuOTk1JTJDMS4wMTMlMjAwJTJDMC41NTklMjAwLjQ0NiUyQzEuMDEzJTIwMC45OTUlMkMxLjAxMyUyMDAuNTUxJTJDMCUyMDAuOTk2JTJDLTAuNDU0JTIwMC45OTYlMkMtMS4wMTMlMjAwJTJDLTAuNTYlMjAtMC40NDUlMkMtMS4wMTMlMjAtMC45OTYlMkMtMS4wMTMlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2EwYTBhMCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjhweDtoZWlnaHQ6MTJweDtiYWNrZ3JvdW5kLXNpemU6OHB4IDEycHh9LmRnLW1hcC1nZW9jbGlja2VyX19wdXJwb3NlX3R5cGVfc3RyZWV0OmJlZm9yZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTIlMjIlMjBoZWlnaHQlM0QlMjIxMiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDguOCUyQzAlMjBIJTIwMy4xOTklMjBMJTIwMCUyQzEyJTIwSCUyMDEyJTIwTCUyMDguOCUyQzAlMjB6JTIwTSUyMDclMkMxMiUyMEglMjA1JTIwViUyMDklMjBoJTIwMiUyMHYlMjAzJTIweiUyME0lMjA3JTJDOCUyMEglMjA1JTIwViUyMDYlMjBIJTIwNyUyMFYlMjA4JTIweiUyME0lMjA3JTJDNSUyMEglMjA1JTIwViUyMDMlMjBIJTIwNyUyMFYlMjA1JTIweiUyME0lMjA3JTJDMiUyMEglMjA1JTIwViUyMDAlMjBoJTIwMiUyMHYlMjAyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhMGEwYTAlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoxMnB4O2hlaWdodDoxMnB4O2JhY2tncm91bmQtc2l6ZToxMnB4IDEycHh9LmRnLW1hcC1nZW9jbGlja2VyX19wdXJwb3NlX3R5cGVfc2lnaHQ6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjI4JTIyJTIwaGVpZ2h0JTNEJTIyMTIlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA3JTJDMCUyMEglMjAyLjU0NyUyMEMlMjAwLjU0NyUyQzAlMjAwJTJDMC44MjglMjAwJTJDMi41JTIwMCUyQzMuNzM0JTIwMC41JTJDNSUyMDIlMkM1JTIwMy4zNTklMkM1JTIwNCUyQzMuODQ0JTIwNCUyQzMlMjA0JTJDMi4yODElMjAyLjg1OSUyQzIlMjAyJTJDMiUyMDIlMkMyLjc2NiUyMDIuMjM0JTJDMyUyMDMlMkMzJTIwMyUyQzMuNjklMjAyLjQ4JTJDNCUyMDIlMkM0JTIwMS4yMzQlMkM0JTIwMSUyQzMuMzI5JTIwMSUyQzIuNSUyMDElMkMxLjY5MyUyMDEuMzc1JTJDMSUyMDIuNSUyQzElMjA0LjM5MSUyQzElMjA1JTJDMS42NTYlMjA1JTJDMyUyMDUlMkM0LjYlMjA0LjMzOCUyQzUuMTE5JTIwMyUyQzYlMjB2JTIwNCUyMEglMjAyJTIwdiUyMDIlMjBIJTIwOCUyMFYlMjAxJTIwTCUyMDclMkMwJTIweiUyME0lMjA0JTJDMTAlMjBWJTIwNiUyMGwlMjAxJTJDMSUyMHYlMjAzJTIwSCUyMDQlMjB6JTIwbSUyMDIlMkMwJTIwViUyMDYlMjBsJTIwMSUyQzElMjB2JTIwMyUyMEglMjA2JTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhYWElMjIlMjBmaWxsLXJ1bGUlM0QlMjJldmVub2RkJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6OHB4O2hlaWdodDoxMnB4O2JhY2tncm91bmQtc2l6ZTo4cHggMTJweH0uZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2VfdHlwZV9zZXR0bGVtZW50OmJlZm9yZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTIlMjIlMjBoZWlnaHQlM0QlMjIxMiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDklMkM5JTIwQyUyMDguMjM1JTJDOSUyMDcuNzYyJTJDOS41MjIlMjA3LjI1OSUyQzEwLjAyMiUyMDcuNzk1JTJDMTAuMzglMjA4LjA1MSUyQzExLjA1JTIwNy44NzklMkMxMiUyMEglMjAxMiUyMEMlMjAxMiUyQzEwLjQ2JTIwMTAuNTM1JTJDOSUyMDklMkM5JTIweiUyMG0lMjAtMi44NjglMkMxLjI0OCUyMGMlMjAtMC45NjUlMkMwJTIwLTEuNzQ3JTJDMC43ODQlMjAtMS43NDclMkMxLjc1MSUyMGglMjAzLjQ5NCUyMGMlMjAwJTJDLTAuOTY3JTIwLTAuNzgyJTJDLTEuNzUxJTIwLTEuNzQ3JTJDLTEuNzUxJTIweiUyME0lMjAxMCUyQzElMjBWJTIwMCUyMEglMjA3JTIwViUyMDElMjBIJTIwNSUyMFYlMjA2JTIwTCUyMDYlMkM3JTIwViUyMDIlMjBIJTIwNyUyMFYlMjA3JTIwTCUyMDglMkM4JTIwViUyMDIlMjBoJTIwMSUyMHYlMjA2JTIwaCUyMDElMjBWJTIwMiUyMGglMjAxJTIwdiUyMDclMjBsJTIwMSUyQzAuNjA3JTIwViUyMDElMjBIJTIwMTAlMjB6JTIwTSUyMDYuNjYlMkM5LjUzOSUyMDYuNzIxJTJDOS40NzklMjBDJTIwNi45MDMlMkM5LjI5NyUyMDcuMTA0JTJDOS4xNCUyMDcuMzE0JTJDOS4wMDQlMjBWJTIwOC40MTQlMjBMJTIwNi4xMzElMkM3LjE4NyUyMDMlMkM4JTIwdiUyMDQlMjBIJTIwMy42MiUyMEMlMjAzLjYyJTJDMTAuNjEyJTIwNC43NDclMkM5LjQ4MyUyMDYuMTMyJTJDOS40ODMlMjA2LjMxMiUyQzkuNDgyJTIwNi40OSUyQzkuNTAyJTIwNi42NiUyQzkuNTM5JTIweiUyME0lMjAyJTJDMTIlMjB6JTIwTSUyMDElMkMyJTIwMCUyQzUlMjB2JTIwNyUyMEglMjAyJTIwViUyMDUlMjBMJTIwMSUyQzIlMjB6JTIwTSUyMDEuMTExJTJDNi45NTUlMjBDJTIwMC44MDQlMkM2Ljk1NSUyMDAuNTU2JTJDNi43MDYlMjAwLjU1NiUyQzYuNCUyMGMlMjAwJTJDLTAuMzA3JTIwMC4yNDglMkMtMC41NTUlMjAwLjU1NSUyQy0wLjU1NSUyMDAuMzA3JTJDMCUyMDAuNTU0JTJDMC4yNDglMjAwLjU1NCUyQzAuNTU1JTIwMCUyQzAuMzA2JTIwLTAuMjQ3JTJDMC41NTUlMjAtMC41NTQlMkMwLjU1NSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYTBhMGEwJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6MTJweDtoZWlnaHQ6MTJweDtiYWNrZ3JvdW5kLXNpemU6MTJweCAxMnB4fWEuZGctbWFwLWdlb2NsaWNrZXJfX3Nob3ctbW9yZS1zaWdodHMtbGlua3tjb2xvcjojZmZlNmFhfS5uby10b3VjaCBhLmRnLW1hcC1nZW9jbGlja2VyX19zaG93LW1vcmUtc2lnaHRzLWxpbms6aG92ZXJ7Y29sb3I6IzljZH1hLmRnLW1hcC1nZW9jbGlja2VyX19zaG93LW1vcmUtc2lnaHRzLWxpbms6YWZ0ZXJ7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjYlMjIlMjBoZWlnaHQlM0QlMjIxMCUyMiUyMHZpZXdCb3glM0QlMjIwJTIwMCUyMDYlMjAxMCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDYlMkM1JTIwViUyMDUuNCUyMEwlMjAxLjQlMkMxMCUyMEglMjAwJTIwTCUyMDAlMkM4LjYlMjAzLjYlMkM1JTIwMCUyQzEuNCUyMDAlMkMwJTIwMS40JTJDMCUyMDYlMkM0LjYlMjBWJTIwNSUyMGwlMjAwJTJDMCUyMDAlMkMwJTIwMCUyQzAlMjAwJTJDMCUyMDAlMkMwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhYWElMjIlMjBmaWxsLXJ1bGUlM0QlMjJldmVub2RkJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIil9LmRnLW1hcC1nZW9jbGlja2VyX19kcmlsbGRvd257Y29sb3I6I2FhYX0uZGctcHJlbG9hZGVye3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbjowIGF1dG87d2lkdGg6MjAwcHg7aGVpZ2h0OjQ0cHg7dmVydGljYWwtYWxpZ246bWlkZGxlfS5kZy1wcmVsb2FkZXJfYW5pbWF0aW9uX2ZhbHNle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9ER1ByZWxvYWRlcl9fcHJlbG9hZGVyLmdpZik7YmFja2dyb3VuZC1zaXplOjEwMHB4IDI2cHg7YmFja2dyb3VuZC1hdHRhY2htZW50OnNjcm9sbDtiYWNrZ3JvdW5kLXBvc2l0aW9uOjUwJSA1MCV9LmRnLXByZWxvYWRlcl9hbmltYXRpb25fdHJ1ZTpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtsZWZ0OjUwJTttYXJnaW46LTIycHggMCAwIC0yMnB4O3dpZHRoOjQ0cHg7aGVpZ2h0OjQ0cHg7b3V0bGluZTp0cmFuc3BhcmVudCBzb2xpZCAxcHg7Y29udGVudDonJzstd2Via2l0LWFuaW1hdGlvbjpkZy1wcmVsb2FkZXJfX291dGVyIDVzIGxpbmVhciBpbmZpbml0ZTthbmltYXRpb246ZGctcHJlbG9hZGVyX19vdXRlciA1cyBsaW5lYXIgaW5maW5pdGU7aW1hZ2UtcmVuZGVyaW5nOm9wdGltaXplUXVhbGl0eX0uZGctcHJlbG9hZGVyX2FuaW1hdGlvbl90cnVlLmRnLXByZWxvYWRlcl9zaXplX3NtYWxsOmJlZm9yZXttYXJnaW46LTEycHggMCAwIC0xMnB4O3dpZHRoOjI0cHg7aGVpZ2h0OjI0cHh9LmRnLXByZWxvYWRlcl9hbmltYXRpb25fdHJ1ZS5kZy1wcmVsb2FkZXJfc2NoZW1lX3JlZ3VsYXI6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjI0NCUyMiUyMGhlaWdodCUzRCUyMjQ0JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMzUuNjglMkMxMC4zMiUyMEMlMjAzOC4zNjglMkMxMy40NjUlMjA0MCUyQzE3LjUzOSUyMDQwJTJDMjIlMjA0MCUyQzMxLjk0MSUyMDMxLjk0MSUyQzQwJTIwMjIlMkM0MCUyMDEyLjA1OSUyQzQwJTIwNCUyQzMxLjk0MSUyMDQlMkMyMiUyMDQlMkMxNy41MzklMjA1LjYzMiUyQzEzLjQ2NSUyMDguMzIlMkMxMC4zMiUyMEwlMjA1LjQ4JTJDNy40OCUyMEMlMjAyLjA3JTJDMTEuMzU0JTIwMCUyQzE2LjQzNCUyMDAlMkMyMiUyMDAlMkMzNC4xNSUyMDkuODUlMkM0NCUyMDIyJTJDNDQlMjAzNC4xNSUyQzQ0JTIwNDQlMkMzNC4xNSUyMDQ0JTJDMjIlMjA0NCUyQzE2LjQzNCUyMDQxLjkzJTJDMTEuMzU0JTIwMzguNTIlMkM3LjQ4JTIwbCUyMC0yLjg0JTJDMi44NCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzMGRhNWQ1JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwOS4yNzElMkM5LjI3MiUyMEMlMjAxMi41MjklMkM2LjAxNSUyMDE3LjAyOSUyQzQlMjAyMiUyQzQlMjAyNi45NzElMkM0JTIwMzEuNDcxJTJDNi4wMTUlMjAzNC43MjklMkM5LjI3MiUyMEwlMjAzNy41NTclMkM2LjQ0NCUyMEMlMjAzMy41NzUlMkMyLjQ2MiUyMDI4LjA3NSUyQzAlMjAyMiUyQzAlMjAxNS45MjUlMkMwJTIwMTAuNDI1JTJDMi40NjIlMjA2LjQ0MyUyQzYuNDQ0JTIwbCUyMDIuODI4JTJDMi44MjglMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2E2Y2QyYSUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO2JhY2tncm91bmQtc2l6ZTo0NHB4IDQ0cHh9LmRnLXByZWxvYWRlcl9hbmltYXRpb25fdHJ1ZS5kZy1wcmVsb2FkZXJfc2NoZW1lX3JlZ3VsYXIuZGctcHJlbG9hZGVyX3NpemVfc21hbGw6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIyNCUyMiUyMGhlaWdodCUzRCUyMjI0JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTguNTY0JTJDNy40MzUlMjBDJTIwMTkuNDY3JTJDOC43MyUyMDIwJTJDMTAuMzAyJTIwMjAlMkMxMiUyMDIwJTJDMTYuNDE4JTIwMTYuNDE4JTJDMjAlMjAxMiUyQzIwJTIwNy41ODIlMkMyMCUyMDQlMkMxNi40MTglMjA0JTJDMTIlMjA0JTJDMTAuMzAyJTIwNC41MzMlMkM4LjczJTIwNS40MzYlMkM3LjQzNSUyMEwlMjAyLjU4MSUyQzQuNTgxJTIwQyUyMDAuOTY5JTJDNi42MjMlMjAwJTJDOS4xOTUlMjAwJTJDMTIlMjAwJTJDMTguNjI3JTIwNS4zNzMlMkMyNCUyMDEyJTJDMjQlMjAxOC42MjclMkMyNCUyMDI0JTJDMTguNjI3JTIwMjQlMkMxMiUyMDI0JTJDOS4xOTUlMjAyMy4wMzElMkM2LjYyMyUyMDIxLjQxOSUyQzQuNTgxJTIwbCUyMC0yLjg1NSUyQzIuODU0JTIweiUyMiUyMGZpbGwlM0QlMjIlMjMwZGE1ZDUlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxMiUyQzAlMjBDJTIwOC42ODYlMkMwJTIwNS42ODYlMkMxLjM0MyUyMDMuNTE2JTJDMy41MTUlMjBMJTIwNi4zNDMlMkM2LjM0MyUyMEMlMjA3Ljc5MSUyQzQuODk1JTIwOS43OTElMkM0JTIwMTIlMkM0JTIwYyUyMDIuMjA5JTJDMCUyMDQuMjA5JTJDMC44OTUlMjA1LjY1NyUyQzIuMzQzJTIwTCUyMDIwLjQ4NCUyQzMuNTE1JTIwQyUyMDE4LjMxNCUyQzEuMzQzJTIwMTUuMzE0JTJDMCUyMDEyJTJDMCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYTZjZDJhJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7YmFja2dyb3VuZC1zaXplOjI0cHggMjRweH0uZGctcHJlbG9hZGVyX2FuaW1hdGlvbl90cnVlOmFmdGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7bGVmdDo1MCU7bWFyZ2luOi0xNnB4IDAgMCAtMTZweDt3aWR0aDozMnB4O2hlaWdodDozMnB4O291dGxpbmU6dHJhbnNwYXJlbnQgc29saWQgMXB4O2NvbnRlbnQ6Jyc7LXdlYmtpdC1hbmltYXRpb246ZGctcHJlbG9hZGVyX19pbm5lciA0cyBsaW5lYXIgaW5maW5pdGU7YW5pbWF0aW9uOmRnLXByZWxvYWRlcl9faW5uZXIgNHMgbGluZWFyIGluZmluaXRlO2ltYWdlLXJlbmRlcmluZzpvcHRpbWl6ZVF1YWxpdHl9LmRnLXByZWxvYWRlcl9hbmltYXRpb25fdHJ1ZS5kZy1wcmVsb2FkZXJfc2l6ZV9zbWFsbDphZnRlcnttYXJnaW46LTZweCAwIDAgLTZweDt3aWR0aDoxMnB4O2hlaWdodDoxMnB4fS5kZy1wcmVsb2FkZXJfYW5pbWF0aW9uX3RydWUuZGctcHJlbG9hZGVyX3NjaGVtZV9yZWd1bGFyOmFmdGVye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIzMiUyMiUyMGhlaWdodCUzRCUyMjMyJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNi41ODElMkMyMy40MTklMjBDJTIwNC45NjklMkMyMS4zNzclMjA0JTJDMTguODA0JTIwNCUyQzE2JTIwNCUyQzkuMzczJTIwOS4zNzMlMkM0JTIwMTYlMkM0JTIwYyUyMDYuNjI3JTJDMCUyMDEyJTJDNS4zNzMlMjAxMiUyQzEyJTIwMCUyQzIuODA0JTIwLTAuOTY5JTJDNS4zNzclMjAtMi41ODElMkM3LjQxOSUyMGwlMjAyLjg0NyUyQzIuODQ3JTIwQyUyMDMwLjU5NCUyQzIzLjQ4NyUyMDMyJTJDMTkuOTA5JTIwMzIlMkMxNiUyMDMyJTJDNy4xNjMlMjAyNC44MzclMkMwJTIwMTYlMkMwJTIwNy4xNjMlMkMwJTIwMCUyQzcuMTYzJTIwMCUyQzE2JTIwYyUyMDAlMkMzLjkwOSUyMDEuNDA2JTJDNy40ODclMjAzLjczNCUyQzEwLjI2NiUyMGwlMjAyLjg0NyUyQy0yLjg0NyUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYTZjZDJhJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMjcuMzE0JTJDMjcuMzE0JTIwMjQuNDg2JTJDMjQuNDg2JTIwQyUyMDIyLjMxNCUyQzI2LjY1NyUyMDE5LjMxNCUyQzI4JTIwMTYlMkMyOCUyMDEyLjY4NiUyQzI4JTIwOS42ODYlMkMyNi42NTclMjA3LjUxNiUyQzI0LjQ4NSUyMEwlMjA0LjY4OCUyQzI3LjMxMyUyMEMlMjA3LjU4MiUyQzMwLjIwOSUyMDExLjU4MiUyQzMyJTIwMTYlMkMzMiUyMGMlMjA0LjQxOCUyQzAlMjA4LjQxOCUyQy0xLjc5MSUyMDExLjMxNCUyQy00LjY4NiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzMGRhNWQ1JTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7YmFja2dyb3VuZC1zaXplOjMycHggMzJweH0uZGctcHJlbG9hZGVyX2FuaW1hdGlvbl90cnVlLmRnLXByZWxvYWRlcl9zY2hlbWVfcmVndWxhci5kZy1wcmVsb2FkZXJfc2l6ZV9zbWFsbDphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTIlMjIlMjBoZWlnaHQlM0QlMjIxMiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDMuMTQxJTJDNi44NiUyMEMlMjAzLjA1OSUyQzYuNTg2JTIwMyUyQzYuMzAxJTIwMyUyQzYlMjAzJTJDNC4zNDMlMjA0LjM0MyUyQzMlMjA2JTJDMyUyMDcuNjU3JTJDMyUyMDklMkM0LjM0MyUyMDklMkM2JTIwOSUyQzYuMzAxJTIwOC45NDElMkM2LjU4NiUyMDguODU5JTJDNi44NiUyMGwlMjAyLjI2JTJDMi4yNTklMjBDJTIwMTEuNjc0JTJDOC4yMDklMjAxMiUyQzcuMTQ0JTIwMTIlMkM2JTIwMTIlMkMyLjY4NiUyMDkuMzE0JTJDMCUyMDYlMkMwJTIwMi42ODYlMkMwJTIwMCUyQzIuNjg2JTIwMCUyQzYlMjAwJTJDNy4xNDQlMjAwLjMyNiUyQzguMjA5JTIwMC44ODElMkM5LjExOSUyMEwlMjAzLjE0MSUyQzYuODYlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2E2Y2QyYSUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDYlMkMxMiUyMGMlMjAxLjY1NyUyQzAlMjAzLjE1NyUyQy0wLjY3MiUyMDQuMjQzJTJDLTEuNzU3JTIwTCUyMDguMTIyJTJDOC4xMjIlMjBDJTIwNy41NzglMkM4LjY2NCUyMDYuODI4JTJDOSUyMDYlMkM5JTIwNS4xNzIlMkM5JTIwNC40MjIlMkM4LjY2NCUyMDMuODc5JTJDOC4xMjElMjBMJTIwMS43NTglMkMxMC4yNDIlMjBDJTIwMi44NDMlMkMxMS4zMjglMjA0LjM0MyUyQzEyJTIwNiUyQzEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjMwZGE1ZDUlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTtiYWNrZ3JvdW5kLXNpemU6MTJweCAxMnB4fUAtd2Via2l0LWtleWZyYW1lcyBkZy1wcmVsb2FkZXJfX291dGVye3Rvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19QGtleWZyYW1lcyBkZy1wcmVsb2FkZXJfX291dGVye3Rvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19QC13ZWJraXQta2V5ZnJhbWVzIGRnLXByZWxvYWRlcl9faW5uZXJ7dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKC0zNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoLTM2MGRlZyl9fUBrZXlmcmFtZXMgZGctcHJlbG9hZGVyX19pbm5lcnt0b3std2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoLTM2MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgtMzYwZGVnKX19LmRnLXBvcHVwX19mb290ZXItYnV0dG9uc3tkaXNwbGF5OnRhYmxlO21hcmdpbi10b3A6MTBweDt3aWR0aDoxMDAlfS5kZy1wb3B1cF9fZm9vdGVyLWJ1dHRvbi13cmFwcGVye2Rpc3BsYXk6dGFibGUtY2VsbH0uZGctcG9wdXBfX2Zvb3Rlci1idXR0b257cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O21hcmdpbi1sZWZ0OjUlO3dpZHRoOjk1JTtib3JkZXItcmFkaXVzOjJweDt0ZXh0LWFsaWduOmNlbnRlcjt0ZXh0LWRlY29yYXRpb246bm9uZTtmb250OjEycHgvMjRweCBBcmlhbCxzYW5zLXNlcmlmO2N1cnNvcjpwb2ludGVyOy13ZWJraXQtdHJhbnNpdGlvbjphbGwgLjFzO3RyYW5zaXRpb246YWxsIC4xc30uZGctcG9wdXBfX2Zvb3Rlci1idXR0b24td3JhcHBlcjpmaXJzdC1jaGlsZCAuZGctcG9wdXBfX2Zvb3Rlci1idXR0b257bWFyZ2luOjA7d2lkdGg6MTAwJX0ubm8tdG91Y2ggLmRnLXBvcHVwX19mb290ZXItYnV0dG9uOmhvdmVyey13ZWJraXQtdHJhbnNpdGlvbjphbGwgLjJzO3RyYW5zaXRpb246YWxsIC4yc30uZGctcG9wdXBfX2Zvb3Rlci1pY29uLWJ1dHRvbjpiZWZvcmV7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luOi0ycHggNXB4IDAgMDt3aWR0aDoxMnB4O2hlaWdodDoxMnB4O2JhY2tncm91bmQtc2l6ZTpjb250YWluO2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtjb250ZW50OicnO3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0uZGctcG9wdXBfX2J1dHRvbl9uYW1lX2JhY2s6YmVmb3JlLC5kZy1wb3B1cF9fYnV0dG9uX25hbWVfZmlybS1jYXJkLWJhY2s6YmVmb3JlLC5kZy1wb3B1cF9fYnV0dG9uX25hbWVfZmlybS1saXN0LWJhY2s6YmVmb3Jle3dpZHRoOjlweDtoZWlnaHQ6NnB4fS5kZy1wb3B1cF9fc2hvdy1sZXNzLWhvdXNlLWxpbmt7cG9zaXRpb246cmVsYXRpdmU7dG9wOjZweDttYXJnaW46MCAxNXB4IDEwcHg7Y29sb3I6IzAwNzBjMDt0ZXh0LWRlY29yYXRpb246bm9uZTtmb250LXNpemU6MTJweDtsaW5lLWhlaWdodDoyNHB4fS5kZy1wb3B1cF9faGVhZGVyLWxpbmtze21hcmdpbjo4cHggMThweCAwIDB9LmRnLXBvcHVwX19oZWFkZXItdGl0bGVfZm9yX2Zpcm1jYXJke3Bvc2l0aW9uOnJlbGF0aXZlO292ZXJmbG93OmhpZGRlbjttYXgtaGVpZ2h0OjMuNGVtfS5kZy1wb3B1cF9faGVhZGVyLXRlYXNlcntkaXNwbGF5Oi13ZWJraXQtYm94O2hlaWdodDozLjNlbTstd2Via2l0LWxpbmUtY2xhbXA6Mzstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWx9LmRnLXBvcHVwX19oZWFkZXItdGl0bGV7ZGlzcGxheTpibG9jazt3aGl0ZS1zcGFjZTpub3JtYWw7Zm9udDoyMnB4LzI0cHggJ0FyaWFsIG5hcnJvdycsQXJpYWwsc2Fucy1zZXJpZn0uZGctcG9wdXBfX2hlYWRlci1saW5re2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbi1sZWZ0OjIuNmVtO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTt3aGl0ZS1zcGFjZTpub3dyYXB9LmRnLXBvcHVwX19oZWFkZXItbGluazpmaXJzdC1jaGlsZHttYXJnaW4tbGVmdDoxLjJlbX0uZGctcG9wdXBfX3JhdGluZ3tkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW46MCAuNGVtIDNweCAwO3dpZHRoOjcwcHg7aGVpZ2h0OjE0cHg7dmVydGljYWwtYWxpZ246bWlkZGxlfS5kZy1wb3B1cF9fcmF0aW5nLXN0YXJze2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjE0JTIyJTIwaGVpZ2h0JTNEJTIyMTQlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA2Ljk5OSUyQzAlMjA4Ljc0OCUyQzQuOTg5JTIwMTMuOTk3JTJDNC45OTElMjA5LjgzJTJDOC43MDglMjAxMS4zMjQlMkMxNC4wMDIlMjA2Ljk5OSUyQzEwLjg3MSUyMDIuNjc0JTJDMTQuMDAyJTIwNC4xNjglMkM4LjcwOCUyMDAlMkM0Ljk5MSUyMDUuMjQ5JTJDNC45ODklMjA2Ljk5OSUyQzAlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2ZmYzg0YiUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO2Zsb2F0OmxlZnQ7aGVpZ2h0OjEwMCV9LmRnLXBvcHVwX19saW5re3Bvc2l0aW9uOnJlbGF0aXZlO2JhY2tncm91bmQtcG9zaXRpb246Y2VudGVyIGJvdHRvbTtiYWNrZ3JvdW5kLXNpemU6MTBweCAxcHg7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7dGV4dC1kZWNvcmF0aW9uOm5vbmU7LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnRyYW5zcGFyZW50fS5kZy1wb3B1cF9fbGlua190eXBlX2ZsYW1wX3Jldmlld3N7bWFyZ2luLWxlZnQ6LjFlbX0uZGctcG9wdXBfX2xpbmtfdHlwZV9waG90b3M6YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3RvcDoycHg7bGVmdDotMThweDtkaXNwbGF5OmluaGVyaXQ7Y29udGVudDonJ30uZGctcG9wdXBfX2xpbmtfdHlwZV9ib29rbGV0OmJlZm9yZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTIlMjIlMjBoZWlnaHQlM0QlMjIxMCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDAlMkM4JTIwMyUyQzIlMjBWJTIwMiUyMEwlMjAwJTJDMCUyMFYlMjA4JTIweiUyME0lMjA0JTJDMTAlMjA4JTJDOCUyMFYlMjAwJTIwTCUyMDQlMkMyJTIwdiUyMDglMjB6JTIwTSUyMDklMkMwJTIwdiUyMDglMjBsJTIwMyUyQzIlMjBWJTIwMiUyMEwlMjA5JTJDMCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzN2RjODE0JTIyJTIwZmlsbC1ydWxlJTNEJTIyZXZlbm9kZCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjEycHg7aGVpZ2h0OjEwcHg7YmFja2dyb3VuZC1zaXplOjEycHggMTBweDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MnB4O2xlZnQ6LTE4cHg7ZGlzcGxheTppbmhlcml0O2NvbnRlbnQ6Jyd9YS5kZy1wb3B1cF9fbGlua3tiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLGxlZnQgdG9wLHJpZ2h0IHRvcCxmcm9tKHJnYmEoMjU1LDIzMCwxNzAsLjMpKSx0byhyZ2JhKDI1NSwyMzAsMTcwLC4zKSkpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQobGVmdCxyZ2JhKDI1NSwyMzAsMTcwLC4zKSxyZ2JhKDI1NSwyMzAsMTcwLC4zKSAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0byByaWdodCxyZ2JhKDI1NSwyMzAsMTcwLC4zKSxyZ2JhKDI1NSwyMzAsMTcwLC4zKSAxMDAlKTtjb2xvcjojZmZlNmFhfS5uby10b3VjaCBhLmRnLXBvcHVwX19saW5rOmhvdmVye2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsbGVmdCB0b3AscmlnaHQgdG9wLGZyb20ocmdiYSgxNTMsMjA0LDIyMSwuMykpLHRvKHJnYmEoMTUzLDIwNCwyMjEsLjMpKSk7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudChsZWZ0LHJnYmEoMTUzLDIwNCwyMjEsLjMpLHJnYmEoMTUzLDIwNCwyMjEsLjMpIDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LHJnYmEoMTUzLDIwNCwyMjEsLjMpLHJnYmEoMTUzLDIwNCwyMjEsLjMpIDEwMCUpO2NvbG9yOiM5Y2R9LmRnLXBvcHVwX19oZWFkZXItdGl0bGV7Y29sb3I6I2ZmYzg0Yn0uZGctcG9wdXBfX2Zvb3Rlci1idXR0b24td3JhcHBlciAuZGctcG9wdXBfX2Zvb3Rlci1idXR0b24sLmRnLXBvcHVwX19mb290ZXItYnV0dG9uLXdyYXBwZXIgLmRnLXBvcHVwX19mb290ZXItYnV0dG9uOmhvdmVye2NvbG9yOiNlNmU2ZTZ9LmRnLXBvcHVwX19mb290ZXItYnV0dG9ue2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMik7LXdlYmtpdC1ib3gtc2hhZG93OjAgMXB4IHJnYmEoMCwwLDAsLjEpO2JveC1zaGFkb3c6MCAxcHggcmdiYSgwLDAsMCwuMSl9Lm5vLXRvdWNoIC5kZy1wb3B1cF9fZm9vdGVyLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kOiMyMjI7LXdlYmtpdC1ib3gtc2hhZG93OjAgMXB4IDNweCByZ2JhKDAsMCwwLC41KTtib3gtc2hhZG93OjAgMXB4IDNweCByZ2JhKDAsMCwwLC41KX0uZGctcG9wdXBfX3JhdGluZ3tiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxNCUyMiUyMGhlaWdodCUzRCUyMjE0JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNy4wMDIlMkMwJTIwOC43NTElMkM0Ljk4OSUyMDE0JTJDNC45OTElMjA5LjgzMyUyQzguNzA4JTIwMTEuMzI3JTJDMTQuMDAyJTIwNy4wMDIlMkMxMC44NzElMjAyLjY3NyUyQzE0LjAwMiUyMDQuMTcxJTJDOC43MDglMjAwLjAwMyUyQzQuOTkxJTIwNS4yNTIlMkM0Ljk4OSUyMDcuMDAyJTJDMCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYWFhJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIil9LmRnLXBvcHVwX19saW5rX3R5cGVfcGhvdG9zOmJlZm9yZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTIlMjIlMjBoZWlnaHQlM0QlMjIxMCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDExJTJDMSUyMEglMjAxMCUyMEwlMjA5JTJDMCUyMEglMjA2JTIwTCUyMDUlMkMxJTIwSCUyMDElMjBMJTIwMCUyQzIlMjB2JTIwNyUyMGwlMjAxJTJDMSUyMEglMjAxMSUyMEwlMjAxMiUyQzklMjBWJTIwMiUyMEwlMjAxMSUyQzElMjB6JTIwTSUyMDMlMkM0JTIwSCUyMDIlMjBWJTIwMyUyMGglMjAxJTIwdiUyMDElMjB6JTIwbSUyMDQuNTE4JTJDMy45OTIlMjBjJTIwLTEuMzgxJTJDMCUyMC0yLjUlMkMtMS4xMTklMjAtMi41JTJDLTIuNSUyMDAlMkMtMS4zOCUyMDEuMTE5JTJDLTIuNSUyMDIuNSUyQy0yLjUlMjAxLjM4JTJDMCUyMDIuNSUyQzEuMTIlMjAyLjUlMkMyLjUlMjAwJTJDMS4zODElMjAtMS4xMjElMkMyLjUlMjAtMi41JTJDMi41JTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3OWIwYmMlMjIlMjBmaWxsLXJ1bGUlM0QlMjJldmVub2RkJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6MTJweDtoZWlnaHQ6MTBweDtiYWNrZ3JvdW5kLXNpemU6MTJweCAxMHB4fS5kZy1wb3B1cF9fYnV0dG9uX25hbWVfZmlybS1jYXJkLWJhY2s6YmVmb3JlLC5kZy1wb3B1cF9fYnV0dG9uX25hbWVfZmlybS1saXN0LWJhY2s6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjI5JTIyJTIwaGVpZ2h0JTNEJTIyNiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDAlMkMzJTIwNCUyQzYlMjBWJTIwNCUyMEglMjA5JTIwViUyMDIlMjBIJTIwNCUyMFYlMjAwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM5ZjlmOWYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKX0uZGctcG9wdXBfX2J1dHRvbl9uYW1lX2JhY2s6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjI5JTIyJTIwaGVpZ2h0JTNEJTIyNiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDAlMkMzJTIwNCUyQzYlMjBWJTIwNCUyMEglMjA5JTIwViUyMDIlMjBIJTIwNCUyMFYlMjAwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM5ZjlmOWYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDo5cHg7aGVpZ2h0OjZweDtiYWNrZ3JvdW5kLXNpemU6OXB4IDZweH0uZGctcG9wdXBfX2J1dHRvbl9uYW1lX2dvdG86YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIyMCUyMiUyMGhlaWdodCUzRCUyMjclMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxNi41JTJDMCUyMEMlMjAxNC43MzglMkMwJTIwMTMuMjk1JTJDMS4zMDYlMjAxMy4wNTElMkMzJTIwSCUyMDQuOTQ5JTIwQyUyMDQuNzE4JTJDMS44NTglMjAzLjcxJTJDMSUyMDIuNSUyQzElMjAxLjExOSUyQzElMjAwJTJDMi4xMTklMjAwJTJDMy41JTIwMCUyQzQuODgxJTIwMS4xMTklMkM2JTIwMi41JTJDNiUyMDMuNzElMkM2JTIwNC43MTglMkM1LjE0MiUyMDQuOTQ5JTJDNCUyMGglMjA4LjEwMiUyMEMlMjAxMy4yOTUlMkM1LjY5MyUyMDE0LjczOSUyQzclMjAxNi41JTJDNyUyMDE4LjQzMyUyQzclMjAyMCUyQzUuNDMzJTIwMjAlMkMzLjUlMjAyMCUyQzEuNTY2JTIwMTguNDMzJTJDMCUyMDE2LjUlMkMwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM5ZjlmOWYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoyMHB4O2hlaWdodDo3cHg7YmFja2dyb3VuZC1zaXplOjIwcHggN3B4fS5kZy1wb3B1cF9fYnV0dG9uX25hbWVfc2hvdy1lbnRyYW5jZTpiZWZvcmV7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjEyJTIyJTIwaGVpZ2h0JTNEJTIyMTIlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA1JTJDOSUyMDklMkM2JTIwNSUyQzMlMjBWJTIwNSUyMEglMjAwJTIwViUyMDclMjBIJTIwNSUyMFYlMjA5JTIweiUyME0lMjA5LjYlMkMwJTIwSCUyMDIuNCUyMEMlMjAxLjA3NCUyQzAlMjAwJTJDMS4wNzQlMjAwJTJDMi40JTIwViUyMDQlMjBIJTIwMiUyMFYlMjAzLjYlMjBDJTIwMiUyQzIuNzE2JTIwMi43MTYlMkMyJTIwMy42JTJDMiUyMEglMjA4LjQlMjBDJTIwOS4yODMlMkMyJTIwMTAlMkMyLjcxNiUyMDEwJTJDMy42JTIwViUyMDguNCUyMEMlMjAxMCUyQzkuMjg0JTIwOS4yODMlMkMxMCUyMDguNCUyQzEwJTIwSCUyMDMuNiUyMEMlMjAyLjcxNiUyQzEwJTIwMiUyQzkuMjg0JTIwMiUyQzguNCUyMFYlMjA4JTIwSCUyMDAlMjBWJTIwOS42JTIwQyUyMDAlMkMxMC45MjUlMjAxLjA3NCUyQzEyJTIwMi40JTJDMTIlMjBIJTIwOS42JTIwQyUyMDEwLjkyNiUyQzEyJTIwMTIlMkMxMC45MjUlMjAxMiUyQzkuNiUyMFYlMjAyLjQlMjBDJTIwMTIlMkMxLjA3NCUyMDEwLjkyNiUyQzAlMjA5LjYlMkMwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhMGEwYTAlMjIlMjBmaWxsLXJ1bGUlM0QlMjJldmVub2RkJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIil9LmRnLWZpcm0tY2FyZF9faWNvbntwb3NpdGlvbjpyZWxhdGl2ZTtwYWRkaW5nLWxlZnQ6MjRweH0uZGctZmlybS1jYXJkX19pY29uOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7bWFyZ2luOmF1dG87YmFja2dyb3VuZC1wb3NpdGlvbjowIDUwJTtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7Y29udGVudDonJ30uZGctZmlybS1jYXJkX19saW5re292ZXJmbG93OmhpZGRlbjttYXJnaW4tYm90dG9tOjRweDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO3doaXRlLXNwYWNlOm5vd3JhcDt3b3JkLXdyYXA6bm9ybWFsO2xpbmUtaGVpZ2h0OjE2cHh9LmRnLWZpcm0tY2FyZF9fbGluayBhe2JhY2tncm91bmQtcG9zaXRpb246Y2VudGVyIGJvdHRvbTtiYWNrZ3JvdW5kLXNpemU6MTBweCAxcHg7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmRnLWZpcm0tY2FyZF9fYWRkcmVzc3ttYXJnaW4tYm90dG9tOjEwcHg7Zm9udC1zaXplOjE2cHh9LmRnLWZpcm0tY2FyZF9fYWRkcmVzczpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjVweDtsZWZ0OjFweDtjb250ZW50OicnfS5kZy1maXJtLWNhcmRfX2NvbW1lbnR7cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luLWxlZnQ6NXB4O2ZvbnQtc2l6ZToxMnB4fS5kZy1maXJtLWNhcmRfX3Bob25le292ZXJmbG93OmhpZGRlbjttYXJnaW4tYm90dG9tOjRweDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO2xpbmUtaGVpZ2h0OjE2cHh9LmRnLWZpcm0tY2FyZF9fcGhvbmU6YmVmb3Jle3RvcDozcHg7bGVmdDoxcHh9LmRnLWZpcm0tY2FyZF9fc2l0ZTpiZWZvcmV7dG9wOjNweH0uZGctZmlybS1jYXJkX19lbWFpbDpiZWZvcmV7dG9wOjVweH0uZGctZmlybS1jYXJkX19ydWJyaWNze292ZXJmbG93OmhpZGRlbjttYXJnaW4tYm90dG9tOjRweDtmb250LXNpemU6MTJweDtsaW5lLWhlaWdodDoxNnB4fS5kZy1maXJtLWNhcmRfX3J1YnJpY3MtbGlzdHttYXJnaW46MDtwYWRkaW5nOjA7bGlzdC1zdHlsZTpub25lfS5kZy1maXJtLWNhcmRfX3J1YnJpY3MtbGlzdC1pdGVte2Rpc3BsYXk6aW5saW5lO2N1cnNvcjpkZWZhdWx0fS5kZy1maXJtLWNhcmRfX3J1YnJpY3MtbGlzdC1pdGVtOmJlZm9yZXtkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW46MCA0cHg7Y29udGVudDon4oCiJ30uZGctZmlybS1jYXJkX19ydWJyaWNzLWxpc3QtaXRlbTpmaXJzdC1jaGlsZDpiZWZvcmV7bWFyZ2luOjA7Y29udGVudDonJ30uZGctZmlybS1jYXJkX19hYXttYXJnaW46MCAwIDRweDtwYWRkaW5nOjAgMCAwIDI0cHg7Zm9udC1zaXplOjEycHh9LmRnLWZpcm0tY2FyZF9fYWEtbGlzdHtkaXNwbGF5OmlubGluZTttYXJnaW46MDtwYWRkaW5nOjA7bGlzdC1zdHlsZTpub25lO2xpbmUtaGVpZ2h0OjE2cHh9LmRnLWZpcm0tY2FyZF9fYWEtbGlzdC1pdGVte2Rpc3BsYXk6aW5saW5lOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDttYXgtd2lkdGg6MTAwJTtjdXJzb3I6ZGVmYXVsdH0uZGctZmlybS1jYXJkX19hYS1saXN0LWl0ZW06YmVmb3Jle2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbjowIDRweDtjb250ZW50OifigKInfS5kZy1maXJtLWNhcmRfX2FhLWxpc3QtaXRlbTpmaXJzdC1jaGlsZDpiZWZvcmV7bWFyZ2luOjA7Y29udGVudDonJ30uZGctZmlybS1jYXJkX19hYS1saXN0LWFkZGl0aW9uYWx7ZGlzcGxheTppbmxpbmU7bWFyZ2luOjA7cGFkZGluZzowO2xpc3Qtc3R5bGU6bm9uZTtsaW5lLWhlaWdodDoxNnB4fS5kZy1maXJtLWNhcmRfX3NjaGVkdWxle21hcmdpbi1ib3R0b206MTBweH0uZGctZmlybS1jYXJkX19saW5rIGF7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IHRvcCxyaWdodCB0b3AsZnJvbShyZ2JhKDI1NSwyMzAsMTcwLC4zKSksdG8ocmdiYSgyNTUsMjMwLDE3MCwuMykpKTtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KGxlZnQscmdiYSgyNTUsMjMwLDE3MCwuMykscmdiYSgyNTUsMjMwLDE3MCwuMykgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQscmdiYSgyNTUsMjMwLDE3MCwuMykscmdiYSgyNTUsMjMwLDE3MCwuMykgMTAwJSk7Y29sb3I6I2ZmZTZhYX0ubm8tdG91Y2ggLmRnLWZpcm0tY2FyZF9fbGluayBhOmhvdmVye2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsbGVmdCB0b3AscmlnaHQgdG9wLGZyb20ocmdiYSgxNTMsMjA0LDIyMSwuMykpLHRvKHJnYmEoMTUzLDIwNCwyMjEsLjMpKSk7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudChsZWZ0LHJnYmEoMTUzLDIwNCwyMjEsLjMpLHJnYmEoMTUzLDIwNCwyMjEsLjMpIDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LHJnYmEoMTUzLDIwNCwyMjEsLjMpLHJnYmEoMTUzLDIwNCwyMjEsLjMpIDEwMCUpO2NvbG9yOiM5Y2R9LmRnLWZpcm0tY2FyZF9fY29tbWVudCwuZGctZmlybS1jYXJkX19ydWJyaWNze2NvbG9yOiNhYWF9LmRnLWZpcm0tY2FyZF9fcnVicmljcy1saXN0LWl0ZW06YWZ0ZXJ7Y29sb3I6IzZlNjk2NH0uZGctZmlybS1jYXJkX19hYS1saXN0LWl0ZW06YWZ0ZXJ7Y29sb3I6I2U2ZTZlNn0uZGctZmlybS1jYXJkX19hZGRyZXNzOmJlZm9yZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyOSUyMiUyMGhlaWdodCUzRCUyMjExJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNC45NTglMkMxMSUyMEMlMjA0Ljk1OCUyQzkuMDM2JTIwNi43NTYlMkM2Ljc1MSUyMDguNzE5JTJDNi43NTElMjA4Ljg4NSUyQzYuMjIzJTIwOSUyQzUuNjU2JTIwOSUyQzUuMDYzJTIwOSUyQzIuMjY3JTIwNi45ODUlMkMwJTIwNC41JTJDMCUyMDIuMDE1JTJDMCUyMDAlMkMyLjI2NyUyMDAlMkM1LjA2MyUyMDAlMkM1LjY1NiUyMDAuMTE0JTJDNi4yMjIlMjAwLjI4JTJDNi43NTElMjAyLjI0MyUyQzYuNzUxJTIwNC4wMTglMkM5LjAxMiUyMDQuMDE4JTJDMTElMjBoJTIwMC45NCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYTBhMGEwJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6OXB4O2hlaWdodDoxMXB4O2JhY2tncm91bmQtc2l6ZTo5cHggMTFweH0uZGctZmlybS1jYXJkX19waG9uZTpiZWZvcmV7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjEwJTIyJTIwaGVpZ2h0JTNEJTIyMTAlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA5LjE4MSUyQzkuMDUlMjBDJTIwOC42NzMlMkM5LjU1NiUyMDguMDQ3JTJDOS44NzMlMjA3LjM5MSUyQzEwJTIwNi4xNTYlMkM5Ljg0MSUyMDUuMDA4JTJDOS40MTclMjAzLjk5OCUyQzguNzg4JTIwTCUyMDEuMjkzJTJDNi4wOTIlMjBDJTIwMC42MzklMkM1LjA1MyUyMDAuMjAzJTJDMy44NjUlMjAwLjA1MiUyQzIuNTg5JTIwMC4xOSUyQzEuOTY0JTIwMC40OTQlMkMxLjM2OCUyMDAuOTgzJTJDMC44ODIlMjBMJTIwMS44MDMlMkMwLjA2NSUyMDMuOTg3JTJDMi4yNDElMjBWJTIwMi43OSUyMEwlMjAzLjQ0MSUyQzMuMzMyJTIwYyUyMC0wLjQ1MiUyQzAuNDUxJTIwLTAuNDUzJTJDMS4xODMlMjAwJTJDMS42MzQlMjBMJTIwNS4wODIlMkM2LjYlMjBjJTIwMC40NTIlMkMwLjQ1MSUyMDEuMTg3JTJDMC40NTElMjAxLjYzOSUyQzAlMjBMJTIwNy4yNDQlMkM2LjA3OSUyMEglMjA3LjgzOCUyMEwlMjAxMCUyQzguMjMzJTIwOS4xODElMkM5LjA1JTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhMGEwYTAlMjIlMjBmaWxsLXJ1bGUlM0QlMjJldmVub2RkJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6MTBweDtoZWlnaHQ6MTBweDtiYWNrZ3JvdW5kLXNpemU6MTBweCAxMHB4fS5kZy1maXJtLWNhcmRfX3NpdGU6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMSUyMiUyMGhlaWdodCUzRCUyMjExJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNS41JTJDMTElMjBDJTIwMi40NjMlMkMxMSUyMDAlMkM4LjUzOCUyMDAlMkM1LjUlMjAwJTJDMi40NjIlMjAyLjQ2MyUyQzAlMjA1LjUlMkMwJTIwOC41MzclMkMwJTIwMTElMkMyLjQ2MiUyMDExJTJDNS41JTIwMTElMkM4LjUzOCUyMDguNTM3JTJDMTElMjA1LjUlMkMxMSUyMHolMjBtJTIwMCUyQy05JTIwQyUyMDMuNTY2JTJDMiUyMDIlMkMzLjU2NyUyMDIlMkM1LjUlMjAyJTJDNy40MzMlMjAzLjU2NiUyQzklMjA1LjUlMkM5JTIwNS42NTUlMkM5JTIwNS44MDQlMkM4Ljk3NCUyMDUuOTU0JTJDOC45NTQlMjBMJTIwMyUyQzYlMjBWJTIwNSUyMEwlMjA1LjU3MSUyQzMuMjg2JTIwNS45ODQlMkMyLjA0OSUyMEMlMjA1LjgyNCUyQzIuMDI2JTIwNS42NjYlMkMyJTIwNS41JTJDMiUyMHolMjBNJTIwOC45NDklMkM1JTIwSCUyMDcuMzc1JTIwQyUyMDcuMDIxJTJDNS41MDUlMjA2LjU0NSUyQzYuMDgyJTIwNiUyQzYuNDk3JTIwViUyMDguOTUlMjBDJTIwNy42OTMlMkM4LjcwNSUyMDklMkM3LjI2MiUyMDklMkM1LjUlMjA5JTJDNS4zMjklMjA4Ljk3NCUyQzUuMTY1JTIwOC45NDklMkM1JTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhMGEwYTAlMjIlMjBmaWxsLXJ1bGUlM0QlMjJldmVub2RkJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6MTFweDtoZWlnaHQ6MTFweDtiYWNrZ3JvdW5kLXNpemU6MTFweCAxMXB4fS5kZy1maXJtLWNhcmRfX2VtYWlsOmJlZm9yZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTElMjIlMjBoZWlnaHQlM0QlMjI3JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMTElMkMxLjU1NSUyMHYlMjAzLjg5JTIwQyUyMDExJTJDNi4zMDMlMjAxMC4yNDIlMkM3JTIwOS4zMDklMkM3JTIwSCUyMDEuNjkyJTIwQyUyMDAuNzU4JTJDNyUyMDAlMkM2LjMwMyUyMDAlMkM1LjQ0NCUyMFYlMjAxLjU1NCUyMEwlMjA1LjUlMkM0LjgyNiUyMDExJTJDMS41NTUlMjB6JTIwTSUyMDAuMTkxJTJDMCUyMEglMjAxMC44MDglMjBMJTIwNS41JTJDMy4xMTElMjAwLjE5MSUyQzAlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2FhYSUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoxMXB4O2hlaWdodDo3cHg7YmFja2dyb3VuZC1zaXplOjExcHggN3B4fS5kZy1zY2hlZHVsZV9fdG9kYXl7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLWxlZnQ6MjRweDttYXgtd2lkdGg6ODQlO2JhY2tncm91bmQtcG9zaXRpb246Y2VudGVyIGJvdHRvbTtiYWNrZ3JvdW5kLXNpemU6MnB4IDFweDtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDtmb250LXNpemU6MTRweDtsaW5lLWhlaWdodDoxNnB4O2N1cnNvcjpwb2ludGVyfS5kZy1zY2hlZHVsZV9fdG9kYXk6YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3RvcDozcHg7bGVmdDotMjRweDtjb250ZW50OicnfS5kZy1zY2hlZHVsZV9fdG9kYXk6YWZ0ZXJ7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6LTE1cHg7Ym90dG9tOjRweDtjb250ZW50OicnfS5kZy1zY2hlZHVsZV9fdG9kYXktaW5uZXJ7b3ZlcmZsb3c6aGlkZGVuO3dpZHRoOjEwMCU7dGV4dC1vdmVyZmxvdzplbGxpcHNpczt3aGl0ZS1zcGFjZTpub3dyYXB9LmRnLXNjaGVkdWxlX3dvcmtzLWV2ZXJ5ZGF5X3RydWUgLmRnLXNjaGVkdWxlX190b2RheXtiYWNrZ3JvdW5kLWltYWdlOm5vbmU7Y3Vyc29yOmRlZmF1bHR9LmRnLXNjaGVkdWxlX3dvcmtzLWV2ZXJ5ZGF5X3RydWUgLmRnLXNjaGVkdWxlX190b2RheTphZnRlcntiYWNrZ3JvdW5kLWltYWdlOm5vbmV9LmRnLXNjaGVkdWxlX29wZW5fdHJ1ZSAuZGctc2NoZWR1bGVfX3RvZGF5OmJlZm9yZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTElMjIlMjBoZWlnaHQlM0QlMjIxMSUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDUuNSUyQzExJTIwQyUyMDIuNDYzJTJDMTElMjAwJTJDOC41MzclMjAwJTJDNS41JTIwMCUyQzIuNDYyJTIwMi40NjMlMkMwJTIwNS41JTJDMCUyMDguNTM3JTJDMCUyMDExJTJDMi40NjIlMjAxMSUyQzUuNSUyMDExJTJDOC41MzclMjA4LjUzNyUyQzExJTIwNS41JTJDMTElMjB6JTIwTSUyMDYlMkM1LjI5MyUyMFYlMjAyJTIwSCUyMDUlMjBWJTIwNS43MDclMjBMJTIwNy42NDYlMkM4LjM1MyUyMDguMzUzJTJDNy42NDYlMjA2JTJDNS4yOTMlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzcwYmYwMCUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoxMXB4O2hlaWdodDoxMXB4O2JhY2tncm91bmQtc2l6ZToxMXB4IDExcHh9LmRnLXNjaGVkdWxlX19ub3d7bWFyZ2luOjJweCA3cHggMCAzNnB4O2ZvbnQtc2l6ZToxMnB4fS5kZy1zY2hlZHVsZV9fc3RyaW5ne3BhZGRpbmc6M3B4IDE2cHggM3B4IDI0cHg7dGV4dC1hbGlnbjpsZWZ0O2ZvbnQtc2l6ZToxNHB4fS5kZy1zY2hlZHVsZV9fc3RyaW5nLXRpbWV7d2hpdGUtc3BhY2U6bm93cmFwfS5kZy1zY2hlZHVsZV9fdGFibGV7ZGlzcGxheTpub25lO3RleHQtYWxpZ246Y2VudGVyO2ZvbnQtc2l6ZTowfS5kZy1zY2hlZHVsZV9fdGFibGUtY2VsbC1ncm91cHt3aGl0ZS1zcGFjZTpub3dyYXB9LmRnLXNjaGVkdWxlX190Y3tkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjJweCAwIDE1cHg7d2lkdGg6NDRweDt2ZXJ0aWNhbC1hbGlnbjp0b3A7d2hpdGUtc3BhY2U6bm9ybWFsO2ZvbnQtc2l6ZToxNHB4fS5kZy1zY2hlZHVsZV9fdGNfcHJle3dpZHRoOjE5cHh9LmRnLXNjaGVkdWxlX19kYXktbmFtZXttYXJnaW46MDtjb2xvcjojOGM4NzgyO3RleHQtdHJhbnNmb3JtOmNhcGl0YWxpemV9LmRnLXNjaGVkdWxlX190ZHttYXJnaW46MTBweCAwIDB9LmRnLXNjaGVkdWxlX3N0YXRlX2V4cGFuZGVkIC5kZy1zY2hlZHVsZV9fcG9wdXB7ZGlzcGxheTpibG9jazt2aXNpYmlsaXR5OnZpc2libGU7bWF4LWhlaWdodDoxMDAwcHg7b3BhY2l0eToxfS5kZy1zY2hlZHVsZV9fdGFibGUtY2xvY2t7bWFyZ2luOjEzcHggMCAwfS5kZy1zY2hlZHVsZV9fdGFibGUtbHVuY2h7bWFyZ2luOjMxcHggMCAwfS5kZy1zY2hlZHVsZV9fdG9kYXl7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IHRvcCxyaWdodCB0b3AsZnJvbShyZ2JhKDIzMCwyMzAsMjMwLC41NSkpLGNvbG9yLXN0b3AoNTAlLHJnYmEoMjMwLDIzMCwyMzAsLjU1KSksY29sb3Itc3RvcCg1MSUscmdiYSgwLDAsMCwwKSksdG8ocmdiYSgwLDAsMCwwKSkpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQobGVmdCxyZ2JhKDIzMCwyMzAsMjMwLC41NSkscmdiYSgyMzAsMjMwLDIzMCwuNTUpIDUwJSxyZ2JhKDAsMCwwLDApIDUxJSxyZ2JhKDAsMCwwLDApIDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LHJnYmEoMjMwLDIzMCwyMzAsLjU1KSxyZ2JhKDIzMCwyMzAsMjMwLC41NSkgNTAlLHJnYmEoMCwwLDAsMCkgNTElLHJnYmEoMCwwLDAsMCkgMTAwJSl9LmRnLXNjaGVkdWxlX19ub3d7Y29sb3I6I2FhYX0uZGctc2NoZWR1bGVfX3Rke2NvbG9yOiNlNmU2ZTZ9LmRnLXNjaGVkdWxlX190Y19hY3RpdmVfdHJ1ZXtiYWNrZ3JvdW5kOnJnYmEoMjU1LDI1NSwyNTUsLjEpfS5kZy1zY2hlZHVsZV9fc3RyaW5nLXRpbWV7Y29sb3I6I2U2ZTZlNn0uZGctc2NoZWR1bGVfX3RhYmxlLWNsb2Nre2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMSUyMiUyMGhlaWdodCUzRCUyMjExJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNS41JTJDMTElMjBDJTIwMi40NjMlMkMxMSUyMDAlMkM4LjUzNyUyMDAlMkM1LjUlMjAwJTJDMi40NjIlMjAyLjQ2MyUyQzAlMjA1LjUlMkMwJTIwOC41MzclMkMwJTIwMTElMkMyLjQ2MiUyMDExJTJDNS41JTIwMTElMkM4LjUzNyUyMDguNTM3JTJDMTElMjA1LjUlMkMxMSUyMHolMjBNJTIwNiUyQzUuMjkzJTIwViUyMDIlMjBIJTIwNSUyMFYlMjA1LjcwNyUyMEwlMjA3LjY0NiUyQzguMzUzJTIwOC4zNTMlMkM3LjY0NiUyMDYlMkM1LjI5MyUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYTBhMGEwJTIyJTIwZmlsbC1ydWxlJTNEJTIyZXZlbm9kZCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjExcHg7aGVpZ2h0OjExcHg7YmFja2dyb3VuZC1zaXplOjExcHggMTFweH0uZGctc2NoZWR1bGVfX3RhYmxlLWx1bmNoe2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMiUyMiUyMGhlaWdodCUzRCUyMjExJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNCUyQzclMjBIJTIwOCUyMEMlMjA4LjU4JTJDNyUyMDkuNDYxJTJDNi4wODQlMjA5LjgyNiUyQzQuOTc3JTIwViUyMDUlMjBDJTIwMTEuMDQ3JTJDNSUyMDEyJTJDMy40NTMlMjAxMiUyQzIuMDMxJTIwMTIlMkMxLjQ1MyUyMDExLjUzMSUyQzElMjAxMS4wMTYlMkMxJTIwSCUyMDEwJTIwQyUyMDEwJTJDMC4xODglMjA5Ljc4MSUyQzAlMjA5JTJDMCUyMEglMjAzJTIwQyUyMDIuMjk3JTJDMCUyMDIlMkMwLjE4OCUyMDIlMkMxJTIwdiUyMDMlMjBjJTIwMCUyQzEuNDklMjAxLjEzNyUyQzMlMjAyJTJDMyUyMHolMjBtJTIwNiUyQy01JTIwaCUyMDAuNSUyMEMlMjAxMC44NzUlMkMyJTIwMTElMkMyLjIxOSUyMDExJTJDMi41JTIwMTElMkMzLjYyNSUyMDEwLjU2MiUyQzQlMjAxMCUyQzQlMjBWJTIwMiUyMHolMjBNJTIwMCUyQzklMjBjJTIwMCUyQzAuNDQ4JTIwMS43OTElMkMxJTIwMyUyQzElMjAwJTJDMC40MDUlMjAwLjY0NiUyQzElMjAxJTJDMSUyMGglMjA0JTIwYyUyMDAuMzU0JTJDMCUyMDElMkMtMC41OTUlMjAxJTJDLTElMjAxLjIwOCUyQzAlMjAzJTJDLTAuNTUyJTIwMyUyQy0xJTIwViUyMDglMjBIJTIwMCUyMHYlMjAxJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhYWE1YTAlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoxMnB4O2hlaWdodDoxMXB4O2JhY2tncm91bmQtc2l6ZToxMnB4IDExcHh9LmRnLXNjaGVkdWxlX29wZW5fZmFsc2UgLmRnLXNjaGVkdWxlX190b2RheTpiZWZvcmV7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjExJTIyJTIwaGVpZ2h0JTNEJTIyMTElMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA1LjUlMkMxMSUyMEMlMjAyLjQ2MyUyQzExJTIwMCUyQzguNTM3JTIwMCUyQzUuNSUyMDAlMkMyLjQ2MiUyMDIuNDYzJTJDMCUyMDUuNSUyQzAlMjA4LjUzNyUyQzAlMjAxMSUyQzIuNDYyJTIwMTElMkM1LjUlMjAxMSUyQzguNTM3JTIwOC41MzclMkMxMSUyMDUuNSUyQzExJTIweiUyME0lMjA2JTJDNS4yOTMlMjBWJTIwMiUyMEglMjA1JTIwViUyMDUuNzA3JTIwTCUyMDcuNjQ2JTJDOC4zNTMlMjA4LjM1MyUyQzcuNjQ2JTIwNiUyQzUuMjkzJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhMGEwYTAlMjIlMjBmaWxsLXJ1bGUlM0QlMjJldmVub2RkJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6MTFweDtoZWlnaHQ6MTFweDtiYWNrZ3JvdW5kLXNpemU6MTFweCAxMXB4fS5kZy1zY2hlZHVsZV9fdG9kYXk6YWZ0ZXJ7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjEwJTIyJTIwaGVpZ2h0JTNEJTIyNiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDUlMkM2JTIwSCUyMDQuNTg2JTIwTCUyMDAlMkMxLjQxNCUyMFYlMjAwJTIwSCUyMDEuNDE0JTIwTCUyMDUlMkMzLjU4NiUyMDguNTg2JTJDMCUyMEglMjAxMCUyMFYlMjAxLjQxNCUyMEwlMjA1LjQxNCUyQzYlMjBIJTIwNSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYTVhMDljJTIyJTIwZmlsbC1ydWxlJTNEJTIyZXZlbm9kZCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjEwcHg7aGVpZ2h0OjZweDtiYWNrZ3JvdW5kLXNpemU6MTBweCA2cHh9LmRnLXNjaGVkdWxlX190b2RheV9zaG93bl90cnVlOmFmdGVye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMCUyMiUyMGhlaWdodCUzRCUyMjYlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA1JTJDMCUyMEglMjA1LjQxNCUyMEwlMjAxMCUyQzQuNTg2JTIwViUyMDYlMjBIJTIwOC41ODYlMjBMJTIwNSUyQzIuNDE0JTIwMS40MTQlMkM2JTIwSCUyMDAlMjBWJTIwNC41ODYlMjBMJTIwNC41ODYlMkMwJTIwSCUyMDUlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2E1YTA5YyUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoxMHB4O2hlaWdodDo2cHg7YmFja2dyb3VuZC1zaXplOjEwcHggNnB4fS5kZy1saW5rLC5kZy1saW5rOmhvdmVye2JhY2tncm91bmQtcG9zaXRpb246MCA5NSU7YmFja2dyb3VuZC1zaXplOjEwcHggMXB4O2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14fS5kZy1saW5rX3R5cGVfbG9jYWx7YmFja2dyb3VuZDotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IHRvcCxyaWdodCB0b3AsZnJvbSgjOWNkKSxjb2xvci1zdG9wKDUwJSwjOWNkKSxjb2xvci1zdG9wKDUwJSx0cmFuc3BhcmVudCkpO2JhY2tncm91bmQ6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQobGVmdCwjOWNkLCM5Y2QgNTAlLHRyYW5zcGFyZW50IDUwJSk7YmFja2dyb3VuZDpsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIzljZCwjOWNkIDUwJSx0cmFuc3BhcmVudCA1MCUpfS5uby10b3VjaCAuZGctbGlua190eXBlX2xvY2FsOmhvdmVye2JhY2tncm91bmQ6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsbGVmdCB0b3AscmlnaHQgdG9wLGZyb20oIzliYyksY29sb3Itc3RvcCg1MCUsIzliYyksY29sb3Itc3RvcCg1MCUsdHJhbnNwYXJlbnQpKTtiYWNrZ3JvdW5kOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KGxlZnQsIzliYywjOWJjIDUwJSx0cmFuc3BhcmVudCA1MCUpO2JhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCM5YmMsIzliYyA1MCUsdHJhbnNwYXJlbnQgNTAlKX0uZGctbGluay5kZy1saW5rX3R5cGVfbG9jYWwsLmRnLWxpbmsuZGctbGlua190eXBlX2xvY2FsOmhvdmVye2JhY2tncm91bmQtc2l6ZTo2cHggMXB4fS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfdHJhZmZpYzphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMjAlMjIlMjBoZWlnaHQlM0QlMjIxNCUyMiUyMHZpZXdCb3glM0QlMjIwJTIwMCUyMDIwJTIwMTQlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxOCUyQzUlMjBDJTIwMTglMkM0JTIwMTclMkMxJTIwMTUlMkMxJTIwSCUyMDEyJTIwMTAlMjBDJTIwOCUyQzElMjA3JTJDNCUyMDclMkM1JTIwSCUyMDUlMjB2JTIwMiUyMGglMjAxJTIwdiUyMDQlMjBjJTIwMCUyQzAuNiUyMDAlMkMxJTIwMSUyQzElMjB2JTIwMiUyMGglMjAyJTIwdiUyMC0yJTIwaCUyMDclMjB2JTIwMiUyMGglMjAyJTIwdiUyMC0yJTIwYyUyMDElMkMwJTIwMSUyQy0wLjQlMjAxJTJDLTElMjBWJTIwNyUyMGglMjAxJTIwViUyMDUlMjBIJTIwMTglMjB6JTIwTSUyMDEwJTJDMyUyMGglMjAyJTIwMyUyMGMlMjAyJTJDMCUyMDIlMkMxJTIwMiUyQzMlMjBIJTIwOCUyMEMlMjA4JTJDNCUyMDglMkMzJTIwMTAlMkMzJTIweiUyME0lMjA5JTJDMTAlMjBIJTIwOCUyMEMlMjA3LjQlMkMxMCUyMDclMkM5LjYlMjA3JTJDOSUyMDclMkM4LjQlMjA3LjQlMkM4JTIwOCUyQzglMjBoJTIwMSUyMGMlMjAwLjYlMkMwJTIwMSUyQzAuNCUyMDElMkMxJTIwMCUyQzAuNiUyMC0wLjQlMkMxJTIwLTElMkMxJTIweiUyMG0lMjA4JTJDMCUyMEglMjAxNiUyMEMlMjAxNS40JTJDMTAlMjAxNSUyQzkuNiUyMDE1JTJDOSUyMDE1JTJDOC40JTIwMTUuNCUyQzglMjAxNiUyQzglMjBoJTIwMSUyMGMlMjAwLjYlMkMwJTIwMSUyQzAuNCUyMDElMkMxJTIwMCUyQzAuNiUyMC0wLjQlMkMxJTIwLTElMkMxJTIweiUyME0lMjA0JTJDNCUyMEglMjA2JTIwViUyMDMlMjBIJTIwNCUyMEMlMjAxJTJDMyUyMDElMkM2JTIwMSUyQzclMjBIJTIwMCUyMHYlMjAxJTIwaCUyMDElMjB2JTIwNCUyMEglMjAzJTIwViUyMDExJTIwSCUyMDUlMjBWJTIwNyUyMEglMjAyJTIwQyUyMDIlMkM2JTIwMiUyQzQlMjA0JTJDNCUyMHolMjBNJTIwMyUyQzklMjA0JTJDMTAlMjBIJTIwMiUyMFYlMjA5JTIwaCUyMDElMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzYxNjE2MSUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NnJTIwZmlsbCUzRCUyMiUyM2ZmZiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDE2JTJDOCUyMGglMjAxJTIwYyUyMDAuNCUyQzAlMjAwLjclMkMwLjIlMjAwLjglMkMwLjUlMjBDJTIwMTcuOSUyQzguNCUyMDE4JTJDOC4yJTIwMTglMkM4JTIwMTglMkM3LjQlMjAxNy42JTJDNyUyMDE3JTJDNyUyMGglMjAtMSUyMGMlMjAtMC42JTJDMCUyMC0xJTJDMC40JTIwLTElMkMxJTIwMCUyQzAuMiUyMDAuMSUyQzAuNCUyMDAuMiUyQzAuNSUyMEMlMjAxNS4zJTJDOC4yJTIwMTUuNiUyQzglMjAxNiUyQzglMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwOCUyQzglMjBIJTIwOSUyMEMlMjA5LjQlMkM4JTIwOS43JTJDOC4yJTIwOS44JTJDOC41JTIwOS45JTJDOC40JTIwMTAlMkM4LjIlMjAxMCUyQzglMjAxMCUyQzcuNCUyMDkuNiUyQzclMjA5JTJDNyUyMEglMjA4JTIwQyUyMDcuNCUyQzclMjA3JTJDNy40JTIwNyUyQzglMjA3JTJDOC4yJTIwNy4xJTJDOC40JTIwNy4yJTJDOC41JTIwNy4zJTJDOC4yJTIwNy42JTJDOCUyMDglMkM4JTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDYlMkMzJTIwSCUyMDQlMjBDJTIwNCUyQzMlMjA0JTJDMyUyMDQlMkMzJTIwMiUyQzMlMjAyJTJDNSUyMDIlMkM2JTIwSCUyMDIlMjBDJTIwMi4xJTJDNSUyMDIuNSUyQzQlMjA0JTJDNCUyMEglMjA1JTIwNiUyMFYlMjAzJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTAlMjA3SDFWOEgweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE1JTJDMiUyMEglMjAxMiUyMDEwJTIwQyUyMDglMkMyJTIwOCUyQzMlMjA4JTJDNSUyMEglMjA4JTIwQyUyMDglMkMzLjclMjA4LjMlMkMzJTIwMTAlMkMzJTIwaCUyMDIlMjAzJTIwYyUyMDEuNyUyQzAlMjAxLjklMkMwLjclMjAyJTJDMiUyMGglMjAwJTIwQyUyMDE3JTJDMyUyMDE3JTJDMiUyMDE1JTJDMiUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0zJTIwOUw0JTIwOSUyMDMlMjA4JTIwMiUyMDglMjAyJTIwOSUyMDIlMjA5JTIwMiUyMDklMjAzJTIwOXolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA3JTJDMTElMjBDJTIwNiUyQzExJTIwNiUyQzEwLjYlMjA2JTJDMTAlMjB2JTIwMSUyMGMlMjAwJTJDMC42JTIwMCUyQzElMjAxJTJDMSUyMHYlMjAtMSUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAxOCUyQzExJTIwdiUyMDElMjBjJTIwMSUyQzAlMjAxJTJDLTAuNCUyMDElMkMtMSUyMHYlMjAtMSUyMGMlMjAwJTJDMC42JTIwMCUyQzElMjAtMSUyQzElMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMTklMjA2SDIwVjdIMTl6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMyUyMDExTDElMjAxMSUyMDElMjAxMiUyMDMlMjAxMiUyMDMlMjAxMSUyMDUlMjAxMSUyMDUlMjA3JTIwNSUyMDclMjA1JTIwMTAlMjAzJTIwMTB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMTYlMjAxM0gxOFYxNEgxNnolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk01JTIwNkg2VjdINXolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk05JTIwMTNMNyUyMDEzJTIwNyUyMDE0JTIwOSUyMDE0JTIwOSUyMDEyJTIwMTYlMjAxMiUyMDE2JTIwMTElMjA5JTIwMTF6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDJTJGZyUzRSUwQSUyMCUyMCUyMCUyMCUzQ2clMjBmaWxsJTNEJTIyJTIzNDQ0JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMiUyQzYlMjBDJTIwMiUyQzYuNCUyMDIlMkM2LjclMjAyJTJDNyUyMEglMjA1JTIwViUyMDYlMjBIJTIwMiUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0yJTIwOUwyJTIwMTAlMjA0JTIwMTAlMjAzJTIwOXolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA0JTJDMyUyMEglMjA2JTIwViUyMDIlMjBIJTIwNCUyMEMlMjAxJTJDMiUyMDElMkM1JTIwMSUyQzYlMjBIJTIwMCUyMFYlMjA3JTIwSCUyMDElMjBDJTIwMSUyQzYlMjAxJTJDMyUyMDQlMkMzJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE4JTJDNCUyMEMlMjAxOCUyQzMlMjAxNyUyQzAlMjAxNSUyQzAlMjBIJTIwMTIlMjAxMCUyMEMlMjA4JTJDMCUyMDclMkMzJTIwNyUyQzQlMjBIJTIwNiUyMDUlMjBWJTIwNSUyMEglMjA3JTIwQyUyMDclMkM0JTIwOCUyQzElMjAxMCUyQzElMjBoJTIwMiUyMDMlMjBjJTIwMiUyQzAlMjAzJTJDMyUyMDMlMkM0JTIwaCUyMDIlMjBWJTIwNCUyMGglMjAtMiUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA4JTJDMTAlMjBIJTIwOSUyMEMlMjA5LjYlMkMxMCUyMDEwJTJDOS42JTIwMTAlMkM5JTIwMTAlMkM4LjglMjA5LjklMkM4LjYlMjA5LjglMkM4LjUlMjA5LjclMkM4LjglMjA5LjQlMkM5JTIwOSUyQzklMjBIJTIwOCUyMEMlMjA3LjYlMkM5JTIwNy4zJTJDOC44JTIwNy4yJTJDOC41JTIwNy4xJTJDOC42JTIwNyUyQzguOCUyMDclMkM5JTIwYyUyMDAlMkMwLjYlMjAwLjQlMkMxJTIwMSUyQzElMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTclMkM2JTIwQyUyMDE3JTJDNS42JTIwMTclMkM1LjMlMjAxNyUyQzUlMjBIJTIwOCUyMGMlMjAwJTJDMC4zJTIwMCUyQzAuNiUyMDAlMkMxJTIwaCUyMDklMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTcuOCUyQzguNSUyMEMlMjAxNy43JTJDOC44JTIwMTcuNCUyQzklMjAxNyUyQzklMjBIJTIwMTYlMjBDJTIwMTUuNiUyQzklMjAxNS4zJTJDOC44JTIwMTUuMiUyQzguNSUyMDE1LjElMkM4LjYlMjAxNSUyQzguOCUyMDE1JTJDOSUyMGMlMjAwJTJDMC42JTIwMC40JTJDMSUyMDElMkMxJTIwaCUyMDElMjBjJTIwMC42JTJDMCUyMDElMkMtMC40JTIwMSUyQy0xJTIwMCUyQy0wLjIlMjAtMC4xJTJDLTAuNCUyMC0wLjIlMkMtMC41JTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQyUyRmclM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoyMHB4O2hlaWdodDoxNHB4O2JhY2tncm91bmQtc2l6ZToyMHB4IDE0cHg7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7bWFyZ2luOmF1dG87Y29udGVudDonJ30uZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX3RyYWZmaWM6YWN0aXZlOmFmdGVyLC5uby10b3VjaCAuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX3RyYWZmaWM6aG92ZXI6YWZ0ZXJ7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjIwJTIyJTIwaGVpZ2h0JTNEJTIyMTQlMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAyMCUyMDE0JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTglMkM1JTIwQyUyMDE4JTJDNCUyMDE3JTJDMSUyMDE1JTJDMSUyMEglMjAxMiUyMDEwJTIwQyUyMDglMkMxJTIwNyUyQzQlMjA3JTJDNSUyMEglMjA1JTIwdiUyMDIlMjBoJTIwMSUyMHYlMjA0JTIwYyUyMDAlMkMwLjYlMjAwJTJDMSUyMDElMkMxJTIwdiUyMDIlMjBoJTIwMiUyMHYlMjAtMiUyMGglMjA3JTIwdiUyMDIlMjBoJTIwMiUyMHYlMjAtMiUyMGMlMjAxJTJDMCUyMDElMkMtMC40JTIwMSUyQy0xJTIwViUyMDclMjBoJTIwMSUyMFYlMjA1JTIwSCUyMDE4JTIweiUyME0lMjAxMCUyQzMlMjBoJTIwMiUyMDMlMjBjJTIwMiUyQzAlMjAyJTJDMSUyMDIlMkMzJTIwSCUyMDglMjBDJTIwOCUyQzQlMjA4JTJDMyUyMDEwJTJDMyUyMHolMjBNJTIwOSUyQzEwJTIwSCUyMDglMjBDJTIwNy40JTJDMTAlMjA3JTJDOS42JTIwNyUyQzklMjA3JTJDOC40JTIwNy40JTJDOCUyMDglMkM4JTIwaCUyMDElMjBjJTIwMC42JTJDMCUyMDElMkMwLjQlMjAxJTJDMSUyMDAlMkMwLjYlMjAtMC40JTJDMSUyMC0xJTJDMSUyMHolMjBtJTIwOCUyQzAlMjBIJTIwMTYlMjBDJTIwMTUuNCUyQzEwJTIwMTUlMkM5LjYlMjAxNSUyQzklMjAxNSUyQzguNCUyMDE1LjQlMkM4JTIwMTYlMkM4JTIwaCUyMDElMjBjJTIwMC42JTJDMCUyMDElMkMwLjQlMjAxJTJDMSUyMDAlMkMwLjYlMjAtMC40JTJDMSUyMC0xJTJDMSUyMHolMjBNJTIwNCUyQzQlMjBIJTIwNiUyMFYlMjAzJTIwSCUyMDQlMjBDJTIwMSUyQzMlMjAxJTJDNiUyMDElMkM3JTIwSCUyMDAlMjB2JTIwMSUyMGglMjAxJTIwdiUyMDQlMjBIJTIwMyUyMFYlMjAxMSUyMEglMjA1JTIwViUyMDclMjBIJTIwMiUyMEMlMjAyJTJDNiUyMDIlMkM0JTIwNCUyQzQlMjB6JTIwTSUyMDMlMkM5JTIwNCUyQzEwJTIwSCUyMDIlMjBWJTIwOSUyMGglMjAxJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM0MjQyNDIlMjIlMjBmaWxsLXJ1bGUlM0QlMjJldmVub2RkJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDZyUyMGZpbGwlM0QlMjIlMjNmZmYlMjIlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAxNiUyQzglMjBoJTIwMSUyMGMlMjAwLjQlMkMwJTIwMC43JTJDMC4yJTIwMC44JTJDMC41JTIwQyUyMDE3LjklMkM4LjQlMjAxOCUyQzguMiUyMDE4JTJDOCUyMDE4JTJDNy40JTIwMTcuNiUyQzclMjAxNyUyQzclMjBoJTIwLTElMjBjJTIwLTAuNiUyQzAlMjAtMSUyQzAuNCUyMC0xJTJDMSUyMDAlMkMwLjIlMjAwLjElMkMwLjQlMjAwLjIlMkMwLjUlMjBDJTIwMTUuMyUyQzguMiUyMDE1LjYlMkM4JTIwMTYlMkM4JTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDglMkM4JTIwSCUyMDklMjBDJTIwOS40JTJDOCUyMDkuNyUyQzguMiUyMDkuOCUyQzguNSUyMDkuOSUyQzguNCUyMDEwJTJDOC4yJTIwMTAlMkM4JTIwMTAlMkM3LjQlMjA5LjYlMkM3JTIwOSUyQzclMjBIJTIwOCUyMEMlMjA3LjQlMkM3JTIwNyUyQzcuNCUyMDclMkM4JTIwNyUyQzguMiUyMDcuMSUyQzguNCUyMDcuMiUyQzguNSUyMDcuMyUyQzguMiUyMDcuNiUyQzglMjA4JTJDOCUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA2JTJDMyUyMEglMjA0JTIwQyUyMDQlMkMzJTIwNCUyQzMlMjA0JTJDMyUyMDIlMkMzJTIwMiUyQzUlMjAyJTJDNiUyMEglMjAyJTIwQyUyMDIuMSUyQzUlMjAyLjUlMkM0JTIwNCUyQzQlMjBIJTIwNSUyMDYlMjBWJTIwMyUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0wJTIwN0gxVjhIMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxNSUyQzIlMjBIJTIwMTIlMjAxMCUyMEMlMjA4JTJDMiUyMDglMkMzJTIwOCUyQzUlMjBIJTIwOCUyMEMlMjA4JTJDMy43JTIwOC4zJTJDMyUyMDEwJTJDMyUyMGglMjAyJTIwMyUyMGMlMjAxLjclMkMwJTIwMS45JTJDMC43JTIwMiUyQzIlMjBoJTIwMCUyMEMlMjAxNyUyQzMlMjAxNyUyQzIlMjAxNSUyQzIlMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMyUyMDlMNCUyMDklMjAzJTIwOCUyMDIlMjA4JTIwMiUyMDklMjAyJTIwOSUyMDIlMjA5JTIwMyUyMDl6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNyUyQzExJTIwQyUyMDYlMkMxMSUyMDYlMkMxMC42JTIwNiUyQzEwJTIwdiUyMDElMjBjJTIwMCUyQzAuNiUyMDAlMkMxJTIwMSUyQzElMjB2JTIwLTElMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMTglMkMxMSUyMHYlMjAxJTIwYyUyMDElMkMwJTIwMSUyQy0wLjQlMjAxJTJDLTElMjB2JTIwLTElMjBjJTIwMCUyQzAuNiUyMDAlMkMxJTIwLTElMkMxJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTE5JTIwNkgyMFY3SDE5eiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTMlMjAxMUwxJTIwMTElMjAxJTIwMTIlMjAzJTIwMTIlMjAzJTIwMTElMjA1JTIwMTElMjA1JTIwNyUyMDUlMjA3JTIwNSUyMDEwJTIwMyUyMDEweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTE2JTIwMTNIMThWMTRIMTZ6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNNSUyMDZINlY3SDV6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNOSUyMDEzTDclMjAxMyUyMDclMjAxNCUyMDklMjAxNCUyMDklMjAxMiUyMDE2JTIwMTIlMjAxNiUyMDExJTIwOSUyMDExeiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQyUyRmclM0UlMEElMjAlMjAlMjAlMjAlM0NnJTIwZmlsbCUzRCUyMiUyMzJlMmUyZSUyMiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDIlMkM2JTIwQyUyMDIlMkM2LjQlMjAyJTJDNi43JTIwMiUyQzclMjBIJTIwNSUyMFYlMjA2JTIwSCUyMDIlMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMiUyMDlMMiUyMDEwJTIwNCUyMDEwJTIwMyUyMDl6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNCUyQzMlMjBIJTIwNiUyMFYlMjAyJTIwSCUyMDQlMjBDJTIwMSUyQzIlMjAxJTJDNSUyMDElMkM2JTIwSCUyMDAlMjBWJTIwNyUyMEglMjAxJTIwQyUyMDElMkM2JTIwMSUyQzMlMjA0JTJDMyUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxOCUyQzQlMjBDJTIwMTglMkMzJTIwMTclMkMwJTIwMTUlMkMwJTIwSCUyMDEyJTIwMTAlMjBDJTIwOCUyQzAlMjA3JTJDMyUyMDclMkM0JTIwSCUyMDYlMjA1JTIwViUyMDUlMjBIJTIwNyUyMEMlMjA3JTJDNCUyMDglMkMxJTIwMTAlMkMxJTIwaCUyMDIlMjAzJTIwYyUyMDIlMkMwJTIwMyUyQzMlMjAzJTJDNCUyMGglMjAyJTIwViUyMDQlMjBoJTIwLTIlMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwOCUyQzEwJTIwSCUyMDklMjBDJTIwOS42JTJDMTAlMjAxMCUyQzkuNiUyMDEwJTJDOSUyMDEwJTJDOC44JTIwOS45JTJDOC42JTIwOS44JTJDOC41JTIwOS43JTJDOC44JTIwOS40JTJDOSUyMDklMkM5JTIwSCUyMDglMjBDJTIwNy42JTJDOSUyMDcuMyUyQzguOCUyMDcuMiUyQzguNSUyMDcuMSUyQzguNiUyMDclMkM4LjglMjA3JTJDOSUyMGMlMjAwJTJDMC42JTIwMC40JTJDMSUyMDElMkMxJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE3JTJDNiUyMEMlMjAxNyUyQzUuNiUyMDE3JTJDNS4zJTIwMTclMkM1JTIwSCUyMDglMjBjJTIwMCUyQzAuMyUyMDAlMkMwLjYlMjAwJTJDMSUyMGglMjA5JTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE3LjglMkM4LjUlMjBDJTIwMTcuNyUyQzguOCUyMDE3LjQlMkM5JTIwMTclMkM5JTIwSCUyMDE2JTIwQyUyMDE1LjYlMkM5JTIwMTUuMyUyQzguOCUyMDE1LjIlMkM4LjUlMjAxNS4xJTJDOC42JTIwMTUlMkM4LjglMjAxNSUyQzklMjBjJTIwMCUyQzAuNiUyMDAuNCUyQzElMjAxJTJDMSUyMGglMjAxJTIwYyUyMDAuNiUyQzAlMjAxJTJDLTAuNCUyMDElMkMtMSUyMDAlMkMtMC4yJTIwLTAuMSUyQy0wLjQlMjAtMC4yJTJDLTAuNSUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0MlMkZnJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIil9LmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfYWN0aXZlLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV90cmFmZmljOmFjdGl2ZTphZnRlciwuZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX3RyYWZmaWM6YWZ0ZXIsLm5vLXRvdWNoIC5kZy1jb250cm9sLXJvdW5kX19pY29uX3N0YXRlX2FjdGl2ZS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfdHJhZmZpYzpob3ZlcjphZnRlcntiYWNrZ3JvdW5kLWltYWdlOm5vbmV9YS5kZy10cmFmZmljLWNvbnRyb2x7ei1pbmRleDowO2NvbG9yOiNmMmYyZjI7dGV4dC1kZWNvcmF0aW9uOm5vbmU7dGV4dC1zaGFkb3c6MCAxcHggMnB4IHJnYmEoMCwwLDAsLjMpO2ZvbnQ6NDAwIDE1cHgvMzJweCAnQXJpYWwgbmFycm93JyxBcmlhbCxzYW5zLXNlcmlmfWEuZGctdHJhZmZpYy1jb250cm9sX2NvbG9yX2dyZWVuOmFmdGVyLGEuZGctdHJhZmZpYy1jb250cm9sX2NvbG9yX3JlZDphZnRlcixhLmRnLXRyYWZmaWMtY29udHJvbF9jb2xvcl95ZWxsb3c6YWZ0ZXJ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7ei1pbmRleDotMTttYXJnaW46YXV0bzt3aWR0aDoyMnB4O2hlaWdodDoyMnB4O2JvcmRlci1yYWRpdXM6NTAlOy13ZWJraXQtYm94LXNoYWRvdzppbnNldCAwIDFweCAwIDAgcmdiYSgwLDAsMCwuMiksMCAxcHggMCAwICNmZmY7Ym94LXNoYWRvdzppbnNldCAwIDFweCAwIDAgcmdiYSgwLDAsMCwuMiksMCAxcHggMCAwICNmZmZ9Lm5vLXRvdWNoIGEuZGctdHJhZmZpYy1jb250cm9sOmhvdmVye2NvbG9yOiNmMmYyZjJ9Lm5vLXRvdWNoIGEuZGctdHJhZmZpYy1jb250cm9sX2NvbG9yX2dyZWVuOmhvdmVyOmFmdGVyLC5uby10b3VjaCBhLmRnLXRyYWZmaWMtY29udHJvbF9jb2xvcl9yZWQ6aG92ZXI6YWZ0ZXIsLm5vLXRvdWNoIGEuZGctdHJhZmZpYy1jb250cm9sX2NvbG9yX3llbGxvdzpob3ZlcjphZnRlcnt3aWR0aDoyMnB4O2hlaWdodDoyMnB4fWEuZGctdHJhZmZpYy1jb250cm9sX2NvbG9yX2dyZWVuOmFmdGVye2JhY2tncm91bmQ6IzNmYzAzYn0ubm8tdG91Y2ggYS5kZy10cmFmZmljLWNvbnRyb2xfY29sb3JfZ3JlZW46aG92ZXI6YWZ0ZXIsYS5kZy10cmFmZmljLWNvbnRyb2xfY29sb3JfZ3JlZW46YWN0aXZlOmFmdGVye2JhY2tncm91bmQ6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsbGVmdCBib3R0b20sbGVmdCB0b3AsZnJvbSgjMmFhNzMxKSx0bygjNTNlMTNhKSkgIzNlYzQzNTtiYWNrZ3JvdW5kOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KGJvdHRvbSwjMmFhNzMxLCM1M2UxM2EpICMzZWM0MzU7YmFja2dyb3VuZDpsaW5lYXItZ3JhZGllbnQodG8gdG9wLCMyYWE3MzEsIzUzZTEzYSkgIzNlYzQzNX1hLmRnLXRyYWZmaWMtY29udHJvbF9jb2xvcl95ZWxsb3c6YWZ0ZXJ7YmFja2dyb3VuZDojZjNiMjIzfS5uby10b3VjaCBhLmRnLXRyYWZmaWMtY29udHJvbF9jb2xvcl95ZWxsb3c6aG92ZXI6YWZ0ZXIsYS5kZy10cmFmZmljLWNvbnRyb2xfY29sb3JfeWVsbG93OmFjdGl2ZTphZnRlcntiYWNrZ3JvdW5kOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLGxlZnQgYm90dG9tLGxlZnQgdG9wLGZyb20oI2VmOTMxYiksdG8oI2Y3YmUyNikpICNmNGE4MjA7YmFja2dyb3VuZDotd2Via2l0LWxpbmVhci1ncmFkaWVudChib3R0b20sI2VmOTMxYiwjZjdiZTI2KSAjZjRhODIwO2JhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KHRvIHRvcCwjZWY5MzFiLCNmN2JlMjYpICNmNGE4MjB9YS5kZy10cmFmZmljLWNvbnRyb2xfY29sb3JfcmVkOmFmdGVye2JhY2tncm91bmQ6I2ViMjQwY30ubm8tdG91Y2ggYS5kZy10cmFmZmljLWNvbnRyb2xfY29sb3JfcmVkOmhvdmVyOmFmdGVyLGEuZGctdHJhZmZpYy1jb250cm9sX2NvbG9yX3JlZDphY3RpdmU6YWZ0ZXJ7YmFja2dyb3VuZDotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IGJvdHRvbSxsZWZ0IHRvcCxmcm9tKCNjMDFjMGEpLHRvKCNmNzM0MTYpKSAjZGIyODExO2JhY2tncm91bmQ6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQoYm90dG9tLCNjMDFjMGEsI2Y3MzQxNikgI2RiMjgxMTtiYWNrZ3JvdW5kOmxpbmVhci1ncmFkaWVudCh0byB0b3AsI2MwMWMwYSwjZjczNDE2KSAjZGIyODExfS5sZWFmbGV0LXJ1bGVyTWFya2VyLXBhbmV7ei1pbmRleDo2MDB9LmRnLXJ1bGVyX19sYWJlbHtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7ei1pbmRleDoyMDA7LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnRyYW5zcGFyZW50fS5kZy1ydWxlcl9fbGFiZWwtc3BhY2Vye2Rpc3BsYXk6YmxvY2t9LmRnLXJ1bGVyX19sYWJlbC1jb250YWluZXJ7ZGlzcGxheTpub25lO3BhZGRpbmc6MnB4IDRweDtib3JkZXI6NHB4IHNvbGlkICNmZmY7Ym9yZGVyLXJhZGl1czoxM3B4O2JhY2tncm91bmQ6IzBkYTVkNTtiYWNrZ3JvdW5kLWNsaXA6cGFkZGluZy1ib3g7Y29sb3I6I2ZmZjt3aGl0ZS1zcGFjZTpub3dyYXA7Zm9udC1zaXplOjEycHh9LmRnLXJ1bGVyX19wb2ludHtkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW46MnB4IDRweCAwIDA7d2lkdGg6MTBweDtoZWlnaHQ6MTBweDtib3JkZXItcmFkaXVzOjVweDtiYWNrZ3JvdW5kOiNmZmZ9LmRnLXJ1bGVyX19sYWJlbC1yZW1vdmUtbGlua3tiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTIlMjIlMjBoZWlnaHQlM0QlMjIxMiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDYlMkMwJTIwQyUyMDIuNjg3JTJDMCUyMDAlMkMyLjY4NyUyMDAlMkM2JTIwMCUyQzkuMzEzJTIwMi42ODclMkMxMiUyMDYlMkMxMiUyMDkuMzEzJTJDMTIlMjAxMiUyQzkuMzEzJTIwMTIlMkM2JTIwMTIlMkMyLjY4NyUyMDkuMzEzJTJDMCUyMDYlMkMwJTIweiUyME0lMjA5LjQwMSUyQzkuMzk4JTIwOC44JTJDOS42JTIwNiUyQzYuOCUyMDMuMTk5JTJDOS42JTIwMi41OSUyQzkuNDE1JTIwMi4zNzUlMkM4Ljc3NCUyMDUuMTk5JTJDNiUyMDIuMzk5JTJDMy4xNzUlMjAyLjYyJTJDMi41OTElMjAzLjE3NSUyQzIuMzc1JTIwNS45NDklMkM1LjIyNSUyMDguNzc0JTJDMi4zNzUlMjA5LjQxNSUyQzIuNjA1JTIwOS41NjYlMkMzLjE5NiUyMDYuODI0JTJDNiUyMDkuNiUyQzguOCUyMDkuNDAxJTJDOS4zOTglMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2ZmZiUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoxMnB4O2hlaWdodDoxMnB4O2JhY2tncm91bmQtc2l6ZToxMnB4IDEycHg7ZGlzcGxheTpub25lO21hcmdpbjoxcHggMCAwIDRweDt2ZXJ0aWNhbC1hbGlnbjp0b3A7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuMnMgZWFzZTt0cmFuc2l0aW9uOmFsbCAuMnMgZWFzZX0ubm8tdG91Y2ggLmRnLXJ1bGVyX19sYWJlbC1yZW1vdmUtbGluazpob3Zlcnstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoOTBkZWcpOy1tcy10cmFuc2Zvcm06cm90YXRlKDkwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDkwZGVnKX0uZGctcnVsZXJfX3JlbW92ZS1saW5rLW92ZXJsYXl7cG9zaXRpb246YWJzb2x1dGU7dG9wOi03cHg7cmlnaHQ6LTdweDtib3R0b206LTdweDt3aWR0aDo0MHB4fS5uby10b3VjaCAuZGctcnVsZXJfX3JlbW92ZS1saW5rLW92ZXJsYXl7ZGlzcGxheTpub25lfS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfcnVsZXI6YWZ0ZXJ7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjE2JTIyJTIwaGVpZ2h0JTNEJTIyOSUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDEyLjk5OSUyQzAlMjB2JTIwNC4wMDElMjBoJTIwLTElMjBWJTIwMCUyMGglMjAtMiUyMHYlMjAyJTIwaCUyMC0xJTIwViUyMDAlMjBoJTIwLTIlMjBWJTIwMiUyMEglMjA2JTIwViUyMDAlMjBIJTIwMy45OTglMjB2JTIwNC4wMDElMjBoJTIwLTElMjBWJTIwMCUyMGglMjAtMyUyMFYlMjA4JTIwSCUyMDE2JTIwViUyMDAlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzYxNjE2MSUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDIuOTk5JTJDNCUyMGglMjAxJTIwdiUyMDElMjBoJTIwLTElMjB6JTIwbSUyMDMlMkMtMiUyMGglMjAxJTIwdiUyMDElMjBoJTIwLTElMjB6JTIwbSUyMDMlMkMwJTIwaCUyMDElMjB2JTIwMSUyMGglMjAtMSUyMHolMjBtJTIwMyUyQzIlMjBoJTIwMSUyMHYlMjAxJTIwaCUyMC0xJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM0NDQlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAwJTJDOCUyMEglMjAxNiUyMFYlMjA5JTIwSCUyMDAlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2ZmZiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDAlMkMwJTIwSCUyMDMlMjBWJTIwMSUyMEglMjAwJTIweiUyMG0lMjAxMyUyQzAlMjBoJTIwMyUyMHYlMjAxJTIwaCUyMC0zJTIweiUyMG0lMjAtMyUyQzAlMjBoJTIwMiUyMFYlMjAxJTIwSCUyMDEwJTIweiUyME0lMjA3JTJDMCUyMEglMjA5JTIwViUyMDElMjBIJTIwNyUyMHolMjBNJTIwNCUyQzAlMjBIJTIwNiUyMFYlMjAxJTIwSCUyMDQlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzQ0NCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjE2cHg7aGVpZ2h0OjlweDtiYWNrZ3JvdW5kLXNpemU6MTZweCA5cHg7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7bWFyZ2luOmF1dG87Y29udGVudDonJ30uZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX3J1bGVyOmFjdGl2ZTphZnRlciwubm8tdG91Y2ggLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9ydWxlcjpob3ZlcjphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTYlMjIlMjBoZWlnaHQlM0QlMjI5JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMTIuOTk5JTJDMCUyMHYlMjA0LjAwMSUyMGglMjAtMSUyMFYlMjAwJTIwaCUyMC0yJTIwdiUyMDIlMjBoJTIwLTElMjBWJTIwMCUyMGglMjAtMiUyMFYlMjAyJTIwSCUyMDYlMjBWJTIwMCUyMEglMjAzLjk5OCUyMHYlMjA0LjAwMSUyMGglMjAtMSUyMFYlMjAwJTIwaCUyMC0zJTIwViUyMDglMjBIJTIwMTYlMjBWJTIwMCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNDI0MjQyJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMi45OTklMkM0JTIwaCUyMDElMjB2JTIwMSUyMGglMjAtMSUyMHolMjBtJTIwMyUyQy0yJTIwaCUyMDElMjB2JTIwMSUyMGglMjAtMSUyMHolMjBtJTIwMyUyQzAlMjBoJTIwMSUyMHYlMjAxJTIwaCUyMC0xJTIweiUyMG0lMjAzJTJDMiUyMGglMjAxJTIwdiUyMDElMjBoJTIwLTElMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzJlMmUyZSUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDAlMkM4JTIwSCUyMDE2JTIwViUyMDklMjBIJTIwMCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMCUyQzAlMjBIJTIwMyUyMFYlMjAxJTIwSCUyMDAlMjB6JTIwbSUyMDEzJTJDMCUyMGglMjAzJTIwdiUyMDElMjBoJTIwLTMlMjB6JTIwbSUyMC0zJTJDMCUyMGglMjAyJTIwViUyMDElMjBIJTIwMTAlMjB6JTIwTSUyMDclMkMwJTIwSCUyMDklMjBWJTIwMSUyMEglMjA3JTIweiUyME0lMjA0JTJDMCUyMEglMjA2JTIwViUyMDElMjBIJTIwNCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzMmUyZTJlJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIil9LmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfYWN0aXZlLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9ydWxlcjphY3RpdmU6YWZ0ZXIsLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfYWN0aXZlLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9ydWxlcjphZnRlciwubm8tdG91Y2ggLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfYWN0aXZlLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9ydWxlcjpob3ZlcjphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTYlMjIlMjBoZWlnaHQlM0QlMjI5JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMTIuOTk5JTJDMCUyMHYlMjA0LjAwMSUyMGglMjAtMSUyMFYlMjAwJTIwaCUyMC0yJTIwdiUyMDIlMjBoJTIwLTElMjBWJTIwMCUyMGglMjAtMiUyMFYlMjAyJTIwSCUyMDYlMjBWJTIwMCUyMEglMjAzLjk5OSUyMHYlMjA0LjAwMSUyMGglMjAtMSUyMFYlMjAwJTIwaCUyMC0zJTIwViUyMDglMjBIJTIwMTYlMjBWJTIwMCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzMjFhN2Q2JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMi45OTklMkM0JTIwaCUyMDElMjB2JTIwMSUyMGglMjAtMSUyMHolMjBtJTIwMyUyQy0yJTIwaCUyMDElMjB2JTIwMSUyMGglMjAtMSUyMHolMjBtJTIwMyUyQzAlMjBoJTIwMSUyMHYlMjAxJTIwaCUyMC0xJTIweiUyMG0lMjAzJTJDMiUyMGglMjAxJTIwdiUyMDElMjBoJTIwLTElMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzE0NzU5NiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDAlMkM4JTIwSCUyMDE2JTIwViUyMDklMjBIJTIwMCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMCUyQzAlMjBIJTIwMyUyMFYlMjAxJTIwSCUyMDAlMjB6JTIwbSUyMDEzJTJDMCUyMGglMjAzJTIwdiUyMDElMjBoJTIwLTMlMjB6JTIwbSUyMC0zJTJDMCUyMGglMjAyJTIwViUyMDElMjBIJTIwMTAlMjB6JTIwTSUyMDclMkMwJTIwSCUyMDklMjBWJTIwMSUyMEglMjA3JTIweiUyME0lMjA0JTJDMCUyMEglMjA2JTIwViUyMDElMjBIJTIwNCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzMTQ3NTk2JTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIil9XCI7IChyZXF1aXJlKFwiYnJvd3NlcmlmeS1jc3NcIikuY3JlYXRlU3R5bGUoY3NzLCB7IFwiaHJlZlwiOiBcImRpc3QvY3NzL3N0eWxlcy5mdWxsLmRhcmsuY3NzXCIgfSwgeyBcImluc2VydEF0XCI6IFwiYm90dG9tXCIgfSkpOyBtb2R1bGUuZXhwb3J0cyA9IGNzczsiLCIvKiByZWR1Y2UgaW1wbGVtaW50YXRpb24gYnkgTW96aWxhIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L1JlZHVjZT9yZWRpcmVjdGxvY2FsZT1lbi1VUyZyZWRpcmVjdHNsdWc9SmF2YVNjcmlwdCUyRlJlZmVyZW5jZSUyRkdsb2JhbF9PYmplY3RzJTJGQXJyYXklMkZSZWR1Y2UqL1xuaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBBcnJheS5wcm90b3R5cGUucmVkdWNlKSB7XG4gIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbihjYWxsYmFjaywgb3B0X2luaXRpYWxWYWx1ZSl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGlmIChudWxsID09PSB0aGlzIHx8ICd1bmRlZmluZWQnID09PSB0eXBlb2YgdGhpcykge1xuICAgICAgLy8gQXQgdGhlIG1vbWVudCBhbGwgbW9kZXJuIGJyb3dzZXJzLCB0aGF0IHN1cHBvcnQgc3RyaWN0IG1vZGUsIGhhdmVcbiAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBvZiBBcnJheS5wcm90b3R5cGUucmVkdWNlLiBGb3IgaW5zdGFuY2UsIElFOFxuICAgICAgLy8gZG9lcyBub3Qgc3VwcG9ydCBzdHJpY3QgbW9kZSwgc28gdGhpcyBjaGVjayBpcyBhY3R1YWxseSB1c2VsZXNzLlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnQXJyYXkucHJvdG90eXBlLnJlZHVjZSBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBjYWxsYmFjaykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjYWxsYmFjayArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIGluZGV4LCB2YWx1ZSxcbiAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGggPj4+IDAsXG4gICAgICAgIGlzVmFsdWVTZXQgPSBmYWxzZTtcbiAgICBpZiAoMSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhbHVlID0gb3B0X2luaXRpYWxWYWx1ZTtcbiAgICAgIGlzVmFsdWVTZXQgPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGluZGV4ID0gMDsgbGVuZ3RoID4gaW5kZXg7ICsraW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KGluZGV4KSkge1xuICAgICAgICBpZiAoaXNWYWx1ZVNldCkge1xuICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2sodmFsdWUsIHRoaXNbaW5kZXhdLCBpbmRleCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSB0aGlzW2luZGV4XTtcbiAgICAgICAgICBpc1ZhbHVlU2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzVmFsdWVTZXQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG4vLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZvckVhY2hcbi8vIFByb2R1Y3Rpb24gc3RlcHMgb2YgRUNNQS0yNjIsIEVkaXRpb24gNSwgMTUuNC40LjE4XG4vLyBSZWZlcmVuY2U6IGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xOFxuaWYgKCFBcnJheS5wcm90b3R5cGUuZm9yRWFjaCkge1xuXG4gIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgVCwgaztcblxuICAgIGlmICh0aGlzID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0aGlzIGlzIG51bGwgb3Igbm90IGRlZmluZWRcIik7XG4gICAgfVxuXG4gICAgdmFyIGtWYWx1ZSxcbiAgICAgICAgLy8gMS4gTGV0IE8gYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIFRvT2JqZWN0IHBhc3NpbmcgdGhlIHx0aGlzfCB2YWx1ZSBhcyB0aGUgYXJndW1lbnQuXG4gICAgICAgIE8gPSBPYmplY3QodGhpcyksXG5cbiAgICAgICAgLy8gMi4gTGV0IGxlblZhbHVlIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgR2V0IGludGVybmFsIG1ldGhvZCBvZiBPIHdpdGggdGhlIGFyZ3VtZW50IFwibGVuZ3RoXCIuXG4gICAgICAgIC8vIDMuIExldCBsZW4gYmUgVG9VaW50MzIobGVuVmFsdWUpLlxuICAgICAgICBsZW4gPSBPLmxlbmd0aCA+Pj4gMDsgLy8gSGFjayB0byBjb252ZXJ0IE8ubGVuZ3RoIHRvIGEgVUludDMyXG5cbiAgICAvLyA0LiBJZiBJc0NhbGxhYmxlKGNhbGxiYWNrKSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgIC8vIFNlZTogaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS4xMVxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGNhbGxiYWNrKSAhPT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNhbGxiYWNrICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgLy8gNS4gSWYgdGhpc0FyZyB3YXMgc3VwcGxpZWQsIGxldCBUIGJlIHRoaXNBcmc7IGVsc2UgbGV0IFQgYmUgdW5kZWZpbmVkLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIFQgPSB0aGlzQXJnO1xuICAgIH1cblxuICAgIC8vIDYuIExldCBrIGJlIDBcbiAgICBrID0gMDtcblxuICAgIC8vIDcuIFJlcGVhdCwgd2hpbGUgayA8IGxlblxuICAgIHdoaWxlIChrIDwgbGVuKSB7XG5cbiAgICAgIC8vIGEuIExldCBQayBiZSBUb1N0cmluZyhrKS5cbiAgICAgIC8vICAgVGhpcyBpcyBpbXBsaWNpdCBmb3IgTEhTIG9wZXJhbmRzIG9mIHRoZSBpbiBvcGVyYXRvclxuICAgICAgLy8gYi4gTGV0IGtQcmVzZW50IGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgSGFzUHJvcGVydHkgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCBhcmd1bWVudCBQay5cbiAgICAgIC8vICAgVGhpcyBzdGVwIGNhbiBiZSBjb21iaW5lZCB3aXRoIGNcbiAgICAgIC8vIGMuIElmIGtQcmVzZW50IGlzIHRydWUsIHRoZW5cbiAgICAgIGlmIChrIGluIE8pIHtcblxuICAgICAgICAvLyBpLiBMZXQga1ZhbHVlIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgR2V0IGludGVybmFsIG1ldGhvZCBvZiBPIHdpdGggYXJndW1lbnQgUGsuXG4gICAgICAgIGtWYWx1ZSA9IE9ba107XG5cbiAgICAgICAgLy8gaWkuIENhbGwgdGhlIENhbGwgaW50ZXJuYWwgbWV0aG9kIG9mIGNhbGxiYWNrIHdpdGggVCBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcbiAgICAgICAgLy8gYXJndW1lbnQgbGlzdCBjb250YWluaW5nIGtWYWx1ZSwgaywgYW5kIE8uXG4gICAgICAgIGNhbGxiYWNrLmNhbGwoVCwga1ZhbHVlLCBrLCBPKTtcbiAgICAgIH1cbiAgICAgIC8vIGQuIEluY3JlYXNlIGsgYnkgMS5cbiAgICAgIGsrKztcbiAgICB9XG4gICAgLy8gOC4gcmV0dXJuIHVuZGVmaW5lZFxuICB9O1xufVxuXG4vLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9rZXlzXG5pZiAoIU9iamVjdC5rZXlzKSB7XG4gIE9iamVjdC5rZXlzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgaGFzRG9udEVudW1CdWcgPSAhKHt0b1N0cmluZzogbnVsbH0pLnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpLFxuICAgICAgICBkb250RW51bXMgPSBbXG4gICAgICAgICAgJ3RvU3RyaW5nJyxcbiAgICAgICAgICAndG9Mb2NhbGVTdHJpbmcnLFxuICAgICAgICAgICd2YWx1ZU9mJyxcbiAgICAgICAgICAnaGFzT3duUHJvcGVydHknLFxuICAgICAgICAgICdpc1Byb3RvdHlwZU9mJyxcbiAgICAgICAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAgICAgICAgICdjb25zdHJ1Y3RvcidcbiAgICAgICAgXSxcbiAgICAgICAgZG9udEVudW1zTGVuZ3RoID0gZG9udEVudW1zLmxlbmd0aDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgJiYgKHR5cGVvZiBvYmogIT09ICdmdW5jdGlvbicgfHwgb2JqID09PSBudWxsKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gbm9uLW9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sIHByb3AsIGk7XG5cbiAgICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNEb250RW51bUJ1Zykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZG9udEVudW1zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGRvbnRFbnVtc1tpXSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRvbnRFbnVtc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH0oKSk7XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29tZVxuaWYgKCFBcnJheS5wcm90b3R5cGUuc29tZSlcbntcbiAgQXJyYXkucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbihmdW4gLyosIHRoaXNBcmcgKi8pXG4gIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cbiAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG4gICAgaWYgKHR5cGVvZiBmdW4gIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cbiAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgIHtcbiAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpc0FyZywgdFtpXSwgaSwgdCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn1cblxuLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9tYXBcbmlmICghQXJyYXkucHJvdG90eXBlLm1hcClcbntcbiAgQXJyYXkucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKGZ1biAvKiwgdGhpc0FyZyAqLylcbiAge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXG4gICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuICAgIGlmICh0eXBlb2YgZnVuICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICB7XG4gICAgICAvLyBOT1RFOiBBYnNvbHV0ZSBjb3JyZWN0bmVzcyB3b3VsZCBkZW1hbmQgT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICAgICAvLyAgICAgICBiZSB1c2VkLiAgQnV0IHRoaXMgbWV0aG9kIGlzIGZhaXJseSBuZXcsIGFuZCBmYWlsdXJlIGlzXG4gICAgICAvLyAgICAgICBwb3NzaWJsZSBvbmx5IGlmIE9iamVjdC5wcm90b3R5cGUgb3IgQXJyYXkucHJvdG90eXBlXG4gICAgICAvLyAgICAgICBoYXMgYSBwcm9wZXJ0eSB8aXwgKHZlcnkgdW5saWtlbHkpLCBzbyB1c2UgYSBsZXNzLWNvcnJlY3RcbiAgICAgIC8vICAgICAgIGJ1dCBtb3JlIHBvcnRhYmxlIGFsdGVybmF0aXZlLlxuICAgICAgaWYgKGkgaW4gdClcbiAgICAgICAgcmVzW2ldID0gZnVuLmNhbGwodGhpc0FyZywgdFtpXSwgaSwgdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn1cblxuLy9Gcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbHRlclxuaWYgKCFBcnJheS5wcm90b3R5cGUuZmlsdGVyKVxue1xuICBBcnJheS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24oZnVuIC8qLCB0aGlzQXJnICovKVxuICB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cbiAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG4gICAgaWYgKHR5cGVvZiBmdW4gIT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAge1xuICAgICAgaWYgKGkgaW4gdClcbiAgICAgIHtcbiAgICAgICAgdmFyIHZhbCA9IHRbaV07XG5cbiAgICAgICAgLy8gTk9URTogVGVjaG5pY2FsbHkgdGhpcyBzaG91bGQgT2JqZWN0LmRlZmluZVByb3BlcnR5IGF0XG4gICAgICAgIC8vICAgICAgIHRoZSBuZXh0IGluZGV4LCBhcyBwdXNoIGNhbiBiZSBhZmZlY3RlZCBieVxuICAgICAgICAvLyAgICAgICBwcm9wZXJ0aWVzIG9uIE9iamVjdC5wcm90b3R5cGUgYW5kIEFycmF5LnByb3RvdHlwZS5cbiAgICAgICAgLy8gICAgICAgQnV0IHRoYXQgbWV0aG9kJ3MgbmV3LCBhbmQgY29sbGlzaW9ucyBzaG91bGQgYmVcbiAgICAgICAgLy8gICAgICAgcmFyZSwgc28gdXNlIHRoZSBtb3JlLWNvbXBhdGlibGUgYWx0ZXJuYXRpdmUuXG4gICAgICAgIGlmIChmdW4uY2FsbCh0aGlzQXJnLCB2YWwsIGksIHQpKVxuICAgICAgICAgIHJlcy5wdXNoKHZhbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn1cblxuLy9Gcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmRcbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcbiAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAob1RoaXMpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgLy8gY2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1IGludGVybmFsIElzQ2FsbGFibGUgZnVuY3Rpb25cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZVwiKTtcbiAgICB9XG5cbiAgICB2YXIgYUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICBmVG9CaW5kID0gdGhpcyxcbiAgICAgICAgZk5PUCA9IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBmQm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGZOT1AgJiYgb1RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBvVGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9O1xuXG4gICAgZk5PUC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICBmQm91bmQucHJvdG90eXBlID0gbmV3IGZOT1AoKTtcblxuICAgIHJldHVybiBmQm91bmQ7XG4gIH07XG59XG5cbi8vRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mP3JlZGlyZWN0bG9jYWxlPWVuLVVTJnJlZGlyZWN0c2x1Zz1KYXZhU2NyaXB0JTJGUmVmZXJlbmNlJTJGR2xvYmFsX09iamVjdHMlMkZBcnJheSUyRmluZGV4T2ZcbmlmICghQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgaWYgKCB0aGlzID09PSB1bmRlZmluZWQgfHwgdGhpcyA9PT0gbnVsbCApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoICdcInRoaXNcIiBpcyBudWxsIG9yIG5vdCBkZWZpbmVkJyApO1xuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCA+Pj4gMDsgLy8gSGFjayB0byBjb252ZXJ0IG9iamVjdC5sZW5ndGggdG8gYSBVSW50MzJcblxuICAgIGZyb21JbmRleCA9ICtmcm9tSW5kZXggfHwgMDtcblxuICAgIGlmIChNYXRoLmFicyhmcm9tSW5kZXgpID09PSBJbmZpbml0eSkge1xuICAgICAgZnJvbUluZGV4ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgICAgZnJvbUluZGV4ICs9IGxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgIGZyb21JbmRleCA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICg7ZnJvbUluZGV4IDwgbGVuZ3RoOyBmcm9tSW5kZXgrKykge1xuICAgICAgaWYgKHRoaXNbZnJvbUluZGV4XSA9PT0gc2VhcmNoRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZnJvbUluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcbn1cbiIsImlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAoZnVuY3Rpb24oKSB7XG4gIHZhciBkZWZpbmUsIHJlcXVpcmVNb2R1bGUsIHJlcXVpcmUsIHJlcXVpcmVqcztcblxuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlZ2lzdHJ5ID0ge30sIHNlZW4gPSB7fTtcblxuICAgIGRlZmluZSA9IGZ1bmN0aW9uKG5hbWUsIGRlcHMsIGNhbGxiYWNrKSB7XG4gICAgICByZWdpc3RyeVtuYW1lXSA9IHsgZGVwczogZGVwcywgY2FsbGJhY2s6IGNhbGxiYWNrIH07XG4gICAgfTtcblxuICAgIHJlcXVpcmVqcyA9IHJlcXVpcmUgPSByZXF1aXJlTW9kdWxlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJlcXVpcmVqcy5fZWFrX3NlZW4gPSByZWdpc3RyeTtcblxuICAgICAgaWYgKHNlZW5bbmFtZV0pIHsgcmV0dXJuIHNlZW5bbmFtZV07IH1cbiAgICAgIHNlZW5bbmFtZV0gPSB7fTtcblxuICAgICAgaWYgKCFyZWdpc3RyeVtuYW1lXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBtb2R1bGUgXCIgKyBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1vZCA9IHJlZ2lzdHJ5W25hbWVdLFxuICAgICAgICAgIGRlcHMgPSBtb2QuZGVwcyxcbiAgICAgICAgICBjYWxsYmFjayA9IG1vZC5jYWxsYmFjayxcbiAgICAgICAgICByZWlmaWVkID0gW10sXG4gICAgICAgICAgZXhwb3J0cztcblxuICAgICAgZm9yICh2YXIgaT0wLCBsPWRlcHMubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICBpZiAoZGVwc1tpXSA9PT0gJ2V4cG9ydHMnKSB7XG4gICAgICAgICAgcmVpZmllZC5wdXNoKGV4cG9ydHMgPSB7fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVpZmllZC5wdXNoKHJlcXVpcmVNb2R1bGUocmVzb2x2ZShkZXBzW2ldKSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGNhbGxiYWNrLmFwcGx5KHRoaXMsIHJlaWZpZWQpO1xuICAgICAgcmV0dXJuIHNlZW5bbmFtZV0gPSBleHBvcnRzIHx8IHZhbHVlO1xuXG4gICAgICBmdW5jdGlvbiByZXNvbHZlKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZC5jaGFyQXQoMCkgIT09ICcuJykgeyByZXR1cm4gY2hpbGQ7IH1cbiAgICAgICAgdmFyIHBhcnRzID0gY2hpbGQuc3BsaXQoXCIvXCIpO1xuICAgICAgICB2YXIgcGFyZW50QmFzZSA9IG5hbWUuc3BsaXQoXCIvXCIpLnNsaWNlKDAsIC0xKTtcblxuICAgICAgICBmb3IgKHZhciBpPTAsIGw9cGFydHMubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgICAgICBpZiAocGFydCA9PT0gJy4uJykgeyBwYXJlbnRCYXNlLnBvcCgpOyB9XG4gICAgICAgICAgZWxzZSBpZiAocGFydCA9PT0gJy4nKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgZWxzZSB7IHBhcmVudEJhc2UucHVzaChwYXJ0KTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudEJhc2Uuam9pbihcIi9cIik7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcblxuICBkZWZpbmUoXCJwcm9taXNlL2FsbFwiLFxuICAgIFtcIi4vdXRpbHNcIixcImV4cG9ydHNcIl0sXG4gICAgZnVuY3Rpb24oX19kZXBlbmRlbmN5MV9fLCBfX2V4cG9ydHNfXykge1xuICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAvKiBnbG9iYWwgdG9TdHJpbmcgKi9cblxuICAgICAgdmFyIGlzQXJyYXkgPSBfX2RlcGVuZGVuY3kxX18uaXNBcnJheTtcbiAgICAgIHZhciBpc0Z1bmN0aW9uID0gX19kZXBlbmRlbmN5MV9fLmlzRnVuY3Rpb247XG5cbiAgICAgIC8qKlxuICAgICAgICBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIGFsbCB0aGUgZ2l2ZW4gcHJvbWlzZXMgaGF2ZSBiZWVuXG4gICAgICAgIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLiBUaGUgcmV0dXJuIHByb21pc2VcbiAgICAgICAgaXMgZnVsZmlsbGVkIHdpdGggYW4gYXJyYXkgdGhhdCBnaXZlcyBhbGwgdGhlIHZhbHVlcyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlXG4gICAgICAgIHBhc3NlZCBpbiB0aGUgYHByb21pc2VzYCBhcnJheSBhcmd1bWVudC5cblxuICAgICAgICBFeGFtcGxlOlxuXG4gICAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgICAgdmFyIHByb21pc2UxID0gUlNWUC5yZXNvbHZlKDEpO1xuICAgICAgICB2YXIgcHJvbWlzZTIgPSBSU1ZQLnJlc29sdmUoMik7XG4gICAgICAgIHZhciBwcm9taXNlMyA9IFJTVlAucmVzb2x2ZSgzKTtcbiAgICAgICAgdmFyIHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgICAgICAgUlNWUC5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgICAgICAgIC8vIFRoZSBhcnJheSBoZXJlIHdvdWxkIGJlIFsgMSwgMiwgMyBdO1xuICAgICAgICB9KTtcbiAgICAgICAgYGBgXG5cbiAgICAgICAgSWYgYW55IG9mIHRoZSBgcHJvbWlzZXNgIGdpdmVuIHRvIGBSU1ZQLmFsbGAgYXJlIHJlamVjdGVkLCB0aGUgZmlyc3QgcHJvbWlzZVxuICAgICAgICB0aGF0IGlzIHJlamVjdGVkIHdpbGwgYmUgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgdG8gdGhlIHJldHVybmVkIHByb21pc2VzJ3NcbiAgICAgICAgcmVqZWN0aW9uIGhhbmRsZXIuIEZvciBleGFtcGxlOlxuXG4gICAgICAgIEV4YW1wbGU6XG5cbiAgICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgICB2YXIgcHJvbWlzZTEgPSBSU1ZQLnJlc29sdmUoMSk7XG4gICAgICAgIHZhciBwcm9taXNlMiA9IFJTVlAucmVqZWN0KG5ldyBFcnJvcihcIjJcIikpO1xuICAgICAgICB2YXIgcHJvbWlzZTMgPSBSU1ZQLnJlamVjdChuZXcgRXJyb3IoXCIzXCIpKTtcbiAgICAgICAgdmFyIHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgICAgICAgUlNWUC5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgICAgICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zIGJlY2F1c2UgdGhlcmUgYXJlIHJlamVjdGVkIHByb21pc2VzIVxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIGVycm9yLm1lc3NhZ2UgPT09IFwiMlwiXG4gICAgICAgIH0pO1xuICAgICAgICBgYGBcblxuICAgICAgICBAbWV0aG9kIGFsbFxuICAgICAgICBAZm9yIFJTVlBcbiAgICAgICAgQHBhcmFtIHtBcnJheX0gcHJvbWlzZXNcbiAgICAgICAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsXG4gICAgICAgIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiBhbGwgYHByb21pc2VzYCBoYXZlIGJlZW5cbiAgICAgICAgZnVsZmlsbGVkLCBvciByZWplY3RlZCBpZiBhbnkgb2YgdGhlbSBiZWNvbWUgcmVqZWN0ZWQuXG4gICAgICAqL1xuICAgICAgZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHZhciBQcm9taXNlID0gdGhpcztcblxuICAgICAgICBpZiAoIWlzQXJyYXkocHJvbWlzZXMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byBhbGwuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXSwgcmVtYWluaW5nID0gcHJvbWlzZXMubGVuZ3RoLFxuICAgICAgICAgIHByb21pc2U7XG5cbiAgICAgICAgICBpZiAocmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlcihpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJlc29sdmVBbGwoaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZUFsbChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAoLS1yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChwcm9taXNlICYmIGlzRnVuY3Rpb24ocHJvbWlzZS50aGVuKSkge1xuICAgICAgICAgICAgICBwcm9taXNlLnRoZW4ocmVzb2x2ZXIoaSksIHJlamVjdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlQWxsKGksIHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIF9fZXhwb3J0c19fLmFsbCA9IGFsbDtcbiAgICB9KTtcbiAgZGVmaW5lKFwicHJvbWlzZS9hc2FwXCIsXG4gICAgW1wiZXhwb3J0c1wiXSxcbiAgICBmdW5jdGlvbihfX2V4cG9ydHNfXykge1xuICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICB2YXIgYnJvd3Nlckdsb2JhbCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgPyB3aW5kb3cgOiB7fTtcbiAgICAgIHZhciBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgICB2YXIgbG9jYWwgPSB3aW5kb3c7XG5cbiAgICAgIC8vIG5vZGVcbiAgICAgIGZ1bmN0aW9uIHVzZU5leHRUaWNrKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gICAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcbiAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBub2RlLmRhdGEgPSAoaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDIpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1c2VTZXRUaW1lb3V0KCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbG9jYWwuc2V0VGltZW91dChmbHVzaCwgMSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdHVwbGUgPSBxdWV1ZVtpXTtcbiAgICAgICAgICB2YXIgY2FsbGJhY2sgPSB0dXBsZVswXSwgYXJnID0gdHVwbGVbMV07XG4gICAgICAgICAgY2FsbGJhY2soYXJnKTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2NoZWR1bGVGbHVzaDtcblxuICAgICAgLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgICAgIHNjaGVkdWxlRmx1c2ggPSB1c2VOZXh0VGljaygpO1xuICAgICAgfSBlbHNlIGlmIChCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBxdWV1ZS5wdXNoKFtjYWxsYmFjaywgYXJnXSk7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAvLyBJZiBsZW5ndGggaXMgMSwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgICAgICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAgICAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9fZXhwb3J0c19fLmFzYXAgPSBhc2FwO1xuICAgIH0pO1xuICBkZWZpbmUoXCJwcm9taXNlL2NvbmZpZ1wiLFxuICAgIFtcImV4cG9ydHNcIl0sXG4gICAgZnVuY3Rpb24oX19leHBvcnRzX18pIHtcbiAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgaW5zdHJ1bWVudDogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGNvbmZpZ3VyZShuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGNvbmZpZ1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjb25maWdbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX19leHBvcnRzX18uY29uZmlnID0gY29uZmlnO1xuICAgICAgX19leHBvcnRzX18uY29uZmlndXJlID0gY29uZmlndXJlO1xuICAgIH0pO1xuICBkZWZpbmUoXCJwcm9taXNlL3BvbHlmaWxsXCIsXG4gICAgW1wiLi9wcm9taXNlXCIsXCIuL3V0aWxzXCIsXCJleHBvcnRzXCJdLFxuICAgIGZ1bmN0aW9uKF9fZGVwZW5kZW5jeTFfXywgX19kZXBlbmRlbmN5Ml9fLCBfX2V4cG9ydHNfXykge1xuICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAvKmdsb2JhbCBzZWxmKi9cbiAgICAgIHZhciBSU1ZQUHJvbWlzZSA9IF9fZGVwZW5kZW5jeTFfXy5Qcm9taXNlO1xuICAgICAgdmFyIGlzRnVuY3Rpb24gPSBfX2RlcGVuZGVuY3kyX18uaXNGdW5jdGlvbjtcblxuICAgICAgZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gICAgICAgIHZhciBsb2NhbDtcblxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50KSB7XG4gICAgICAgICAgbG9jYWwgPSB3aW5kb3c7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9jYWwgPSBzZWxmO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVzNlByb21pc2VTdXBwb3J0ID1cbiAgICAgICAgICBcIlByb21pc2VcIiBpbiBsb2NhbCAmJlxuICAgICAgICAgIC8vIFNvbWUgb2YgdGhlc2UgbWV0aG9kcyBhcmUgbWlzc2luZyBmcm9tXG4gICAgICAgICAgLy8gRmlyZWZveC9DaHJvbWUgZXhwZXJpbWVudGFsIGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgIFwicmVzb2x2ZVwiIGluIGxvY2FsLlByb21pc2UgJiZcbiAgICAgICAgICBcInJlamVjdFwiIGluIGxvY2FsLlByb21pc2UgJiZcbiAgICAgICAgICBcImFsbFwiIGluIGxvY2FsLlByb21pc2UgJiZcbiAgICAgICAgICBcInJhY2VcIiBpbiBsb2NhbC5Qcm9taXNlICYmXG4gICAgICAgICAgLy8gT2xkZXIgdmVyc2lvbiBvZiB0aGUgc3BlYyBoYWQgYSByZXNvbHZlciBvYmplY3RcbiAgICAgICAgICAvLyBhcyB0aGUgYXJnIHJhdGhlciB0aGFuIGEgZnVuY3Rpb25cbiAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZTtcbiAgICAgICAgICAgIG5ldyBsb2NhbC5Qcm9taXNlKGZ1bmN0aW9uKHIpIHsgcmVzb2x2ZSA9IHI7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ocmVzb2x2ZSk7XG4gICAgICAgICAgfSgpKTtcblxuICAgICAgICBpZiAoIWVzNlByb21pc2VTdXBwb3J0KSB7XG4gICAgICAgICAgbG9jYWwuUHJvbWlzZSA9IFJTVlBQcm9taXNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9fZXhwb3J0c19fLnBvbHlmaWxsID0gcG9seWZpbGw7XG4gICAgfSk7XG4gIGRlZmluZShcInByb21pc2UvcHJvbWlzZVwiLFxuICAgIFtcIi4vY29uZmlnXCIsXCIuL3V0aWxzXCIsXCIuL2FsbFwiLFwiLi9yYWNlXCIsXCIuL3Jlc29sdmVcIixcIi4vcmVqZWN0XCIsXCIuL2FzYXBcIixcImV4cG9ydHNcIl0sXG4gICAgZnVuY3Rpb24oX19kZXBlbmRlbmN5MV9fLCBfX2RlcGVuZGVuY3kyX18sIF9fZGVwZW5kZW5jeTNfXywgX19kZXBlbmRlbmN5NF9fLCBfX2RlcGVuZGVuY3k1X18sIF9fZGVwZW5kZW5jeTZfXywgX19kZXBlbmRlbmN5N19fLCBfX2V4cG9ydHNfXykge1xuICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICB2YXIgY29uZmlnID0gX19kZXBlbmRlbmN5MV9fLmNvbmZpZztcbiAgICAgIHZhciBjb25maWd1cmUgPSBfX2RlcGVuZGVuY3kxX18uY29uZmlndXJlO1xuICAgICAgdmFyIG9iamVjdE9yRnVuY3Rpb24gPSBfX2RlcGVuZGVuY3kyX18ub2JqZWN0T3JGdW5jdGlvbjtcbiAgICAgIHZhciBpc0Z1bmN0aW9uID0gX19kZXBlbmRlbmN5Ml9fLmlzRnVuY3Rpb247XG4gICAgICB2YXIgbm93ID0gX19kZXBlbmRlbmN5Ml9fLm5vdztcbiAgICAgIHZhciBhbGwgPSBfX2RlcGVuZGVuY3kzX18uYWxsO1xuICAgICAgdmFyIHJhY2UgPSBfX2RlcGVuZGVuY3k0X18ucmFjZTtcbiAgICAgIHZhciBzdGF0aWNSZXNvbHZlID0gX19kZXBlbmRlbmN5NV9fLnJlc29sdmU7XG4gICAgICB2YXIgc3RhdGljUmVqZWN0ID0gX19kZXBlbmRlbmN5Nl9fLnJlamVjdDtcbiAgICAgIHZhciBhc2FwID0gX19kZXBlbmRlbmN5N19fLmFzYXA7XG5cbiAgICAgIHZhciBjb3VudGVyID0gMDtcblxuICAgICAgY29uZmlnLmFzeW5jID0gYXNhcDsgLy8gZGVmYXVsdCBhc3luYyBpcyBhc2FwO1xuXG4gICAgICBmdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgICAgIGlmICghaXNGdW5jdGlvbihyZXNvbHZlcikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgICAgICBpbnZva2VSZXNvbHZlcihyZXNvbHZlciwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludm9rZVJlc29sdmVyKHJlc29sdmVyLCBwcm9taXNlKSB7XG4gICAgICAgIGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKSB7XG4gICAgICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXNvbHZlcihyZXNvbHZlUHJvbWlzZSwgcmVqZWN0UHJvbWlzZSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIHJlamVjdFByb21pc2UoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICAgICAgICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgICAgICAgIHZhbHVlLCBlcnJvciwgc3VjY2VlZGVkLCBmYWlsZWQ7XG5cbiAgICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2soZGV0YWlsKTtcbiAgICAgICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhbmRsZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICAgICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChmYWlsZWQpIHtcbiAgICAgICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IEZVTEZJTExFRCkge1xuICAgICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IFJFSkVDVEVEKSB7XG4gICAgICAgICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgUEVORElORyAgID0gdm9pZCAwO1xuICAgICAgdmFyIFNFQUxFRCAgICA9IDA7XG4gICAgICB2YXIgRlVMRklMTEVEID0gMTtcbiAgICAgIHZhciBSRUpFQ1RFRCAgPSAyO1xuXG4gICAgICBmdW5jdGlvbiBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgICAgICAgdmFyIGxlbmd0aCA9IHN1YnNjcmliZXJzLmxlbmd0aDtcblxuICAgICAgICBzdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gICAgICAgIHN1YnNjcmliZXJzW2xlbmd0aCArIEZVTEZJTExFRF0gPSBvbkZ1bGZpbGxtZW50O1xuICAgICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBSRUpFQ1RFRF0gID0gb25SZWplY3Rpb247XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHB1Ymxpc2gocHJvbWlzZSwgc2V0dGxlZCkge1xuICAgICAgICB2YXIgY2hpbGQsIGNhbGxiYWNrLCBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzLCBkZXRhaWwgPSBwcm9taXNlLl9kZXRhaWw7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XG4gICAgICAgICAgY2FsbGJhY2sgPSBzdWJzY3JpYmVyc1tpICsgc2V0dGxlZF07XG5cbiAgICAgICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9taXNlLl9zdWJzY3JpYmVycyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIFByb21pc2UucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogUHJvbWlzZSxcblxuICAgICAgICBfc3RhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgX2RldGFpbDogdW5kZWZpbmVkLFxuICAgICAgICBfc3Vic2NyaWJlcnM6IHVuZGVmaW5lZCxcblxuICAgICAgICB0aGVuOiBmdW5jdGlvbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICAgICAgICAgIHZhciBwcm9taXNlID0gdGhpcztcblxuICAgICAgICAgIHZhciB0aGVuUHJvbWlzZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGZ1bmN0aW9uKCkge30pO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgY29uZmlnLmFzeW5jKGZ1bmN0aW9uIGludm9rZVByb21pc2VDYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2socHJvbWlzZS5fc3RhdGUsIHRoZW5Qcm9taXNlLCBjYWxsYmFja3NbcHJvbWlzZS5fc3RhdGUgLSAxXSwgcHJvbWlzZS5fZGV0YWlsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpYmUodGhpcywgdGhlblByb21pc2UsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhlblByb21pc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgUHJvbWlzZS5hbGwgPSBhbGw7XG4gICAgICBQcm9taXNlLnJhY2UgPSByYWNlO1xuICAgICAgUHJvbWlzZS5yZXNvbHZlID0gc3RhdGljUmVzb2x2ZTtcbiAgICAgIFByb21pc2UucmVqZWN0ID0gc3RhdGljUmVqZWN0O1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSkge1xuICAgICAgICB2YXIgdGhlbiA9IG51bGwsXG4gICAgICAgIHJlc29sdmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoZW4gPSB2YWx1ZS50aGVuO1xuXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGVuKSkge1xuICAgICAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHByb21pc2UsIHZhbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHJlamVjdChwcm9taXNlLCB2YWwpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaWYgKHJlc29sdmVkKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICAgICAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmICghaGFuZGxlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUpKSB7XG4gICAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICAgICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHsgcmV0dXJuOyB9XG4gICAgICAgIHByb21pc2UuX3N0YXRlID0gU0VBTEVEO1xuICAgICAgICBwcm9taXNlLl9kZXRhaWwgPSB2YWx1ZTtcblxuICAgICAgICBjb25maWcuYXN5bmMocHVibGlzaEZ1bGZpbGxtZW50LCBwcm9taXNlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICAgICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHsgcmV0dXJuOyB9XG4gICAgICAgIHByb21pc2UuX3N0YXRlID0gU0VBTEVEO1xuICAgICAgICBwcm9taXNlLl9kZXRhaWwgPSByZWFzb247XG5cbiAgICAgICAgY29uZmlnLmFzeW5jKHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwdWJsaXNoRnVsZmlsbG1lbnQocHJvbWlzZSkge1xuICAgICAgICBwdWJsaXNoKHByb21pc2UsIHByb21pc2UuX3N0YXRlID0gRlVMRklMTEVEKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gICAgICAgIHB1Ymxpc2gocHJvbWlzZSwgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRCk7XG4gICAgICB9XG5cbiAgICAgIF9fZXhwb3J0c19fLlByb21pc2UgPSBQcm9taXNlO1xuICAgIH0pO1xuICBkZWZpbmUoXCJwcm9taXNlL3JhY2VcIixcbiAgICBbXCIuL3V0aWxzXCIsXCJleHBvcnRzXCJdLFxuICAgIGZ1bmN0aW9uKF9fZGVwZW5kZW5jeTFfXywgX19leHBvcnRzX18pIHtcbiAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgLyogZ2xvYmFsIHRvU3RyaW5nICovXG4gICAgICB2YXIgaXNBcnJheSA9IF9fZGVwZW5kZW5jeTFfXy5pc0FycmF5O1xuXG4gICAgICAvKipcbiAgICAgICAgYFJTVlAucmFjZWAgYWxsb3dzIHlvdSB0byB3YXRjaCBhIHNlcmllcyBvZiBwcm9taXNlcyBhbmQgYWN0IGFzIHNvb24gYXMgdGhlXG4gICAgICAgIGZpcnN0IHByb21pc2UgZ2l2ZW4gdG8gdGhlIGBwcm9taXNlc2AgYXJndW1lbnQgZnVsZmlsbHMgb3IgcmVqZWN0cy5cblxuICAgICAgICBFeGFtcGxlOlxuXG4gICAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgICAgdmFyIHByb21pc2UxID0gbmV3IFJTVlAuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJlc29sdmUoXCJwcm9taXNlIDFcIik7XG4gICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHByb21pc2UyID0gbmV3IFJTVlAuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJlc29sdmUoXCJwcm9taXNlIDJcIik7XG4gICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgUlNWUC5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAgICAgLy8gcmVzdWx0ID09PSBcInByb21pc2UgMlwiIGJlY2F1c2UgaXQgd2FzIHJlc29sdmVkIGJlZm9yZSBwcm9taXNlMVxuICAgICAgICAgIC8vIHdhcyByZXNvbHZlZC5cbiAgICAgICAgfSk7XG4gICAgICAgIGBgYFxuXG4gICAgICAgIGBSU1ZQLnJhY2VgIGlzIGRldGVybWluaXN0aWMgaW4gdGhhdCBvbmx5IHRoZSBzdGF0ZSBvZiB0aGUgZmlyc3QgY29tcGxldGVkXG4gICAgICAgIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlIGBwcm9taXNlc2BcbiAgICAgICAgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IGNvbXBsZXRlZCBwcm9taXNlIGhhcyBiZWNvbWVcbiAgICAgICAgcmVqZWN0ZWQgYmVmb3JlIHRoZSBvdGhlciBwcm9taXNlcyBiZWNhbWUgZnVsZmlsbGVkLCB0aGUgcmV0dXJuZWQgcHJvbWlzZVxuICAgICAgICB3aWxsIGJlY29tZSByZWplY3RlZDpcblxuICAgICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICAgIHZhciBwcm9taXNlMSA9IG5ldyBSU1ZQLlByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXNvbHZlKFwicHJvbWlzZSAxXCIpO1xuICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBwcm9taXNlMiA9IG5ldyBSU1ZQLlByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwicHJvbWlzZSAyXCIpKTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9KTtcblxuICAgICAgICBSU1ZQLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgICAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVucyBiZWNhdXNlIHRoZXJlIGFyZSByZWplY3RlZCBwcm9taXNlcyFcbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gXCJwcm9taXNlMlwiIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAgICAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICAgICAgICB9KTtcbiAgICAgICAgYGBgXG5cbiAgICAgICAgQG1ldGhvZCByYWNlXG4gICAgICAgIEBmb3IgUlNWUFxuICAgICAgICBAcGFyYW0ge0FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlcyB0byBvYnNlcnZlXG4gICAgICAgIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBvcHRpb25hbCBzdHJpbmcgZm9yIGRlc2NyaWJpbmcgdGhlIHByb21pc2UgcmV0dXJuZWQuXG4gICAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgICAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgYmVjb21lcyBmdWxmaWxsZWQgd2l0aCB0aGUgdmFsdWUgdGhlIGZpcnN0XG4gICAgICAgIGNvbXBsZXRlZCBwcm9taXNlcyBpcyByZXNvbHZlZCB3aXRoIGlmIHRoZSBmaXJzdCBjb21wbGV0ZWQgcHJvbWlzZSB3YXNcbiAgICAgICAgZnVsZmlsbGVkLCBvciByZWplY3RlZCB3aXRoIHRoZSByZWFzb24gdGhhdCB0aGUgZmlyc3QgY29tcGxldGVkIHByb21pc2VcbiAgICAgICAgd2FzIHJlamVjdGVkIHdpdGguXG4gICAgICAqL1xuICAgICAgZnVuY3Rpb24gcmFjZShwcm9taXNlcykge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICB2YXIgUHJvbWlzZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KHByb21pc2VzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXSwgcHJvbWlzZTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlc1tpXTtcblxuICAgICAgICAgICAgaWYgKHByb21pc2UgJiYgdHlwZW9mIHByb21pc2UudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBwcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUocHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgX19leHBvcnRzX18ucmFjZSA9IHJhY2U7XG4gICAgfSk7XG4gIGRlZmluZShcInByb21pc2UvcmVqZWN0XCIsXG4gICAgW1wiZXhwb3J0c1wiXSxcbiAgICBmdW5jdGlvbihfX2V4cG9ydHNfXykge1xuICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAvKipcbiAgICAgICAgYFJTVlAucmVqZWN0YCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIHJlamVjdGVkIHdpdGggdGhlIHBhc3NlZFxuICAgICAgICBgcmVhc29uYC4gYFJTVlAucmVqZWN0YCBpcyBlc3NlbnRpYWxseSBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBSU1ZQLlByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG4gICAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG4gICAgICAgIH0pO1xuICAgICAgICBgYGBcblxuICAgICAgICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgICB2YXIgcHJvbWlzZSA9IFJTVlAucmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuXG4gICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG4gICAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG4gICAgICAgIH0pO1xuICAgICAgICBgYGBcblxuICAgICAgICBAbWV0aG9kIHJlamVjdFxuICAgICAgICBAZm9yIFJTVlBcbiAgICAgICAgQHBhcmFtIHtBbnl9IHJlYXNvbiB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aC5cbiAgICAgICAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgaWRlbnRpZnlpbmcgdGhlIHJldHVybmVkIHByb21pc2UuXG4gICAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgICAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgcmVqZWN0ZWQgd2l0aCB0aGUgZ2l2ZW5cbiAgICAgICAgYHJlYXNvbmAuXG4gICAgICAqL1xuICAgICAgZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICB2YXIgUHJvbWlzZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIF9fZXhwb3J0c19fLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgZGVmaW5lKFwicHJvbWlzZS9yZXNvbHZlXCIsXG4gICAgW1wiZXhwb3J0c1wiXSxcbiAgICBmdW5jdGlvbihfX2V4cG9ydHNfXykge1xuICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICBmdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSB0aGlzKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIFByb21pc2UgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBfX2V4cG9ydHNfXy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgZGVmaW5lKFwicHJvbWlzZS91dGlsc1wiLFxuICAgIFtcImV4cG9ydHNcIl0sXG4gICAgZnVuY3Rpb24oX19leHBvcnRzX18pIHtcbiAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHgpIHx8ICh0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiB4ICE9PSBudWxsKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0FycmF5KHgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgICAgfVxuXG4gICAgICAvLyBEYXRlLm5vdyBpcyBub3QgYXZhaWxhYmxlIGluIGJyb3dzZXJzIDwgSUU5XG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL25vdyNDb21wYXRpYmlsaXR5XG4gICAgICB2YXIgbm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcblxuXG4gICAgICBfX2V4cG9ydHNfXy5vYmplY3RPckZ1bmN0aW9uID0gb2JqZWN0T3JGdW5jdGlvbjtcbiAgICAgIF9fZXhwb3J0c19fLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgICAgX19leHBvcnRzX18uaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgICBfX2V4cG9ydHNfXy5ub3cgPSBub3c7XG4gICAgfSk7XG4gIHJlcXVpcmVNb2R1bGUoJ3Byb21pc2UvcG9seWZpbGwnKS5wb2x5ZmlsbCgpO1xuICB9KCkpO1xufVxuIiwicmVxdWlyZSgnbGVhZmxldCcpO1xucmVxdWlyZSgnaHRtbDVzaGl2Jyk7XG5cbi8vIERHIGluaGVyaXRhbmNlXG52YXIgb2xkREcgPSB3aW5kb3cuREc7XG52YXIgREcgPSBuZXcgKFxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIERnQXBpID0gZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgIERnQXBpQ29yZSA9IGZ1bmN0aW9uKCkge307XG5cbiAgICAgICAgRGdBcGlDb3JlLnByb3RvdHlwZSA9IEw7XG4gICAgICAgIERnQXBpLnByb3RvdHlwZSA9IG5ldyBEZ0FwaUNvcmUoKTtcblxuICAgICAgICByZXR1cm4gRGdBcGk7XG4gICAgfSkoKVxuKSgpO1xuXG5mb3IgKHZhciBwcm9wIGluIG9sZERHKSB7XG4gICAgaWYgKG9sZERHLmhhc093blByb3BlcnR5KHByb3ApICYmIHR5cGVvZiBER1twcm9wXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgREdbcHJvcF0gPSBvbGRER1twcm9wXTtcbiAgICB9XG59XG5cbndpbmRvdy5fX2RnQXBpX18gPSB3aW5kb3cuX19kZ0FwaV9fIHx8IHt9O1xuREcudmVyc2lvbiA9IHdpbmRvdy5fX2RnQXBpX18udmVyc2lvbjtcbkRHLkljb24uRGVmYXVsdC5pbWFnZVBhdGggID0gJy4uL2ltZy92ZW5kb3JzL2xlYWZsZXQnO1xuXG5ERy5NYXAuYWRkSW5pdEhvb2soKGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbml0ZWQgPSBmYWxzZTtcblxuICAgIC8vIEFuYWx5dGljcyBpbml0ZWQgb25jZVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFpbml0ZWQpIHtcbiAgICAgICAgICAgIC8qZXNsaW50LWRpc2FibGUgKi9cbiAgICAgICAgICAgIChmdW5jdGlvbihpLHMsbyxnLHIsYSxtKXtpWydHb29nbGVBbmFseXRpY3NPYmplY3QnXT1yO2lbcl09aVtyXXx8ZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIChpW3JdLnE9aVtyXS5xfHxbXSkucHVzaChhcmd1bWVudHMpfSxpW3JdLmw9MSpuZXcgRGF0ZSgpO2E9cy5jcmVhdGVFbGVtZW50KG8pLFxuICAgICAgICAgICAgbT1zLmdldEVsZW1lbnRzQnlUYWdOYW1lKG8pWzBdO2EuYXN5bmM9MTthLnNyYz1nO20ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSxtKVxuICAgICAgICAgICAgfSkod2luZG93LGRvY3VtZW50LCdzY3JpcHQnLERHLmNvbmZpZy5nb29nbGVBbmFseXRpY3MsJ2dhJyk7XG4gICAgICAgICAgICAvKmVzbGludC1lbmFibGUgKi9cblxuICAgICAgICAgICAgaW5pdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qZXNsaW50LWRpc2FibGUgKi9cbiAgICAgICAgZ2EoJ2NyZWF0ZScsIERHLmNvbmZpZy5nYUNvZGUsIHtcbiAgICAgICAgICAgIHN0b3JhZ2U6ICdub25lJywgLy8gZG9uJ3Qgc3RvcmUgYW5kIHVzZSBjb29raWVzIHRoYW5rcyBHRFBSXG4gICAgICAgICAgICBuYW1lOiBERy5jb25maWcuZ2FOYW1lLFxuICAgICAgICAgICAgc2FtcGxlUmF0ZTogNTBcbiAgICAgICAgfSk7XG4gICAgICAgIGdhKERHLmNvbmZpZy5nYU5hbWUgKyAnLnNldCcsICdhbm9ueW1pemVJcCcsIHRydWUpO1xuICAgICAgICBnYShERy5jb25maWcuZ2FOYW1lICsgJy5zZW5kJywgJ3BhZ2V2aWV3Jyk7XG4gICAgICAgIC8qZXNsaW50LWVuYWJsZSAqL1xuXG4gICAgICAgIHZhciBuZXdJbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgbmV3SW1nLnNyYyA9IERHLmNvbmZpZy5wcm90b2NvbCArIERHLmNvbmZpZy5hbmFseXRpY3MgKyAnPycgK1xuICAgICAgICAgICAgJ3NyPScgKyB3aW5kb3cuc2NyZWVuLndpZHRoICsgJ3gnICsgd2luZG93LnNjcmVlbi5oZWlnaHQgKyAnJicgK1xuICAgICAgICAgICAgJ3Y9JyArIERHLnZlcnNpb247XG4gICAgfTtcbn0pKCkpO1xuXG4vLyBJbXByb3ZlIElIYW5kbGVyXG5ERy5NYXAuaW5jbHVkZSh7XG4gICAgYWRkSGFuZGxlcjogZnVuY3Rpb24obmFtZSwgSGFuZGxlckNsYXNzKSB7XG4gICAgICAgIGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNbbmFtZV0sXG4gICAgICAgICAgICBwYXJhbSA9IChvcHRpb25zID09PSBPYmplY3Qob3B0aW9ucykpID8gb3B0aW9ucyA6IG51bGwsXG4gICAgICAgICAgICBoYW5kbGVyID0gdGhpc1tuYW1lXSA9IG5ldyBIYW5kbGVyQ2xhc3ModGhpcywgcGFyYW0pO1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuZW5hYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcblxuLy8gQXBwbHkgY2xhc3MgdG8gbWFwIGNvbnRhaW5lciBmb3IgZGV0ZWN0IHdoZW4gd2UgZG9udCBuZWVkIGhvdmVyIGVmZmVjdHNcbkRHLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbigpIHtcbiAgICBpZiAoIURHLkJyb3dzZXIudG91Y2hFbmFibGVkKSB7XG4gICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbm8tdG91Y2gnKTtcbiAgICB9XG59KTtcblxud2luZG93LkRHID0gREc7XG5tb2R1bGUuZXhwb3J0cyA9IERHO1xuIiwidmFyIGhhbmRsZXJzID0gd2luZG93Ll9fZGdBcGlfXy5jYWxsYmFja3MgfHwgW10sXG4gICAgY2hhaW4gPSBQcm9taXNlLnJlc29sdmUoKTtcblxuaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVycykge1xuICAgIGNoYWluID0gY2hhaW4udGhlbihoYW5kbGVyc1swXSwgaGFuZGxlcnNbMV0pO1xufSk7XG5cbkRHLnRoZW4gPSBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZXR1cm4gY2hhaW4udGhlbihyZXNvbHZlLCByZWplY3QpO1xufTtcblxuLy8gSUU4IHRocm93IGVycm9yIGlmIGBjaGFpbi5jYXRjaGBcbi8qIGVzbGludC1kaXNhYmxlIGRvdC1ub3RhdGlvbiwgbm8tY29uc29sZSAqL1xuY2hhaW5bJ2NhdGNoJ10oZnVuY3Rpb24oZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xufSk7XG4vKiBlc2xpbnQtZW5hYmxlIGRvdC1ub3RhdGlvbiwgbm8tY29uc29sZSAqL1xuIiwiREcucGx1Z2luID0gZnVuY3Rpb24ocGx1Z2lucykge1xuICAgIHZhciBjb3VudCxcbiAgICAgICAganNSZWcgPSBuZXcgUmVnRXhwKC8uanMkL2kpLFxuICAgICAgICBjc3NSZWcgPSBuZXcgUmVnRXhwKC8uY3NzJC9pKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTG9hZGluZygpIHtcbiAgICAgICAgICAgIGNvdW50LS07XG5cbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFwcGVuZEpTKGxpbmspIHtcbiAgICAgICAgICAgIHZhciBqcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAganMuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvamF2YXNjcmlwdCcpO1xuICAgICAgICAgICAganMuc2V0QXR0cmlidXRlKCdzcmMnLCBsaW5rKTtcbiAgICAgICAgICAgIGpzLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNoZWNrTG9hZGluZygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGpzLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjaGVja0xvYWRpbmcoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBsb2FkL2Vycm9yIGZvciBJRVxuICAgICAgICAgICAganMub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpzLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScgfHwganMucmVhZHlTdGF0ZSA9PT0gJ2xvYWRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tMb2FkaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChqcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhcHBlbmRDU1MobGluaykge1xuICAgICAgICAgICAgdmFyIGNzcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgICAgICAgICAgIGNzcy5zZXRBdHRyaWJ1dGUoJ3JlbCcsICdzdHlsZXNoZWV0Jyk7XG4gICAgICAgICAgICBjc3Muc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgICAgICAgICBjc3Muc2V0QXR0cmlidXRlKCdocmVmJywgbGluayk7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGNzcyk7XG5cbiAgICAgICAgICAgIGNoZWNrTG9hZGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNKcyh1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiBqc1JlZy50ZXN0KHVybCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc0Nzcyh1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiBjc3NSZWcudGVzdCh1cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYXBwZW5kQXNzZXQoYXNzZXQpIHtcbiAgICAgICAgICAgIGlmIChpc0pzKGFzc2V0KSkge1xuICAgICAgICAgICAgICAgIGFwcGVuZEpTKGFzc2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNDc3MoYXNzZXQpKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kQ1NTKGFzc2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChERy5VdGlsLmlzQXJyYXkocGx1Z2lucykpIHtcbiAgICAgICAgICAgIGNvdW50ID0gcGx1Z2lucy5sZW5ndGg7XG4gICAgICAgICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kQXNzZXQocGx1Z2luKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwbHVnaW5zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY291bnQgPSAxO1xuICAgICAgICAgICAgYXBwZW5kQXNzZXQocGx1Z2lucyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG4iLCJERy5hamF4ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHdpbiA9IHdpbmRvdyxcbiAgICAgICAgZG9jID0gZG9jdW1lbnQsXG5cbiAgICAgICAgcnVybCA9IC9eKFtcXHcuKy1dKzopPyg/OlxcL1xcLyhbXlxcLz8jOl0qKSg/OjooXFxkKyl8KXwpLyxcbiAgICAgICAgdHdvSHVuZG8gPSAvXjIwXFxkJC8sXG5cbiAgICAgICAgLy8gRG9jdW1lbnQgbG9jYXRpb25cbiAgICAgICAgYWpheExvY1BhcnRzLFxuICAgICAgICBhamF4TG9jYXRpb24sXG5cbiAgICAgICAgYnlUYWcgPSAnZ2V0RWxlbWVudHNCeVRhZ05hbWUnLFxuICAgICAgICByZWFkeVN0YXRlID0gJ3JlYWR5U3RhdGUnLFxuICAgICAgICBjb250ZW50VHlwZSA9ICdDb250ZW50LVR5cGUnLFxuICAgICAgICByZXF1ZXN0ZWRXaXRoID0gJ1gtUmVxdWVzdGVkLVdpdGgnLFxuICAgICAgICBoZWFkID0gZG9jW2J5VGFnXSgnaGVhZCcpWzBdLFxuICAgICAgICB1bmlxaWQgPSAwLFxuICAgICAgICBjYWxsYmFja1ByZWZpeCA9ICdsX2RnX2FqYXhfY2FsbGJhY2tfJyArICgrbmV3IERhdGUoKSksXG4gICAgICAgIGxhc3RWYWx1ZSwgLy8gZGF0YSBzdG9yZWQgYnkgdGhlIG1vc3QgcmVjZW50IEpTT05QIGNhbGxiYWNrXG4gICAgICAgIHhtbEh0dHBSZXF1ZXN0ID0gJ1hNTEh0dHBSZXF1ZXN0JyxcbiAgICAgICAgeERvbWFpblJlcXVlc3QgPSAnWERvbWFpblJlcXVlc3QnLCAvLyBJRSA4IGFuZCA5IG9ubHlcbiAgICAgICAgbm9vcCA9IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIGRlZmF1bHRIZWFkZXJzID0ge1xuICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgcmVxdWVzdGVkV2l0aDogeG1sSHR0cFJlcXVlc3QsXG4gICAgICAgICAgICBhY2NlcHQ6IHtcbiAgICAgICAgICAgICAgICAnKic6ICAndGV4dC9qYXZhc2NyaXB0LCB0ZXh0L2h0bWwsIGFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWwsICovKicsXG4gICAgICAgICAgICAgICAgeG1sOiAgJ2FwcGxpY2F0aW9uL3htbCwgdGV4dC94bWwnLFxuICAgICAgICAgICAgICAgIGh0bWw6ICd0ZXh0L2h0bWwnLFxuICAgICAgICAgICAgICAgIHRleHQ6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgICAgICAgICBqc29uOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0JyxcbiAgICAgICAgICAgICAgICBqczogICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCwgdGV4dC9qYXZhc2NyaXB0J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKmdsb2JhbCBYRG9tYWluUmVxdWVzdDpmYWxzZSAqL1xuICAgICAgICB4aHIgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICAvLyBpcyBpdCB4LWRvbWFpblxuICAgICAgICAgICAgaWYgKG8uY3Jvc3NEb21haW4gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgeGhyID0gd2luW3htbEh0dHBSZXF1ZXN0XSA/IG5ldyBYTUxIdHRwUmVxdWVzdCgpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoeGhyICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geGhyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2luW3hEb21haW5SZXF1ZXN0XSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2xvYmFsU2V0dXBPcHRpb25zID0ge1xuICAgICAgICAgICAgZGF0YUZpbHRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgLy8gSUUgbWF5IHRocm93IGFuIGV4Y2VwdGlvbiB3aGVuIGFjY2Vzc2luZ1xuICAgIC8vIGEgZmllbGQgZnJvbSB3aW5kb3cubG9jYXRpb24gaWYgZG9jdW1lbnQuZG9tYWluIGhhcyBiZWVuIHNldFxuICAgIHRyeSB7XG4gICAgICAgIGFqYXhMb2NhdGlvbiA9IGxvY2F0aW9uLmhyZWY7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBVc2UgdGhlIGhyZWYgYXR0cmlidXRlIG9mIGFuIEEgZWxlbWVudFxuICAgICAgICAvLyBzaW5jZSBJRSB3aWxsIG1vZGlmeSBpdCBnaXZlbiBkb2N1bWVudC5sb2NhdGlvblxuICAgICAgICBhamF4TG9jYXRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgIGFqYXhMb2NhdGlvbi5ocmVmID0gJyc7XG4gICAgICAgIGFqYXhMb2NhdGlvbiA9IGFqYXhMb2NhdGlvbi5ocmVmO1xuICAgIH1cblxuICAgIC8vIFNlZ21lbnQgbG9jYXRpb24gaW50byBwYXJ0c1xuICAgIGFqYXhMb2NQYXJ0cyA9IHJ1cmwuZXhlYyhhamF4TG9jYXRpb24udG9Mb3dlckNhc2UoKSkgfHwgW107XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVSZWFkeVN0YXRlKHIsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHVzZSBfYWJvcnRlZCB0byBtaXRpZ2F0ZSBhZ2FpbnN0IElFIGVyciBjMDBjMDIzZlxuICAgICAgICAgICAgLy8gKGNhbid0IHJlYWQgcHJvcHMgb24gYWJvcnRlZCByZXF1ZXN0IG9iamVjdHMpXG4gICAgICAgICAgICBpZiAoci5fYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihyLnJlcXVlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIucmVxdWVzdCAmJiByLnJlcXVlc3RbcmVhZHlTdGF0ZV0gPT09IDQpIHtcbiAgICAgICAgICAgICAgICByLnJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gbm9vcDtcbiAgICAgICAgICAgICAgICBpZiAodHdvSHVuZG8udGVzdChyLnJlcXVlc3Quc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKHIucmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Ioci5yZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SGVhZGVycyhodHRwLCBvKSB7XG4gICAgICAgIHZhciBoZWFkZXJzID0gby5oZWFkZXJzIHx8IHt9LFxuICAgICAgICAgICAgaDtcblxuICAgICAgICBoZWFkZXJzLkFjY2VwdCA9IGhlYWRlcnMuQWNjZXB0IHx8IGRlZmF1bHRIZWFkZXJzLmFjY2VwdFtvLmRhdGFUeXBlXSB8fCBkZWZhdWx0SGVhZGVycy5hY2NlcHRbJyonXTtcblxuICAgICAgICAvLyBicmVha3MgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzIHdpdGggbGVnYWN5IGJyb3dzZXJzXG4gICAgICAgIGlmICghby5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1tyZXF1ZXN0ZWRXaXRoXSkge1xuICAgICAgICAgICAgaGVhZGVyc1tyZXF1ZXN0ZWRXaXRoXSA9IGRlZmF1bHRIZWFkZXJzLnJlcXVlc3RlZFdpdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoZWFkZXJzW2NvbnRlbnRUeXBlXSkge1xuICAgICAgICAgICAgaGVhZGVyc1tjb250ZW50VHlwZV0gPSBvLmNvbnRlbnRUeXBlIHx8IGRlZmF1bHRIZWFkZXJzLmNvbnRlbnRUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaCBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShoKSAmJiAnc2V0UmVxdWVzdEhlYWRlcicgaW4gaHR0cCkge1xuICAgICAgICAgICAgICAgIGh0dHAuc2V0UmVxdWVzdEhlYWRlcihoLCBoZWFkZXJzW2hdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldENyZWRlbnRpYWxzKGh0dHAsIG8pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvLndpdGhDcmVkZW50aWFscyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGh0dHAud2l0aENyZWRlbnRpYWxzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaHR0cC53aXRoQ3JlZGVudGlhbHMgPSAhIW8ud2l0aENyZWRlbnRpYWxzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhbENhbGxiYWNrKGRhdGEpIHtcbiAgICAgICAgbGFzdFZhbHVlID0gZGF0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cmxhcHBlbmQodXJsLCBzKSB7XG4gICAgICAgIHJldHVybiB1cmwgKyAoL1xcPy8udGVzdCh1cmwpID8gJyYnIDogJz8nKSArIHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlSnNvbnAobywgZm4sIGVyciwgdXJsKSB7XG4gICAgICAgIHZhciByZXFJZCA9IHVuaXFpZCsrLFxuICAgICAgICAgICAgY2JrZXkgPSBvLmpzb25wQ2FsbGJhY2sgfHwgJ2NhbGxiYWNrJywgLy8gdGhlICdjYWxsYmFjaycga2V5XG4gICAgICAgICAgICBjYnZhbCA9IG8uanNvbnBDYWxsYmFja05hbWUgfHwgY2FsbGJhY2tQcmVmaXgsXG4gICAgICAgICAgICBjYnJlZyA9IG5ldyBSZWdFeHAoJygoXnxcXFxcP3wmKScgKyBjYmtleSArICcpPShbXiZdKyknKSxcbiAgICAgICAgICAgIG1hdGNoID0gdXJsLm1hdGNoKGNicmVnKSxcbiAgICAgICAgICAgIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSxcbiAgICAgICAgICAgIGxvYWRlZCA9IDAsXG4gICAgICAgICAgICBpc0lFMTAgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUgMTAuMCcpICE9PSAtMTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaFszXSA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoY2JyZWcsICckMT0nICsgY2J2YWwpOyAvLyB3aWxkY2FyZCBjYWxsYmFjayBmdW5jIG5hbWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2J2YWwgPSBtYXRjaFszXTsgLy8gcHJvdmlkZWQgY2FsbGJhY2sgZnVuYyBuYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmwgPSB1cmxhcHBlbmQodXJsLCBjYmtleSArICc9JyArIGNidmFsKTsgLy8gbm8gY2FsbGJhY2sgZGV0YWlscywgYWRkICdlbVxuICAgICAgICB9XG5cbiAgICAgICAgd2luW2NidmFsXSA9IGdlbmVyYWxDYWxsYmFjaztcblxuICAgICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICBzY3JpcHQuc3JjID0gdXJsO1xuICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgIT09ICd1bmRlZmluZWQnICYmICFpc0lFMTApIHtcbiAgICAgICAgICAgIC8vIG5lZWQgdGhpcyBmb3IgSUUgZHVlIHRvIG91dC1vZi1vcmRlciBvbnJlYWR5c3RhdGVjaGFuZ2UoKSwgYmluZGluZyBzY3JpcHRcbiAgICAgICAgICAgIC8vIGV4ZWN1dGlvbiB0byBhbiBldmVudCBsaXN0ZW5lciBnaXZlcyB1cyBjb250cm9sIG92ZXIgd2hlbiB0aGUgc2NyaXB0XG4gICAgICAgICAgICAvLyBpcyBleGVjdXRlZC4gU2VlIGh0dHA6Ly9qYXVib3VyZy5uZXQvMjAxMC8wNy9sb2FkaW5nLXNjcmlwdC1hcy1vbmNsaWNrLWhhbmRsZXItb2YuaHRtbFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaGFjayBpcyB1c2VkIGluIElFMTAganNvbnAgY2FsbGJhY2sgYXJlIG5ldmVyIGNhbGxlZFxuICAgICAgICAgICAgc2NyaXB0LmV2ZW50ID0gJ29uY2xpY2snO1xuICAgICAgICAgICAgc2NyaXB0Lmh0bWxGb3IgPSBzY3JpcHQuaWQgPSAnX3JlcXVlc3RfJyArIHJlcUlkO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgZXJyKHt9LCAnUmVxdWVzdCB1bmtub3duIGVycm9yJywge30pO1xuICAgICAgICAgICAgbGFzdFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgbG9hZGVkID0gMTtcbiAgICAgICAgfTtcbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICgoc2NyaXB0W3JlYWR5U3RhdGVdICYmIHNjcmlwdFtyZWFkeVN0YXRlXSAhPT0gJ2NvbXBsZXRlJyAmJiBzY3JpcHRbcmVhZHlTdGF0ZV0gIT09ICdsb2FkZWQnKSB8fCBsb2FkZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY3JpcHQub25lcnJvciA9IHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChzY3JpcHQub25jbGljaykge1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbmNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYWxsIHRoZSB1c2VyIGNhbGxiYWNrIHdpdGggdGhlIGxhc3QgdmFsdWUgc3RvcmVkIGFuZCBjbGVhbiB1cCB2YWx1ZXMgYW5kIHNjcmlwdHMuXG4gICAgICAgICAgICBmbihsYXN0VmFsdWUpO1xuICAgICAgICAgICAgbGFzdFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgbG9hZGVkID0gMTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBZGQgdGhlIHNjcmlwdCB0byB0aGUgRE9NIGhlYWRcbiAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXG4gICAgICAgIC8vIEVuYWJsZSBKU09OUCB0aW1lb3V0XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZXJyKHt9LCAnUmVxdWVzdCBpcyBhYm9ydGVkOiB0aW1lb3V0Jywge30pO1xuICAgICAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgbG9hZGVkID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRSZXF1ZXN0KGZuLCBlcnIpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBtZXRob2QgPSAoby50eXBlIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgdXJsID0gdHlwZW9mIG8gPT09ICdzdHJpbmcnID8gbyA6IG8udXJsLFxuICAgICAgICAgICAgLy8gY29udmVydCBub24tc3RyaW5nIG9iamVjdHMgdG8gcXVlcnktc3RyaW5nIGZvcm0gdW5sZXNzIG8ucHJvY2Vzc0RhdGEgaXMgZmFsc2VcbiAgICAgICAgICAgIGRhdGEgPSAoby5wcm9jZXNzRGF0YSAhPT0gZmFsc2UgJiYgby5kYXRhICYmIHR5cGVvZiBvLmRhdGEgIT09ICdzdHJpbmcnKSA/IEFqYXgudG9RdWVyeVN0cmluZyhvLmRhdGEpIDogKG8uZGF0YSB8fCBudWxsKSxcbiAgICAgICAgICAgIGh0dHAsXG4gICAgICAgICAgICBzZW5kV2FpdCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGlmIHdlJ3JlIHdvcmtpbmcgb24gYSBHRVQgcmVxdWVzdCBhbmQgd2UgaGF2ZSBkYXRhIHRoZW4gd2Ugc2hvdWxkIGFwcGVuZFxuICAgICAgICAvLyBxdWVyeSBzdHJpbmcgdG8gZW5kIG9mIFVSTCBhbmQgbm90IHBvc3QgZGF0YVxuICAgICAgICBpZiAoKG8udHlwZSA9PT0gJ2pzb25wJyB8fCBtZXRob2QgPT09ICdHRVQnKSAmJiBkYXRhKSB7XG4gICAgICAgICAgICB1cmwgPSB1cmxhcHBlbmQodXJsLCBkYXRhKTtcbiAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG8udHlwZSA9PT0gJ2pzb25wJykge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUpzb25wKG8sIGZuLCBlcnIsIHVybCk7XG4gICAgICAgIH1cblxuICAgICAgICBodHRwID0geGhyKG8pO1xuICAgICAgICBodHRwLm9wZW4obWV0aG9kLCB1cmwsIG8uYXN5bmMgIT09IGZhbHNlKTtcblxuICAgICAgICBzZXRIZWFkZXJzKGh0dHAsIG8pO1xuICAgICAgICBzZXRDcmVkZW50aWFscyhodHRwLCBvKTtcblxuICAgICAgICBpZiAod2luW3hEb21haW5SZXF1ZXN0XSAmJiBodHRwIGluc3RhbmNlb2Ygd2luW3hEb21haW5SZXF1ZXN0XSkge1xuICAgICAgICAgICAgaHR0cC5vbmxvYWQgPSBmbjtcbiAgICAgICAgICAgIGh0dHAub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgICAgICBodHRwLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgICAgICBodHRwLm9uZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICBzZW5kV2FpdCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZVJlYWR5U3RhdGUodGhpcywgZm4sIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbmRXYWl0KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGh0dHAuc2VuZChkYXRhKTtcbiAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBodHRwLnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh0dHA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRQYXJhbXMocHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQpIHtcbiAgICAgICAgdmFyIG5hbWUsIGksIHYsXG4gICAgICAgICAgICByYnJhY2tldCA9IC9cXFtcXF0kLztcblxuICAgICAgICBpZiAoREcuVXRpbC5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgLy8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBvYmogJiYgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHYgPSBvYmpbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QocHJlZml4KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG4gICAgICAgICAgICAgICAgICAgIGFkZChwcmVmaXgsIHYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCArICdbJyArICh0eXBlb2YgdiA9PT0gJ29iamVjdCcgPyBpIDogJycpICsgJ10nLCB2LCB0cmFkaXRpb25hbCwgYWRkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob2JqICYmIG9iai50b1N0cmluZygpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgICAgLy8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuICAgICAgICAgICAgZm9yIChuYW1lIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRQYXJhbXMocHJlZml4ICsgJ1snICsgbmFtZSArICddJywgb2JqW25hbWVdLCB0cmFkaXRpb25hbCwgYWRkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG4gICAgICAgICAgICBhZGQocHJlZml4LCBvYmopO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VHlwZSh1cmwpIHtcbiAgICAgICAgdmFyIG0gPSB1cmwubWF0Y2goL1xcLihqc29ufGpzb25wfGh0bWx8eG1sKShcXD98JCkvKTtcbiAgICAgICAgcmV0dXJuIG0gPyBtWzFdIDogJ2pzJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0Nyb3NzRG9tYWluKHVybCkge1xuICAgICAgICB2YXIgcGFydHMgPSBydXJsLmV4ZWModXJsLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICByZXR1cm4gISEocGFydHMgJiZcbiAgICAgICAgICAgICAgICAocGFydHNbMV0gIT09IGFqYXhMb2NQYXJ0c1sxXSB8fCBwYXJ0c1syXSAhPT0gYWpheExvY1BhcnRzWzJdIHx8XG4gICAgICAgICAgICAgICAgICAgIChwYXJ0c1szXSB8fCAocGFydHNbMV0gPT09ICdodHRwOicgPyAnODAnIDogJzQ0MycpKSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIChhamF4TG9jUGFydHNbM10gfHwgKGFqYXhMb2NQYXJ0c1sxXSA9PT0gJ2h0dHA6JyA/ICc4MCcgOiAnNDQzJykpKVxuICAgICAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb1JlcXVlc3Qobykge1xuXG4gICAgICAgIGlmICghKCdjcm9zc0RvbWFpbicgaW4gbykpIHtcbiAgICAgICAgICAgIG8uY3Jvc3NEb21haW4gPSBpc0Nyb3NzRG9tYWluKG8udXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxmID0ge307XG4gICAgICAgIHNlbGYucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgc2VsZi5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX2Fib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlamVjdCgnYWJvcnRlZCcpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc2VsZi51cmwgPSBvLnVybDtcbiAgICAgICAgICAgIHNlbGYudGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLm9wdGlvbnMgPSBvO1xuXG4gICAgICAgICAgICBzZWxmLl9hYm9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxmLl9lcnJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzID0ge307XG5cbiAgICAgICAgICAgIHZhciB0eXBlID0gby50eXBlID09PSAnanNvbnAnID8gby50eXBlIDogKG8uZGF0YVR5cGUgfHwgc2V0VHlwZShzZWxmLnVybCkpO1xuXG4gICAgICAgICAgICBpZiAoby50aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH0sIG8udGltZW91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlKHJlc3ApIHtcbiAgICAgICAgICAgICAgICBpZiAoby50aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChzZWxmLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9lcnJlZCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QocmVzcCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN1Y2Nlc3MocmVzcCkge1xuICAgICAgICAgICAgICAgIHJlc3AgPSAodHlwZSAhPT0gJ2pzb25wJykgPyBzZWxmLnJlcXVlc3QgOiByZXNwO1xuICAgICAgICAgICAgICAgIC8vIHVzZSBnbG9iYWwgZGF0YSBmaWx0ZXIgb24gcmVzcG9uc2UgdGV4dFxuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJlZFJlc3BvbnNlID0gZ2xvYmFsU2V0dXBPcHRpb25zLmRhdGFGaWx0ZXIocmVzcC5yZXNwb25zZVRleHQsIHR5cGUpLFxuICAgICAgICAgICAgICAgICAgICByID0gZmlsdGVyZWRSZXNwb25zZTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3AucmVzcG9uc2VUZXh0ID0gcjtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbid0IGFzc2lnbiB0aGlzIGluIElFPD04LCBqdXN0IGlnbm9yZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1ldmFsICovXG4gICAgICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwID0gd2luLkpTT04ucGFyc2Uocik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihyZXNwLCAnQ291bGQgbm90IHBhcnNlIEpTT04gaW4gcmVzcG9uc2UnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2pzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwID0gZXZhbCgnKCcgKyByICsgJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AgPSByO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneG1sJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwID0gcmVzcC5yZXNwb25zZVhNTCAmJiByZXNwLnJlc3BvbnNlWE1MLnBhcnNlRXJyb3IgJiYgcmVzcC5yZXNwb25zZVhNTC5wYXJzZUVycm9yLmVycm9yQ29kZSAmJiByZXNwLnJlc3BvbnNlWE1MLnBhcnNlRXJyb3IucmVhc29uID8gbnVsbCA6IHJlc3AucmVzcG9uc2VYTUw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1ldmFsICovXG4gICAgICAgICAgICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLnJlc3AgPSByZXNwO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlKHJlc3ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBlcnJvcihyZXNwLCBtc2csIHQpIHtcbiAgICAgICAgICAgICAgICByZXNwID0gc2VsZi5yZXF1ZXN0O1xuICAgICAgICAgICAgICAgIHNlbGYuX3Jlc3BvbnNlQXJncy5yZXNwID0gcmVzcDtcbiAgICAgICAgICAgICAgICBzZWxmLl9yZXNwb25zZUFyZ3MubXNnID0gbXNnO1xuICAgICAgICAgICAgICAgIHNlbGYuX3Jlc3BvbnNlQXJncy50ID0gdDtcbiAgICAgICAgICAgICAgICBzZWxmLl9lcnJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29tcGxldGUocmVzcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYucmVxdWVzdCA9IGdldFJlcXVlc3QuY2FsbChzZWxmLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEFqYXgodXJsLCBvcHRpb25zKSB7XG5cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh1cmwpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHVybDtcbiAgICAgICAgICAgIHVybCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy51cmwgPSB1cmwgfHwgb3B0aW9ucy51cmw7XG5cbiAgICAgICAgdmFyIHJlcXVlc3RQcm9taXNlID0gZG9SZXF1ZXN0KG9wdGlvbnMpLFxuICAgICAgICAgICAgcmVzdWx0UHJvbWlzZSA9IHJlcXVlc3RQcm9taXNlLnByb21pc2U7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc3VjY2VzcyB8fCBvcHRpb25zLmVycm9yIHx8IG9wdGlvbnMuY29tcGxldGUpIHtcbiAgICAgICAgICAgIHJlc3VsdFByb21pc2UudGhlbihvcHRpb25zLnN1Y2Nlc3MsIG9wdGlvbnMuZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0UHJvbWlzZS5hYm9ydCA9IHJlcXVlc3RQcm9taXNlLmFib3J0O1xuXG4gICAgICAgIHJldHVybiByZXN1bHRQcm9taXNlO1xuICAgIH1cblxuICAgIEFqYXguc2V0dXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBmb3IgKHZhciBrIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsU2V0dXBPcHRpb25zW2tdID0gb3B0aW9uc1trXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBBamF4LnRvUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihvLCB0cmFkKSB7XG4gICAgICAgIHZhciBwcmVmaXgsIGksXG4gICAgICAgICAgICB0cmFkaXRpb25hbCA9IHRyYWQgfHwgZmFsc2UsXG4gICAgICAgICAgICBzID0gW10sXG4gICAgICAgICAgICBlbmMgPSBlbmNvZGVVUklDb21wb25lbnQsXG4gICAgICAgICAgICBhZGQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCByZXR1cm4gaXRzIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIHx8ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNbcy5sZW5ndGhdID0gZW5jKGtleSkgKyAnPScgKyBlbmModmFsdWUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuICAgICAgICBpZiAoREcuVXRpbC5pc0FycmF5KG8pKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBvICYmIGkgPCBvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYWRkKG9baV0ubmFtZSwgb1tpXS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuICAgICAgICAgICAgLy8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG4gICAgICAgICAgICBmb3IgKHByZWZpeCBpbiBvKSB7XG4gICAgICAgICAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkocHJlZml4KSkge1xuICAgICAgICAgICAgICAgICAgICBidWlsZFBhcmFtcyhwcmVmaXgsIG9bcHJlZml4XSwgdHJhZGl0aW9uYWwsIGFkZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3BhY2VzIHNob3VsZCBiZSArIGFjY29yZGluZyB0byBzcGVjXG4gICAgICAgIHJldHVybiBzLmpvaW4oJyYnKS5yZXBsYWNlKC8lMjAvZywgJysnKTtcbiAgICB9O1xuXG4gICAgdmFyIHRlc3R4aHIgPSB3aW5beG1sSHR0cFJlcXVlc3RdID8gbmV3IFhNTEh0dHBSZXF1ZXN0KCkgOiBudWxsO1xuXG4gICAgQWpheC5jb3JzU3VwcG9ydCA9ICEoISh0ZXN0eGhyICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIHRlc3R4aHIpICYmICF3aW5beERvbWFpblJlcXVlc3RdKSAmJlxuICAgICAgICAvLyBjb3JzIG5vdCBhdmFpbGFibGUgaW4gSUUgYW5kIHdpdGggY3lyaWxsaWMgZG9tYWluXG4gICAgICAgICEoREcuQnJvd3Nlci5pZSAmJiBkb2N1bWVudC5sb2NhdGlvbi5ob3N0LnRvTG93ZXJDYXNlKCkuc2VhcmNoKC9b0LAt0Y9dLykgIT0gLTEpO1xuXG4gICAgcmV0dXJuIEFqYXg7XG59KSgpO1xuIiwiREcuV2t0ID0ge307XG5cbkRHLldrdC50b0dlb0pTT04gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmIChERy5VdGlsLmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IGRhdGFbMF07XG4gICAgfVxuICAgIHZhciBwYXJ0cyA9IGRhdGEuc3BsaXQoJzsnKTtcbiAgICBkYXRhID0gcGFydHMucG9wKCk7XG5cbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIHNyaWQgPSAocGFydHMuc2hpZnQoKSB8fCAnJykuc3BsaXQoJz0nKS5wb3AoKTtcblxuICAgIGZ1bmN0aW9uICQocmUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZGF0YS5zdWJzdHJpbmcoaSkubWF0Y2gocmUpO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JzKG9iaikge1xuICAgICAgICBpZiAob2JqICYmIHNyaWQubWF0Y2goL1xcZCsvKSkge1xuICAgICAgICAgICAgb2JqLmNycyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbmFtZScsXG4gICAgICAgICAgICAgICAgJ3Byb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd1cm46b2djOmRlZjpjcnM6RVBTRzo6JyArIHNyaWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aGl0ZSgpIHsgJCgvXlxccyovKTsgfVxuXG4gICAgZnVuY3Rpb24gbXVsdGljb29yZHMoKSB7XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIHZhciBkZXB0aCA9IDAsIHJpbmdzID0gW10sIHN0YWNrID0gW3JpbmdzXSxcbiAgICAgICAgICAgIHBvaW50ZXIgPSByaW5ncywgZWxlbTtcbiAgICAgICAgd2hpbGUgKGVsZW0gPVxuICAgICAgICAgICAgJCgvXihcXCgpLykgfHxcbiAgICAgICAgICAgICQoL14oXFwpKS8pIHx8XG4gICAgICAgICAgICAkKC9eKFxcLCkvKSB8fFxuICAgICAgICAgICAgJCgvXlstK10/KFswLTldKlxcLlswLTldK3xbMC05XSspLykpIHtcbiAgICAgICAgICAgIGlmIChlbGVtID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIHBvaW50ZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5wdXNoKHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW0gPT09ICcpJykge1xuICAgICAgICAgICAgICAgIHBvaW50ZXIgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW0gPT09ICcsJykge1xuICAgICAgICAgICAgICAgIHBvaW50ZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5wdXNoKHBvaW50ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb2ludGVyLnB1c2gocGFyc2VGbG9hdChlbGVtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmIChkZXB0aCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJpbmdzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvb3JkcygpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXSwgaXRlbSwgcHQ7XG4gICAgICAgIHdoaWxlIChwdCA9XG4gICAgICAgICAgICAkKC9eWy0rXT8oWzAtOV0qXFwuWzAtOV0rfFswLTldKykvKSB8fFxuICAgICAgICAgICAgJCgvXihcXCwpLykpIHtcbiAgICAgICAgICAgIGlmIChwdCA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbS5wdXNoKHBhcnNlRmxvYXQocHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdC5sZW5ndGggPyBsaXN0IDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2ludCgpIHtcbiAgICAgICAgaWYgKCEkKC9eKHBvaW50KS9pKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB3aGl0ZSgpO1xuICAgICAgICBpZiAoISQoL14oXFwoKS8pKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHZhciBjID0gY29vcmRzKCk7XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIGlmICghJCgvXihcXCkpLykpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICAgICAgICBjb29yZGluYXRlczogY1swXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG11bHRpcG9pbnQoKSB7XG4gICAgICAgIGlmICghJCgvXihtdWx0aXBvaW50KS9pKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB3aGl0ZSgpO1xuICAgICAgICB2YXIgYyA9IG11bHRpY29vcmRzKCk7XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnTXVsdGlQb2ludCcsXG4gICAgICAgICAgICBjb29yZGluYXRlczogY1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG11bHRpbGluZXN0cmluZygpIHtcbiAgICAgICAgaWYgKCEkKC9eKG11bHRpbGluZXN0cmluZykvaSkpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgdmFyIGMgPSBtdWx0aWNvb3JkcygpO1xuICAgICAgICB3aGl0ZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ011bHRpTGluZVN0cmluZycsXG4gICAgICAgICAgICBjb29yZGluYXRlczogY1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVzdHJpbmcoKSB7XG4gICAgICAgIGlmICghJCgvXihsaW5lc3RyaW5nKS9pKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB3aGl0ZSgpO1xuICAgICAgICBpZiAoISQoL14oXFwoKS8pKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHZhciBjID0gY29vcmRzKCk7XG4gICAgICAgIGlmICghJCgvXihcXCkpLykpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9seWdvbigpIHtcbiAgICAgICAgaWYgKCEkKC9eKHBvbHlnb24pL2kpKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnUG9seWdvbicsXG4gICAgICAgICAgICBjb29yZGluYXRlczogbXVsdGljb29yZHMoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG11bHRpcG9seWdvbigpIHtcbiAgICAgICAgaWYgKCEkKC9eKG11bHRpcG9seWdvbikvaSkpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdNdWx0aVBvbHlnb24nLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IG11bHRpY29vcmRzKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW9tZXRyeWNvbGxlY3Rpb24oKSB7XG4gICAgICAgIHZhciBnZW9tZXRyaWVzID0gW10sIGdlb21ldHJ5O1xuXG4gICAgICAgIGlmICghJCgvXihnZW9tZXRyeWNvbGxlY3Rpb24pL2kpKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHdoaXRlKCk7XG5cbiAgICAgICAgaWYgKCEkKC9eKFxcKCkvKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB3aGlsZSAoZ2VvbWV0cnkgPSByb290KCkpIHtcbiAgICAgICAgICAgIGdlb21ldHJpZXMucHVzaChnZW9tZXRyeSk7XG4gICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgJCgvXihcXCwpLyk7XG4gICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJCgvXihcXCkpLykpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0dlb21ldHJ5Q29sbGVjdGlvbicsXG4gICAgICAgICAgICBnZW9tZXRyaWVzOiBnZW9tZXRyaWVzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50KCkgfHxcbiAgICAgICAgICAgIGxpbmVzdHJpbmcoKSB8fFxuICAgICAgICAgICAgcG9seWdvbigpIHx8XG4gICAgICAgICAgICBtdWx0aXBvaW50KCkgfHxcbiAgICAgICAgICAgIG11bHRpbGluZXN0cmluZygpIHx8XG4gICAgICAgICAgICBtdWx0aXBvbHlnb24oKSB8fFxuICAgICAgICAgICAgZ2VvbWV0cnljb2xsZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNycyhyb290KCkpO1xufTtcblxuREcuV2t0Lmdlb0pzb25MYXllciA9IGZ1bmN0aW9uIChkYXRhLCBvcHRzKSB7XG4gICAgcmV0dXJuIERHLmdlb0pzb24oREcuV2t0LnRvR2VvSlNPTihkYXRhKSwgb3B0cyk7XG59O1xuXG5ERy5Xa3QuX2Nvb3Jkc1RvTGF0TG5ncyA9IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICBpZiAoREcuVXRpbC5pc0FycmF5KGNvb3JkcykgJiYgIURHLlV0aWwuaXNBcnJheShjb29yZHNbMF0pKSB7XG4gICAgICAgIHJldHVybiBbREcuR2VvSlNPTi5jb29yZHNUb0xhdExuZyhjb29yZHMpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29vcmRzLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBERy5Xa3QuX2Nvb3Jkc1RvTGF0TG5ncyhlbCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFyciwgY29vcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIuY29uY2F0KGNvb3JkKTtcbiAgICAgICAgfSk7XG59O1xuXG5ERy5Xa3QudG9MYXRMbmdzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIURHLlV0aWwuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIGNvb3JkcyA9IERHLldrdC50b0dlb0pTT04oZWwpLmNvb3JkaW5hdGVzO1xuXG4gICAgICAgIHJldHVybiBERy5Xa3QuX2Nvb3Jkc1RvTGF0TG5ncyhjb29yZHMpO1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbiAoYXJyLCBjb29yZCkge1xuICAgICAgICByZXR1cm4gYXJyLmNvbmNhdChjb29yZCk7XG4gICAgfSk7XG59O1xuXG5ERy5Xa3QudG9Qb2ludHMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBERy5Xa3QudG9HZW9KU09OKGRhdGEpLmNvb3JkaW5hdGVzO1xufTtcblxuREcuV2t0LnBvaW50c1RvTGF0TG5nT25NYXAgPSBmdW5jdGlvbiAod2t0LCBtYXApIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIHBhcnNlUG9pbnRzKHBvaW50cykge1xuICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkocG9pbnRzKSAmJiBBcnJheS5pc0FycmF5KHBvaW50c1swXSkpID9cbiAgICAgICAgICAgIHBvaW50cy5tYXAocGFyc2VQb2ludHMpIDpcbiAgICAgICAgICAgIG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHBvaW50cyk7XG4gICAgfSkoREcuV2t0LnRvUG9pbnRzKHdrdCkpO1xufTtcbiIsIkRHLlByb2plY3REZXRlY3RvciA9IERHLkhhbmRsZXIuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihtYXApIHsgLy8gKE9iamVjdClcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl9vc21WaWV3cG9ydCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcm9qZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9sb2FkUHJvamVjdExpc3QoKTtcbiAgICB9LFxuXG4gICAgYWRkSG9va3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9wcm9qZWN0V2F0Y2goKTtcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdtb3ZlJywgdGhpcy5fcHJvamVjdFdhdGNoLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlSG9va3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9tYXAub2ZmKCdtb3ZlJywgdGhpcy5fcHJvamVjdFdhdGNoLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgZ2V0UHJvamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJvamVjdCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgICByZXR1cm4gREcuVXRpbC5leHRlbmQoe30sIHRoaXMuX3Byb2plY3QpO1xuICAgIH0sXG5cbiAgICBnZXRQcm9qZWN0c0xpc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvamVjdExpc3Quc2xpY2UoMCk7XG4gICAgfSxcblxuICAgIGlzUHJvamVjdEhlcmU6IGZ1bmN0aW9uKGNvb3JkcywgcHJvamVjdCwgY2hlY2tNZXRob2QpIHtcbiAgICAgICAgaWYgKCFjb29yZHMpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgICBpZiAoIShjb29yZHMgaW5zdGFuY2VvZiBERy5MYXRMbmcpICYmICEoY29vcmRzIGluc3RhbmNlb2YgREcuTGF0TG5nQm91bmRzKSkge1xuICAgICAgICAgICAgY29vcmRzID0gREcubGF0TG5nKGNvb3Jkcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb29yZHMgPSAoY29vcmRzIGluc3RhbmNlb2YgREcuTGF0TG5nQm91bmRzKSA/XG4gICAgICAgICAgICBERy5sYXRMbmdCb3VuZHMoY29vcmRzLmdldFNvdXRoV2VzdCgpLndyYXAoKSwgY29vcmRzLmdldE5vcnRoRWFzdCgpLndyYXAoKSkgOiBjb29yZHMud3JhcCgpO1xuXG4gICAgICAgIGNoZWNrTWV0aG9kID0gY2hlY2tNZXRob2QgfHwgKChjb29yZHMgaW5zdGFuY2VvZiBERy5MYXRMbmdCb3VuZHMpID8gICdpbnRlcnNlY3RzJyA6ICdjb250YWlucycpO1xuXG4gICAgICAgIHZhciBtZXRob2QgPSBjaGVja01ldGhvZCA9PSAnaW50ZXJzZWN0cycgPyB0aGlzLl90ZXN0UHJvamVjdEludGVyc2VjdHMgOiB0aGlzLl90ZXN0UHJvamVjdENvbnRhaW5zO1xuICAgICAgICBtZXRob2QgPSBtZXRob2QuYmluZCh0aGlzLCBjb29yZHMpO1xuXG4gICAgICAgIGlmIChwcm9qZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kKHByb2plY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3RMaXN0LmZpbHRlcihtZXRob2QpWzBdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9wcm9qZWN0V2F0Y2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX21hcC5fbG9hZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fb3NtVmlld3BvcnQgPT09ICh0aGlzLl9wcm9qZWN0ICYmIHRoaXMuX2NlbnRlckluUHJvamVjdCh0aGlzLl9wcm9qZWN0LCAnY29udGFpbnMnKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX29zbVZpZXdwb3J0ID0gIXRoaXMuX29zbVZpZXdwb3J0O1xuICAgICAgICAgICAgdGhpcy5fbWFwLmF0dHJpYnV0aW9uQ29udHJvbC5fdXBkYXRlKG51bGwsIHRoaXMuX29zbVZpZXdwb3J0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9wcm9qZWN0ICYmIHRoaXMuX3pvb21JblByb2plY3QodGhpcy5fcHJvamVjdCkgJiYgdGhpcy5fY2VudGVySW5Qcm9qZWN0KHRoaXMuX3Byb2plY3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZWFyY2hQcm9qZWN0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Byb2plY3QpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vc21WaWV3cG9ydCA9PT0gKHRoaXMuX3Byb2plY3QgJiYgdGhpcy5fY2VudGVySW5Qcm9qZWN0KHRoaXMuX3Byb2plY3QsICdjb250YWlucycpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29zbVZpZXdwb3J0ID0gIXRoaXMuX29zbVZpZXdwb3J0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFwLmF0dHJpYnV0aW9uQ29udHJvbC5fdXBkYXRlKG51bGwsIHRoaXMuX29zbVZpZXdwb3J0LCB0aGlzLl9wcm9qZWN0LmNvdW50cnlfY29kZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NoZWNrUHJvamVjdERhdGE6IGZ1bmN0aW9uKHByb2plY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gY2hlY2sodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb2plY3QgJiZcbiAgICAgICAgICAgICAgICBwcm9qZWN0LmJvdW5kcyAmJlxuICAgICAgICAgICAgICAgIGNoZWNrKHByb2plY3QuY29kZSkgJiZcbiAgICAgICAgICAgICAgICBjaGVjayhwcm9qZWN0LmRvbWFpbikgJiZcbiAgICAgICAgICAgICAgICBjaGVjayhwcm9qZWN0LmNvdW50cnlfY29kZSkgJiZcbiAgICAgICAgICAgICAgICBwcm9qZWN0Lnpvb21fbGV2ZWwgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hlY2socHJvamVjdC56b29tX2xldmVsLm1pbikgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hlY2socHJvamVjdC56b29tX2xldmVsLm1heCkgJiZcbiAgICAgICAgICAgICAgICBwcm9qZWN0LnRpbWVfem9uZSAmJlxuICAgICAgICAgICAgICAgICAgICBjaGVjayhwcm9qZWN0LnRpbWVfem9uZS5vZmZzZXQpO1xuICAgIH0sXG5cbiAgICBfbG9hZFByb2plY3RMaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgREcuZmFsbGJhY2tQcm9qZWN0c0xpc3QgPSBERy5mYWxsYmFja1Byb2plY3RzTGlzdCB8fCBbXTtcblxuICAgICAgICBpZiAoIURHLnByb2plY3RzTGlzdCkge1xuICAgICAgICAgICAgREcucHJvamVjdHNMaXN0ID0gREcuZmFsbGJhY2tQcm9qZWN0c0xpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIERHLmZhbGxiYWNrUHJvamVjdHNMaXN0O1xuXG4gICAgICAgIHRoaXMuX3Byb2plY3RMaXN0ID0gREcucHJvamVjdHNMaXN0XG4gICAgICAgICAgICAuZmlsdGVyKHRoaXMuX2NoZWNrUHJvamVjdERhdGEpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHByb2plY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmQgPSBERy5Xa3QudG9HZW9KU09OKHByb2plY3QuYm91bmRzKTtcbiAgICAgICAgICAgICAgICB2YXIgbGF0TG5nQm91bmRzID0gREcuZ2VvSlNPTihib3VuZCkuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRQb3MgPSBwcm9qZWN0LmRlZmF1bHRfcG9zID8gREcubGF0TG5nKHByb2plY3QuZGVmYXVsdF9wb3MubGF0LCBwcm9qZWN0LmRlZmF1bHRfcG9zLmxvbikgOiBudWxsO1xuXG5cbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpZDogcHJvamVjdC5pZCxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogcHJvamVjdC5jb2RlLFxuICAgICAgICAgICAgICAgICAgICBtaW5ab29tOiBwcm9qZWN0Lnpvb21fbGV2ZWwubWluLFxuICAgICAgICAgICAgICAgICAgICBtYXhab29tOiBwcm9qZWN0Lnpvb21fbGV2ZWwubWF4LFxuICAgICAgICAgICAgICAgICAgICB0aW1lT2Zmc2V0OiBwcm9qZWN0LnRpbWVfem9uZS5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kOiBib3VuZCxcbiAgICAgICAgICAgICAgICAgICAgbGF0TG5nQm91bmRzOiBsYXRMbmdCb3VuZHMsXG4gICAgICAgICAgICAgICAgICAgIHRyYWZmaWM6ICEhcHJvamVjdC5mbGFncy50cmFmZmljLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6ICEhcHJvamVjdC5mbGFncy5wdWJsaWNfdHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgICAgICByb2FkczogISFwcm9qZWN0LmZsYWdzLnJvYWRfbmV0d29yayxcbiAgICAgICAgICAgICAgICAgICAgY291bnRyeV9jb2RlOiBwcm9qZWN0LmNvdW50cnlfY29kZSxcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBwcm9qZWN0LmRvbWFpbixcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFBvczogZGVmYXVsdFBvc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfc2VhcmNoUHJvamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vINCS0L3QsNGH0LDQu9C1INC+0YLRgdC10LjQstCw0LXQvCDRgNC10LPQuNC+0L3RiyDQv9C+INC30YPQvNGDXG4gICAgICAgIHZhciBmaWx0ZXJlZEJ5Wm9vbSA9IHRoaXMuX3Byb2plY3RMaXN0LmZpbHRlcih0aGlzLl96b29tSW5Qcm9qZWN0LCB0aGlzKTtcblxuICAgICAgICAvLyDQndCw0YXQvtC00LjQvCDQv9GA0L7QtdC60YIg0LIg0LPRgNCw0L3QuNGG0Ysg0LrQvtGC0L7RgNC+0LPQviDQv9C+0L/QsNC00LDQtdGCINGG0LXQvdGC0YAg0LrQsNGA0YLRi1xuICAgICAgICB2YXIgZm91bmRQcm9qZWN0cyA9IGZpbHRlcmVkQnlab29tLmZpbHRlcih0aGlzLl9jZW50ZXJJblByb2plY3QsIHRoaXMpO1xuXG4gICAgICAgIC8vINCV0YHQu9C4INGC0LDQutC+0Lkg0L/RgNC+0LXQutGCINC90LUg0L3QsNC50LTQtdC9LCDRgtC+INC40YnQtdC8INC/0YDQvtC10LrRgtGLINCx0LDRg9C90LQg0LHQvtC60YHRiyDQutC+0YLQvtGA0YvRhSDQv9C10YDQtdGB0LXQutCw0Y7RgtGB0Y8g0YEg0Y3QutGA0LDQvdC+0LxcbiAgICAgICAgaWYgKGZvdW5kUHJvamVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgbWFwQm91bmRzID0gdGhpcy5fbWFwLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgZm91bmRQcm9qZWN0cyA9IGZpbHRlcmVkQnlab29tLmZpbHRlcihERy5iaW5kKHRoaXMuX3Rlc3RQcm9qZWN0SW50ZXJzZWN0cywgdGhpcywgbWFwQm91bmRzKSk7XG5cbiAgICAgICAgICAgIGlmIChmb3VuZFByb2plY3RzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwQ2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuICAgICAgICAgICAgICAgIHZhciBuZWFyZWFzdFByb2plY3QgPSBmb3VuZFByb2plY3RzWzBdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZm91bmRQcm9qZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFByb2plY3QgPSBmb3VuZFByb2plY3RzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFByb2plY3QuZGVmYXVsdFBvcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwQ2VudGVyLmRpc3RhbmNlVG8obmVhcmVhc3RQcm9qZWN0LmRlZmF1bHRQb3MpID5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcENlbnRlci5kaXN0YW5jZVRvKGN1cnJlbnRQcm9qZWN0LmRlZmF1bHRQb3MpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVhcmVhc3RQcm9qZWN0ID0gY3VycmVudFByb2plY3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm91bmRQcm9qZWN0cyA9IFtuZWFyZWFzdFByb2plY3RdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld1Byb2plY3QgPSBmb3VuZFByb2plY3RzWzBdIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Byb2plY3QgPT09IG5ld1Byb2plY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5fcHJvamVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvamVjdCA9IG51bGw7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX21hcC5maXJlKCdwcm9qZWN0bGVhdmUnKTtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld1Byb2plY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2plY3QgPSBuZXdQcm9qZWN0O1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9tYXAuZmlyZSgncHJvamVjdGNoYW5nZScsIHtnZXRQcm9qZWN0OiBzZWxmLmdldFByb2plY3QuYmluZChzZWxmKX0pO1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3Rlc3RQcm9qZWN0SW50ZXJzZWN0czogZnVuY3Rpb24oYm91bmRzLCBwcm9qZWN0KSB7XG4gICAgICAgIHJldHVybiBwcm9qZWN0LmxhdExuZ0JvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcyk7XG4gICAgfSxcblxuICAgIF90ZXN0UHJvamVjdENvbnRhaW5zOiBmdW5jdGlvbihsYXRsbmcsIHByb2plY3QpIHtcbiAgICAgICAgcmV0dXJuIERHLlBvbHlVdGlsLmluc2lkZShbbGF0bG5nLmxuZywgbGF0bG5nLmxhdF0sIHByb2plY3QuYm91bmQpO1xuICAgIH0sXG5cbiAgICBfY2VudGVySW5Qcm9qZWN0OiBmdW5jdGlvbihwcm9qZWN0LCBjaGVja01ldGhvZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1Byb2plY3RIZXJlKHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgcHJvamVjdCwgY2hlY2tNZXRob2QpO1xuICAgIH0sXG5cbiAgICBfem9vbUluUHJvamVjdDogZnVuY3Rpb24ocHJvamVjdCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX21hcC5nZXRab29tKCkgPj0gcHJvamVjdC5taW5ab29tKTtcbiAgICB9XG59KTtcblxuREcuTWFwLm1lcmdlT3B0aW9ucyh7XG4gICAgcHJvamVjdERldGVjdG9yOiB0cnVlXG59KTtcblxuREcuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3Byb2plY3REZXRlY3RvcicsIERHLlByb2plY3REZXRlY3Rvcik7XG4iLCIvKlxuICogVXRpbGl0eSBmdW5jdGlvbnNcbiAqL1xuXG5ERy5NZXRyaWMgPSBmdW5jdGlvbigpIHt9O1xuXG4vKlxuICogREcuTWV0cmljLlNlZ21lbnRzIGNsYXNzIGNhbiBjYWxjdWxhdGUgdG90YWwgcHVzaGVkIHNlZ21lbnRzIGxlbmd0aCBhbmQgdXNlZCB0byBzaG9ydGN1dFxuICogJ2dldCBTb21ldGhpbmcgYnkgcHJvdmlkZWQgTGVuZ3RoJyBjYWxjdWxhdGlvbnMgKHNlZ21lbnQncyBJbmRleCwgc2VnbWVudCdzIExlbmd0aCwgZXRjLi4uKVxuICovXG5ERy5NZXRyaWMuU2VnbWVudHMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG59O1xuXG5ERy5NZXRyaWMuU2VnbWVudHMucHJvdG90eXBlID0ge1xuICAgIHB1c2g6IGZ1bmN0aW9uKGxlbikge1xuICAgICAgICB0aGlzW3RoaXMubGVuZ3RoXSA9IHRoaXMubGVuZ3RoID4gMCA/IHRoaXNbdGhpcy5sZW5ndGggLSAxXSArIGxlbiA6IGxlbjtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gMTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICB9LFxuXG4gICAgZ2V0UmV2ZXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWdtZW50cyA9IG5ldyBERy5NZXRyaWMuU2VnbWVudHMoKTtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgaWYgKGkgPCAwKSB7IHJldHVybiBzZWdtZW50czsgfVxuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2godGhpc1tpICsgMV0gLSB0aGlzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWdtZW50cy5wdXNoKHRoaXNbMF0pO1xuICAgIH0sXG5cbiAgICBnZXRJbmRleDogZnVuY3Rpb24obGVuKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIGlmIChpIDwgMCkgeyByZXR1cm4gaTsgfVxuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2ldIDw9IGxlbikgeyBicmVhazsgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgIH0sXG5cbiAgICBnZXRTZWdSYXRpbzogZnVuY3Rpb24obGVuKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5nZXRJbmRleChsZW4pO1xuICAgICAgICB2YXIgc3ViID0gaSA+IDAgPyB0aGlzW2kgLSAxXSA6IDA7XG5cbiAgICAgICAgcmV0dXJuIChsZW4gLSBzdWIpIC8gKHRoaXNbaV0gLSBzdWIpO1xuICAgIH0sXG5cbiAgICBnZXRTZWdMZW5ndGg6IGZ1bmN0aW9uKGxlbikge1xuICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0SW5kZXgobGVuKTtcbiAgICAgICAgdmFyIHN1YiA9IGkgPiAwID8gdGhpc1tpIC0gMV0gOiAwO1xuXG4gICAgICAgIHJldHVybiBsZW4gLSBzdWI7XG4gICAgfVxufTtcbiIsIi8qXG4gKiBERy5WZXJ0ZXhUcmFuc2Zvcm0gaXMgYSBjbGFzc2ljIDJEIG1hdHJpeCB0cmFuc2Zvcm1hdGlvbiBjbGFzc1xuICpcbiAqIFByb3RvdHlwZSBtZXRob2RzIGNhbiBzY2FsZS9yb3RhdGUvdHJhbnNsYXRlIHZlcnRpY2VzXG4gKlxuICogU3RhdGljIG1ldGhvZHMgZG8gdGhlIHNhbWUgYnV0IHJldHVybiBzaW1wbGUgYXJyYXkgaW5zdGFuY2VzIHdpdGggYXR0YWNoZWRcbiAqIC5jbG9uZSgpIG1ldGhvZCB3aGljaCBjYW4gcmVjb25zdHJ1Y3QgZnVsbCBERy5WZXJ0ZXhUcmFuc2Zvcm0gb2JqZWN0XG4gKi9cblxuREcuVmVydGV4VHJhbnNmb3JtID0gREcuQ2xhc3MuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgICAgICB0aGlzLl92ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuXG4gICAgICAgIHRoaXMuX3NjYWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYW5nbGUgPSBudWxsO1xuICAgICAgICB0aGlzLl90cmFucyA9IG51bGw7XG4gICAgICAgIHRoaXMuX21hdHJpeCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgfSxcblxuICAgIGxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnZlcnRpY2VzID0gdGhpcy5fdmVydGljZXMubWFwKGZ1bmN0aW9uKHZlcnRleCkgeyByZXR1cm4gdmVydGV4LmNsb25lKCk7IH0pO1xuICAgICAgICB0aGlzLnZlcnRpY2VzLmNsb25lID0gREcuVmVydGV4VHJhbnNmb3JtLmNsb25lO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzYXZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzLm1hcChmdW5jdGlvbih2ZXJ0ZXgpIHsgcmV0dXJuIHZlcnRleC5jbG9uZSgpOyB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0U2NhbGU6IGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgICAgIHRoaXMuX3NjYWxlID0gc2NhbGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRTY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZTtcbiAgICB9LFxuXG4gICAgc2V0QW5nbGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICAgIHRoaXMuX2FuZ2xlID0gYW5nbGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRBbmdsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbmdsZTtcbiAgICB9LFxuXG4gICAgc2V0VHJhbnNsYXRpb246IGZ1bmN0aW9uKHRyYW5zKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zID0gdHJhbnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRUcmFuc2xhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFucztcbiAgICB9LFxuXG4gICAgc2V0TWF0cml4OiBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICAgICAgdGhpcy5fbWF0cml4ID0gbWF0cml4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0TWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdHJpeDtcbiAgICB9LFxuXG4gICAgc2NhbGU6IGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlcztcbiAgICAgICAgdmFyIGkgPSB2Lmxlbmd0aDtcblxuICAgICAgICBzY2FsZSA9IHNjYWxlIHx8IHRoaXMuX3NjYWxlIHx8IDE7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHZbaV0ueCAqPSBzY2FsZTtcbiAgICAgICAgICAgIHZbaV0ueSAqPSBzY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB1blNjYWxlOiBmdW5jdGlvbihzY2FsZSkge1xuICAgICAgICBzY2FsZSA9IHNjYWxlIHx8IHRoaXMuX3NjYWxlIHx8IDE7ICAgICAgLy8gIEFsc28gc2FmZWd1YXJkIGFnYWluc3QgemVybyBzY2FsZVxuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZSgxIC8gc2NhbGUpO1xuICAgIH0sXG5cbiAgICByb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICAgIHZhciBjb3MgPSBhbmdsZSA/IGFuZ2xlLmNvcyA6ICh0aGlzLl9hbmdsZSA/IHRoaXMuX2FuZ2xlLmNvcyA6IDEpO1xuICAgICAgICB2YXIgc2luID0gYW5nbGUgPyBhbmdsZS5zaW4gOiAodGhpcy5fYW5nbGUgPyB0aGlzLl9hbmdsZS5zaW4gOiAwKTtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZlcnRpY2VzO1xuICAgICAgICB2YXIgaSA9IHYubGVuZ3RoO1xuICAgICAgICB2YXIgeCwgeTtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICB4ID0gdltpXS54O1xuICAgICAgICAgICAgeSA9IHZbaV0ueTtcbiAgICAgICAgICAgIHZbaV0ueCA9IHggKiBjb3MgLSB5ICogc2luO1xuICAgICAgICAgICAgdltpXS55ID0geCAqIHNpbiArIHkgKiBjb3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdW5Sb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICAgIHZhciBjb3MgPSBhbmdsZSA/IGFuZ2xlLmNvcyA6ICh0aGlzLl9hbmdsZSA/IHRoaXMuX2FuZ2xlLmNvcyA6IDEpO1xuICAgICAgICB2YXIgc2luID0gYW5nbGUgPyBhbmdsZS5zaW4gOiAodGhpcy5fYW5nbGUgPyB0aGlzLl9hbmdsZS5zaW4gOiAwKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGUoe2NvczogY29zLCBzaW46IC1zaW59KTtcbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbih0cmFucykge1xuICAgICAgICB2YXIgZHggPSB0cmFucyA/IHRyYW5zLnggOiAodGhpcy5fdHJhbnMgPyB0aGlzLl90cmFucy54IDogMCk7XG4gICAgICAgIHZhciBkeSA9IHRyYW5zID8gdHJhbnMueSA6ICh0aGlzLl90cmFucyA/IHRoaXMuX3RyYW5zLnkgOiAwKTtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZlcnRpY2VzO1xuICAgICAgICB2YXIgaSA9IHYubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHZbaV0ueCArPSBkeDtcbiAgICAgICAgICAgIHZbaV0ueSArPSBkeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB1blRyYW5zbGF0ZTogZnVuY3Rpb24odHJhbnMpIHtcbiAgICAgICAgdmFyIGR4ID0gdHJhbnMgPyB0cmFucy54IDogKHRoaXMuX3RyYW5zID8gdGhpcy5fdHJhbnMueCA6IDApO1xuICAgICAgICB2YXIgZHkgPSB0cmFucyA/IHRyYW5zLnkgOiAodGhpcy5fdHJhbnMgPyB0aGlzLl90cmFucy55IDogMCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlKHt4OiAtZHgsIHk6IC1keX0pO1xuICAgIH0sXG5cbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgICAgICB2YXIgYSwgYiwgYywgZCwgZHgsIGR5O1xuICAgICAgICB2YXIgdiA9IHRoaXMudmVydGljZXM7XG4gICAgICAgIHZhciBpID0gdi5sZW5ndGg7XG4gICAgICAgIHZhciB4LCB5O1xuXG4gICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgIGEgPSBtYXRyaXhbMF07IGIgPSBtYXRyaXhbMV07IGR4ID0gbWF0cml4WzJdO1xuICAgICAgICAgICAgYyA9IG1hdHJpeFszXTsgZCA9IG1hdHJpeFs0XTsgZHkgPSBtYXRyaXhbNV07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbWF0cml4KSB7XG4gICAgICAgICAgICBhID0gdGhpcy5fbWF0cml4WzBdOyBiID0gdGhpcy5fbWF0cml4WzFdOyBkeCA9IHRoaXMuX21hdHJpeFsyXTtcbiAgICAgICAgICAgIGMgPSB0aGlzLl9tYXRyaXhbM107IGQgPSB0aGlzLl9tYXRyaXhbNF07IGR5ID0gdGhpcy5fbWF0cml4WzVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYSA9IDE7IGIgPSAwOyBkeCA9IDA7XG4gICAgICAgICAgICBjID0gMDsgZCA9IDE7IGR5ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHggPSB2W2ldLng7XG4gICAgICAgICAgICB5ID0gdltpXS55O1xuICAgICAgICAgICAgdltpXS54ID0geCAqIGEgKyB5ICogYiArIGR4O1xuICAgICAgICAgICAgdltpXS55ID0geCAqIGMgKyB5ICogZCArIGR5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgc2NhbGU6IGZ1bmN0aW9uKHZ0LCBzY2FsZSkge1xuICAgICAgICAgICAgdmFyIHYgPSB2dC52ZXJ0aWNlcztcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHZhciB4LCB5O1xuXG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlIHx8IDE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB4ID0gdltpXS54ICogc2NhbGU7XG4gICAgICAgICAgICAgICAgeSA9IHZbaV0ueSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBERy5Qb2ludCh4LCB5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuY2xvbmUgPSBERy5WZXJ0ZXhUcmFuc2Zvcm0uY2xvbmU7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5TY2FsZTogZnVuY3Rpb24odnQsIHNjYWxlKSB7XG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlIHx8IDE7ICAgICAgICAgLy8gIEFsc28gc2FmZWd1YXJkIGFnYWluc3QgemVybyBzY2FsZVxuICAgICAgICAgICAgcmV0dXJuIERHLlZlcnRleFRyYW5zZm9ybS5zY2FsZSh2dCwgMSAvIHNjYWxlKTtcbiAgICAgICAgfSxcblxuICAgICAgICByb3RhdGU6IGZ1bmN0aW9uKHZ0LCBhbmdsZSkge1xuICAgICAgICAgICAgdmFyIGNvcyA9IGFuZ2xlID8gYW5nbGUuY29zIDogMTtcbiAgICAgICAgICAgIHZhciBzaW4gPSBhbmdsZSA/IGFuZ2xlLnNpbiA6IDA7XG4gICAgICAgICAgICB2YXIgdiA9IHZ0LnZlcnRpY2VzO1xuICAgICAgICAgICAgdmFyIHgsIHksIHJ4LCByeTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcnggPSB2W2ldLng7XG4gICAgICAgICAgICAgICAgcnkgPSB2W2ldLnk7XG4gICAgICAgICAgICAgICAgeCA9IHJ4ICogY29zIC0gcnkgKiBzaW47XG4gICAgICAgICAgICAgICAgeSA9IHJ4ICogc2luICsgcnkgKiBjb3M7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IERHLlBvaW50KHgsIHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5jbG9uZSA9IERHLlZlcnRleFRyYW5zZm9ybS5jbG9uZTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICB1blJvdGF0ZTogZnVuY3Rpb24odnQsIGFuZ2xlKSB7XG4gICAgICAgICAgICB2YXIgY29zID0gYW5nbGUgPyBhbmdsZS5jb3MgOiAxO1xuICAgICAgICAgICAgdmFyIHNpbiA9IGFuZ2xlID8gYW5nbGUuc2luIDogMDtcblxuICAgICAgICAgICAgcmV0dXJuIERHLlZlcnRleFRyYW5zZm9ybS5yb3RhdGUodnQsIHtjb3M6IGNvcywgc2luOiAtc2lufSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbih2dCwgdHJhbnMpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IHRyYW5zID8gdHJhbnMueCA6IDA7XG4gICAgICAgICAgICB2YXIgZHkgPSB0cmFucyA/IHRyYW5zLnkgOiAwO1xuICAgICAgICAgICAgdmFyIHYgPSB2dC52ZXJ0aWNlcztcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHZhciB4LCB5O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB4ID0gdltpXS54ICsgZHg7XG4gICAgICAgICAgICAgICAgeSA9IHZbaV0ueSArIGR5O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBERy5Qb2ludCh4LCB5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuY2xvbmUgPSBERy5WZXJ0ZXhUcmFuc2Zvcm0uY2xvbmU7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5UcmFuc2xhdGU6IGZ1bmN0aW9uKHZ0LCB0cmFucykge1xuICAgICAgICAgICAgdmFyIGR4ID0gdHJhbnMgPyB0cmFucy54IDogMDtcbiAgICAgICAgICAgIHZhciBkeSA9IHRyYW5zID8gdHJhbnMueSA6IDA7XG5cbiAgICAgICAgICAgIHJldHVybiBERy5WZXJ0ZXhUcmFuc2Zvcm0udHJhbnNsYXRlKHZ0LCB7eDogLWR4LCB5OiAtZHl9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyAgJ3RoaXMnIGlzIGFuIGFycmF5XG4gICAgICAgICAgICByZXR1cm4gbmV3IERHLlZlcnRleFRyYW5zZm9ybSh0aGlzKS5zYXZlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGVuZ3RoOiBmdW5jdGlvbih2ZWMxLCB2ZWMyKSB7XG4gICAgICAgICAgICB2YXIgZHgsIGR5O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZlYzEgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gICd2ZWMxJyBhbmQgJ3ZlYzInIGFyZSBhYnNvbHV0ZSBjb29yZGluYXRlcyBvZiB2ZWN0b3JcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHZlYzEgKiB2ZWMxICsgdmVjMiAqIHZlYzIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAgJ3ZlYzEnIGFuZCAndmVjMicgYXJlIHZlY3RvciBvYmplY3RzXG4gICAgICAgICAgICAgICAgZHggPSB2ZWMyLnggLSB2ZWMxLng7XG4gICAgICAgICAgICAgICAgZHkgPSB2ZWMyLnkgLSB2ZWMxLnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U2NhbGVkOiBmdW5jdGlvbih2ZWMxLCB2ZWMyLCBzY2FsZSkge1xuICAgICAgICAgICAgdmFyIGR4LCBkeTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ZWMxID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vICAndmVjMScgYW5kICd2ZWMyJyBhcmUgYWJzb2x1dGUgY29vcmRpbmF0ZXMgb2YgdmVjdG9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBERy5Qb2ludCh2ZWMxICogc2NhbGUsIHZlYzIgKiBzY2FsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vICAndmVjMScgYW5kICd2ZWMyJyBhcmUgdmVjdG9yIG9iamVjdHNcbiAgICAgICAgICAgICAgICBkeCA9ICh2ZWMyLnggLSB2ZWMxLngpICogc2NhbGU7XG4gICAgICAgICAgICAgICAgZHkgPSAodmVjMi55IC0gdmVjMS55KSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgREcuUG9pbnQodmVjMS54ICsgZHgsIHZlYzEueSArIGR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBbmdsZTogZnVuY3Rpb24odmVjMSwgdmVjMiwgb3JpZ2luKSB7XG4gICAgICAgICAgICB2YXIgbCwgc3AsIHgxLCB5MSwgeDIsIHkyO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZlYzEgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gICd2ZWMxJyBhbmQgJ3ZlYzInIGFyZSBhYnNvbHV0ZSBjb29yZGluYXRlcyBvZiB2ZWN0b3JcbiAgICAgICAgICAgICAgICBsID0gTWF0aC5zcXJ0KHZlYzEgKiB2ZWMxICsgdmVjMiAqIHZlYzIpO1xuICAgICAgICAgICAgICAgIGlmIChsID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvczogdmVjMSAvIGwsIHNpbjogdmVjMiAvIGx9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29zOiAxLCBzaW46IDB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gICd2ZWMxJyBhbmQgJ3ZlYzInIGFyZSB2ZWN0b3Igb2JqZWN0c1xuICAgICAgICAgICAgICAgIHgxID0gdmVjMS54OyB5MSA9IHZlYzEueTtcbiAgICAgICAgICAgICAgICB4MiA9IHZlYzIueDsgeTIgPSB2ZWMyLnk7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICB4MSAtPSBvcmlnaW4ueDsgeTEgLT0gb3JpZ2luLnk7XG4gICAgICAgICAgICAgICAgICAgIHgyIC09IG9yaWdpbi54OyB5MiAtPSBvcmlnaW4ueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3AgPSBNYXRoLnNxcnQoeDEgKiB4MSArIHkxICogeTEpICogTWF0aC5zcXJ0KHgyICogeDIgKyB5MiAqIHkyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb3M6ICh4MSAqIHgyICsgeTEgKiB5MikgLyBzcCxcbiAgICAgICAgICAgICAgICAgICAgc2luOiAoeDEgKiB5MiAtIHgyICogeTEpIC8gc3BcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEFuZ2xlc1N1bTogZnVuY3Rpb24oYW5nbGUxLCBhbmdsZTIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29zOiBhbmdsZTEuY29zICogYW5nbGUyLmNvcyAtIGFuZ2xlMS5zaW4gKiBhbmdsZTIuc2luLFxuICAgICAgICAgICAgICAgIHNpbjogYW5nbGUxLnNpbiAqIGFuZ2xlMi5jb3MgKyBhbmdsZTEuY29zICogYW5nbGUyLnNpblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBbmdsZXNEaWY6IGZ1bmN0aW9uKGFuZ2xlMSwgYW5nbGUyKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvczogYW5nbGUxLmNvcyAqIGFuZ2xlMi5jb3MgKyBhbmdsZTEuc2luICogYW5nbGUyLnNpbixcbiAgICAgICAgICAgICAgICBzaW46IGFuZ2xlMS5zaW4gKiBhbmdsZTIuY29zIC0gYW5nbGUxLmNvcyAqIGFuZ2xlMi5zaW5cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIi8qXG4gKiBERy5BcnJvd1BhdGhUcmFuc2Zvcm0gY2xhc3MgaXMgYSBjb3JlIG9mIGFycm93J3MgYm9keSBjYWxjdWxhdGlvbnNcbiAqXG4gKiBHZW5lcmFsIGlkZWFzIGFyZTpcbiAqICAgICAgV2UgY29uc3RydWN0IGFycm93IGJvZHkgd2l0aCBzdHJva2UgcG9pbnRzIG1ha2luZyBhcmNzIG9uIG91dGVyIHBhdGggdHVybnNcbiAqICAgICAgUHJvY2Vzc2luZyBpcyBkb25lIHNlZ21lbnQgYnkgc2VnbWVudCBhcm91bmQgezAsIDB9IHZpcnR1YWwgcG9pbnRcbiAqICAgICAgICAgIGFuZCByZXN1bHRpbmcgJ3BhdGgnIGZpbmFsbHkgcm90YXRlZCB0byBpdCdzIG9yaWdpbmFsIG1hcCdzIGFuZ2xlICguZnVsbEFuZ2xlKVxuICogICAgICBTdWJzZXQgb2YgdGhpcyB2ZXJ0aWNlcyBsYXRlbHkgdXNlZCBpbiAuc3ViUGF0aCgpIGNhbGN1bGF0aW9ucyB3aGljaCBjYW4gYmUgdXNlZFxuICogICAgICAgICAgaW4gYW5pbWF0aW9ucyBmb3IgZXguXG4gKlxuICogIEZpbmFsIHRyYW5zbGF0aW9uIChzZWUgREcuRW50cmFuY2UuQXJyb3cpIG1vdmVzIGFycm93IG9iamVjdHMgdG8gdGhlaXIgb3JpZ2luYWwgcG9zaXRpb25zXG4gKi9cblxuREcuQXJyb3dQYXRoVHJhbnNmb3JtID0gREcuVmVydGV4VHJhbnNmb3JtLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAvLyAgJ3BhdGgub2Zmc2V0JyBpcyBpbml0aWFsIHBvaW50cyBvZmZzZXQgKC14IC8gK3gpIHRvIGNvbXBlbnNhdGUgYXJyb3cgdGlwIGxlbmd0aFxuXG4gICAgICAgIC8vICBTa2lwIHN1cGVyIGluaXRpYWxpemF0aW9uIGFzIHdlIG5lZWQgb25seSBzdWJzZXQgb2YgREcuVmVydGV4VHJhbnNmb3JtIHBvd2VyXG4gICAgICAgIHRoaXMuX2xlbmd0aHMgPSBuZXcgREcuTWV0cmljLlNlZ21lbnRzKCk7XG4gICAgICAgIHRoaXMuX3ZlcnRpY2VzID0gW1tdLCBbXV07XG4gICAgICAgIHRoaXMuX2RyYXdpbmdzID0gW1tdLCBbXV07XG4gICAgICAgIC8vICB0aGlzLl9hcmNzID0gW107ICAgIC8vICBpbml0aWFsaXplZCBpbiBfc2V0UGF0aCgpXG5cbiAgICAgICAgdGhpcy5fc2V0UGF0aChwYXRoKTtcbiAgICAgICAgdGhpcy5zdWJQYXRoKDEpO1xuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViUGF0aCgxKTtcbiAgICB9LFxuXG4gICAgc2F2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzOyAgICAvLyAgTm9PcFxuICAgIH0sXG5cbiAgICAvLyAgTWV0aG9kIGNvbnN0cnVjdHMgbmV3IHBhdGggcG9pbnRzIHdpdGggc29tZSBkaXNwbGFjZW1lbnQgZnJvbSBvcmlnaW5hbCAncGF0aCdcbiAgICAvLyAgT3V0ZXIgY29ybmVycyB3aWxsIGJlIHNtb290aGVkIGJ5IGFyY3MgKGN1YmljIELDqXppZXIgY3VydmVzKVxuICAgIF9zZXRQYXRoOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBERy5BcnJvd1BhdGhUcmFuc2Zvcm0udHJhbnNmb3JtO1xuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLl92ZXJ0aWNlcztcbiAgICAgICAgdmFyIGRyYXdpbmdzID0gdGhpcy5fZHJhd2luZ3M7XG4gICAgICAgIHZhciBQb2ludCA9IERHLlBvaW50O1xuICAgICAgICB2YXIgd2lkdGggPSBwYXRoLndpZHRoO1xuICAgICAgICB2YXIgYXJjcyA9IFtbXSwgW10sIFtdXTtcbiAgICAgICAgdmFyIGxlbmd0aHMgPSBbXTtcblxuICAgICAgICB2YXIgaSwgeCxcbiAgICAgICAgICAgIGF4LCBieCwgY3gsXG4gICAgICAgICAgICBhbmdsZXMsIGFuZ2xlO1xuXG4gICAgICAgIHZlcnRpY2VzLnB1c2gocGF0aC52ZXJ0aWNlcyk7ICAgLy8gIGV4cGVjdCAucG9wKCkgaW4gZmluYWwgdHJhbnNmb3JtXG4gICAgICAgIHZlcnRpY2VzWzBdLnB1c2gobmV3IERHLlBvaW50KHBhdGgub2Zmc2V0LCArd2lkdGgpKTtcbiAgICAgICAgdmVydGljZXNbMV0ucHVzaChuZXcgREcuUG9pbnQocGF0aC5vZmZzZXQsIC13aWR0aCkpO1xuICAgICAgICBhbmdsZXMgPSBERy5BcnJvd1BhdGhUcmFuc2Zvcm0uZ2V0QW5nbGVzKHBhdGgpO1xuXG4gICAgICAgIGN4ID0gLXBhdGgub2Zmc2V0O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYW5nbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB4ID0gcGF0aC52ZXJ0aWNlc1tpICsgMV0ueDtcbiAgICAgICAgICAgIGF4ID0gd2lkdGggKiBhbmdsZXNbaV0uY290O1xuXG4gICAgICAgICAgICAvLyAgaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNjaXJjbGVzX2N1YmljXG4gICAgICAgICAgICAvLyAgYWN0dWFsIGVxdWF0aW9uIGlzICg0LzMgKiB0YW4ozrEvNCkgKiByYWRpdXMpXG4gICAgICAgICAgICBieCA9IGFuZ2xlc1tpXS50YW4gKiB3aWR0aCAqIDggLyAzO1xuXG4gICAgICAgICAgICAvLyAgTmV4dCBjb2RlIGNhbiBiZSBjb21iaW5lZCBieSAtLysgaW52ZXJzaW9uIGJ1dCBmb3Igc2ltcGxpY2l0eSBpdCBpcyBsZWZ0IGFzIGlzXG4gICAgICAgICAgICBpZiAoYXggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbMF0ucHVzaChuZXcgUG9pbnQoeCArIGF4LCAgICAgICt3aWR0aCkpO1xuICAgICAgICAgICAgICAgIGRyYXdpbmdzWzBdLnB1c2goJ0wnKTtcblxuICAgICAgICAgICAgICAgIGFyY3NbMl0ucHVzaCgxKTtcbiAgICAgICAgICAgICAgICBhcmNzWzFdLnB1c2godmVydGljZXNbMV0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1sxXS5wdXNoKG5ldyBQb2ludCh4ICsgYXgsICAgICAgLXdpZHRoKSk7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbMV0ucHVzaChuZXcgUG9pbnQoeCArIGF4IC0gYngsIC13aWR0aCkpO1xuXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKHZlcnRpY2VzLCBhbmdsZXNbaV0sIHt4OiB4LCB5OiAwfSk7XG5cbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1sxXS5wdXNoKG5ldyBQb2ludCgwIC0gYXggKyBieCwgLXdpZHRoKSk7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbMV0ucHVzaChuZXcgUG9pbnQoMCAtIGF4LCAgICAgIC13aWR0aCkpO1xuICAgICAgICAgICAgICAgIGRyYXdpbmdzWzFdLnB1c2goJ0wnLCAnQycpO1xuXG4gICAgICAgICAgICAgICAgbGVuZ3Rocy5wdXNoKE1hdGguYWJzKHggKyBheCkgLSBjeCk7IGN4ID0gK2F4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1sxXS5wdXNoKG5ldyBQb2ludCh4IC0gYXgsICAgICAgLXdpZHRoKSk7XG4gICAgICAgICAgICAgICAgZHJhd2luZ3NbMV0ucHVzaCgnTCcpO1xuXG4gICAgICAgICAgICAgICAgYXJjc1syXS5wdXNoKDApO1xuICAgICAgICAgICAgICAgIGFyY3NbMF0ucHVzaCh2ZXJ0aWNlc1swXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzWzBdLnB1c2gobmV3IFBvaW50KHggLSBheCwgICAgICArd2lkdGgpKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1swXS5wdXNoKG5ldyBQb2ludCh4IC0gYXggKyBieCwgK3dpZHRoKSk7XG5cbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0odmVydGljZXMsIGFuZ2xlc1tpXSwge3g6IHgsIHk6IDB9KTtcblxuICAgICAgICAgICAgICAgIHZlcnRpY2VzWzBdLnB1c2gobmV3IFBvaW50KDAgKyBheCAtIGJ4LCArd2lkdGgpKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1swXS5wdXNoKG5ldyBQb2ludCgwICsgYXgsICAgICAgK3dpZHRoKSk7XG4gICAgICAgICAgICAgICAgZHJhd2luZ3NbMF0ucHVzaCgnTCcsICdDJyk7XG5cbiAgICAgICAgICAgICAgICBsZW5ndGhzLnB1c2goTWF0aC5hYnMoeCAtIGF4KSAtIGN4KTsgY3ggPSAtYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgRmluYWwgc2VnbWVudHMgYW5kIHRhaWwgYXJjXG4gICAgICAgIGF4ID0gcGF0aC52ZXJ0aWNlc1tpICsgMV0ueDtcbiAgICAgICAgYnggPSB3aWR0aCAqIDQgLyAzOyAvLyB0YW4oUEkvNCkgPSAxXG5cbiAgICAgICAgdmVydGljZXNbMF0ucHVzaChuZXcgUG9pbnQoYXgsICt3aWR0aCkpO1xuICAgICAgICB2ZXJ0aWNlc1sxXS5wdXNoKG5ldyBQb2ludChheCwgLXdpZHRoKSk7XG5cbiAgICAgICAgdmVydGljZXNbMF0ucHVzaChuZXcgUG9pbnQoYXggLSBieCwgK3dpZHRoKSk7XG4gICAgICAgIHZlcnRpY2VzWzFdLnB1c2gobmV3IFBvaW50KGF4IC0gYngsIC13aWR0aCkpO1xuXG4gICAgICAgIGRyYXdpbmdzWzBdLnB1c2goJ0wnKTtcbiAgICAgICAgZHJhd2luZ3NbMV0ucHVzaCgnTCcpO1xuXG4gICAgICAgIGxlbmd0aHMucHVzaChNYXRoLmFicyhheCkgLSBjeCk7XG5cbiAgICAgICAgLy8gIFJldmVyc2UgcmlnaHQgcGF0aFxuICAgICAgICB2ZXJ0aWNlc1sxXS5yZXZlcnNlKCk7XG4gICAgICAgIGRyYXdpbmdzWzFdLnJldmVyc2UoKTtcblxuICAgICAgICAvLyAgTW92ZSB2ZXJ0aWNlcyBpbnRvIG9yaWdpbmFsIHBvc2l0aW9uIChiZWZvcmUgbGFzdCB0cmFuc2xhdGlvbilcbiAgICAgICAgYW5nbGUgPSBERy5WZXJ0ZXhUcmFuc2Zvcm0uZ2V0QW5nbGVzU3VtKGFuZ2xlcy5mdWxsQW5nbGUsIHBhdGguZ2V0QW5nbGUoKSk7XG4gICAgICAgIHRyYW5zZm9ybSh2ZXJ0aWNlcywgYW5nbGUsIHZlcnRpY2VzLnBvcCgpWzBdKTsgIC8vICBwYXRoLnZlcnRpY2VzWzBdXG5cbiAgICAgICAgLy8gIFdlIG5lZWQgdG8gcmVjb25zdHJ1Y3QgYXJjJ3MgaW5kZXhlcyBidXQgdG9vIG1hbnkgdmFyaWFibGVzIGFscmVhZHkgdG91Y2hlZCwgcmV1c2Ugc29tZSBvZiB0aGVtXG4gICAgICAgIGF4ID0gdmVydGljZXNbMF0ubGVuZ3RoO1xuICAgICAgICBieCA9IHZlcnRpY2VzWzFdLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fYXJjcyA9IGFyY3NbMl0ubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgIGN4ID0gYXJjc1tpXS5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBERy5BcmNCZXppZXIodmVydGljZXNbMV0uc2xpY2UoYnggLSBjeCAtIDQsIGJ4IC0gY3gpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBERy5BcmNCZXppZXIodmVydGljZXNbMF0uc2xpY2UoY3gsIGN4ICsgNCkucmV2ZXJzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkucmV2ZXJzZSgpO1xuXG4gICAgICAgIHRoaXMuX2xlbmd0aHMucHVzaChsZW5ndGhzLnBvcCgpKTtcbiAgICAgICAgbGVuZ3Rocy5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbihsLCBpKSB7XG4gICAgICAgICAgICB0aGlzLl9sZW5ndGhzLnB1c2godGhpcy5fYXJjc1tpXS5nZXRMZW5ndGgoKSkucHVzaChsKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgLy8gIFNob3J0Y3V0IGJvcmRlciBjYXNlcyAoMCUtbGVuZ3RoIHN1Yi1wYXRoIGFuZCBmdWxsLXBhdGgpXG4gICAgICAgIHRoaXNbMF0gPSB7XG4gICAgICAgICAgICB2ZXJ0aWNlczogW3ZlcnRpY2VzWzBdW2F4IC0gMl0sIHZlcnRpY2VzWzBdW2F4IC0gMV0sIHZlcnRpY2VzWzFdWzBdLCB2ZXJ0aWNlc1sxXVsxXV0sXG4gICAgICAgICAgICBkcmF3aW5nczogWydNJywgJ0MnXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzWzFdID0ge1xuICAgICAgICAgICAgdmVydGljZXM6IHZlcnRpY2VzWzBdLmNvbmNhdCh2ZXJ0aWNlc1sxXSksXG4gICAgICAgICAgICBkcmF3aW5nczogWydNJ10uY29uY2F0KGRyYXdpbmdzWzBdLCAnQycsIGRyYXdpbmdzWzFdKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBfc2V0QW5nbGVBbmREaXNwbGFjZW1lbnQ6IGZ1bmN0aW9uKHZMLCB2UikgeyAvLyBVc2VkIGluIERHLkFycm93VGlwVHJhbnNmb3JtLnN1YlNoYXBlKClcbiAgICAgICAgdGhpcy5hbmdsZSA9IERHLlZlcnRleFRyYW5zZm9ybS5nZXRBbmdsZSh7eDogdkwueCAtIHZSLngsIHk6IHZMLnkgLSB2Ui55fSwge3g6IDAsIHk6IDF9KTtcbiAgICAgICAgdGhpcy5kaXNwbCA9IHZSLmNsb25lKCk7XG4gICAgfSxcblxuICAgIHN1YlBhdGg6IGZ1bmN0aW9uKHBhdGhSYXRpbykge1xuICAgICAgICBwYXRoUmF0aW8gPSBwYXRoUmF0aW8gPiAxID8gMSA6IHBhdGhSYXRpbztcblxuICAgICAgICAvLyAgU2hvcnRjdXQgYm9yZGVyIGNhc2VzICgwJS1sZW5ndGggc3ViLXBhdGggYW5kIGZ1bGwtcGF0aClcbiAgICAgICAgaWYgKHBhdGhSYXRpbyA9PT0gMCB8fCBwYXRoUmF0aW8gPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudmVydGljZXMgPSB0aGlzW3BhdGhSYXRpb10udmVydGljZXMubWFwKGZ1bmN0aW9uKHZlcnRleCkgeyByZXR1cm4gdmVydGV4LmNsb25lKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5kcmF3aW5ncyA9IHRoaXNbcGF0aFJhdGlvXS5kcmF3aW5ncztcbiAgICAgICAgICAgIHRoaXMuX3NldEFuZ2xlQW5kRGlzcGxhY2VtZW50KHRoaXMudmVydGljZXNbMF0sIHRoaXMudmVydGljZXNbdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnZXRTY2FsZWQgPSBERy5WZXJ0ZXhUcmFuc2Zvcm0uZ2V0U2NhbGVkO1xuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLl92ZXJ0aWNlcztcbiAgICAgICAgdmFyIGRyYXdpbmdzID0gdGhpcy5fZHJhd2luZ3M7XG4gICAgICAgIHZhciBsZW5ndGhzID0gdGhpcy5fbGVuZ3RocztcbiAgICAgICAgdmFyIGxlbiA9IGxlbmd0aHMuZ2V0TGVuZ3RoKCkgKiBwYXRoUmF0aW87XG4gICAgICAgIHZhciBzZWdJbmRleCA9IGxlbmd0aHMuZ2V0SW5kZXgobGVuKTtcbiAgICAgICAgdmFyIHNlZ1JhdGlvID0gbGVuZ3Rocy5nZXRTZWdSYXRpbyhsZW4pO1xuICAgICAgICB2YXIgdmVydGV4SW5kZXhMZWZ0ID0gdmVydGljZXNbMF0ubGVuZ3RoIC0gMjtcbiAgICAgICAgdmFyIHZlcnRleEluZGV4UmlnaHQgPSAxO1xuICAgICAgICB2YXIgZHJhd2luZ0luZGV4TGVmdCA9IGRyYXdpbmdzWzBdLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBkcmF3aW5nSW5kZXhSaWdodCA9IDA7XG4gICAgICAgIHZhciB2ZXJ0ZXhMZWZ0LCB2ZXJ0ZXhSaWdodDtcbiAgICAgICAgdmFyIGFyYyA9IDAsIGFlZCA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGFlZCsrIDwgc2VnSW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChhZWQgJSAyID09IDEpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhJbmRleExlZnQtLTtcbiAgICAgICAgICAgICAgICBkcmF3aW5nSW5kZXhMZWZ0LS07XG4gICAgICAgICAgICAgICAgdmVydGV4SW5kZXhSaWdodCsrO1xuICAgICAgICAgICAgICAgIGRyYXdpbmdJbmRleFJpZ2h0Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChkcmF3aW5nc1swXVtkcmF3aW5nSW5kZXhMZWZ0XSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRleEluZGV4TGVmdCAtPSAzO1xuICAgICAgICAgICAgICAgICAgICBkcmF3aW5nSW5kZXhMZWZ0IC09IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4SW5kZXhSaWdodCArPSAzO1xuICAgICAgICAgICAgICAgICAgICBkcmF3aW5nSW5kZXhSaWdodCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcmMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWdJbmRleCAlIDIgPT0gMSkge1xuICAgICAgICAgICAgLy8gIE9uZSBwYXRoIGVuZHMgd2l0aCBhbiBhcmNcbiAgICAgICAgICAgIGFyYyA9IHRoaXMuX2FyY3NbYXJjXTtcbiAgICAgICAgICAgIGlmIChkcmF3aW5nc1swXVtkcmF3aW5nSW5kZXhMZWZ0XSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICAgICAgYXJjID0gYXJjLmdldEN1cnZlQmVmb3JlKGFyYy5nZXRUYnlMKGxlbmd0aHMuZ2V0U2VnTGVuZ3RoKGxlbikpKTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhMZWZ0ID0gYXJjLnBvaW50c1szXTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhSaWdodCA9IHZlcnRpY2VzWzFdW3ZlcnRleEluZGV4UmlnaHRdO1xuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXMgPSBhcmMucG9pbnRzLnNsaWNlKDEpLnJldmVyc2UoKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHZlcnRpY2VzWzBdLnNsaWNlKHZlcnRleEluZGV4TGVmdCksIHZlcnRpY2VzWzFdLnNsaWNlKDAsIHZlcnRleEluZGV4UmlnaHQgKyAxKSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbih2ZXJ0ZXgpIHsgcmV0dXJuIHZlcnRleC5jbG9uZSgpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdpbmdzID0gWydNJ10uY29uY2F0KGRyYXdpbmdzWzBdLnNsaWNlKGRyYXdpbmdJbmRleExlZnQpLCAnQycsIGRyYXdpbmdzWzFdLnNsaWNlKDAsIGRyYXdpbmdJbmRleFJpZ2h0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyYyA9IGFyYy5nZXRDdXJ2ZUJlZm9yZShhcmMuZ2V0VGJ5TChsZW5ndGhzLmdldFNlZ0xlbmd0aChsZW4pKSk7XG4gICAgICAgICAgICAgICAgdmVydGV4TGVmdCA9IHZlcnRpY2VzWzBdW3ZlcnRleEluZGV4TGVmdF07XG4gICAgICAgICAgICAgICAgdmVydGV4UmlnaHQgPSBhcmMucG9pbnRzWzNdO1xuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXMgPSB2ZXJ0aWNlc1swXS5zbGljZSh2ZXJ0ZXhJbmRleExlZnQpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQodmVydGljZXNbMV0uc2xpY2UoMCwgdmVydGV4SW5kZXhSaWdodCArIDEpLCBhcmMucG9pbnRzLnNsaWNlKDEpKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHZlcnRleCkgeyByZXR1cm4gdmVydGV4LmNsb25lKCk7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd2luZ3MgPSBbJ00nXS5jb25jYXQoZHJhd2luZ3NbMF0uc2xpY2UoZHJhd2luZ0luZGV4TGVmdCArIDEpLCAnQycsIGRyYXdpbmdzWzFdLnNsaWNlKDAsIGRyYXdpbmdJbmRleFJpZ2h0ICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gIEJvdGggcGF0aHMgZW5kIHdpdGggbGluZXNcbiAgICAgICAgICAgIHZlcnRleExlZnQgPSBnZXRTY2FsZWQodmVydGljZXNbMF1bdmVydGV4SW5kZXhMZWZ0XSwgdmVydGljZXNbMF1bdmVydGV4SW5kZXhMZWZ0IC0gMV0sIHNlZ1JhdGlvKTtcbiAgICAgICAgICAgIHZlcnRleFJpZ2h0ID0gZ2V0U2NhbGVkKHZlcnRpY2VzWzFdW3ZlcnRleEluZGV4UmlnaHRdLCB2ZXJ0aWNlc1sxXVt2ZXJ0ZXhJbmRleFJpZ2h0ICsgMV0sIHNlZ1JhdGlvKTtcbiAgICAgICAgICAgIHRoaXMudmVydGljZXMgPSBbdmVydGV4TGVmdF1cbiAgICAgICAgICAgICAgICAuY29uY2F0KHZlcnRpY2VzWzBdLnNsaWNlKHZlcnRleEluZGV4TGVmdCksIHZlcnRpY2VzWzFdLnNsaWNlKDAsIHZlcnRleEluZGV4UmlnaHQgKyAxKSwgdmVydGV4UmlnaHQpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbih2ZXJ0ZXgpIHsgcmV0dXJuIHZlcnRleC5jbG9uZSgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuZHJhd2luZ3MgPSBbJ00nXS5jb25jYXQoZHJhd2luZ3NbMF0uc2xpY2UoZHJhd2luZ0luZGV4TGVmdCksICdDJywgZHJhd2luZ3NbMV0uc2xpY2UoMCwgZHJhd2luZ0luZGV4UmlnaHQgKyAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXRBbmdsZUFuZERpc3BsYWNlbWVudCh2ZXJ0ZXhMZWZ0LCB2ZXJ0ZXhSaWdodCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIGdldEFuZ2xlczogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgdmFyIGdldEFuZ2xlID0gREcuVmVydGV4VHJhbnNmb3JtLmdldEFuZ2xlO1xuICAgICAgICAgICAgdmFyIGZ1bGxBbmdsZSA9IHtjb3M6IDEsIHNpbjogMH07XG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBwYXRoLnZlcnRpY2VzO1xuICAgICAgICAgICAgdmFyIGFuZ2xlcyA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgYWJzU2luLCBhbmdsZSxcbiAgICAgICAgICAgICAgICBjb3MsIHNpbiwgY290LCB0ZW1wLCBzaWduO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gdmVydGljZXMubGVuZ3RoIC0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYW5nbGUgPSBnZXRBbmdsZSh2ZXJ0aWNlc1tpIC0gMV0sIHZlcnRpY2VzW2kgKyAxXSwgdmVydGljZXNbaV0pO1xuXG4gICAgICAgICAgICAgICAgYWJzU2luID0gTWF0aC5hYnMoYW5nbGUuc2luKTtcbiAgICAgICAgICAgICAgICBpZiAoYWJzU2luIDwgMC4wMDAwMDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gIEV4Y2x1ZGUgMTgwwrAgYW5nbGUgZnJvbSB2ZXJ0aWNlcyBhcnJheVxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5zcGxpY2UodmVydGljZXMubGVuZ3RoIC0gaSAtIDEsIDEpO1xuICAgICAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICBUaGlzIGlzIGhhbGYg4oiizrEgY290YW5nZW50LCBzaWduIGRlc2NyaWJlcyBhbmdsZSBkaXJlY3Rpb24gYW5kIHVzZWQgdG8gc2hvcnRjdXQgc3Ryb2tlIGNhbGN1bGF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyAgJy0xJyAtIHJpZ2h0IGFuZ2xlIGlzIGlubmVyIGFuZ2xlLCAnMScgLSBsZWZ0IGFuZ2xlIGlzIGlubmVyIGFuZ2xlIChpZiBzZWVuIGZyb20gWzAsIDBdIHRvIFstMSwgMF0pXG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlLmNvdCA9ICgxICsgYW5nbGUuY29zKSAvIGFuZ2xlLnNpbjtcblxuICAgICAgICAgICAgICAgICAgICAvLyAgV2UgbmVlZCB0byByb3RhdGUgbmV4dCBzZWdtZW50IHRvIFstMSwgMF0gYXhpcywgc28gd2UgbmVlZCBjb21wbGVtZW50YXJ5IGFuZ2xlIGFjdHVhbGx5XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlLmNvcyA9IC1hbmdsZS5jb3M7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gIENvbXBsaW1lbnRhcnkgYW5nbGUgYWxzbyB1c2VkIHRvIGNhbGN1bGF0ZSBpdCdzIHF1YXRlcm5hcnkg4oiizrIgdGFuZ2VudFxuICAgICAgICAgICAgICAgICAgICAvLyAg4oiizrIgdGFuZ2VudCB1c2VkIGluIGFwcHJveGltYXRpb24gb2Ygb3V0ZXIgYXJjIHNlZ21lbnQgYnkgQsOpemllciBjdXJ2ZVxuICAgICAgICAgICAgICAgICAgICBjb3QgPSAoMSArIGFuZ2xlLmNvcykgLyBhbmdsZS5zaW47XG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPSBjb3QgPCAwID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wID0gc2lnbiAqIE1hdGguc3FydCg0ICogY290ICogY290ICsgNCk7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlLnRhbiA9IC0wLjUgKiAoY290ICsgY290IC0gdGVtcCk7XG5cbiAgICAgICAgICAgICAgICAgICAgYW5nbGVzLnB1c2goYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvcyA9IGZ1bGxBbmdsZS5jb3MgKiBhbmdsZS5jb3MgLSBmdWxsQW5nbGUuc2luICogYW5nbGUuc2luO1xuICAgICAgICAgICAgICAgICAgICBzaW4gPSBmdWxsQW5nbGUuc2luICogYW5nbGUuY29zICsgZnVsbEFuZ2xlLmNvcyAqIGFuZ2xlLnNpbjtcblxuICAgICAgICAgICAgICAgICAgICBmdWxsQW5nbGUgPSB7Y29zOiBjb3MsIHNpbjogc2lufTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vICBVc2VkIGluIGZpbmFsIHN0cm9rZSBwb2ludHMgdHJhbnNsYXRpb25cbiAgICAgICAgICAgIGFuZ2xlcy5mdWxsQW5nbGUgPSAge2NvczogZnVsbEFuZ2xlLmNvcywgc2luOiAtZnVsbEFuZ2xlLnNpbn07XG4gICAgICAgICAgICByZXR1cm4gYW5nbGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vICBUT0RPIC0gaWYgbGVuZ3RoIG9mICdsYXRsbmdzJyBhcnJheSBpcyBsZXNzIHRoYW4gMiBvciBpdCBpcyB1bmRlZmluZWQgbmV4dCBmdW5jdGlvbiBwcm9kdWNlcyBleGNlcHRpb25cbiAgICAgICAgLy8gIGNoZWNrIHRoaXMgY29uZGl0aW9uIGluIG91dGVyIHJvdXRpbmVzPyFcbiAgICAgICAgZ2V0VHJhbnNsYXRlZFBhdGg6IGZ1bmN0aW9uKG1hcCwgbGF0bG5ncykge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBuZXcgREcuVmVydGV4VHJhbnNmb3JtKFtdKTtcbiAgICAgICAgICAgIHZhciBpID0gbGF0bG5ncy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdmFyIHYgPSBtYXAucHJvamVjdChsYXRsbmdzW2ldKTtcbiAgICAgICAgICAgIHZhciBkeCA9IHYueCwgZHkgPSB2Lnk7XG5cbiAgICAgICAgICAgIHBhdGgudmVydGljZXMucHVzaChuZXcgREcuUG9pbnQoMCwgMCkpO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIHYgPSBtYXAucHJvamVjdChsYXRsbmdzW2ldKTtcbiAgICAgICAgICAgICAgICBwYXRoLnZlcnRpY2VzLnB1c2gobmV3IERHLlBvaW50KHYueCAtIGR4LCB2LnkgLSBkeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhdGhcbiAgICAgICAgICAgICAgICAuc2V0QW5nbGUoREcuVmVydGV4VHJhbnNmb3JtLmdldEFuZ2xlKC1wYXRoLnZlcnRpY2VzWzFdLngsIC1wYXRoLnZlcnRpY2VzWzFdLnkpKVxuICAgICAgICAgICAgICAgIC51blJvdGF0ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24ocmluZ3MsIGFuZ2xlLCB2ZWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBpID0gcmluZ3MubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGNvcyA9IGFuZ2xlLmNvcztcbiAgICAgICAgICAgIHZhciBzaW4gPSBhbmdsZS5zaW47XG4gICAgICAgICAgICB2YXIgZHggPSB2ZWN0b3IueDtcbiAgICAgICAgICAgIHZhciBkeSA9IHZlY3Rvci55O1xuICAgICAgICAgICAgdmFyIHJpbmcsIHgsIHksIGo7XG5cbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICByaW5nID0gcmluZ3NbaV07XG4gICAgICAgICAgICAgICAgaiA9IHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHJpbmdbal0ueCAtIGR4O1xuICAgICAgICAgICAgICAgICAgICB5ID0gcmluZ1tqXS55IC0gZHk7XG4gICAgICAgICAgICAgICAgICAgIHJpbmdbal0ueCA9IHggKiBjb3MgLSB5ICogc2luO1xuICAgICAgICAgICAgICAgICAgICByaW5nW2pdLnkgPSB4ICogc2luICsgeSAqIGNvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIi8qXG4gKiBERy5BcnJvd1RpcFRyYW5zZm9ybSBjbGFzcyBpcyBhIGNvcmUgb2YgYXJyb3cncyB0aXAgY2FsY3VsYXRpb25zXG4gKlxuICogLnN1YlNoYXBlKCkgcm91dGluZSAnYm91bmQnIGFycm93J3MgdGlwIHRvIHRoZSBlbmRpbmcgcG9pbnRzIG9mIC5zdWJQYXRoKClcbiAqIGNhbGN1bGF0ZWQgc2VwYXJhdGVseSBpbiBERy5BcnJvd1BhdGhUcmFuc2Zvcm1cbiAqXG4gKiAgRmluYWwgdHJhbnNsYXRpb24gKHNlZSBERy5FbnRyYW5jZS5BcnJvdykgbW92ZXMgYXJyb3cgb2JqZWN0cyB0byB0aGVpciBvcmlnaW5hbCBwb3NpdGlvbnNcbiAqL1xuXG5ERy5BcnJvd1RpcFRyYW5zZm9ybSA9IERHLlZlcnRleFRyYW5zZm9ybS5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHBhdGgsIHNoYXBlKSB7XG4gICAgICAgIHRoaXMuZHJhd2luZ3MgPSBzaGFwZS5kcmF3aW5nczsgLy8gIHN0YXRpYyBtYXBwaW5nXG4gICAgICAgIHRoaXMuX3ZlcnRpY2VzID0gc2hhcGUudmVydGljZXM7XG5cbiAgICAgICAgdGhpcy5fc2V0U2hhcGUocGF0aCwgc2hhcGUpO1xuICAgIH0sXG5cbiAgICBfc2V0U2hhcGU6IGZ1bmN0aW9uKHBhdGgsIHNoYXBlKSB7XG4gICAgICAgIHZhciBzcCA9IHNoYXBlLnZlcnRpY2VzWzBdO1xuICAgICAgICB2YXIgd2lkdGggPSBNYXRoLmFicyhzcC55KTtcbiAgICAgICAgdmFyIHBsID0gcGF0aC52ZXJ0aWNlc1sxXS54OyAgICAvLyAgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgdmFyIGxlbmd0aCA9IHNwLng7ICAgICAgICAgICAgICAvLyAgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgdmFyIG9mZnNldCA9IHBsIC0gbGVuZ3RoICsgd2lkdGggKyB3aWR0aDtcblxuICAgICAgICBwYXRoLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHBhdGgub2Zmc2V0ID0gbGVuZ3RoICsgKG9mZnNldCA+IDAgPyBvZmZzZXQgOiAwKTtcbiAgICAgICAgaWYgKHBhdGgudmVydGljZXMubGVuZ3RoIDwgMyAmJiBsZW5ndGggPiAtMTApIHtcbiAgICAgICAgICAgIHBhdGgub2Zmc2V0ICs9IDIuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ZlcnRpY2VzID0gdGhpcy5sb2FkKCkudW5UcmFuc2xhdGUoc3ApLnZlcnRpY2VzO1xuICAgIH0sXG5cbiAgICBzdWJTaGFwZTogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMubG9hZCgpLnVuUm90YXRlKHRyYW5zZm9ybS5hbmdsZSkudHJhbnNsYXRlKHRyYW5zZm9ybS5kaXNwbCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0pO1xuIiwiLypcbiAqIERHLkNvbXBsZXhQYXRoIGlzIGEgc2ltcGxlIHZlY3RvciBsYXllciBjbGFzcyB3aXRoIGVtcHR5IC5nZXRFdmVudHMoKSBvYmplY3QoISlcbiAqIEl0J3MgZHJhd2luZyBsb2dpYyBpcyBtYWludGFpbmVkIGluIERHLkVudHJhbmNlLkFycm93IGNsYXNzXG4gKlxuICogX3B4Qm91bmRzIGlzIGEgcGl4ZWwgYm91bmRzIG9mIHRoaXMgZHJhd2luZ3MgYW5kIHRoZXkgYXJlIHVzZWQgaW4gTC5DYW52YXNcbiAqL1xuXG5ERy5Db21wbGV4UGF0aCA9IERHLlBhdGguZXh0ZW5kKHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIGZpbGw6IHRydWUsXG4gICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICBpbnRlcmFjdGl2ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBERy5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX2VtcHR5ID0gW107XG5cbiAgICAgICAgdGhpcy5fcHhFbXB0eSA9IERHLmJvdW5kcyhcbiAgICAgICAgICAgIERHLnBvaW50KDAsIDApLCBERy5wb2ludCgwLCAwKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9weEJvdW5kcyA9IHRoaXMuX3B4RW1wdHk7XG5cbiAgICAgICAgdGhpcy5fdmVydGljZXMgPSBbdGhpcy5fZW1wdHldO1xuICAgICAgICB0aGlzLl9kcmF3aW5ncyA9IFt0aGlzLl9lbXB0eV07XG4gICAgfSxcblxuICAgIGdldEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9LFxuXG4gICAgX3Byb2plY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIHpvb20sIHdlaWdodDtcblxuICAgICAgICBpZiAodGhpcy5fbWFwKSB7XG4gICAgICAgICAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzLnZpc2liaWxpdHkuaXNTaG93biAmJiBvcHRzLnRyYW5zZm9ybVt6b29tXSkge1xuICAgICAgICAgICAgLy8gIE5leHQgbnVtYmVycyB3YXMgZW1waXJpY2FsbHkgc2VsZWN0ZWQgaW4gb3JkZXIgdG8gcHJvdmlkZSB2aXN1YWwgY29tcGxpYW5jZVxuICAgICAgICAgICAgLy8gIHRvIHRoZSBvcmlnaW5hbCBhcnJvdydzIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICB3ZWlnaHQgPSAyLjIgLSAoKDE5IC0gem9vbSkgKiAwLjIpO1xuICAgICAgICAgICAgaWYgKG9wdHMud2VpZ2h0ICE9PSB3ZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0eWxlKHt3ZWlnaHQ6ICt3ZWlnaHQudG9GaXhlZCgyKX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl92ZXJ0aWNlc1swXSA9IG9wdHMudHJhbnNmb3JtW3pvb21dLnZlcnRpY2VzO1xuICAgICAgICAgICAgdGhpcy5fZHJhd2luZ3NbMF0gPSBvcHRzLnRyYW5zZm9ybVt6b29tXS5kcmF3aW5ncztcblxuICAgICAgICAgICAgdGhpcy5fcHhCb3VuZHMgPSBvcHRzLnRyYW5zZm9ybVt6b29tXS5fcHhCb3VuZHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92ZXJ0aWNlc1swXSA9IHRoaXMuX2VtcHR5O1xuICAgICAgICAgICAgdGhpcy5fZHJhd2luZ3NbMF0gPSB0aGlzLl9lbXB0eTtcblxuICAgICAgICAgICAgdGhpcy5fcHhCb3VuZHMgPSB0aGlzLl9weEVtcHR5O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fbWFwKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3VwZGF0ZVBhdGg6IGZ1bmN0aW9uKCkgeyAgLy8gIHVzZWQgaW4gQ2FudmFzIHJlbmRlcmVyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLl91cGRhdGVDb21wbGV4UGF0aCh0aGlzKTtcbiAgICB9XG59KTtcbiIsIi8qXG4gKiBBY3R1YWwgcGFpbnRpbmcgbWV0aG9kcyB0aGF0IGNhbiBkcmF3IGNvbXBsZXggb2JqZWN0cyB3aXRoIGN1cnZlc1xuICpcbiAqIFBvaW50IGNvb3JkaW5hdGVzIG11c3QgYmUgcHJvdmlkZWQgaW4gbGF5ZXIuX3ZlcnRpY2VzIG9iamVjdFxuICogQW5kIHR5cGVzIG9mIGxpbmUgbXVzdCBiZSBwcm92aWRlZCBpbiBsYXllci5fZHJhd2luZ3Mgb2JqZWN0XG4gKi9cblxuREcuZXh0ZW5kKEwuQ2FudmFzLnByb3RvdHlwZSwge1xuICAgIF91cGRhdGVDb21wbGV4UGF0aDogZnVuY3Rpb24obGF5ZXIsIGNsb3NlZCkge1xuICAgICAgICB2YXIgaSwgaiwgaywgZCwgeCwgeSwgX3gsIF95LCAkeCwgJHksIHBvaW50cztcbiAgICAgICAgdmFyIGRyYXdpbmdzID0gbGF5ZXIuX2RyYXdpbmdzO1xuICAgICAgICB2YXIgdmVydGljZXMgPSBsYXllci5fdmVydGljZXM7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cbiAgICAgICAgdGhpcy5fZHJhd25MYXllcnNbbGF5ZXIuX2xlYWZsZXRfaWRdID0gbGF5ZXI7XG5cbiAgICAgICAgLy8gIFRPRE86IERvIHdlIG5lZWQgdG8gZG8gYSAnYmVnaW5QYXRoKCknIGFuZCBwb3NzaWJsZSAnY2xvc2VQYXRoKCknIHBlciByaW5nPyFcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcG9pbnRzID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICB4ID0geSA9IDA7XG4gICAgICAgICAgICBqID0gayA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaiA8IHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkID0gZHJhd2luZ3NbaV1baysrXTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gcG9pbnRzW2pdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gcG9pbnRzW2pdLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHBvaW50c1tqXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBwb2ludHNbal0ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBwb2ludHNbal0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBwb2ludHNbal0ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gcG9pbnRzW2pdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHBvaW50c1tqXS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3ggPSBwb2ludHNbal0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF95ID0gcG9pbnRzW2pdLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAkeCA9IHBvaW50c1tqXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgJHkgPSBwb2ludHNbal0ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBwb2ludHNbal0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBwb2ludHNbal0ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKF94LCBfeSwgJHgsICR5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3ggPSB4ICsgcG9pbnRzW2pdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBfeSA9IHkgKyBwb2ludHNbal0ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICR4ID0geCArIHBvaW50c1tqXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgJHkgPSB5ICsgcG9pbnRzW2pdLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0geCArIHBvaW50c1tqXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHkgKyBwb2ludHNbal0ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKF94LCBfeSwgJHgsICR5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3ggPSBwb2ludHNbal0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF95ID0gcG9pbnRzW2pdLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gcG9pbnRzW2pdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gcG9pbnRzW2pdLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhfeCwgX3ksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBfeCA9IHggKyBwb2ludHNbal0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF95ID0geSArIHBvaW50c1tqXS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHggKyBwb2ludHNbal0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB5ICsgcG9pbnRzW2pdLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhfeCwgX3ksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG4gICAgfVxufSk7XG5cblxuREcuZXh0ZW5kKEwuU1ZHLnByb3RvdHlwZSwge1xuICAgIF91cGRhdGVDb21wbGV4UGF0aDogZnVuY3Rpb24obGF5ZXIsIGNsb3NlZCkge1xuICAgICAgICB0aGlzLl9zZXRQYXRoKGxheWVyLCBMLlNWRy5jb21wbGV4UG9pbnRzVG9QYXRoKGxheWVyLl92ZXJ0aWNlcywgbGF5ZXIuX2RyYXdpbmdzLCBjbG9zZWQpKTtcbiAgICB9XG59KTtcblxuXG5ERy5leHRlbmQoTC5TVkcsIHtcbiAgICBjb21wbGV4UG9pbnRzVG9QYXRoOiBmdW5jdGlvbih2ZXJ0aWNlcywgZHJhd2luZ3MsIGNsb3NlZCkge1xuICAgICAgICB2YXIgc3RyID0gJyc7XG4gICAgICAgIHZhciBzdmcgPSBERy5Ccm93c2VyLnN2ZztcbiAgICAgICAgdmFyIGksIGosIGssIG4sIGQsIHBvaW50cztcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBvaW50cyA9IHZlcnRpY2VzW2ldO1xuXG4gICAgICAgICAgICAvLyAgU3BlZWR1cCBob3QgcGF0aCBieSByZW1vdmluZyBpZi90ZXJuYXJ5IGNvbmRpdGlvbiBjaGVja3MgYnV0IGR1cGxpY2F0aW5nIGxvb3BzXG4gICAgICAgICAgICBpZiAoc3ZnKSB7XG4gICAgICAgICAgICAgICAgaiA9IGsgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkID0gZHJhd2luZ3NbaV1baysrXTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOiAgIG4gPSAzOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncSc6ICAgbiA9IDI7IGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiAgICBuID0gMTsgIC8vICAnTScsICdtJywgJ0wnLCAnbCcsIC4uLlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBkO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gcG9pbnRzW2pdLngudG9GaXhlZCg0KSArICcsJyArIHBvaW50c1tqXS55LnRvRml4ZWQoNCkgKyAnICc7XG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vICB2bWwgaW4gSUU4IGNhbiBzdXBwb3J0IG9ubHkgaW50ZWdlciB2YWx1ZXMgaW4gJ3BhdGgnLCBzb3JyeSBhYm91dCBsb3NzIG9mIHByZWNpc2lvblxuICAgICAgICAgICAgICAgIGogPSBrID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGRyYXdpbmdzW2ldW2srK107XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnTSc6ICAgZCA9ICdtJzsgbiA9IDE7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6ICAgZCA9ICd0JzsgbiA9IDE7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnTCc6ICAgZCA9ICdsJzsgbiA9IDE7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6ICAgZCA9ICdyJzsgbiA9IDE7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnQyc6ICAgZCA9ICdjJzsgbiA9IDM7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6ICAgZCA9ICd2JzsgbiA9IDM7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIFZNTCBzcGVjIGhhcyAncWInIGNvbW1hbmQgaW4gJ3YnIGF0dHJpYnV0ZSBzdHJpbmcgYnV0IG5vICdyZWxhdGl2ZVRvJyBjb21wbGltZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIFNvIHdlJ2xsIGVtdWxhdGUgQ3ViaWMgQsOpemllciBjdXJ2ZSBieSBhcHBseWluZyBRdWFkcmF0aWMgdmFyaWFudCBpbiBib3RoIGNhc2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIFRPRE86IEJvdGggY29udHJvbCBwb2ludHMgd2lsbCB1c2UgdGhlIHNhbWUgdmFsdWUgYnV0IHRoaXMgaXMgbm90IHRydWUgc29sdXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ0MnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzW2pdLngudG9GaXhlZCgwKSArICcsJyArIHBvaW50c1tqXS55LnRvRml4ZWQoMCkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbal0ueC50b0ZpeGVkKDApICsgJywnICsgcG9pbnRzW2pdLnkudG9GaXhlZCgwKSArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1tqICsgMV0ueC50b0ZpeGVkKDApICsgJywnICsgcG9pbnRzW2ogKyAxXS55LnRvRml4ZWQoMCkgKyAnICc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnYycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbal0ueC50b0ZpeGVkKDApICsgJywnICsgcG9pbnRzW2pdLnkudG9GaXhlZCgwKSArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1tqXS54LnRvRml4ZWQoMCkgKyAnLCcgKyBwb2ludHNbal0ueS50b0ZpeGVkKDApICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzW2ogKyAxXS54LnRvRml4ZWQoMCkgKyAnLCcgKyBwb2ludHNbaiArIDFdLnkudG9GaXhlZCgwKSArICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiAgICBuID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gZDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG4tLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHBvaW50c1tqXS54LnRvRml4ZWQoMCkgKyAnLCcgKyBwb2ludHNbal0ueS50b0ZpeGVkKDApICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHIgKz0gY2xvc2VkID8gKHN2ZyA/ICd6JyA6ICd4JykgOiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNWRyBjb21wbGFpbnMgYWJvdXQgZW1wdHkgcGF0aCBzdHJpbmdzXG4gICAgICAgIHJldHVybiBzdHIgfHwgJ20wLDAnO1xuICAgIH1cbn0pO1xuIiwiLypcbiAqIERHQmV6aWVyQ3VydmVzIGlzIGEgY29sbGVjdGlvbiBvZiB0aHJlZSBjbGFzc2VzOlxuICogT3JpZ2luYWwgREcuQmV6aWVyIGNsYXNzIHByb3ZpZGVzIGJhc2ljIG1hdGggZm9yIEN1YmljIGFuZCBRdWFkcmF0aWMgQsOpemllciBjdXJ2ZXNcbiAqIERHLlRpbWVCZXppZXIgdXNlZCBpbiBhbmltYXRpb24gZWZmZWN0cyBpdCBjYW4gcmV0dXJuICdEaXN0YW5jZScgKFkpIGJ5IFRpbWUgKFgpIHZhbHVlXG4gKiBERy5BcmNCZXppZXIgY2FuIHJldHVybiAndCcgdmFsdWUgYnkgY3VydmUncyBzZWdtZW50IGxlbmd0aFxuICogQWN0dWFsIGNhbGN1bGF0aW9ucyBjYW4gYmUgdmVyeSBoYXJkIChpbiBtYXRoIHRlcm1zKSBzbyB3ZSB1c2UgTFVUJ3MgdG8gb3B0aW1pemUgdGhlbVxuICpcbiAqIE9yaWdpbmFsIGlkZWFzIGNvbWUgZnJvbSB0aGlzIHNvdXJjZTogICBodHRwczovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvL1xuICovXG5cbkRHLkJlemllciA9IERHLkNsYXNzLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBjdXJ2ZSBvYmplY3QgYnkgcHJvdmlkZWQgY29udHJvbCBwb2ludHNcbiAgICAgKiBAcGFyYW0ge0FycmF5PERHLlBvaW50Pn0gY29vcmRzIEN1cnZlJ3MgY29udHJvbCBwb2ludHMgaW4gREcuUG9pbnQgZm9ybWF0ICh1cCB0byBmb3VyIGNvbnRyb2wgcG9pbnRzIHN1cHBvcnRlZClcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjbG9uZV0gQ2xvbmUgb3JpZ2luYWwgcG9pbnRzIG9yIG5vdCAoRGVmYXVsdClcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihjb29yZHMsIGNsb25lKSB7XG4gICAgICAgIGlmIChjbG9uZSkge1xuICAgICAgICAgICAgdGhpcy5wb2ludHMgPSBjb29yZHMubWFwKGZ1bmN0aW9uKGNvb3JkKSB7IHJldHVybiBjb29yZC5jbG9uZSgpOyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucG9pbnRzID0gY29vcmRzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHBvaW50cyA9IHRoaXMuX2dldERlcml2YXRpdmVzKCk7XG4gICAgICAgIHRoaXMub3JkZXIgPSB0aGlzLnBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLl9sdXQgPSBbXTtcbiAgICB9LFxuXG4gICAgZ2V0UG9pbnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIG10LCBtdDIsIHQyO1xuICAgICAgICB2YXIgYSwgYiwgYywgZDtcblxuICAgICAgICBpZiAodCA9PT0gMCkgeyByZXR1cm4gcFswXTsgfVxuICAgICAgICBpZiAodCA9PT0gMSkgeyByZXR1cm4gcFt0aGlzLm9yZGVyXTsgfVxuXG4gICAgICAgIG10ID0gMSAtIHQ7XG4gICAgICAgIG10MiA9IG10ICogbXQ7XG4gICAgICAgIHQyID0gdCAqIHQ7XG5cbiAgICAgICAgaWYgKHRoaXMub3JkZXIgPiAyKSB7XG4gICAgICAgICAgICBhID0gbXQyICogbXQ7XG4gICAgICAgICAgICBiID0gbXQyICogdCAqIDM7XG4gICAgICAgICAgICBjID0gbXQgKiB0MiAqIDM7XG4gICAgICAgICAgICBkID0gdCAqIHQyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IFtwWzBdLCBwWzFdLCBwWzJdLCB7eDogMCwgeTogMH1dO1xuICAgICAgICAgICAgYSA9IG10MjtcbiAgICAgICAgICAgIGIgPSBtdCAqIHQgKiAyO1xuICAgICAgICAgICAgYyA9IHQyO1xuICAgICAgICAgICAgZCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERHLlBvaW50KFxuICAgICAgICAgICAgYSAqIHBbMF0ueCArIGIgKiBwWzFdLnggKyBjICogcFsyXS54ICsgZCAqIHBbM10ueCxcbiAgICAgICAgICAgIGEgKiBwWzBdLnkgKyBiICogcFsxXS55ICsgYyAqIHBbMl0ueSArIGQgKiBwWzNdLnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgZGVyaXZhdGl2ZTogZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMuZHBvaW50c1swXTtcbiAgICAgICAgdmFyIG10ID0gMSAtIHQ7XG4gICAgICAgIHZhciBhLCBiLCBjO1xuXG4gICAgICAgIGlmICh0aGlzLm9yZGVyID4gMikge1xuICAgICAgICAgICAgYSA9IG10ICogbXQ7XG4gICAgICAgICAgICBiID0gbXQgKiB0ICogMjtcbiAgICAgICAgICAgIGMgPSB0ICogdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgPSBbcFswXSwgcFsxXSwge3g6IDAsIHk6IDB9XTtcbiAgICAgICAgICAgIGEgPSBtdDsgYiA9IHQ7IGMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBERy5Qb2ludChcbiAgICAgICAgICAgIGEgKiBwWzBdLnggKyBiICogcFsxXS54ICsgYyAqIHBbMl0ueCxcbiAgICAgICAgICAgIGEgKiBwWzBdLnkgKyBiICogcFsxXS55ICsgYyAqIHBbMl0ueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgICAgICAgdmFyIHdfaSA9IERHLkJlemllci5XRUlHSFQ7XG4gICAgICAgIHZhciB4X2kgPSBERy5CZXppZXIuQUJTQ0lTU0E7XG4gICAgICAgIHZhciB6ID0gMC41O1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgdmFyIGQsIGwsIHQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4X2kubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHQgPSB6ICogeF9pW2ldICsgejtcbiAgICAgICAgICAgIGQgPSB0aGlzLmRlcml2YXRpdmUodCk7XG4gICAgICAgICAgICBsID0gZC54ICogZC54ICsgZC55ICogZC55O1xuICAgICAgICAgICAgc3VtICs9IHdfaVtpXSAqIE1hdGguc3FydChsKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuXG4gICAgICAgIHJldHVybiB6ICogc3VtO1xuICAgIH0sXG5cbiAgICBnZXRDdXJ2ZUJlZm9yZTogZnVuY3Rpb24oeikge1xuICAgICAgICB2YXIgcCA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgejIsIHozLCBteiwgbXoyLCBtejM7XG4gICAgICAgIHZhciBiJDMsIGIkNCwgYyQ0O1xuICAgICAgICB2YXIgY3VydmU7XG5cbiAgICAgICAgaWYgKHogPT09IDEpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKTsgfVxuXG4gICAgICAgIGN1cnZlID0gW107XG4gICAgICAgIHoyID0geiAqIHo7XG4gICAgICAgIG16ID0geiAtIDE7XG4gICAgICAgIG16MiA9IG16ICogbXo7XG5cbiAgICAgICAgY3VydmVbMF0gPSBuZXcgREcuUG9pbnQoXG4gICAgICAgICAgICBwWzBdLngsXG4gICAgICAgICAgICBwWzBdLnlcbiAgICAgICAgKTtcblxuICAgICAgICBjdXJ2ZVsxXSA9IG5ldyBERy5Qb2ludChcbiAgICAgICAgICAgIHogKiBwWzFdLnggLSBteiAqIHBbMF0ueCxcbiAgICAgICAgICAgIHogKiBwWzFdLnkgLSBteiAqIHBbMF0ueVxuICAgICAgICApO1xuXG4gICAgICAgIGIkMyA9IHogKiBteiAqIDI7XG4gICAgICAgIGN1cnZlWzJdID0gbmV3IERHLlBvaW50KFxuICAgICAgICAgICAgejIgKiBwWzJdLnggLSBiJDMgKiBwWzFdLnggKyBtejIgKiBwWzBdLngsXG4gICAgICAgICAgICB6MiAqIHBbMl0ueSAtIGIkMyAqIHBbMV0ueSArIG16MiAqIHBbMF0ueVxuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0aGlzLm9yZGVyID4gMikge1xuICAgICAgICAgICAgejMgPSB6MiAqIHo7XG4gICAgICAgICAgICBtejMgPSBtejIgKiBtejtcbiAgICAgICAgICAgIGIkNCA9IHoyICogbXogKiAzO1xuICAgICAgICAgICAgYyQ0ID0geiAqIG16MiAqIDM7XG4gICAgICAgICAgICBjdXJ2ZVszXSA9IG5ldyBERy5Qb2ludChcbiAgICAgICAgICAgICAgICB6MyAqIHBbM10ueCAtIGIkNCAqIHBbMl0ueCArIGMkNCAqIHBbMV0ueCAtIG16MyAqIHBbMF0ueCxcbiAgICAgICAgICAgICAgICB6MyAqIHBbM10ueSAtIGIkNCAqIHBbMl0ueSArIGMkNCAqIHBbMV0ueSAtIG16MyAqIHBbMF0ueVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgREcuQmV6aWVyKGN1cnZlKTtcbiAgICB9LFxuXG4gICAgZ2V0Q3VydmVBZnRlcjogZnVuY3Rpb24oeikge1xuICAgICAgICB2YXIgcCA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgbiA9IHRoaXMub3JkZXI7XG4gICAgICAgIHZhciB6MiwgejMsIG16LCBtejIsIG16MztcbiAgICAgICAgdmFyIGIkMywgYiQ0LCBjJDQ7XG4gICAgICAgIHZhciBjdXJ2ZTtcblxuICAgICAgICBpZiAoeiA9PT0gMSkgeyByZXR1cm4gdGhpcy5jbG9uZSgpOyB9XG5cbiAgICAgICAgY3VydmUgPSBbXTtcbiAgICAgICAgejIgPSB6ICogejtcbiAgICAgICAgbXogPSB6IC0gMTtcbiAgICAgICAgbXoyID0gbXogKiBtejtcblxuICAgICAgICBjdXJ2ZVtuXSA9IG5ldyBERy5Qb2ludChcbiAgICAgICAgICAgIHBbbl0ueCxcbiAgICAgICAgICAgIHBbbl0ueVxuICAgICAgICApO1xuXG4gICAgICAgIGN1cnZlWy0tbl0gPSBuZXcgREcuUG9pbnQoXG4gICAgICAgICAgICB6ICogcFtuICsgMV0ueCAtIG16ICogcFtuXS54LFxuICAgICAgICAgICAgeiAqIHBbbiArIDFdLnkgLSBteiAqIHBbbl0ueVxuICAgICAgICApO1xuXG4gICAgICAgIGIkMyA9IHogKiBteiAqIDI7XG4gICAgICAgIGN1cnZlWy0tbl0gPSBuZXcgREcuUG9pbnQoXG4gICAgICAgICAgICB6MiAqIHBbbiArIDJdLnggLSBiJDMgKiBwW24gKyAxXS54ICsgbXoyICogcFtuXS54LFxuICAgICAgICAgICAgejIgKiBwW24gKyAyXS55IC0gYiQzICogcFtuICsgMV0ueSArIG16MiAqIHBbbl0ueVxuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0aGlzLm9yZGVyID4gMikge1xuICAgICAgICAgICAgejMgPSB6MiAqIHo7XG4gICAgICAgICAgICBtejMgPSBtejIgKiBtejtcbiAgICAgICAgICAgIGIkNCA9IHoyICogbXogKiAzO1xuICAgICAgICAgICAgYyQ0ID0geiAqIG16MiAqIDM7XG4gICAgICAgICAgICBjdXJ2ZVstLW5dID0gbmV3IERHLlBvaW50KFxuICAgICAgICAgICAgICAgIHozICogcFtuICsgM10ueCAtIGIkNCAqIHBbbiArIDJdLnggKyBjJDQgKiBwW24gKyAxXS54IC0gbXozICogcFtuXS54LFxuICAgICAgICAgICAgICAgIHozICogcFtuICsgM10ueSAtIGIkNCAqIHBbbiArIDJdLnkgKyBjJDQgKiBwW24gKyAxXS55IC0gbXozICogcFtuXS55XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBERy5CZXppZXIoY3VydmUpO1xuICAgIH0sXG5cbiAgICBfZ2V0RGVyaXZhdGl2ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgZCwgYywgaiwgbGlzdDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvciAoZCA9IHAubGVuZ3RoLCBjID0gZCAtIDE7IGQgPiAxOyBkLS0sIGMtLSkge1xuICAgICAgICAgICAgbGlzdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGM7IGorKykge1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaChuZXcgREcuUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgIGMgKiAocFtqICsgMV0ueCAtIHBbal0ueCksXG4gICAgICAgICAgICAgICAgICAgIGMgKiAocFtqICsgMV0ueSAtIHBbal0ueSlcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxpc3QpO1xuICAgICAgICAgICAgcCA9IGxpc3Q7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRMVVQ6IGZ1bmN0aW9uKHN0ZXBzKSB7XG4gICAgICAgIHN0ZXBzID0gc3RlcHMgfHwgMTI1O1xuXG4gICAgICAgIGlmICh0aGlzLl9sdXQubGVuZ3RoICE9PSBzdGVwcyArIDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9yZGVyID4gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldExVVDMoc3RlcHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRMVVQyKHN0ZXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9sdXQ7XG4gICAgfSxcblxuICAgIF9zZXRMVVQyOiBmdW5jdGlvbihzdGVwcykge1xuICAgICAgICB2YXIgbHV0ID0gdGhpcy5fbHV0ID0gW107XG4gICAgICAgIHZhciBwID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHZhciB0LCBtdDtcbiAgICAgICAgdmFyIGEsIGIsIGM7XG5cbiAgICAgICAgbHV0LnB1c2goe3g6IHBbMF0ueCwgeTogcFswXS55LCBsOiAwfSk7XG4gICAgICAgIGZvciAodmFyIHMgPSAxOyBzIDwgc3RlcHM7IHMrKykge1xuICAgICAgICAgICAgdCA9IHMgLyBzdGVwcztcbiAgICAgICAgICAgIG10ID0gMSAtIHQ7XG4gICAgICAgICAgICBhID0gbXQgKiBtdDtcbiAgICAgICAgICAgIGIgPSBtdCAqIHQgKiAyO1xuICAgICAgICAgICAgYyA9IHQgKiB0O1xuICAgICAgICAgICAgbHV0LnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IGEgKiBwWzBdLnggKyBiICogcFsxXS54ICsgYyAqIHBbMl0ueCxcbiAgICAgICAgICAgICAgICB5OiBhICogcFswXS55ICsgYiAqIHBbMV0ueSArIGMgKiBwWzJdLnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGx1dC5wdXNoKHt4OiBwWzJdLngsIHk6IHBbMl0ueSwgbDogMH0pO1xuICAgIH0sXG5cbiAgICBfc2V0TFVUMzogZnVuY3Rpb24oc3RlcHMpIHtcbiAgICAgICAgdmFyIGx1dCA9IHRoaXMuX2x1dCA9IFtdO1xuICAgICAgICB2YXIgcCA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgdCwgdDIsIG10LCBtdDI7XG4gICAgICAgIHZhciBhLCBiLCBjLCBkO1xuXG4gICAgICAgIGx1dC5wdXNoKHt4OiBwWzBdLngsIHk6IHBbMF0ueSwgbDogMH0pO1xuICAgICAgICBmb3IgKHZhciBzID0gMTsgcyA8IHN0ZXBzOyBzKyspIHtcbiAgICAgICAgICAgIHQgPSBzIC8gc3RlcHM7XG4gICAgICAgICAgICBtdCA9IDEgLSB0O1xuICAgICAgICAgICAgbXQyID0gbXQgKiBtdDtcbiAgICAgICAgICAgIHQyID0gdCAqIHQ7XG4gICAgICAgICAgICBhID0gbXQyICogbXQ7XG4gICAgICAgICAgICBiID0gbXQyICogdCAqIDM7XG4gICAgICAgICAgICBjID0gbXQgKiB0MiAqIDM7XG4gICAgICAgICAgICBkID0gdCAqIHQyO1xuICAgICAgICAgICAgbHV0LnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IGEgKiBwWzBdLnggKyBiICogcFsxXS54ICsgYyAqIHBbMl0ueCArIGQgKiBwWzNdLngsXG4gICAgICAgICAgICAgICAgeTogYSAqIHBbMF0ueSArIGIgKiBwWzFdLnkgKyBjICogcFsyXS55ICsgZCAqIHBbM10ueVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbHV0LnB1c2goe3g6IHBbM10ueCwgeTogcFszXS55LCBsOiAwfSk7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBERy5CZXppZXIodGhpcy5wb2ludHMsIHRydWUpO1xuICAgIH1cbn0pO1xuXG5ERy5iZXppZXIgPSBmdW5jdGlvbihjb29yZHMpIHtcbiAgICBpZiAodHlwZW9mIGNvb3JkcyA9PT0gJ251bWJlcicgfHwgY29vcmRzIGluc3RhbmNlb2YgREcuUG9pbnQpIHtcbiAgICAgICAgY29vcmRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvb3Jkc1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGNvb3Jkcy5sZW5ndGggPCA3KSB7XG4gICAgICAgICAgICBjb29yZHMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IERHLlBvaW50KGNvb3Jkc1swXSwgY29vcmRzWzFdKSxcbiAgICAgICAgICAgICAgICBuZXcgREcuUG9pbnQoY29vcmRzWzJdLCBjb29yZHNbM10pLFxuICAgICAgICAgICAgICAgIG5ldyBERy5Qb2ludChjb29yZHNbNF0sIGNvb3Jkc1s1XSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb29yZHMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IERHLlBvaW50KGNvb3Jkc1swXSwgY29vcmRzWzFdKSxcbiAgICAgICAgICAgICAgICBuZXcgREcuUG9pbnQoY29vcmRzWzJdLCBjb29yZHNbM10pLFxuICAgICAgICAgICAgICAgIG5ldyBERy5Qb2ludChjb29yZHNbNF0sIGNvb3Jkc1s1XSksXG4gICAgICAgICAgICAgICAgbmV3IERHLlBvaW50KGNvb3Jkc1s2XSwgY29vcmRzWzddKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERHLkJlemllcihjb29yZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgREcuQmV6aWVyKGNvb3JkcywgdHJ1ZSk7XG4gICAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG5ERy5CZXppZXIuV0VJR0hUID0gW1xuICAgIDAuMzYyNjgzNzgzMzc4MzYyMCxcbiAgICAwLjM2MjY4Mzc4MzM3ODM2MjAsXG4gICAgMC4zMTM3MDY2NDU4Nzc4ODczLFxuICAgIDAuMzEzNzA2NjQ1ODc3ODg3MyxcbiAgICAwLjIyMjM4MTAzNDQ1MzM3NDUsXG4gICAgMC4yMjIzODEwMzQ0NTMzNzQ1LFxuICAgIDAuMTAxMjI4NTM2MjkwMzc2MyxcbiAgICAwLjEwMTIyODUzNjI5MDM3NjNcbl07XG5ERy5CZXppZXIuQUJTQ0lTU0EgPSBbXG4gICAtMC4xODM0MzQ2NDI0OTU2NDk4LFxuICAgIDAuMTgzNDM0NjQyNDk1NjQ5OCxcbiAgIC0wLjUyNTUzMjQwOTkxNjMyOTAsXG4gICAgMC41MjU1MzI0MDk5MTYzMjkwLFxuICAgLTAuNzk2NjY2NDc3NDEzNjI2NyxcbiAgICAwLjc5NjY2NjQ3NzQxMzYyNjcsXG4gICAtMC45NjAyODk4NTY0OTc1MzYzLFxuICAgIDAuOTYwMjg5ODU2NDk3NTM2M1xuXTtcbi8qIGVzbGludC1lbmFibGUgaW5kZW50ICovXG5cblxuLy8gIFRoaXMgY3VydmUgaXMgbW9ub3RvbmljYWxseSBvcmRlcmVkIGJ5ICdYJyBjb29yZGluYXRlIGFuZCBoYXMgUFswXSA9IHswLCAwfSBhbmQgUFszXSA9IHsxLCAxfVxuLy8gIFdlIGNhbiB1dGlsaXplIHRoaXMgZmFjdHMgdG8gc2hvcnRjdXQgY2FsY3VsYXRpb25zXG5ERy5UaW1lQmV6aWVyID0gREcuQmV6aWVyLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY29udHJvbFBvaW50MSwgY29udHJvbFBvaW50MiwgY2xvbmUpIHtcbiAgICAgICAgREcuQmV6aWVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgW0RHLlRpbWVCZXppZXIuU1RBUlQsIGNvbnRyb2xQb2ludDEsIGNvbnRyb2xQb2ludDIsIERHLlRpbWVCZXppZXIuRU5EXSxcbiAgICAgICAgICAgIGNsb25lXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGdldFlieVg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIGx1dCA9IHRoaXMuZ2V0TFVUKCk7XG4gICAgICAgIHZhciBtYXggPSBsdXQubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIG1pbiA9IDA7XG4gICAgICAgIHZhciBtaWQ7XG5cbiAgICAgICAgaWYgKHggPD0gMCkgeyByZXR1cm4gMDsgfVxuICAgICAgICBpZiAoeCA+PSAxKSB7IHJldHVybiAxOyB9XG5cbiAgICAgICAgLy8gICdYJyBpcyBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgc28gd2UgY2FuIGRvIGEgc2ltcGxlIGJpbmFyeSBzZWFyY2ggKExVVClcbiAgICAgICAgLy8gIGFuZCB0aGVuIGZpbmUtdHVuZSB0aGUgcmVzdWx0IGJ5IGxpbmVhciBpbnRlcnBvbGF0aW9uIGFzc3VtaW5nICdZJyBpcyBub3QgY2hhbmdlZCBzbyByYWRpY2FsbHlcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIG1pZCA9IG1pbiArIChtYXggLSBtaW4gPj4gMSk7XG4gICAgICAgICAgICBpZiAoeCA8IGx1dFttaWRdLngpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBtaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pbiA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXggLSBtaW4gPCAyKSB7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgeCA9ICh4IC0gbHV0W21pbl0ueCkgLyAobHV0W21heF0ueCAtIGx1dFttaW5dLngpO1xuXG4gICAgICAgIHJldHVybiAobHV0W21pbl0ueSArIChsdXRbbWF4XS55IC0gbHV0W21pbl0ueSkgKiB4KTtcbiAgICB9LFxuXG4gICAgZ2V0TFVUOiBmdW5jdGlvbihzdGVwcykge1xuICAgICAgICB2YXIgcCA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgdCwgdDIsIG10O1xuICAgICAgICB2YXIgYiwgYywgZDtcbiAgICAgICAgdmFyIGx1dDtcblxuICAgICAgICBzdGVwcyA9IHN0ZXBzIHx8IDI0MDtcbiAgICAgICAgaWYgKHRoaXMuX2x1dC5sZW5ndGggPT09IHN0ZXBzICsgMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2x1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2x1dCA9IGx1dCA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgbHV0LnB1c2goe3g6IDAsIHk6IDB9KTtcbiAgICAgICAgZm9yICh2YXIgcyA9IDE7IHMgPCBzdGVwczsgcysrKSB7XG4gICAgICAgICAgICB0ID0gcyAvIHN0ZXBzO1xuICAgICAgICAgICAgbXQgPSAxIC0gdDtcbiAgICAgICAgICAgIHQyID0gdCAqIHQ7XG4gICAgICAgICAgICAvLyAgV2UgZG9uJ3QgbmVlZCAnYScgY29lZmZpY2llbnQgYmVjYXVzZSBwWzBdIGlzIHswLCAwfVxuICAgICAgICAgICAgYiA9IG10ICogbXQgKiB0ICogMztcbiAgICAgICAgICAgIGMgPSBtdCAqIHQyICogMztcbiAgICAgICAgICAgIGQgPSB0ICogdDI7XG4gICAgICAgICAgICBsdXQucHVzaCh7XG4gICAgICAgICAgICAgICAgeDogYiAqIHBbMV0ueCArIGMgKiBwWzJdLnggKyBkLFxuICAgICAgICAgICAgICAgIHk6IGIgKiBwWzFdLnkgKyBjICogcFsyXS55ICsgZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbHV0LnB1c2goe3g6IDEsIHk6IDF9KTtcblxuICAgICAgICByZXR1cm4gbHV0O1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgREcuVGltZUJlemllcih0aGlzLnBvaW50cywgdHJ1ZSk7XG4gICAgfVxufSk7XG5cbkRHLlRpbWVCZXppZXIuU1RBUlQgPSBERy5wb2ludCgwLCAwKTtcbkRHLlRpbWVCZXppZXIuRU5EID0gREcucG9pbnQoMSwgMSk7XG5cblxuLy8gIFRoaXMgaXMgY3ViaWMgQmV6aWVyIGRlc2NyaWJpbmcgY2lyY3VsYXIgYXJjXG5ERy5BcmNCZXppZXIgPSBERy5CZXppZXIuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihjb29yZHMsIGNsb25lKSB7XG4gICAgICAgIERHLkJlemllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGNvb3JkcywgY2xvbmUpO1xuICAgICAgICB0aGlzLmdldExVVCgpO1xuICAgICAgICB0aGlzLl9zZXRMdXRMZW5ndGhzKCk7XG4gICAgfSxcblxuICAgIGdldFRieUw6IGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgdmFyIGx1dCA9IHRoaXMuZ2V0TFVUKCk7XG4gICAgICAgIHZhciBtYXggPSBsdXQubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIG1pbiA9IDA7XG4gICAgICAgIHZhciBtaWQ7XG4gICAgICAgIHZhciB4LCB5O1xuXG4gICAgICAgIGlmIChsIDw9IDApIHsgcmV0dXJuIDA7IH1cbiAgICAgICAgaWYgKGwgPj0gbHV0W21heF0ubCkgeyByZXR1cm4gMTsgfVxuXG4gICAgICAgIC8vICAnTCcgaXMgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIHNvIHdlIGNhbiBkbyBhIGJpbmFyeSBzZWFyY2ggKExVVClcbiAgICAgICAgLy8gIGFuZCB0aGVuIGZpbmUtdHVuZSB0aGUgcmVzdWx0IGJ5IGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBtaWQgPSBtaW4gKyAobWF4IC0gbWluID4+IDEpO1xuICAgICAgICAgICAgaWYgKGwgPCBsdXRbbWlkXS5sKSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gbWlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4IC0gbWluIDwgMikgeyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICAgIGwgPSAobCAtIGx1dFttaW5dLmwpIC8gKGx1dFttYXhdLmwgLSBsdXRbbWluXS5sKTtcblxuICAgICAgICB4ID0gKGx1dFttaW5dLnggKyAobHV0W21heF0ueCAtIGx1dFttaW5dLngpICogbCk7XG4gICAgICAgIHkgPSAobHV0W21pbl0ueSArIChsdXRbbWF4XS55IC0gbHV0W21pbl0ueSkgKiBsKTtcblxuICAgICAgICAvLyAgQlVUIHRoaXMgaXMgYSBwYXJ0IG9mIHN0b3J5LCB3ZSBuZWVkIGEgcHJvamVjdGlvbiBvZiB0aGlzIHBvaW50IHRvIHRoZSBhY3R1YWwgY3VydmUgYW5kIGl0J3MgcmV2ZXJzZSAndCcgdmFsXG4gICAgICAgIHZhciBwLCBkeCwgZHksIHQ7XG4gICAgICAgIHZhciBldCA9IG1heCAvIGx1dC5sZW5ndGg7XG4gICAgICAgIHZhciBkdCA9IG1pbiAvIGx1dC5sZW5ndGg7XG4gICAgICAgIHZhciBzID0gMSAvIGx1dC5sZW5ndGggLyAxMDsgICAgLy8gIFRPRE9cbiAgICAgICAgdmFyIGQgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG4gICAgICAgIGZvciAodCA9IGR0OyBkdCA8IGV0OyBkdCArPSBzKSB7XG4gICAgICAgICAgICBwID0gdGhpcy5nZXRQb2ludChkdCk7XG4gICAgICAgICAgICBkeCA9IHAueCAtIHg7IGR5ID0gcC55IC0geTtcbiAgICAgICAgICAgIGwgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgaWYgKGwgPCBkKSB7XG4gICAgICAgICAgICAgICAgZCA9IGw7XG4gICAgICAgICAgICAgICAgdCA9IGR0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSxcblxuICAgIF9zZXRMdXRMZW5ndGhzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGx1dCA9IHRoaXMuX2x1dDtcbiAgICAgICAgdmFyIGR4LCBkeTtcblxuICAgICAgICBsdXRbMF0ubCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkeCA9IGx1dFtpXS54IC0gbHV0W2kgLSAxXS54O1xuICAgICAgICAgICAgZHkgPSBsdXRbaV0ueSAtIGx1dFtpIC0gMV0ueTtcbiAgICAgICAgICAgIGx1dFtpXS5sID0gbHV0W2kgLSAxXS5sICsgTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbHV0W3RoaXMuX2x1dC5sZW5ndGggLSAxXS5sO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgREcuQXJjQmV6aWVyKHRoaXMucG9pbnRzLCB0cnVlKTtcbiAgICB9XG59KTtcbiIsIi8qXG4gKiBERy5BbmltYXRpb24gcHJvdmlkZXMgdGljayAoc3RlcCkgbG9naWMgcmV0dXJuaW5nIHByb2dyZXNzaW9uIHZhbHVlc1xuICogY2FsY3VsYXRlZCBvdmVyIHByb3ZpZGVkIG9yIGN1c3RvbSBCw6l6aWVyIGN1cnZlc1xuICogT3JpZ2luYWwgaW5wdXQgY2FuIGJlIGFycmF5IG9iamVjdCBidHcuLi5cbiAqL1xuXG5ERy5BbmltYXRpb24gPSBERy5FdmVudGVkLmV4dGVuZCh7XG4gICAgb3B0aW9uczoge1xuICAgICAgICAvLyBhbmltYXRpb246IHsgICAgLy8gIE9yIGFycmF5IG9mIG9iamVjdHNcbiAgICAgICAgLy8gICAgIGZ1bmN0aW9uOiBERy5BbmltYXRpb24uRUFTRSxcbiAgICAgICAgLy8gICAgIGR1cmF0aW9uOiAyMDAwLFxuICAgICAgICAvLyAgICAgZnJhbWVzOiBudWxsXG4gICAgICAgIC8vIH1cblxuICAgICAgICAvL29mZnNldDogMFxuICAgICAgICAvL3JlcGVhdDogMFxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIERHLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fYW5pbUlEID0gLTE7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IDA7XG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZHVyYXRpb25zID0gbnVsbDtcbiAgICB9LFxuXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5fcHJlcGFyZSgpO1xuXG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuZmlyZSgnc3RhcnQnKTtcblxuICAgICAgICAvLyAgRGF0ZS5ub3coKSwgYnV0Li4uIElFOStcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgdGhpcy5fYW5pbWF0ZSgpO1xuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3J1bih0aGlzLl9kdXJhdGlvbnMuZ2V0TGVuZ3RoKCkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9wcmVwYXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uID0gREcuVXRpbC5pc0FycmF5KHRoaXMub3B0aW9ucy5hbmltYXRpb24pID8gdGhpcy5vcHRpb25zLmFuaW1hdGlvbiA6IFt0aGlzLm9wdGlvbnMuYW5pbWF0aW9uXTtcblxuICAgICAgICB0aGlzLl9kdXJhdGlvbnMgPSBuZXcgREcuTWV0cmljLlNlZ21lbnRzKCk7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbi5mb3JFYWNoKGZ1bmN0aW9uKGFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5wdXNoKGFuaW1hdGlvbi5kdXJhdGlvbik7XG4gICAgICAgIH0sIHRoaXMuX2R1cmF0aW9ucyk7XG4gICAgfSxcblxuICAgIF9hbmltYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fYW5pbUlEID0gREcuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FuaW1hdGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9ydW4oKTtcbiAgICB9LFxuXG4gICAgX3J1bjogZnVuY3Rpb24oZWxhcHNlZCkge1xuICAgICAgICB2YXIgZWwsIGluZGV4LCBwcm9ncmVzcztcbiAgICAgICAgLy8gIFBvc3NpYmxlIHNraXAgemVybyBkZWx0YSB0aW1lIGJ1dCB3aG8gY2FyZXM/IVxuICAgICAgICBlbGFwc2VkID0gZWxhcHNlZCA/IGVsYXBzZWQgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX3N0YXJ0VGltZTtcblxuICAgICAgICBpZiAoZWxhcHNlZCA8IHRoaXMuX2R1cmF0aW9ucy5nZXRMZW5ndGgoKSkge1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9kdXJhdGlvbnMuZ2V0SW5kZXgoZWxhcHNlZCk7XG4gICAgICAgICAgICBlbCA9IHRoaXMuX2R1cmF0aW9ucy5nZXRTZWdSYXRpbyhlbGFwc2VkKTtcbiAgICAgICAgICAgIHByb2dyZXNzID0gdGhpcy5fYW5pbWF0aW9uW2luZGV4XVsnZnVuY3Rpb24nXS5nZXRZYnlYKGVsKTtcbiAgICAgICAgICAgIHRoaXMuX3N0ZXAodGhpcy5fZ2V0RnJhbWVWYWx1ZXMoaW5kZXgsIHByb2dyZXNzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuX2R1cmF0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdGhpcy5fc3RlcCh0aGlzLl9nZXRGcmFtZVZhbHVlcyhpbmRleCwgMSkpO1xuICAgICAgICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfc3RlcDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnc3RlcCcsIG9iaik7XG4gICAgfSxcblxuICAgIF9jb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIERHLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1JRCk7XG5cbiAgICAgICAgdGhpcy5fZHVyYXRpb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZpcmUoJ2VuZCcpO1xuICAgIH0sXG5cbiAgICBfZ2V0RnJhbWVWYWx1ZXM6IGZ1bmN0aW9uKGluZGV4LCBwcm9ncmVzcykge1xuICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5fYW5pbWF0aW9uW2luZGV4XS5mcmFtZXM7XG4gICAgICAgIHZhciBvYmogPSB7cHJvZ3Jlc3M6IHByb2dyZXNzfTtcbiAgICAgICAgdmFyIGZyLCB0bztcblxuICAgICAgICBpZiAoZnJhbWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lc1trZXldLnByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gZnJhbWVzW2tleV0ucHJvZ3Jlc3MocHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZyID0gZnJhbWVzW2tleV0uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBmcmFtZXNba2V5XS50bztcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSBmciArICh0byAtIGZyKSAqIHByb2dyZXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbn0pO1xuXG5ERy5hbmltYXRpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBERy5BbmltYXRpb24ob3B0aW9ucyk7XG59O1xuXG5ERy5BbmltYXRpb24uTElORUFSICAgICAgICAgPSBuZXcgREcuVGltZUJlemllcihERy5wb2ludCgwLjAwLCAwLjApLCBERy5wb2ludCgxLjAwLCAxLjApKTtcbkRHLkFuaW1hdGlvbi5FQVNFICAgICAgICAgICA9IG5ldyBERy5UaW1lQmV6aWVyKERHLnBvaW50KDAuMjUsIDAuMSksIERHLnBvaW50KDAuMjUsIDEuMCkpO1xuREcuQW5pbWF0aW9uLkVBU0VfSU4gICAgICAgID0gbmV3IERHLlRpbWVCZXppZXIoREcucG9pbnQoMC40MiwgMC4wKSwgREcucG9pbnQoMS4wMCwgMS4wKSk7XG5ERy5BbmltYXRpb24uRUFTRV9JTl9PVVQgICAgPSBuZXcgREcuVGltZUJlemllcihERy5wb2ludCgwLjQyLCAwLjApLCBERy5wb2ludCgwLjU4LCAxLjApKTtcbkRHLkFuaW1hdGlvbi5FQVNFX09VVCAgICAgICA9IG5ldyBERy5UaW1lQmV6aWVyKERHLnBvaW50KDAuMDAsIDAuMCksIERHLnBvaW50KDAuNTgsIDEuMCkpO1xuIiwiLypcbiAqIERHLkVudHJhbmNlIGlzIGEgbWFpbiBjbGFzcyB0aGF0IGhvc3RzIGFjdHVhbCBhcnJvdyBsYXllcnNcbiAqIEl0IG9yY2hlc3RyYXRlcyBhbmltYXRpb24gYW5kIHByb3ZpZGVzIHVzZXIgc3BhY2UgbWV0aG9kcyBsaWtlIC5zaG93KCkgYW5kIC5oaWRlKClcbiAqL1xuXG5ERy5FbnRyYW5jZSA9IERHLkZlYXR1cmVHcm91cC5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICB2ZWN0b3JzOiBbXSxcblxuICAgICAgICBmaWxsQ29sb3I6ICcjMDA4NWEwJyxcbiAgICAgICAgc3Ryb2tlQ29sb3I6ICcjZmZmJyxcblxuICAgICAgICBlbmFibGVBbmltYXRpb246IHRydWUsXG4gICAgICAgIGludGVyYWN0aXZlOiBmYWxzZSxcblxuICAgICAgICBhdXRvQ2xvc2U6IHRydWVcbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBERy5MYXllckdyb3VwLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcyk7XG5cbiAgICAgICAgREcuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLl9ib3VuZHMgPVxuICAgICAgICAgICAgbmV3IERHLkxhdExuZ0JvdW5kcygpO1xuICAgICAgICB0aGlzLl9hbmltYXRpb25zID0ge1xuICAgICAgICAgICAgYm91bmNlOiBERy5hbmltYXRpb24oREcuRW50cmFuY2UuQk9VTkNFX0FOSU1BVElPTiksXG4gICAgICAgICAgICBwYXRoOiBERy5hbmltYXRpb24oREcuRW50cmFuY2UuUEFUSF9BTklNQVRJT04pXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5faW5pdEFycm93cygpO1xuXG4gICAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICBERy5MYXllckdyb3VwLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgIH0sXG5cbiAgICBvblJlbW92ZTogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICBERy5MYXllckdyb3VwLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG4gICAgfSxcblxuICAgIGdldEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBldmVudHMgPSB7fTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9DbG9zZSkge1xuICAgICAgICAgICAgZXZlbnRzWydsYXllcmFkZCddID0gdGhpcy5fcmVtb3ZlRW50cmFuY2U7ICAvLyAgZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZUFuaW1hdGlvbikge1xuICAgICAgICAgICAgZXZlbnRzWyd6b29tZW5kJ10gPSB0aGlzLl9hbmltYXRlOyAgICAgICAgICAvLyAgZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBldmVudHM7XG4gICAgfSxcblxuICAgIHNob3c6IGZ1bmN0aW9uKGZpdEJvdW5kcykge1xuICAgICAgICBpZiAodGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgICBpZiAoZml0Qm91bmRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXRCb3VuZHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNTaG93bikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uKGFycm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGFycm93LnNldFZpc2liaWxpdHkodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAuZmlyZSgnZW50cmFuY2VzaG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXllcnMgJiYgdGhpcy5faXNTaG93bikge1xuICAgICAgICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24oYXJyb3cpIHtcbiAgICAgICAgICAgICAgICBhcnJvdy5zZXRWaXNpYmlsaXR5KGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fbWFwLmZpcmUoJ2VudHJhbmNlaGlkZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGlzU2hvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTaG93bjtcbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcztcbiAgICB9LFxuXG4gICAgc2V0RmlsbENvbG9yOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICB0aGlzLmVhY2hMYXllcihmdW5jdGlvbihhcnJvdykge1xuICAgICAgICAgICAgYXJyb3cuc2V0U3R5bGUoe2ZpbGxDb2xvcjogY29sb3J9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHNldFN0cm9rZUNvbG9yOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICB0aGlzLmVhY2hMYXllcihmdW5jdGlvbihhcnJvdykge1xuICAgICAgICAgICAgYXJyb3cuc2V0U3R5bGUoe2NvbG9yOiBjb2xvcn0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2luaXRBcnJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYmFzZSA9IHtcbiAgICAgICAgICAgIGNvbG9yOiB0aGlzLm9wdGlvbnMuc3Ryb2tlQ29sb3IsXG4gICAgICAgICAgICBmaWxsQ29sb3I6IHRoaXMub3B0aW9ucy5maWxsQ29sb3IsXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZTogdGhpcy5vcHRpb25zLmludGVyYWN0aXZlXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLnZlY3RvcnNcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERHLldrdC50b0xhdExuZ3ModmVjdG9yKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihsYXRsbmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBERy5VdGlsLmNyZWF0ZShiYXNlKSxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzID0gREcubGF0TG5nQm91bmRzKGxhdGxuZ3MpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fYm91bmRzLmV4dGVuZChib3VuZHMpO1xuXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sYXRsbmdzID0gbGF0bG5ncztcbiAgICAgICAgICAgICAgICBvcHRpb25zLmJvdW5kcyA9IGJvdW5kcztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZUFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGF0bG5ncy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHRoaXMuX2FuaW1hdGlvbnMucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0gdGhpcy5fYW5pbWF0aW9ucy5ib3VuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRpc3RhbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGF5ZXIoREcuZW50cmFuY2UuYXJyb3cob3B0aW9ucykpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuXG4gICAgX2FuaW1hdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5faXNTaG93bikge1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9ucy5ib3VuY2Uuc3RhcnQoKTtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbnMucGF0aC5zdGFydCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vICBDdXJyZW50IGxvZ2ljIG9mIG5leHQgZm91ciBtZXRob2RzIGV4dHJhY3RlZCBmcm9tIG9yaWdpbmFsIGFycm93J3MgaW1wbGVtZW50YXRpb25cbiAgICBmaXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwLCBmaXRab29tLFxuICAgICAgICAgICAgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcblxuICAgICAgICBpZiAoIW1hcC5nZXRCb3VuZHMoKS5jb250YWlucyhib3VuZHMpIHx8ICF0aGlzLl9pc0FsbG93ZWRab29tKCkpIHtcbiAgICAgICAgICAgIGZpdFpvb20gPSB0aGlzLl9nZXRGaXRab29tKCk7XG4gICAgICAgICAgICBpZiAoIW1hcC5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpKSB7XG4gICAgICAgICAgICAgICAgbWFwLm9uY2UoJ21vdmVlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwLnNldFpvb20odGhpcy5fZ2V0Rml0Wm9vbSgpKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcC5zZXRWaWV3KGJvdW5kcy5nZXRDZW50ZXIoKSwgZml0Wm9vbSwge2FuaW1hdGU6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfZ2V0Rml0Wm9vbTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKS5tYXhab29tIHx8IERHLkVudHJhbmNlLlNIT1dfRlJPTV9aT09NO1xuICAgIH0sXG5cbiAgICBfaXNBbGxvd2VkWm9vbTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuZ2V0Wm9vbSgpID49IERHLkVudHJhbmNlLlNIT1dfRlJPTV9aT09NO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlRW50cmFuY2U6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUubGF5ZXIgaW5zdGFuY2VvZiBERy5Qb3B1cCB8fFxuICAgICAgICAgICAgKGUubGF5ZXIgaW5zdGFuY2VvZiBERy5FbnRyYW5jZSAmJiBlLmxheWVyICE9PSB0aGlzKSkge1xuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkRHLmVudHJhbmNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuRW50cmFuY2Uob3B0aW9ucyk7XG59O1xuXG5ERy5FbnRyYW5jZS5TSE9XX0ZST01fWk9PTSA9IDE2O1xuREcuRW50cmFuY2UuUEFUSF9BTklNQVRJT04gPSB7XG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICdmdW5jdGlvbic6IERHLkFuaW1hdGlvbi5FQVNFX0lOX09VVCxcbiAgICAgICAgJ2R1cmF0aW9uJzogNzUwXG4gICAgfVxufTtcbkRHLkVudHJhbmNlLkJPVU5DRV9BTklNQVRJT04gPSB7XG4gICAgYW5pbWF0aW9uOiBbXG4gICAgICAgIHsnZnVuY3Rpb24nOiBERy5BbmltYXRpb24uRUFTRV9JTl9PVVQsICdkdXJhdGlvbic6IDI1MCwgJ2ZyYW1lcyc6IHsnZGlzdGFuY2UnOiB7J2Zyb20nOiAwLCAndG8nOiAwLjZ9fX0sXG4gICAgICAgIHsnZnVuY3Rpb24nOiBERy5BbmltYXRpb24uRUFTRV9JTiwgJ2R1cmF0aW9uJzogMTM1LCAnZnJhbWVzJzogeydkaXN0YW5jZSc6IHsnZnJvbSc6IDAuNiwgJ3RvJzogMH19fSxcbiAgICAgICAgeydmdW5jdGlvbic6IERHLkFuaW1hdGlvbi5FQVNFX09VVCwgJ2R1cmF0aW9uJzogMTM1LCAnZnJhbWVzJzogeydkaXN0YW5jZSc6IHsnZnJvbSc6IDAsICd0byc6IDAuMTZ9fX0sXG4gICAgICAgIHsnZnVuY3Rpb24nOiBERy5BbmltYXRpb24uRUFTRV9JTiwgJ2R1cmF0aW9uJzogOTAsICdmcmFtZXMnOiB7J2Rpc3RhbmNlJzogeydmcm9tJzogMC4xNiwgJ3RvJzogMH19fSxcbiAgICAgICAgeydmdW5jdGlvbic6IERHLkFuaW1hdGlvbi5FQVNFX09VVCwgJ2R1cmF0aW9uJzogOTAsICdmcmFtZXMnOiB7J2Rpc3RhbmNlJzogeydmcm9tJzogMCwgJ3RvJzogMC4wNn19fSxcbiAgICAgICAgeydmdW5jdGlvbic6IERHLkFuaW1hdGlvbi5FQVNFX0lOLCAnZHVyYXRpb24nOiA1MCwgJ2ZyYW1lcyc6IHsnZGlzdGFuY2UnOiB7J2Zyb20nOiAwLjA2LCAndG8nOiAwfX19XG4gICAgXVxufTtcbiIsIi8qXG4gKiBERy5FbnRyYW5jZS5BcnJvdyBjbGFzcyBob3N0cyB0d28gbGF5ZXJzLCBvbmUgZm9yIGFycm93IGJvZHkgKHBhdGgpIGFuZCBvbmUgZm9yIGFycm93IHRpcFxuICogSXQgb3ZlcnJpZGVzIHByb2plY3Rpb24gZXZlbnRzIGZyb20gaG9zdGVkIGxheWVycyB0byBtaW5pbWl6ZSB0b3RhbCBvdmVyaGVhZFxuICogQWN0dWFsIGNhbGN1bGF0aW9ucyBwcm9kdWNlZCBpbiBERy5BcnJvd1BhdGhUcmFuc2Zvcm0gYW5kIERHLkFycm93VGlwVHJhbnNmb3JtIGNsYXNzZXNcbiAqL1xuXG5ERy5FbnRyYW5jZS5BcnJvdyA9IERHLkZlYXR1cmVHcm91cC5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgREcuTGF5ZXJHcm91cC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIERHLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3MgPSAxO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMuX3Zpc2liaWxpdHkgPSB7XG4gICAgICAgICAgICBpc1Nob3duOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wb3NpdGlvbiA9XG4gICAgICAgICAgICBvcHRpb25zLmxhdGxuZ3Nbb3B0aW9ucy5sYXRsbmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLl9zaGFwZSA9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2hhcGUgfHxcbiAgICAgICAgICAgIERHLkVudHJhbmNlLkFycm93LlNIQVBFO1xuXG4gICAgICAgIHRoaXMuX2FwdCA9IHt9OyAvLyBERy5BcnJvd1BhdGhUcmFuc2Zvcm0gb2JqZWN0cyBieSB6b29tIGxldmVsc1xuICAgICAgICB0aGlzLl9hdHQgPSB7fTsgLy8gREcuQXJyb3dUaXBUcmFuc2Zvcm0gb2JqZWN0cyBieSB6b29tIGxldmVsc1xuICAgIH0sXG5cbiAgICBiZWZvcmVBZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAvLyAgdGhpcy5fbWFwIGlzIG5vdCBpbml0aWFsaXplZCB5ZXQsIHNvIHdlIGNhbiBmcmVlbHkgYWRkTGF5ZXIocylcbiAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgLy8gIFRPRE86IENoZWNrIENhbnZhcyBwcm9jZXNzaW5nIG9yZGVyXG4gICAgICAgIC8vICBBZGRpdGlvbmFsIGxvZ2ljIHRvIERJU0FCTEUgYW5pbWF0aW9uIG9uIENhbnZhcyBmb3Igbm93IVxuICAgICAgICBpZiAob3B0cy5hbmltYXRpb24gJiYgIW1hcC5vcHRpb25zLnByZWZlckNhbnZhcyAmJiAhREcuQnJvd3Nlci5pZWx0OSkge1xuICAgICAgICAgICAgb3B0cy5hbmltYXRpb24ub24oJ3N0ZXAnLCB0aGlzLl9hbmltYXRpb24sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0cy5hbmltYXRpb24gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5hZGRMYXllcihuZXcgREcuQ29tcGxleFBhdGgoe1xuICAgICAgICAgICAgbGluZUNhcDogJ2J1dHQnLFxuICAgICAgICAgICAgY29sb3I6IG9wdHMuY29sb3IsXG4gICAgICAgICAgICBmaWxsQ29sb3I6IG9wdHMuZmlsbENvbG9yLFxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IG9wdHMuaW50ZXJhY3RpdmUsXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiB0aGlzLl92aXNpYmlsaXR5LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9hcHRcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHRoaXMuYWRkTGF5ZXIobmV3IERHLkNvbXBsZXhQYXRoKHtcbiAgICAgICAgICAgIGxpbmVKb2luOiAnbWl0ZXInLFxuICAgICAgICAgICAgY29sb3I6IG9wdHMuY29sb3IsXG4gICAgICAgICAgICBmaWxsQ29sb3I6IG9wdHMuZmlsbENvbG9yLFxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IG9wdHMuaW50ZXJhY3RpdmUsXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiB0aGlzLl92aXNpYmlsaXR5LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9hdHRcbiAgICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICBnZXRFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgem9vbWVuZDogdGhpcy5fcHJvamVjdCxcbiAgICAgICAgICAgIG1vdmVlbmQ6IHRoaXMuX3VwZGF0ZSxcbiAgICAgICAgICAgIHZpZXdyZXNldDogdGhpcy5fcmVzZXRcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgc2V0VmlzaWJpbGl0eTogZnVuY3Rpb24oaXNTaG93bikge1xuICAgICAgICBpZiAodGhpcy5fdmlzaWJpbGl0eS5pc1Nob3duICE9PSBpc1Nob3duKSB7XG4gICAgICAgICAgICB0aGlzLl92aXNpYmlsaXR5LmlzU2hvd24gPSBpc1Nob3duO1xuICAgICAgICAgICAgaWYgKGlzU2hvd24pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ib3VuZHM7XG4gICAgfSxcblxuICAgIHByb2plY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwIHx8IHRoaXMuX21hcFRvQWRkO1xuICAgICAgICB2YXIgem9vbSA9IG1hcCA/IG1hcC5nZXRab29tKCkgOiAwO1xuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLl9zaGFwZS52ZXJ0aWNlc1t6b29tXTtcbiAgICAgICAgdmFyIGRyYXdpbmdzID0gdGhpcy5fc2hhcGUuZHJhd2luZ3Nbem9vbV07XG4gICAgICAgIHZhciBsYXRsbmdzID0gdGhpcy5vcHRpb25zLmxhdGxuZ3M7XG4gICAgICAgIHZhciBzaGFwZSwgcGF0aCwgbGFzdFBvaW50LCBwcmV2UG9pbnQ7XG5cbiAgICAgICAgaWYgKHpvb20gJiYgdmVydGljZXMgJiYgZHJhd2luZ3MpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYXR0W3pvb21dKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IERHLkFycm93UGF0aFRyYW5zZm9ybS5nZXRUcmFuc2xhdGVkUGF0aChtYXAsIGxhdGxuZ3MpO1xuICAgICAgICAgICAgICAgIHNoYXBlID0ge3ZlcnRpY2VzOiB2ZXJ0aWNlcywgZHJhd2luZ3M6IGRyYXdpbmdzfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRbem9vbV0gPSBuZXcgREcuQXJyb3dUaXBUcmFuc2Zvcm0ocGF0aCwgc2hhcGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FwdFt6b29tXSA9IG5ldyBERy5BcnJvd1BhdGhUcmFuc2Zvcm0ocGF0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RQb2ludCA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fcG9zaXRpb24pO1xuICAgICAgICAgICAgcHJldlBvaW50ID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmdzW2xhdGxuZ3MubGVuZ3RoIC0gMl0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hcHRbem9vbV0uX3B4Qm91bmRzKSB7XG4gICAgICAgICAgICAgICAgLy8gIE9uZS10aW1lIGFjdGlvbiBwZXIgJ3ZpZXdyZXNldCcgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyAgQ2FjaGluZyBfcHhCb3VuZHMgZm9yIHVzaW5nIHdpdGggQ2FudmFzIHJlbmRlcmVyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Qm91bmRzKGxhc3RQb2ludCwgcHJldlBvaW50LCB0aGlzLl9hcHRbem9vbV0sIHRoaXMuX2F0dFt6b29tXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gIEFycm93IHBvc2l0aW9uIHJlY2FsY3VsYXRlZCBmb3IgQm91bmNlIGFuaW1hdGlvbiBlZmZlY3RcbiAgICAgICAgICAgICAgICBsYXN0UG9pbnQgPSBERy5WZXJ0ZXhUcmFuc2Zvcm0uZ2V0U2NhbGVkKGxhc3RQb2ludCwgcHJldlBvaW50LCB0aGlzLl9kaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vICBNYWluIGNhbGN1bGF0aW9uc1xuICAgICAgICAgICAgLy8gIEdldCBwYXJ0IG9mIHRoZSBhcnJvdyBwYXRoIGFuZCBtb3ZlIChib3VuZCkgYXJyb3cgdGlwIHRvIGl0XG4gICAgICAgICAgICB0aGlzLl9hcHRbem9vbV0uc3ViUGF0aCh0aGlzLl9wcm9ncmVzcykudHJhbnNsYXRlKGxhc3RQb2ludCk7XG4gICAgICAgICAgICB0aGlzLl9hdHRbem9vbV0uc3ViU2hhcGUodGhpcy5fYXB0W3pvb21dKS50cmFuc2xhdGUobGFzdFBvaW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfYW5pbWF0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLmRpc3RhbmNlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSBlLmRpc3RhbmNlOyAgICAvLyAgYm91bmNlIGFuaW1hdGlvbiBlZmZlY3RcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzID0gZS5wcm9ncmVzczsgICAgLy8gIHBhdGggYW5pbWF0aW9uIGVmZmVjdFxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl92aXNpYmlsaXR5LmlzU2hvd24pIHtcbiAgICAgICAgICAgIC8vICBUT0RPOiBBZGRpdGlvbmFsIGxvZ2ljIGZvciBhbmltYXRpb24gb24gQ2FudmFzXG4gICAgICAgICAgICAvLyB0aGlzLnByb2plY3Rpb24oKS5pbnZva2UoJ3JlZHJhdycpO1xuXG4gICAgICAgICAgICB0aGlzLl9wcm9qZWN0KCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcHJvamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbigpLmludm9rZSgnX3Byb2plY3QnKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuaW52b2tlKCdfdXBkYXRlJyk7XG4gICAgfSxcblxuICAgIF9yZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0Qm91bmRzKCk7XG5cbiAgICAgICAgdGhpcy5fcHJvamVjdCgpO1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9LFxuXG4gICAgX3Jlc2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gIENhbnZhcyByZW5kZXJlciBzcGVjaWZpY1xuICAgICAgICB2YXIgejtcblxuICAgICAgICBmb3IgKHogaW4gdGhpcy5fYXB0KSB7XG4gICAgICAgICAgICB0aGlzLl9hcHRbel0uX3B4Qm91bmRzID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoeiBpbiB0aGlzLl9hdHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dFt6XS5fcHhCb3VuZHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRCb3VuZHM6IGZ1bmN0aW9uKHBsLCBwcCwgYXB0LCBhdHQpIHtcbiAgICAgICAgdmFyIF9hcHQgPSBhcHQuc3ViUGF0aCgxKS50cmFuc2xhdGUocGwpLnZlcnRpY2VzLFxuICAgICAgICAgICAgX2F0dCA9IGF0dC5zdWJTaGFwZShhcHQpLnRyYW5zbGF0ZShwbCkudmVydGljZXM7XG5cbi8qXG4gICAgICAgIC8vICBUT0RPOiBBZGRpdGlvbmFsIGxvZ2ljIGZvciBhbmltYXRpb24gb24gQ2FudmFzXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHBsID0gREcuVmVydGV4VHJhbnNmb3JtLmdldFNjYWxlZChwbCwgcHAsIDEpO1xuICAgICAgICAgICAgX2FwdCA9IF9hcHQuY29uY2F0KGFwdC5zdWJQYXRoKDEpLnRyYW5zbGF0ZShwbCkudmVydGljZXMpO1xuICAgICAgICAgICAgX2F0dCA9IF9hdHQuY29uY2F0KGF0dC5zdWJTaGFwZShhcHQpLnRyYW5zbGF0ZShwbCkudmVydGljZXMpO1xuICAgICAgICB9XG4qL1xuICAgICAgICBhcHQuX3B4Qm91bmRzID0gbmV3IERHLkJvdW5kcyhfYXB0KTtcbiAgICAgICAgYXR0Ll9weEJvdW5kcyA9IG5ldyBERy5Cb3VuZHMoX2F0dCk7XG4gICAgfVxufSk7XG5cbkRHLmVudHJhbmNlLmFycm93ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuRW50cmFuY2UuQXJyb3cob3B0aW9ucyk7XG59O1xuIiwiLypcbiAqIFByZWRlZmluZWQgYXJyb3cgdGlwc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuREcuRW50cmFuY2UuQXJyb3cuU0hBUEUgPSB7XG4gICAgdmVydGljZXM6IHtcbiAgICAgICAgMTY6IFtcbiAgICAgICAgICAgIFsgLTYuNTAwMCwgIC0xLjgwMDBdLFxuICAgICAgICAgICAgWyAtNi4wNTIyLCAgLTEuODAwMF0sXG4gICAgICAgICAgICBbIC03LjA5NzUsICAtNS4yNTM3XSxcbiAgICAgICAgICAgIFsgLTYuNjYxOSwgIC02LjI1NjVdLCBbIC02LjU5ODAsICAtNi4zNTUwXSwgWyAtNi4xNzU3LCAgLTYuMTQ3MF0sXG4gICAgICAgICAgICBbICAwLjgzNzEsICAtMC4zNTUyXSxcbiAgICAgICAgICAgIFsgIDAuOTI3NSwgIC0wLjE3NjRdLCBbICAwLjkyNzUsICAgMC4xNzY0XSwgWyAgMC44MzcxLCAgIDAuMzU1Ml0sXG4gICAgICAgICAgICBbIC02LjE3NTcsICAgNi4xNDcwXSxcbiAgICAgICAgICAgIFsgLTYuNTk4MCwgICA2LjM1NTBdLCBbIC02LjY2MTksICAgNi4yNTY1XSwgWyAtNy4wOTc1LCAgIDUuMjUzN10sXG4gICAgICAgICAgICBbIC02LjA1MjIsICAgMS44MDAwXSxcbiAgICAgICAgICAgIFsgLTYuNTAwMCwgICAxLjgwMDBdXG4gICAgICAgIF0sXG4gICAgICAgIDE3OiBbXG4gICAgICAgICAgICBbIC05LjAwMDAsICAtMi40MDAwXSxcbiAgICAgICAgICAgIFsgLTcuODg5MCwgIC0yLjQwMDBdLFxuICAgICAgICAgICAgWyAtOS45MjQ1LCAgLTcuMjU0OF0sXG4gICAgICAgICAgICBbIC05LjMzNjMsICAtOC42NDA0XSwgWyAtOS4zNDQ4LCAgLTguNjQ0OF0sIFsgLTguODcxNywgIC04LjM1MDhdLFxuICAgICAgICAgICAgWyAgMS4wMjg1LCAgLTAuMzU1Ml0sXG4gICAgICAgICAgICBbICAxLjExOTAsICAtMC4xNzY0XSwgWyAgMS4xMTkwLCAgIDAuMTc2NF0sIFsgIDEuMDI4NSwgICAwLjM1NTJdLFxuICAgICAgICAgICAgWyAtOC44NzE3LCAgIDguMzUwOF0sXG4gICAgICAgICAgICBbIC05LjM0NDgsICAgOC42NDQ4XSwgWyAtOS4zMzYzLCAgIDguNjQwNF0sIFsgLTkuOTI0NSwgICA3LjI1NDhdLFxuICAgICAgICAgICAgWyAtNy44ODkwLCAgIDIuNDAwMF0sXG4gICAgICAgICAgICBbIC05LjAwMDAsICAgMi40MDAwXVxuICAgICAgICBdLFxuICAgICAgICAxODogW1xuICAgICAgICAgICAgWy0xMS41MDAwLCAgLTMuMDAwMF0sXG4gICAgICAgICAgICBbLTEwLjA3OTUsICAtMy4wMDAwXSxcbiAgICAgICAgICAgIFstMTIuNDkwOSwgIC05LjMxNzNdLFxuICAgICAgICAgICAgWy0xMS44NDAyLCAtMTAuNzY1NF0sIFstMTEuNTk4NiwgLTEwLjcwNzNdLCBbLTEwLjkzODAsIC0xMC4yMjU4XSxcbiAgICAgICAgICAgIFsgIDEuMTQ5NywgIC0wLjM1NTJdLFxuICAgICAgICAgICAgWyAgMS4yNDAyLCAgLTAuMTc2NF0sIFsgIDEuMjQwMiwgICAwLjE3NjRdLCBbICAxLjE0OTcsICAgMC4zNTUyXSxcbiAgICAgICAgICAgIFstMTAuOTM4MCwgIDEwLjIyNThdLFxuICAgICAgICAgICAgWy0xMS41OTg2LCAgMTAuNzA3M10sIFstMTEuODQwMiwgIDEwLjc2NTRdLCBbLTEyLjQ5MDksICAgOS4zMTczXSxcbiAgICAgICAgICAgIFstMTAuMDc5NSwgICAzLjAwMDBdLFxuICAgICAgICAgICAgWy0xMS41MDAwLCAgIDMuMDAwMF1cbiAgICAgICAgXSxcbiAgICAgICAgMTk6IFtcbiAgICAgICAgICAgIFstMTMuMDAwMCwgIC0zLjYwMDBdLFxuICAgICAgICAgICAgWy0xMS42NjAwLCAgLTMuNjAwMF0sXG4gICAgICAgICAgICBbLTE0LjE2OTYsIC0xMC44MzUxXSxcbiAgICAgICAgICAgIFstMTMuNTE4OSwgLTEyLjI4MzJdLCBbLTEzLjI3NzMsIC0xMi4yMjUxXSwgWy0xMi42MTY3LCAtMTEuNzQzNl0sXG4gICAgICAgICAgICBbICAxLjMwNjEsICAtMC4zNTUyXSxcbiAgICAgICAgICAgIFsgIDEuMzk2NiwgIC0wLjE3NjRdLCBbICAxLjM5NjYsICAgMC4xNzY0XSwgWyAgMS4zMDYxLCAgIDAuMzU1Ml0sXG4gICAgICAgICAgICBbLTEyLjYxNjcsICAxMS43NDM2XSxcbiAgICAgICAgICAgIFstMTMuMjc3MywgIDEyLjIyNTFdLCBbLTEzLjUxODksICAxMi4yODMyXSwgWy0xNC4xNjk2LCAgMTAuODM1MV0sXG4gICAgICAgICAgICBbLTExLjY2MDAsICAgMy42MDAwXSxcbiAgICAgICAgICAgIFstMTMuMDAwMCwgICAzLjYwMDBdXG4gICAgICAgIF1cbiAgICB9LFxuICAgIGRyYXdpbmdzOiB7XG4gICAgICAgIDE2OiBbJ00nLCAnTCcsICdMJywgJ0MnLCAnTCcsICdDJywgJ0wnLCAnQycsICdMJywgJ0wnXSxcbiAgICAgICAgMTc6IFsnTScsICdMJywgJ0wnLCAnQycsICdMJywgJ0MnLCAnTCcsICdDJywgJ0wnLCAnTCddLFxuICAgICAgICAxODogWydNJywgJ0wnLCAnTCcsICdDJywgJ0wnLCAnQycsICdMJywgJ0MnLCAnTCcsICdMJ10sXG4gICAgICAgIDE5OiBbJ00nLCAnTCcsICdMJywgJ0MnLCAnTCcsICdDJywgJ0wnLCAnQycsICdMJywgJ0wnXVxuICAgIH1cbn07XG4vKiBlc2xpbnQtZW5hYmxlIGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG5cbihmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgIGZvciAodmFyIGkgaW4gdmVydGljZXMpIHtcbiAgICAgICAgdmVydGljZXNbaV0gPSB2ZXJ0aWNlc1tpXS5tYXAoZnVuY3Rpb24odmVydGV4KSB7IHJldHVybiBERy5wb2ludCh2ZXJ0ZXgpOyB9KTtcbiAgICB9XG59KShERy5FbnRyYW5jZS5BcnJvdy5TSEFQRS52ZXJ0aWNlcyk7XG4iLCJERy5MYWJlbCA9IERHLkxheWVyLmV4dGVuZCh7XG5cbiAgICBvcHRpb25zOiB7XG4gICAgICAgIG9mZnNldDogbmV3IERHLlBvaW50KDEyLCAxNSksXG4gICAgICAgIGNsYXNzTmFtZTogJ2RnLWxhYmVsJyxcbiAgICAgICAgekluZGV4T2Zmc2V0OiAwLFxuICAgICAgICB0ZXh0RGlyZWN0aW9uOiAnYXV0bycgLy8gJ2F1dG8nIHwgJ2x0cicgfCAncnRsXG4gICAgfSxcblxuICAgIF90eXBlT2ZTdHJpbmcgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoJ3MnKSxcbiAgICBfZGVmYXVsdFpJbmRleDogMTAwLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICBERy5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fYW5pbWF0ZWQgPSBERy5Ccm93c2VyLmFueTNkO1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gY29udGVudDtcbiAgICB9LFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9lbCkge1xuICAgICAgICAgICAgdGhpcy5faW5pdERPTSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgdGhpc1xuICAgICAgICAgICAgLnNldENvbnRlbnQodGhpcy5fY29udGVudClcbiAgICAgICAgICAgIC5fb25WaWV3UmVzZXQoKTtcblxuICAgICAgICBtYXBcbiAgICAgICAgICAgIC5vbigndmlld3Jlc2V0JywgdGhpcy5fb25WaWV3UmVzZXQsIHRoaXMpXG4gICAgICAgICAgICAub24oJ3pvb21hbmltJywgdGhpcy5fb25ab29tQW5pbWF0aW9uLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICBtYXBcbiAgICAgICAgICAgIC5vZmYoJ3ZpZXdyZXNldCcsIHRoaXMuX29uVmlld1Jlc2V0LCB0aGlzKVxuICAgICAgICAgICAgLm9mZignem9vbWFuaW0nLCB0aGlzLl9vblpvb21BbmltYXRpb24sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9lbC5yZW1vdmVDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICBERy5VdGlsLmZhbHNlRm4odGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoKTsgLy8gd2UgbmVlZCByZWZsb3cgaGVyZVxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBudWxsO1xuXG4gICAgICAgIG1hcC5nZXRQYW5lcygpLnRvb2x0aXBQYW5lLnJlbW92ZUNoaWxkKHRoaXMuX2VsKTtcbiAgICAgICAgdGhpcy5fZWwgPSBudWxsO1xuICAgIH0sXG5cbiAgICBfaW5pdERPTTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2VsID0gREcuRG9tVXRpbC5jcmVhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jbGFzc05hbWUgKyAnIGxlYWZsZXQtem9vbS0nICsgKHRoaXMuX2FuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAuZ2V0UGFuZXMoKS50b29sdGlwUGFuZSk7XG4gICAgICAgIHRoaXMuX2VsLnN0eWxlLnpJbmRleCA9IHRoaXMuX2RlZmF1bHRaSW5kZXggKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xuXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lICsgJ19fY29udGVudCcsIHRoaXMuX2VsKTtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnZGlyJywgdGhpcy5vcHRpb25zLnRleHREaXJlY3Rpb24pO1xuXG4gICAgICAgIERHLkRvbUV2ZW50XG4gICAgICAgICAgICAuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fZWwpXG4gICAgICAgICAgICAub24odGhpcy5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIERHLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgICAgIC5vbih0aGlzLl9jb250YWluZXIsICdjb250ZXh0bWVudScsIERHLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XG4gICAgfSxcblxuICAgIF9vblZpZXdSZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl92aXNpYmxlICYmIHRoaXMuX2xhdGxuZykge1xuICAgICAgICAgICAgREcuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbCwgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLmFkZCh0aGlzLm9wdGlvbnMub2Zmc2V0KSwgREcuQnJvd3Nlci5pZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uWm9vbUFuaW1hdGlvbjogZnVuY3Rpb24ob3B0KSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXRsbmcpIHtcbiAgICAgICAgICAgIERHLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWwsIHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgb3B0Lnpvb20sIG9wdC5jZW50ZXIpLmFkZCh0aGlzLm9wdGlvbnMub2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0T2Zmc2V0OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICBpZiAocG9pbnQgaW5zdGFuY2VvZiBERy5Qb2ludCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9mZnNldCA9IHBvaW50O1xuICAgICAgICAgICAgdGhpcy5fb25WaWV3UmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0WkluZGV4T2Zmc2V0OiBmdW5jdGlvbih6SW5kZXgpIHtcbiAgICAgICAgaWYgKCFpc05hTigrekluZGV4KSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCA9ICt6SW5kZXg7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsLnN0eWxlLnpJbmRleCA9IHRoaXMuX2RlZmF1bHRaSW5kZXggKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRDb250ZW50OiBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY29udGVudCkgIT09IHRoaXMuX3R5cGVPZlN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLl92aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uKGxhdGxuZykge1xuICAgICAgICBpZiAoIShsYXRsbmcgaW5zdGFuY2VvZiBERy5MYXRMbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xhdGxuZyA9IGxhdGxuZztcbiAgICAgICAgdGhpcy5fb25WaWV3UmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSk7XG5cbkRHLmxhYmVsID0gZnVuY3Rpb24oY29udGVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuTGFiZWwoY29udGVudCwgb3B0aW9ucyk7XG59O1xuIiwiREcuTWFya2VyLmluY2x1ZGUoe1xuXG4gICAgYmluZExhYmVsOiBmdW5jdGlvbihjb250ZW50LCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc2V0Q29udGVudChjb250ZW50KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgIT09IG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsLnNldE9mZnNldCh0aGlzLm9wdGlvbnMub2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YXRpYyAhPT0gb3B0aW9ucy5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmJpbmRMYWJlbCgpLmJpbmRMYWJlbChjb250ZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gREcuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG5ldyBERy5Qb2ludCg1LCA1KVxuICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHRoaXMuX2xhYmVsID0gREcubGFiZWwoY29udGVudCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHRoaXMub25jZSgncmVtb3ZlJywgdGhpcy5fb25NYXJrZXJSZW1vdmUpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dMYWJlbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgdGhpcy5fbW91c2VPdmVyTGFiZWwpXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCB0aGlzLl9tb3VzZU91dExhYmVsKVxuICAgICAgICAgICAgICAgICAgICAub24oJ2RyYWdzdGFydCcsIHRoaXMuX2RyYWdTdGFydExhYmVsKVxuICAgICAgICAgICAgICAgICAgICAub24oJ2RyYWdlbmQnLCB0aGlzLl9kcmFnRW5kTGFiZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX21hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVMYWJlbFpJbmRleCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ2FkZCcsIHRoaXMuX3VwZGF0ZUxhYmVsWkluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdW5iaW5kTGFiZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICAuaGlkZUxhYmVsKClcbiAgICAgICAgICAgICAgICAub2ZmKCdyZW1vdmUnLCB0aGlzLnVuYmluZExhYmVsKVxuICAgICAgICAgICAgICAgIC5vZmYoJ21vdXNlb3ZlcicsIHRoaXMuX21vdXNlT3ZlckxhYmVsKVxuICAgICAgICAgICAgICAgIC5vZmYoJ21vdXNlb3V0JywgdGhpcy5fbW91c2VPdXRMYWJlbClcbiAgICAgICAgICAgICAgICAub2ZmKCdkcmFnc3RhcnQnLCB0aGlzLl9kcmFnU3RhcnRMYWJlbClcbiAgICAgICAgICAgICAgICAub2ZmKCdkcmFnZW5kJywgdGhpcy5fZHJhZ0VuZExhYmVsKVxuICAgICAgICAgICAgICAgIC5vZmYoJ21vdmUnLCB0aGlzLl91cGRhdGVQb3NpdGlvbilcbiAgICAgICAgICAgICAgICAub2ZmKCdhZGQnLCB0aGlzLl91cGRhdGVMYWJlbFpJbmRleCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2xhYmVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX29uTWFya2VyUmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuX2xhYmVsLl9jb250ZW50O1xuICAgICAgICAgICAgdGhpcy5vbmNlKCdhZGQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHsgcmV0dXJuOyB9IC8vIG5ldyBsYWJlbCBhZGRlZCBhZnRlciByZW1vdmluZyBtYXJrZXJcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRMYWJlbChjb250ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51bmJpbmRMYWJlbCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldExhYmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhYmVsID8gdGhpcy5fbGFiZWwgOiBudWxsO1xuICAgIH0sXG5cbiAgICBfb3JpZ2luYWxVcGRhdGVaSW5kZXg6IERHLk1hcmtlci5wcm90b3R5cGUuX3VwZGF0ZVpJbmRleCxcbiAgICBfdXBkYXRlWkluZGV4OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl96SW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX3pJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3JpZ2luYWxVcGRhdGVaSW5kZXgob2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fdXBkYXRlTGFiZWxaSW5kZXgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF91cGRhdGVMYWJlbFpJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYWJlbCAmJiB0aGlzLl9pY29uKSB7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbC5zZXRaSW5kZXhPZmZzZXQodGhpcy5faWNvbi5zdHlsZS56SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzaG93TGFiZWwgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7XG4gICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgLm9uKCdtb3ZlJywgdGhpcy5fdXBkYXRlUG9zaXRpb24pXG4gICAgICAgICAgICAgICAgLl9tYXAuYWRkTGF5ZXIodGhpcy5fbGFiZWwuc2V0UG9zaXRpb24odGhpcy5nZXRMYXRMbmcoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGhpZGVMYWJlbCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICAub2ZmKCdtb3ZlJywgdGhpcy5fdXBkYXRlUG9zaXRpb24pXG4gICAgICAgICAgICAgICAgLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlUG9zaXRpb24gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbGFiZWwuc2V0UG9zaXRpb24odGhpcy5nZXRMYXRMbmcoKSk7XG4gICAgfSxcblxuICAgIF9kcmFnU3RhcnRMYWJlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2xhYmVsLmlzTWFya2VyRHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuaGlkZUxhYmVsKCk7XG4gICAgfSxcblxuICAgIF9kcmFnRW5kTGFiZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9sYWJlbC5pc01hcmtlckRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuX2xhYmVsLmlzTW91c2VPdmVyTWFya2VyKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dMYWJlbCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9tb3VzZU92ZXJMYWJlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2xhYmVsLmlzTW91c2VPdmVyTWFya2VyID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuX2xhYmVsLmlzTWFya2VyRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0xhYmVsKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX21vdXNlT3V0TGFiZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9sYWJlbC5pc01vdXNlT3Zlck1hcmtlciA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuaGlkZUxhYmVsKCk7XG4gICAgfVxufSk7XG5cbkRHLk1hcmtlci5hZGRJbml0SG9vayhmdW5jdGlvbigpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5iaW5kTGFiZWwodGhpcy5vcHRpb25zLmxhYmVsKTtcbiAgICB9XG59KTtcbiIsIkRHLlBhdGguaW5jbHVkZSh7XG4gICAgYmluZExhYmVsOiBmdW5jdGlvbihjb250ZW50LCBvcHRpb25zKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9sYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwgPSBERy5sYWJlbChjb250ZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMub24odGhpcy5fbGFiZWxFdmVudHMsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc2V0Q29udGVudChjb250ZW50KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2xhYmVsLm9wdGlvbnMub2Zmc2V0ICE9PSBvcHRpb25zLm9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsLnNldE9mZnNldChvcHRpb25zLm9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHVuYmluZExhYmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLm9mZih0aGlzLl9sYWJlbEV2ZW50cywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGFiZWwpO1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRMYWJlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYWJlbCA/IHRoaXMuX2xhYmVsIDogbnVsbDtcbiAgICB9LFxuXG4gICAgX2xhYmVsRXZlbnRzIDoge1xuICAgICAgICBtb3VzZW92ZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuYWRkTGF5ZXIodGhpcy5fbGFiZWwuc2V0UG9zaXRpb24oZXZlbnQubGF0bG5nKSk7XG4gICAgICAgICAgICBERy5Eb21FdmVudC5zdG9wKGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc2V0UG9zaXRpb24oZXZlbnQubGF0bG5nKTtcbiAgICAgICAgICAgIERHLkRvbUV2ZW50LnN0b3AoZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBtb3VzZW91dDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYWJlbCk7XG4gICAgICAgICAgICBERy5Eb21FdmVudC5zdG9wKGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYWJlbCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuREcuUGF0aC5hZGRJbml0SG9vayhmdW5jdGlvbigpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5iaW5kTGFiZWwodGhpcy5vcHRpb25zLmxhYmVsKTtcbiAgICB9XG59KTtcbiIsIkRHLkVudHJhbmNlLmluY2x1ZGUoe1xuICAgIGJpbmRMYWJlbDogZnVuY3Rpb24oY29udGVudCwgb3B0aW9ucykge1xuXG4gICAgICAgIGlmICghdGhpcy5fbGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsID0gREcubGFiZWwoY29udGVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLm9uKHRoaXMuX2xhYmVsRXZlbnRzLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLnNldENvbnRlbnQoY29udGVudCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9sYWJlbC5vcHRpb25zLm9mZnNldCAhPT0gb3B0aW9ucy5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbC5zZXRPZmZzZXQob3B0aW9ucy5vZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB1bmJpbmRMYWJlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5vZmYodGhpcy5fbGFiZWxFdmVudHMsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xhYmVsKTtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0TGFiZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGFiZWwgPyB0aGlzLl9sYWJlbCA6IG51bGw7XG4gICAgfSxcblxuICAgIF9sYWJlbEV2ZW50cyA6IHtcbiAgICAgICAgbW91c2VvdmVyOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLmFkZExheWVyKHRoaXMuX2xhYmVsLnNldFBvc2l0aW9uKGV2ZW50LmxhdGxuZykpO1xuICAgICAgICAgICAgREcuRG9tRXZlbnQuc3RvcChldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLnNldFBvc2l0aW9uKGV2ZW50LmxhdGxuZyk7XG4gICAgICAgICAgICBERy5Eb21FdmVudC5zdG9wKGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwucmVtb3ZlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5ERy5FbnRyYW5jZS5hZGRJbml0SG9vayhmdW5jdGlvbigpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5iaW5kTGFiZWwodGhpcy5vcHRpb25zLmxhYmVsKTtcbiAgICB9XG59KTtcbiIsIkRHLmNvbmZpZ1RoZW1lID0gREcuY29uZmlnVGhlbWUgfHwge307XG5cbkRHLmNvbmZpZ1RoZW1lLmJhbGxvb25PcHRpb25zID0ge1xuICAgIG9mZnNldDoge1xuICAgICAgICB4OiAxLFxuICAgICAgICB5OiAtNDNcbiAgICB9XG59O1xuIiwicmVxdWlyZSgnLi4vLi4vLi4vdmVuZG9ycy9iYXJvbicpO1xuXG4vLyAyR0lTLXJlbGF0ZWQgcG9wdXAgY29udGVudCB3cmFwcGVyIGFuZCBvZmZzZXRcbihmdW5jdGlvbigpIHtcbiAgICB2YXIgb2Zmc2V0WCA9IERHLmNvbmZpZ1RoZW1lLmJhbGxvb25PcHRpb25zLm9mZnNldC54LFxuICAgICAgICBvZmZzZXRZID0gREcuY29uZmlnVGhlbWUuYmFsbG9vbk9wdGlvbnMub2Zmc2V0LnksXG4gICAgICAgIG9yaWdpbmFsSW5pdGlhbGl6ZSA9IERHLlBvcHVwLnByb3RvdHlwZS5pbml0aWFsaXplLFxuICAgICAgICBvcmlnaW5hbEluaXRMYXlvdXQgPSBERy5Qb3B1cC5wcm90b3R5cGUuX2luaXRMYXlvdXQsXG4gICAgICAgIG9yaWdpbmFsT25BZGQgPSBERy5Qb3B1cC5wcm90b3R5cGUub25BZGQsXG4gICAgICAgIGdyYWYgPSBiYXJvbi5ub0NvbmZsaWN0KCk7XG5cbiAgICB2YXIgQmFyb25Eb21IZWxwZXIgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHRoaXNbMF0gPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfTtcbiAgICBCYXJvbkRvbUhlbHBlci5wcm90b3R5cGUgPSB7XG4gICAgICAgIHNldEF0dHJpYnV0ZTogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXNbMF0uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBnZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzWzBdLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQXR0cmlidXRlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICB0aGlzWzBdLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBjc3M6IGZ1bmN0aW9uKHN0eWxlLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpc1swXS5zdHlsZVtzdHlsZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERHLkRvbVV0aWwuZ2V0U3R5bGUodGhpc1swXSwgc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIERHLlBvcHVwLnByb3RvdHlwZS5vcHRpb25zLm9mZnNldCA9IERHLnBvaW50KG9mZnNldFgsIG9mZnNldFkpO1xuXG4gICAgREcuUG9wdXAubWVyZ2VPcHRpb25zKHtcbiAgICAgICAgYm9yZGVyOiAxNixcbiAgICAgICAgbWFwQ29udHJvbHNXaWR0aDogNjAsXG4gICAgICAgIHRleHREaXJlY3Rpb246ICdhdXRvJyAvLyAnYXV0bycgfCAnbHRyJyB8ICdydGxcbiAgICB9KTtcblxuICAgIERHLlBvcHVwLmluY2x1ZGUoe1xuICAgICAgICBfaGVhZGVyQ29udGVudDogbnVsbCxcbiAgICAgICAgX2Zvb3RlckNvbnRlbnQ6IG51bGwsXG5cbiAgICAgICAgLy9iYXJvbiBlbGVtZW50cyByZWZlcmVuY2VzXG4gICAgICAgIF9zY3JvbGxlcjogbnVsbCxcbiAgICAgICAgX3Njcm9sbGVyQmFyOiBudWxsLFxuICAgICAgICBfYmFyV3JhcHBlcjogbnVsbCxcbiAgICAgICAgX2Jhcm9uOiBudWxsLFxuICAgICAgICBfaXNCYXJvbkV4aXN0OiBmYWxzZSxcblxuICAgICAgICBfcG9wdXBTaG93Q2xhc3M6ICdsZWFmbGV0LXBvcHVwX3Nob3dfdHJ1ZScsXG4gICAgICAgIF9wb3B1cEhpZGVDbGFzczogJ2xlYWZsZXQtcG9wdXBfc2hvd19mYWxzZScsXG5cbiAgICAgICAgX3BvcHVwVGlwQ2xhc3M6ICdsZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXInLFxuICAgICAgICBfdGlwU1ZHUGF0aDogJ00wIDBjMTIuNjQzIDAgMjggNy4xMTUgMjggNDRoMmMwLTM2Ljg4NSAxNS4zNTgtNDQgMjgtNDRoLTU4eicsXG5cbiAgICAgICAgX2lzQXV0b1BhblBhZGRpbmdVc2VyRGVmaW5lZDogZmFsc2UsXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgc291cmNlKSB7IC8vIChPYmplY3QsIE9iamVjdClcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwU3RydWN0dXJlID0ge307XG4gICAgICAgICAgICB0aGlzLl9pc0F1dG9QYW5QYWRkaW5nVXNlckRlZmluZWQgPSBvcHRpb25zICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2F1dG9QYW5QYWRkaW5nJyk7XG4gICAgICAgICAgICBvcmlnaW5hbEluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zLCBzb3VyY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHsgLy8gKE1hcClcbiAgICAgICAgICAgIG1hcC5vbih7XG4gICAgICAgICAgICAgICAgZW50cmFuY2VzaG93OiB0aGlzLl9jbG9zZVBvcHVwLFxuICAgICAgICAgICAgICAgIHJlc2l6ZTogdGhpcy5yZXNpemVcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgb3JpZ2luYWxPbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlT3BlbmluZygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVtb3ZlOiBmdW5jdGlvbihtYXApIHsgLy8gKE1hcClcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVDbG9zaW5nKCk7XG4gICAgICAgICAgICBtYXAub2ZmKHtcbiAgICAgICAgICAgICAgICBlbnRyYW5jZXNob3c6IHRoaXMuX2Nsb3NlUG9wdXAsXG4gICAgICAgICAgICAgICAgcmVzaXplOiB0aGlzLnJlc2l6ZVxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChERy5Eb21VdGlsLlRSQU5TSVRJT04pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVUaW1lb3V0ID0gc2V0VGltZW91dChMLmJpbmQoTC5Eb21VdGlsLnJlbW92ZSwgTC5Eb21VdGlsLCB0aGlzLl9jb250YWluZXIpLCAyMDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hcC5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldENvbnRlbnQ6IGZ1bmN0aW9uKGNvbnRlbnQpIHsgLy8gKERPTUVsZW1lbnQgfCBPYmplY3QgfCBIVE1MKSAtPiBQb3B1cFxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc05vZGUoY29udGVudCkgJiYgdHlwZW9mIGNvbnRlbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udGVudCkuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJ18nICsgaXRlbSArICdDb250ZW50J10gPSBjb250ZW50W2l0ZW1dO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEhlYWRlckNvbnRlbnQ6IGZ1bmN0aW9uKGNvbnRlbnQpIHsgLy8gKEhUTUwpIC0+IFBvcHVwXG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEZvb3RlckNvbnRlbnQ6IGZ1bmN0aW9uKGNvbnRlbnQpIHsgLy8gKEhUTUwpIC0+IFBvcHVwXG4gICAgICAgICAgICB0aGlzLl9mb290ZXJDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENvbnRlbnQ6IGZ1bmN0aW9uKCkgeyAvLyAoKSAtPiBIVE1MXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYm9keUNvbnRlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SGVhZGVyQ29udGVudDogZnVuY3Rpb24oKSB7IC8vICgpIC0+IEhUTUxcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJDb250ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEZvb3RlckNvbnRlbnQ6IGZ1bmN0aW9uKCkgeyAvLyAoKSAtPiBIVE1MXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9vdGVyQ29udGVudDtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7IC8vICgpIC0+IFBvcHVwXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9wb3B1cFN0cnVjdHVyZSkuZm9yRWFjaCh0aGlzLl9jbGVhckVsZW1lbnQsIHRoaXMpO1xuXG4gICAgICAgICAgICAvLyB0aGluayBhYm91dCBtb3ZlIHRoaXMgc2V0IHRvIGFub3RoZXIgcHVibGljIG1ldGhvZFxuICAgICAgICAgICAgdGhpcy5faXNCYXJvbkV4aXN0ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhckhlYWRlcjogZnVuY3Rpb24oKSB7IC8vICgpIC0+IFBvcHVwXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xlYXJFbGVtZW50KCdoZWFkZXInKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhckZvb3RlcjogZnVuY3Rpb24oKSB7IC8vICgpIC0+IFBvcHVwXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xlYXJFbGVtZW50KCdmb290ZXInKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5kRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkgeyAvLyAoU3RyaW5nKSAtPiBET01FbGVtZW50XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudE5vZGUucXVlcnlTZWxlY3RvcihlbGVtZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYW5pbWF0ZU9wZW5pbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pbm5lckNvbnRhaW5lciwgdGhpcy5fcG9wdXBTaG93Q2xhc3MpO1xuICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9pbm5lckNvbnRhaW5lciwgdGhpcy5fcG9wdXBIaWRlQ2xhc3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9hbmltYXRlQ2xvc2luZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2lubmVyQ29udGFpbmVyLCB0aGlzLl9wb3B1cEhpZGVDbGFzcyk7XG4gICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2lubmVyQ29udGFpbmVyLCB0aGlzLl9wb3B1cFNob3dDbGFzcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2Nsb3NlUG9wdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLmNsb3NlUG9wdXAodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2lzTm9kZTogZnVuY3Rpb24obykgeyAvLyAoT2JqZWN0KSAtPiBCb29sZWFuXG4gICAgICAgICAgICByZXR1cm4gKG8ubm9kZU5hbWUgPyB0cnVlIDogZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vbkNsb3NlQnV0dG9uQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAuY2xvc2VQb3B1cCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEwuRG9tRXZlbnQuc3RvcChlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgICAgICAgIGlmIChERy5Ccm93c2VyLm1vYmlsZSAmJiB0aGlzLl9tYXAuZ2VvY2xpY2tlciAmJlxuICAgICAgICAgICAgICAgICAgICAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayB8fCB0aGlzLl9tYXAub3B0aW9ucy5jbG9zZVBvcHVwT25DbGljaykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gIFdlIG5lZWQgdG8gc2lnbmFsIGdlb2NsaWNrZXIgdGhhdCBwb3B1cCB3YXMgb3BlbiBiZWZvcmUgJ2NsaWNrJyBldmVudFxuICAgICAgICAgICAgICAgICAgICAvLyAgQnV0IGJ5IHRpbWUgaXQgd2lsbCBnZXQgaXQncyBldmVudCB0aGUgcG9wdXAgd2lsbCBiZSBhbHJlYWR5IGNsb3NlZFxuICAgICAgICAgICAgICAgICAgICAvLyAgU2VlICdER0dlb2NsaWNrZXInIGZvciAnX21hcEV2ZW50c0xpc3RlbmVycycgYW5kICdfc2luZ2xlQ2xpY2snIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAuZ2VvY2xpY2tlci5wb3B1cFdhc09wZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5jbG9zZVBvcHVwKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0TGF5b3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsSW5pdExheW91dC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5faW5uZXJDb250YWluZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtcG9wdXAtaW5uZXIgJyArIHRoaXMuX3BvcHVwSGlkZUNsYXNzLCB0aGlzLl9jb250YWluZXIpO1xuXG4gICAgICAgICAgICAvLyBQcmV2ZW50cyBtb3VzZSBldmVudHMgZnJvbSBsZWFraW5nIHRocm91Z2ggY2xvc2UgYnV0dG9uXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tLzJnaXMvbWFwc2FwaS9wdWxsLzE1My9cbiAgICAgICAgICAgIERHLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRoaXMuX2lubmVyQ29udGFpbmVyKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lubmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2RldGFjaEVsKHRoaXMuX2Nsb3NlQnV0dG9uKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2lubmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2RldGFjaEVsKHRoaXMuX3dyYXBwZXIpKTtcblxuICAgICAgICAgICAgdmFyIHRpcCA9IHRoaXMuX2RldGFjaEVsKHRoaXMuX3RpcENvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGlmIChERy5Ccm93c2VyLnN2Zykge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gREcuU1ZHLmNyZWF0ZSgncGF0aCcpO1xuICAgICAgICAgICAgICAgIHZhciBzdmdDbGFzcyA9IHRoaXMuX3BvcHVwVGlwQ2xhc3MgKyAnICcgKyB0aGlzLl9wb3B1cFRpcENsYXNzICsgJ19zdmcnO1xuXG4gICAgICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLl90aXBTVkdQYXRoKTtcblxuICAgICAgICAgICAgICAgIHRpcCA9IERHLlNWRy5jcmVhdGUoJ3N2ZycpO1xuICAgICAgICAgICAgICAgIHRpcC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgc3ZnQ2xhc3MpO1xuXG4gICAgICAgICAgICAgICAgdGlwLmFwcGVuZENoaWxkKHBhdGgpO1xuICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHBhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKHRpcCwgdGhpcy5fcG9wdXBUaXBDbGFzcyArICdfaW1hZ2UnKTtcbiAgICAgICAgICAgICAgICBERy5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aXApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9pbm5lckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aXApO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jbGVhckVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW0pIHsgLy8gKERPTUVsZW1lbnQpIC0+IFBvcHVwXG4gICAgICAgICAgICB0aGlzWydfJyArIGVsZW0gKyAnQ29udGVudCddID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2RldGFjaEVsKHRoaXMuX3BvcHVwU3RydWN0dXJlW2VsZW1dKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wb3B1cFN0cnVjdHVyZVtlbGVtXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYmFyb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iYXJvbi51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNjcm9sbGVkID0gdGhpcy5fdXBkYXRlTGF5b3V0KCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuXG4gICAgICAgICAgICBpZiAoIXNjcm9sbGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzQmFyb25FeGlzdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxlcldyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIERHLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fc2Nyb2xsZXIsICdkZy1zY3JvbGxlcicpO1xuXG4gICAgICAgICAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fc2Nyb2xsZXIsICdkZy1zY3JvbGxlcl9oaWRkZW5fdHJ1ZScpO1xuICAgICAgICAgICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3Njcm9sbGVyLCAnZGctc2Nyb2xsZXInKTtcbiAgICAgICAgICAgICAgICAgICAgREcuRG9tRXZlbnQub2ZmKHRoaXMuX3Njcm9sbGVyLCAnc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNCYXJvbkV4aXN0KSB7XG4gICAgICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9zY3JvbGxlciwgJ2RnLXNjcm9sbGVyX2hpZGRlbl90cnVlJyk7XG4gICAgICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9zY3JvbGxlciwgJ2RnLXNjcm9sbGVyJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5faXNCYXJvbkV4aXN0ID8gdGhpcy5fc2Nyb2xsZXIuc2Nyb2xsVG9wIDogZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbGVyLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0IC0gdGhpcy5vcHRpb25zLmJvcmRlciAqIDIgLSB0aGlzLl9nZXREZWx0YSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbGVyV3JhcHBlci5zdHlsZS5oZWlnaHQgPSBpbm5lckhlaWdodCArICdweCc7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxQb3NpdGlvbigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNDb250ZW50SGVpZ2h0RW5vdWdoKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0QmFyb25TY3JvbGxlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRCYXJvbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9hZGp1c3RQYW4oKTtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRBZGp1c3RQYW5PblRyYW5zaXRpb25FbmQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYWRqdXN0UGFuOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgaWYgKGUpIHsgLy8gYW5pbWF0ZWQgcG9wdXAgaXMgb3BlbmluZyAoaGVpZ2h0IGZyb20gMCB0byBtYXgpXG4gICAgICAgICAgICAgICAgaWYgKGUucHJvcGVydHlOYW1lID09PSAnbWF4LWhlaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBpdCdzIGZpbmlzaGVkIHdlIGFyZSBoZXJlXG4gICAgICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50Lm9mZih0aGlzLl93cmFwcGVyLCBERy5Eb21VdGlsLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9hZGp1c3RQYW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhlcmUncyBpbnRlcm1lZGlhdGUgc3RlcHMgLSB3ZSBkb24ndCBuZWVkIHRvIHByb2Nlc3MgdGhlbVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmF1dG9QYW4pIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gICAgICAgICAgICAgICAgY29udGFpbmVySGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgICAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxuICAgICAgICAgICAgICAgIGxheWVyUG9zID0gbmV3IEwuUG9pbnQodGhpcy5fY29udGFpbmVyTGVmdCwgLWNvbnRhaW5lckhlaWdodCAtIHRoaXMuX2NvbnRhaW5lckJvdHRvbSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcbiAgICAgICAgICAgICAgICBsYXllclBvcy5fYWRkKEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGF1dG9QYW5QYWRkaW5nID0gW29wdGlvbnMuYXV0b1BhblBhZGRpbmdbMF0sIG9wdGlvbnMuYXV0b1BhblBhZGRpbmdbMV1dO1xuXG4gICAgICAgICAgICAvLyBpZiB3aWR0aCBvZiBtYXAgaXMgbW9yZSB0aGVuIHdpZHRoIG9mIHBvcHVwIGFuZCBjb250cm9sc1xuICAgICAgICAgICAgLy8gc2V0IGRlZmF1bHQgYXV0b1BhblBhZGRpbmcgdG8gd2lkdGggY29udHJvbHNcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhdGhpcy5faXNBdXRvUGFuUGFkZGluZ1VzZXJEZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcC5fY29udGFpbmVyLm9mZnNldFdpZHRoID49IG9wdGlvbnMubWF4V2lkdGggKyBvcHRpb25zLm1hcENvbnRyb2xzV2lkdGggKiAyXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhdXRvUGFuUGFkZGluZ1swXSA9IG9wdGlvbnMubWFwQ29udHJvbHNXaWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lclBvcyA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChsYXllclBvcyksXG4gICAgICAgICAgICAgICAgcGFkZGluZyA9IEwucG9pbnQoYXV0b1BhblBhZGRpbmcpLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdUTCA9IEwucG9pbnQob3B0aW9ucy5hdXRvUGFuUGFkZGluZ1RvcExlZnQgfHwgcGFkZGluZyksXG4gICAgICAgICAgICAgICAgcGFkZGluZ0JSID0gTC5wb2ludChvcHRpb25zLmF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQgfHwgcGFkZGluZyksXG4gICAgICAgICAgICAgICAgc2l6ZSA9IG1hcC5nZXRTaXplKCksXG4gICAgICAgICAgICAgICAgZHggPSAwLFxuICAgICAgICAgICAgICAgIGR5ID0gMDtcblxuICAgICAgICAgICAgaWYgKHNpemUueCA9PT0gMCB8fCBzaXplLnkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBtYXAgaXNuJ3QgdmlzaWJsZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggKyBwYWRkaW5nQlIueCA+IHNpemUueCkgeyAvLyByaWdodFxuICAgICAgICAgICAgICAgIGR4ID0gY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCAtIHNpemUueCArIHBhZGRpbmdCUi54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lclBvcy54IC0gZHggLSBwYWRkaW5nVEwueCA8IDApIHsgLy8gbGVmdFxuICAgICAgICAgICAgICAgIGR4ID0gY29udGFpbmVyUG9zLnggLSBwYWRkaW5nVEwueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCArIHBhZGRpbmdCUi55ID4gc2l6ZS55KSB7IC8vIGJvdHRvbVxuICAgICAgICAgICAgICAgIGR5ID0gY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgLSBzaXplLnkgKyBwYWRkaW5nQlIueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250YWluZXJQb3MueSAtIGR5IC0gcGFkZGluZ1RMLnkgPCAwKSB7IC8vIHRvcFxuICAgICAgICAgICAgICAgIGR5ID0gY29udGFpbmVyUG9zLnkgLSBwYWRkaW5nVEwueTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGR4IHx8IGR5KSB7XG4gICAgICAgICAgICAgICAgbWFwXG4gICAgICAgICAgICAgICAgICAgIC5maXJlKCdhdXRvcGFuc3RhcnQnKVxuICAgICAgICAgICAgICAgICAgICAucGFuQnkoW2R4LCBkeV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9iaW5kQWRqdXN0UGFuT25UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChERy5Eb21VdGlsLlRSQU5TSVRJT04pIHtcbiAgICAgICAgICAgICAgICBERy5Eb21FdmVudC5vbih0aGlzLl93cmFwcGVyLCBERy5Eb21VdGlsLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9hZGp1c3RQYW4sIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGp1c3RQYW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfaXNDb250ZW50SGVpZ2h0RW5vdWdoOiBmdW5jdGlvbigpIHsgLy8gKCkgLT4gQm9vbGVhblxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5tYXhIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBvcHVwSGVpZ2h0ID0gdGhpcy5fcG9wdXBTdHJ1Y3R1cmUuYm9keSA/XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9wdXBTdHJ1Y3R1cmUuYm9keS5vZmZzZXRIZWlnaHQgKyB0aGlzLl9nZXREZWx0YSgpIDpcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50Tm9kZS5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgICAgIHBvcHVwSGVpZ2h0ICs9IG9wdGlvbnMuYm9yZGVyICogMjtcblxuICAgICAgICAgICAgcmV0dXJuIHBvcHVwSGVpZ2h0IDw9IG9wdGlvbnMubWF4SGVpZ2h0O1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0QmFyb25TY3JvbGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudE5vZGUgPSB0aGlzLl9wb3B1cFN0cnVjdHVyZS5ib2R5LnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJXcmFwcGVyID0gdGhpcy5fc2Nyb2xsZXJXcmFwcGVyID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdkZy1zY3JvbGxlcl9fd3JhcHBlcicsIGNvbnRlbnROb2RlKSxcbiAgICAgICAgICAgICAgICBzY3JvbGxlciA9IHRoaXMuX3Njcm9sbGVyID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdkZy1zY3JvbGxlcicsIHNjcm9sbGVyV3JhcHBlciksXG4gICAgICAgICAgICAgICAgYmFyV3JhcHBlciA9IHRoaXMuX2JhcldyYXBwZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2RnLXNjcm9sbGVyX19iYXItd3JhcHBlcicsIHNjcm9sbGVyKSxcbiAgICAgICAgICAgICAgICBpbm5lckhlaWdodCA9IHRoaXMub3B0aW9ucy5tYXhIZWlnaHQgLSB0aGlzLm9wdGlvbnMuYm9yZGVyICogMjtcblxuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsZXJCYXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2RnLXNjcm9sbGVyX19iYXInLCBiYXJXcmFwcGVyKTtcbiAgICAgICAgICAgIHNjcm9sbGVyLmFwcGVuZENoaWxkKHRoaXMuX2RldGFjaEVsKHRoaXMuX3BvcHVwU3RydWN0dXJlLmJvZHkpKTtcblxuICAgICAgICAgICAgaW5uZXJIZWlnaHQgLT0gdGhpcy5fZ2V0RGVsdGEoKTtcbiAgICAgICAgICAgIHNjcm9sbGVyV3JhcHBlci5zdHlsZS5oZWlnaHQgPSBNYXRoLm1heCgxOCwgaW5uZXJIZWlnaHQpICsgJ3B4JztcbiAgICAgICAgICAgIHNjcm9sbGVyV3JhcHBlci5zdHlsZS53aWR0aCA9IGNvbnRlbnROb2RlLm9mZnNldFdpZHRoICsgNSArICdweCc7IC8vVE9ET1xuXG4gICAgICAgICAgICB0aGlzLl9pc0Jhcm9uRXhpc3QgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLl9zd2l0Y2hFdmVudHMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25TY3JvbGw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnc2Nyb2xsJywge29yaWdpbmFsRXZlbnQ6IGV9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25DbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS50YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fbW92aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdjbGljaycsIHtvcmlnaW5hbEV2ZW50OiBlfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uU3RhcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX21vdmVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9tb3ZpbmcpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgIHZhciBmaXJzdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XG5cbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0UG9pbnQgPSBuZXcgREcuUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZVRvdWNoRXZlbnRzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uRW5kOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGVUb3VjaEV2ZW50cyh0cnVlKTtcblxuICAgICAgICAgICAgdGhpcy5fb25DbGljayhlKTtcblxuICAgICAgICAgICAgdGhpcy5fbW92aW5nID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uTW92ZTogZnVuY3Rpb24oZSkge1xuXG4gICAgICAgICAgICBpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXG4gICAgICAgICAgICAgICAgbmV3UG9pbnQgPSBERy5wb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKSxcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBNYXRoLmFicyhuZXdQb2ludC5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvaW50KS55KTtcblxuICAgICAgICAgICAgaWYgKCFvZmZzZXQgfHwgb2Zmc2V0IDwgMTApIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgIHRoaXMuX21vdmluZyA9IHRoaXMuX21vdmVkID0gdHJ1ZTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0QmFyb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9zY3JvbGxlcldyYXBwZXI7XG4gICAgICAgICAgICB0aGlzLl9iYXJvbiA9IGdyYWYoe1xuICAgICAgICAgICAgICAgIHNjcm9sbGVyOiAnLmRnLXNjcm9sbGVyJyxcbiAgICAgICAgICAgICAgICBiYXI6ICcuZGctc2Nyb2xsZXJfX2JhcicsXG4gICAgICAgICAgICAgICAgdHJhY2s6ICcuZGctc2Nyb2xsZXJfX2Jhci13cmFwcGVyJyxcbiAgICAgICAgICAgICAgICAkOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHt9LnRvU3RyaW5nLmNhbGwoc2VsZWN0b3IpID09PSAnW29iamVjdCBTdHJpbmddJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpIDogc2VsZWN0b3I7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCYXJvbkRvbUhlbHBlcihub2RlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV2ZW50OiBmdW5jdGlvbihlbGVtLCBldmVudCwgZnVuYywgbW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgREcuRG9tRXZlbnRbbW9kZSB8fCAnb24nXShlbGVtLCB0eXBlLCBmdW5jKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRIZWFkZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fcG9wdXBTdHJ1Y3R1cmUuaGVhZGVyID0gREcuRG9tVXRpbC5jcmVhdGUoJ2hlYWRlcicsICdkZy1wb3B1cF9faGVhZGVyJywgdGhpcy5fY29udGVudE5vZGUpO1xuICAgICAgICAgICAgdGhpcy5fcG9wdXBTdHJ1Y3R1cmUuaGVhZGVyLnNldEF0dHJpYnV0ZSgnZGlyJywgdGhpcy5vcHRpb25zLnRleHREaXJlY3Rpb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0Rm9vdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwU3RydWN0dXJlLmZvb3RlciA9IERHLkRvbVV0aWwuY3JlYXRlKCdmb290ZXInLCAnZGctcG9wdXBfX2Zvb3RlcicsIHRoaXMuX2NvbnRlbnROb2RlKTtcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwU3RydWN0dXJlLmZvb3Rlci5zZXRBdHRyaWJ1dGUoJ2RpcicsIHRoaXMub3B0aW9ucy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdEJvZHlDb250YWluZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fcG9wdXBTdHJ1Y3R1cmUud3JhcHBlciA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnZGctcG9wdXBfX2NvbnRhaW5lci13cmFwcGVyJywgdGhpcy5fY29udGVudE5vZGUpO1xuICAgICAgICAgICAgdGhpcy5fcG9wdXBTdHJ1Y3R1cmUuYm9keSA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnZGctcG9wdXBfX2NvbnRhaW5lcicsIHRoaXMuX3BvcHVwU3RydWN0dXJlLndyYXBwZXIpO1xuICAgICAgICAgICAgdGhpcy5fcG9wdXBTdHJ1Y3R1cmUuYm9keS5zZXRBdHRyaWJ1dGUoJ2RpcicsIHRoaXMub3B0aW9ucy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgIGlmICghREcuQnJvd3Nlci5pZWx0OSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zd2l0Y2hFdmVudHModHJ1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2NsZWFyTm9kZSh0aGlzLl9jb250ZW50Tm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9pc0Jhcm9uRXhpc3QgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gaW5pdCBwb3B1cCBjb250ZW50IGRvbSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIGlmICh0aGlzLl9oZWFkZXJDb250ZW50KSB7IHRoaXMuX2luaXRIZWFkZXIoKTsgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2JvZHlDb250ZW50KSB7IHRoaXMuX2luaXRCb2R5Q29udGFpbmVyKCk7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9mb290ZXJDb250ZW50KSB7IHRoaXMuX2luaXRGb290ZXIoKTsgfVxuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQb3B1cFN0cnVjdHVyZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcblxuICAgICAgICAgICAgREcuRG9tRXZlbnQub24odGhpcy5fd3JhcHBlciwgJ2NsaWNrJywgREcuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuX3N3aXRjaEV2ZW50cygpO1xuXG4gICAgICAgICAgICBpZiAoREcuQnJvd3Nlci5pZWx0OSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gdGhpcy5fcG9wdXBTdHJ1Y3R1cmUuZm9vdGVyO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uY2xhc3NOYW1lICs9ICcgaWU4JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghREcuQnJvd3Nlci5pZWx0OSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldERlbHRhOiBmdW5jdGlvbigpIHsgLy8gKCkgLT4gTnVtYmVyXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSAwLFxuICAgICAgICAgICAgICAgIHBvcHVwID0gdGhpcy5fcG9wdXBTdHJ1Y3R1cmU7XG5cbiAgICAgICAgICAgIGlmIChwb3B1cC5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBkZWx0YSArPSBwb3B1cC5oZWFkZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcHVwLmZvb3Rlcikge1xuICAgICAgICAgICAgICAgIGRlbHRhICs9IHBvcHVwLmZvb3Rlci5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkZWx0YTtcbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLl9jb250ZW50Tm9kZSwgLy8gbGVhZmxldC1wb3B1cC1jb250ZW50XG4gICAgICAgICAgICAgICAgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXIsIC8vIGxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVyXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBjb250ZW50LnN0eWxlLFxuICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZSA9IHdyYXBwZXIuc3R5bGUsXG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgc2Nyb2xsZWRDbGFzcyA9ICdsZWFmbGV0LXBvcHVwLXNjcm9sbGVkJyxcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgICAgICAgc3R5bGUubWFyZ2luID0gb3B0cy5ib3JkZXIgKyAncHgnO1xuXG4gICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRlbnQsIHNjcm9sbGVkQ2xhc3MpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5faXNDb250ZW50SGVpZ2h0RW5vdWdoKCkpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUubWF4SGVpZ2h0ID0gY29udGVudC5vZmZzZXRIZWlnaHQgKyBvcHRzLmJvcmRlciAqIDIgKyAncHgnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUubWF4SGVpZ2h0ID0gb3B0cy5tYXhIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3MoY29udGVudCwgc2Nyb2xsZWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gb3B0cy5hdXRvUGFuUGFkZGluZ1swXSAqIDI7XG5cbiAgICAgICAgICAgIGlmIChvcHRzLnNwcmF3bGluZykge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gb3B0cy5tYXhXaWR0aDtcblxuICAgICAgICAgICAgICAgIHdpZHRoID0gTWF0aC5taW4od2lkdGgsIHRoaXMuX21hcC5fY29udGFpbmVyLm9mZnNldFdpZHRoIC0gYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICAgICAgICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIG9wdHMubWluV2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUud2lkdGggPSAnJztcblxuICAgICAgICAgICAgICAgIHN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHdyYXBwZXIub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgc3R5bGUud2hpdGVTcGFjZSA9ICcnO1xuXG4gICAgICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1pbih3aWR0aCwgdGhpcy5fbWFwLl9jb250YWluZXIub2Zmc2V0V2lkdGggLSBhdmFpbGFibGVXaWR0aCk7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1pbihNYXRoLm1heCh3aWR0aCwgb3B0cy5taW5XaWR0aCksIG9wdHMubWF4V2lkdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVQb3B1cFN0cnVjdHVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9wb3B1cFN0cnVjdHVyZSkuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5zZXJ0Q29udGVudCh0aGlzWydfJyArIGl0ZW0gKyAnQ29udGVudCddLCB0aGlzLl9wb3B1cFN0cnVjdHVyZVtpdGVtXSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy5maXJlKCdjb250ZW50dXBkYXRlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luc2VydENvbnRlbnQ6IGZ1bmN0aW9uKGNvbnRlbnQsIG5vZGUpIHsgLy8gKFN0cmluZyB8IERPTUVsZW1lbnQsIERPTUVsZW1lbnQpXG4gICAgICAgICAgICBpZiAoIWNvbnRlbnQgfHwgIW5vZGUpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSAodHlwZW9mIGNvbnRlbnQgPT09ICdmdW5jdGlvbicpID8gY29udGVudCh0aGlzLl9zb3VyY2UgfHwgdGhpcykgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhck5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfY2xlYXJOb2RlOiBmdW5jdGlvbihub2RlKSB7IC8vIChET01FbGVtZW50KVxuICAgICAgICAgICAgd2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kZXRhY2hFbDogZnVuY3Rpb24oZWxlbSkgeyAvLyAoRE9NRWxlbWVudCkgLT4gRE9NRWxlbWVudFxuICAgICAgICAgICAgaWYgKGVsZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zd2l0Y2hFdmVudHM6IGZ1bmN0aW9uKG9uKSB7IC8vIChCb29sZWFuKVxuICAgICAgICAgICAgdmFyIHN3aXRjaGVyID0gb24gPyAnb2ZmJyA6ICdvbic7XG5cbiAgICAgICAgICAgIGlmICghREcuQnJvd3Nlci50b3VjaCkge1xuICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50W3N3aXRjaGVyXSh0aGlzLl9jb250ZW50Tm9kZSwgJ2NsaWNrJywgdGhpcy5fb25DbGljaywgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50W3N3aXRjaGVyXSh0aGlzLl9jb250ZW50Tm9kZSwgJ3RvdWNoc3RhcnQgbW91c2Vkb3duIG1vdXNlbW92ZScsIHRoaXMuX29uU3RhcnQsIHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5faXNCYXJvbkV4aXN0KSB7XG4gICAgICAgICAgICAgICAgREcuRG9tRXZlbnRbc3dpdGNoZXJdKHRoaXMuX3Njcm9sbGVyLCAnc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF90b2dnbGVUb3VjaEV2ZW50czogZnVuY3Rpb24ob24pIHtcbiAgICAgICAgICAgIHZhciBzd2l0Y2hlciA9IG9uID8gJ29mZicgOiAnb24nO1xuXG4gICAgICAgICAgICBERy5Eb21FdmVudFtzd2l0Y2hlcl0odGhpcy5fY29udGVudE5vZGUsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xuICAgICAgICAgICAgREcuRG9tRXZlbnRbc3dpdGNoZXJdKHRoaXMuX2NvbnRlbnROb2RlLCAndG91Y2hlbmQnLCB0aGlzLl9vbkVuZCwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgIH0pO1xufSgpKTtcblxuXG5ERy5NYXAuaW5jbHVkZSh7XG4gICAgX21hcmtlckNsYXNzOiAnZGctY3VzdG9taXphdGlvbl9fbWFya2VyX3R5cGVfbXVzaHJvb20nLFxuICAgIF9tYXJrZXJTaG93Q2xhc3M6ICdkZy1jdXN0b21pemF0aW9uX19tYXJrZXJfYXBwZWFyJyxcbiAgICBfbWFya2VySGlkZUNsYXNzOiAnZGctY3VzdG9taXphdGlvbl9fbWFya2VyX2Rpc2FwcGVhcicsXG4gICAgX2RnSGlkZUNsYXNzOiAnZGctcG9wdXBfaGlkZGVuX3RydWUnLFxuICAgIG9wZW5Qb3B1cDogZnVuY3Rpb24ocG9wdXAsIGxhdGxuZywgb3B0aW9ucykgeyAvLyAoUG9wdXApIG9yIChTdHJpbmcgfHwgSFRNTEVsZW1lbnQsIExhdExuZ1ssIE9iamVjdF0pXG4gICAgICAgIGlmICghKHBvcHVwIGluc3RhbmNlb2YgTC5Qb3B1cCkpIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcG9wdXA7XG5cbiAgICAgICAgICAgIHBvcHVwID0gbmV3IEwuUG9wdXAob3B0aW9ucykuc2V0Q29udGVudChjb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXRsbmcpIHtcbiAgICAgICAgICAgIHBvcHVwLnNldExhdExuZyhsYXRsbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzTGF5ZXIocG9wdXApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9wb3B1cC5vcHRpb25zLmF1dG9DbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVBvcHVwKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wb3B1cCA9IHBvcHVwO1xuXG4gICAgICAgIGlmIChwb3B1cC5fc291cmNlICYmIHBvcHVwLl9zb3VyY2UuX2ljb24pIHtcbiAgICAgICAgICAgIGlmIChwb3B1cC5fc291cmNlLl9pY29uLmNsYXNzTmFtZS5pbmRleE9mKHRoaXMuX21hcmtlckNsYXNzKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKHBvcHVwLl9zb3VyY2UuX2ljb24sIHRoaXMuX21hcmtlclNob3dDbGFzcyk7XG4gICAgICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyhwb3B1cC5fc291cmNlLl9pY29uLCB0aGlzLl9tYXJrZXJIaWRlQ2xhc3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKHBvcHVwLl9zb3VyY2UuX2ljb24sIHRoaXMuX2RnSGlkZUNsYXNzKTtcbiAgICAgICAgICAgICAgICBpZiAocG9wdXAuX3NvdXJjZS5fc2hhZG93KSB7XG4gICAgICAgICAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3MocG9wdXAuX3NvdXJjZS5fc2hhZG93LCB0aGlzLl9kZ0hpZGVDbGFzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTGF5ZXIocG9wdXApO1xuICAgIH0sXG5cbiAgICBjbG9zZVBvcHVwOiBmdW5jdGlvbihwb3B1cCkgeyAgLy8gKFBvcHVwKSAtPiBQb3B1cFxuICAgICAgICBpZiAoIXBvcHVwIHx8IHBvcHVwID09PSB0aGlzLl9wb3B1cCkge1xuICAgICAgICAgICAgcG9wdXAgPSB0aGlzLl9wb3B1cDtcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wdXApIHtcbiAgICAgICAgICAgIGlmIChwb3B1cC5fc291cmNlICYmIHBvcHVwLl9zb3VyY2UuX2ljb24pIHtcbiAgICAgICAgICAgICAgICBpZiAocG9wdXAuX3NvdXJjZS5faWNvbi5jbGFzc05hbWUuaW5kZXhPZih0aGlzLl9tYXJrZXJDbGFzcykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIERHLkRvbVV0aWwucmVtb3ZlQ2xhc3MocG9wdXAuX3NvdXJjZS5faWNvbiwgdGhpcy5fbWFya2VySGlkZUNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyhwb3B1cC5fc291cmNlLl9pY29uLCB0aGlzLl9tYXJrZXJTaG93Q2xhc3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIERHLkRvbVV0aWwucmVtb3ZlQ2xhc3MocG9wdXAuX3NvdXJjZS5faWNvbiwgdGhpcy5fZGdIaWRlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9wdXAuX3NvdXJjZS5fc2hhZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKHBvcHVwLl9zb3VyY2UuX3NoYWRvdywgdGhpcy5fZGdIaWRlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVMYXllcihwb3B1cCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcbiIsIkRHLkRpY3Rpb25hcnkgPSB7fTtcblxuREcuRGljdGlvbmFyeS5ydSA9IHtcbiAgICBwbHVyYWxSdWxlczogZnVuY3Rpb24obikgeyAvLyAoTnVtYmVyKVxuICAgICAgICBpZiAobiAlIDEwID09PSAxICYmIG4gJSAxMDAgIT09IDExKSB7IC8vIDEsIDIxXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG4gJSAxMCA+PSAyICYmIG4gJSAxMCA8PSA0ICYmIChuICUgMTApICUgMSA9PT0gMCkgJiYgKG4gJSAxMDAgPCAxMiB8fCBuICUgMTAwID4gMTQpKSB7IC8vIDIsIDNcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChuICUgMTAgPT09IDApIHx8IChuICUgMTAgPj0gNSAmJiBuICUgMTAgPD0gOSAmJiAobiAlIDEwKSAlIDEgPT09IDApIHx8IChuICUgMTAwID49IDExICYmIChuICUgMTAwKSA8PSAxNCAmJiAobiAlIDEwMCkgJSAxID09PSAwKSkgeyAvLyAxMywgMTdcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuREcuRGljdGlvbmFyeS5lbiA9IHtcbiAgICBwbHVyYWxSdWxlczogZnVuY3Rpb24obikgeyAvLyAoTnVtYmVyKVxuICAgICAgICBpZiAobiA9PT0gMSkgeyAvLyAxXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxOyAvLzAsIDIsIDMsIDQgLi5cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkRHLkRpY3Rpb25hcnkuaXQgPSB7XG4gICAgcGx1cmFsUnVsZXM6IGZ1bmN0aW9uKG4pIHsgLy8gKE51bWJlcilcbiAgICAgICAgaWYgKG4gPT09IDEpIHsgLy8gMVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMTsgLy8wLCAyLCAzLCA0IC4uXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5ERy5EaWN0aW9uYXJ5LmNzID0ge1xuICAgIHBsdXJhbFJ1bGVzOiBmdW5jdGlvbihuKSB7IC8vIChOdW1iZXIpXG4gICAgICAgIHJldHVybiAobiA9PT0gMSkgPyAwIDogKG4gPj0gMiAmJiBuIDw9IDQpID8gMSA6IDI7XG4gICAgfVxufTtcblxuREcuRGljdGlvbmFyeS5lcyA9IHtcbiAgICBwbHVyYWxSdWxlczogZnVuY3Rpb24obikgeyAvLyAoTnVtYmVyKVxuICAgICAgICByZXR1cm4gKG4gPj0gMikgPyAxIDogMDtcbiAgICB9XG59O1xuXG4vLyBTdHViIGZvciBBcmFiaWMgbGFuZ3VhZ2UsIHdlIGRvbid0IGhhdmUgY2FzZXMgd2l0aCBwbHVyYWwgZm9ybSB1c2FnZVxuLy8gQWN0dWFsbHkgQXJhYmljIGhhcyA2IHBsdXJhbCBmb3Jtc1xuREcuRGljdGlvbmFyeS5hciA9IHtcbiAgICBwbHVyYWxSdWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG4iLCJERy5Mb2NhbGUgPSB7XG4gICAgdDogZnVuY3Rpb24obXNnLCBhcmd1bWVudCkgeyAvLyAoU3RyaW5nLCBOdW1iZXIpIC0+IFN0cmluZ1xuICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgbGFuZyA9IHRoaXMuX21hcC5nZXRMYW5nKCksXG4gICAgICAgICAgICBtc2dJc3NldCA9IGZhbHNlLFxuICAgICAgICAgICAgZGljdGlvbmFyeU1zZyxcbiAgICAgICAgICAgIGV4cDtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29uc3RydWN0b3IuRGljdGlvbmFyeVtsYW5nXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChsYW5nID09PSAnYXInKSB7XG4gICAgICAgICAgICAgICAgbGFuZyA9ICdlbic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhbmcgPSBERy5jb25maWcuZGVmYXVsdExhbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGljdGlvbmFyeU1zZyA9IHRoaXMuY29uc3RydWN0b3IuRGljdGlvbmFyeVtsYW5nXVttc2ddO1xuICAgICAgICBtc2dJc3NldCA9IHR5cGVvZiBkaWN0aW9uYXJ5TXNnICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKCFtc2dJc3NldCkge1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBtc2dJc3NldCA/IGRpY3Rpb25hcnlNc2cgOiBtc2c7XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VJbnQoYXJndW1lbnQsIDEwKTtcbiAgICAgICAgICAgIGFyZ3VtZW50ID0gaXNOYU4oYXJndW1lbnQpID8gMCA6IGFyZ3VtZW50O1xuICAgICAgICAgICAgZXhwID0gdGhpcy5jb25zdHJ1Y3Rvci5EaWN0aW9uYXJ5W2xhbmddLnBsdXJhbFJ1bGVzKGFyZ3VtZW50KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGRpY3Rpb25hcnlNc2dbZXhwXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IERHLlV0aWwudGVtcGxhdGUocmVzdWx0LCB7bjogYXJndW1lbnR9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG5ERy5NYXAuaW5jbHVkZSh7XG4gICAgc2V0TGFuZzogZnVuY3Rpb24obGFuZykgeyAvLyAoU3RyaW5nKVxuICAgICAgICBpZiAobGFuZyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobGFuZykgPT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuY3VycmVudExhbmcgPSBsYW5nO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdsYW5nY2hhbmdlJywgeydsYW5nJzogbGFuZ30pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldExhbmc6IGZ1bmN0aW9uKCkgeyAvLyAoKSAtPiBTdHJpbmdcbiAgICAgICAgLy8gSWYgdGhlIGxhbmd1YWdlIGhhc24ndCBiZWVuIHNldCBiZWZvcmUsIHNldCBpdCB0byBwYWdlIGxhbmd1YWdlIG9yXG4gICAgICAgIC8vIGRlZmF1bHQgbGFuZ3VhZ2UgZnJvbSBjb25maWdcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuY3VycmVudExhbmcpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgdmFyIGxhbmcgPSByb290LmxhbmcgfHwgKHJvb3QuZ2V0QXR0cmlidXRlTlMgJiYgcm9vdC5nZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJywgJ2xhbmcnKSkgfHwgREcuY29uZmlnLmRlZmF1bHRMYW5nO1xuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuY3VycmVudExhbmcgPSBsYW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jdXJyZW50TGFuZztcbiAgICB9XG59KTtcbiIsIkRHLlJvdW5kQ29udHJvbCA9IERHLkNvbnRyb2wuZXh0ZW5kKHtcbiAgICBpbmNsdWRlczogREcuTWl4aW4uRXZlbnRzLFxuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBwb3NpdGlvbjogJ3RvcHJpZ2h0JyxcbiAgICAgICAgaWNvbkNsYXNzOiAnZGVmYXVsdCdcbiAgICB9LFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB2YXIgY29udHJvbENsYXNzID0gdGhpcy5fY29udHJvbENMYXNzID0gJ2RnLWNvbnRyb2wtcm91bmQnLFxuICAgICAgICAgICAgY29udHJvbEljb25DbGFzcyA9IHRoaXMuX2NvbnRyb2xJY29uQ0xhc3MgPSB0aGlzLl9jb250cm9sQ0xhc3MgKyAnX19pY29uJyxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnJyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2Rpc2FibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsIGNvbnRyb2xDbGFzcyk7XG5cbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLl9saW5rID0gREcuRG9tVXRpbC5jcmVhdGUoXG4gICAgICAgICAgICAnYScsXG4gICAgICAgICAgICBjb250cm9sSWNvbkNsYXNzICsgJyAnICsgY29udHJvbEljb25DbGFzcyArICdfbmFtZV8nICsgdGhpcy5vcHRpb25zLmljb25DbGFzcyxcbiAgICAgICAgICAgIGNvbnRhaW5lclxuICAgICAgICApO1xuXG4gICAgICAgIGxpbmsuaHJlZiA9ICcjJztcblxuICAgICAgICB0aGlzLl9yZW5kZXJUcmFuc2xhdGlvbigpO1xuXG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcblxuICAgICAgICBERy5Eb21FdmVudFxuICAgICAgICAgICAgLm9uKGNvbnRhaW5lciwgJ2NsaWNrJywgdGhpcy5fdG9nZ2xlQ29udHJvbCwgdGhpcylcbiAgICAgICAgICAgIC5vbihjb250YWluZXIsICdkYmxjbGljaycsIERHLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgICAgIC5vbihsaW5rLCAnbW91c2Vkb3duJywgREcuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcblxuICAgICAgICB0aGlzLmZpcmVFdmVudCgnYWRkJyk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZpcmVFdmVudCgncmVtb3ZlJyk7XG4gICAgICAgIERHLkRvbUV2ZW50Lm9mZih0aGlzLl9saW5rLCAnY2xpY2snLCB0aGlzLl90b2dnbGVDb250cm9sKTtcbiAgICB9LFxuXG4gICAgc2V0U3RhdGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5fbGluayB8fCAhdGhpcy5fY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsIHRoaXMuX2NvbnRyb2xDTGFzcyArICdfc3RhdGVfJyArIHRoaXMuX3N0YXRlKTtcbiAgICAgICAgICAgIERHLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbGluaywgdGhpcy5fY29udHJvbEljb25DTGFzcyArICdfc3RhdGVfJyArIHRoaXMuX3N0YXRlKTtcblxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuXG4gICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgdGhpcy5fY29udHJvbENMYXNzICsgJ19zdGF0ZV8nICsgdGhpcy5fc3RhdGUpO1xuICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9saW5rLCB0aGlzLl9jb250cm9sSWNvbkNMYXNzICsgJ19zdGF0ZV8nICsgdGhpcy5fc3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF90b2dnbGVDb250cm9sOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIERHLkRvbUV2ZW50LnN0b3AoZSk7XG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KCdjbGljaycpO1xuICAgIH1cbn0pO1xuXG5ERy5Sb3VuZENvbnRyb2wuaW5jbHVkZShERy5Mb2NhbGUpO1xuXG5ERy5yb3VuZENvbnRyb2wgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBERy5Sb3VuZENvbnRyb2wob3B0aW9ucyk7XG59O1xuIiwidmFyIGllOSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFyIGFsbCA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaScpO1xuICAgIGRpdi5pbm5lckhUTUwgPSAnPCEtLVtpZiBJRSA5XT48aT48L2k+PCFbZW5kaWZdLS0+JztcbiAgICByZXR1cm4gQm9vbGVhbihhbGxbMF0pO1xufSkoKTtcblxudmFyIHNhZmFyaTUxID0gREcuQnJvd3Nlci5zYWZhcmkgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdWZXJzaW9uLzUuMScpICE9PSAtMTtcblxudmFyIHdhc1ByZXZpb3VzbHlEaXNhYmxlZCA9IGZhbHNlO1xuXG4vLyBPbGQgU2FmYXJpIHRocm93cyBlcnJvciB3aGVuIGxvY2FsU3RvcmFnZS5nZXRJdGVtIGlzIGNhbGxlZCBpbiBwcml2YXRlIG1vZGVcbnRyeSB7XG4gICAgd2FzUHJldmlvdXNseURpc2FibGVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ0RHTXVzZXVtJykgPT09ICdmYWxzZSc7XG59IGNhdGNoIChlcnIpIHtcbiAgICAvLyBkbyBub3RoaW5nXG59XG5cbkRHLk1hcC5tZXJnZU9wdGlvbnMoe1xuICAgIG11c2V1bTogIXdhc1ByZXZpb3VzbHlEaXNhYmxlZCAmJiAoREcuQnJvd3Nlci5pZWx0OSB8fCBpZTkgfHwgREcuQnJvd3Nlci5vcGVyYTEyIHx8IHNhZmFyaTUxKVxufSk7XG5cbkRHLk1hcC5NdXNldW0gPSBERy5IYW5kbGVyLmV4dGVuZCh7XG4gICAgc3RhdGljczoge1xuICAgICAgICBEaWN0aW9uYXJ5OiB7XG4gICAgICAgICAgICBhcjoge1xuICAgICAgICAgICAgICAgIHdlYXJlc29ycnk6ICfZhNinINmG2LbZhdmGINmE2YMg2KrYtNi62YrZhCDYq9in2KjYqiDZhNmE2KrYt9io2YrZgiDYudmE2Ykg2YXYqti12YHYrdmDLiDYrdin2YjZhCDYp9mE2KrYrdiv2YrYqzonXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3M6IHtcbiAgICAgICAgICAgICAgICB3ZWFyZXNvcnJ5OiAnTmV6YXJ1xI11amVtZSBzdGFiaWxuw60gZnVuZ292w6Fuw60gYXBsaWthY2UgdmUgVmHFoWVtIHByb2hsw63FvmXEjWkuIFprdXN0ZSBwcm92w6lzdCBha3R1YWxpemFjaTonXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW46IHtcbiAgICAgICAgICAgICAgICB3ZWFyZXNvcnJ5OiAnV2UgZG8gbm90IGd1YXJhbnRlZSBzdGFibGUgb3BlcmF0aW9uIG9mIHRoZSBhcHBsaWNhdGlvbiBpbiB5b3VyIGJyb3dzZXIuIFRyeSB1cGRhdGluZzonXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXM6IHtcbiAgICAgICAgICAgICAgICB3ZWFyZXNvcnJ5OiAnTm8gZ2FyYW50aXphbW9zIHVuIGZ1bmNpb25hbWllbnRvIGVzdGFibGUgZGUgbGEgYXBsaWNhY2nDs24gZW4gc3UgYnVzY2Fkb3IuIEludGVudGUgYWN0dWFsaXphcmxvOidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpdDoge1xuICAgICAgICAgICAgICAgIHdlYXJlc29ycnk6ICdOb24gZ2FyYW50aWFtbyBpbCBmdW56aW9uYW1lbnRvIHN0YWJpbGUgZGVsbFxcJ2FwcGxpY2F6aW9uZSBuZWwgdHVvIGJyb3dzZXIuIFByb3ZhIGFkIGFnZ2lvcm5hcmU6J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1OiB7XG4gICAgICAgICAgICAgICAgd2VhcmVzb3JyeTogJ9Cc0Ysg0L3QtSDQs9Cw0YDQsNC90YLQuNGA0YPQtdC8INGB0YLQsNCx0LjQu9GM0L3Rg9GOINGA0LDQsdC+0YLRgyDQv9GA0LjQu9C+0LbQtdC90LjRjyDQsiDQstCw0YjQtdC8INCx0YDQsNGD0LfQtdGA0LUuINCf0L7Qv9GA0L7QsdGD0LnRgtC1INC+0LHQvdC+0LLQuNGC0YzRgdGPOidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpbmNsdWRlczogW0RHLkxvY2FsZV0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuXG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc05hbWUgPSAnZGctbXVzZXVtJztcbiAgICAgICAgdGhpcy5fZWxlbWVudC5pbm5lckhUTUwgPSAnPHNwYW4+PC9zcGFuPicgK1xuICAgICAgICAgICAgJzxhIGNsYXNzPVwiZGctbXVzZXVtLWJyb3dzZXIgZGctbXVzZXVtX19jaHJvbWVcIiB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPVwiaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9jaHJvbWUvXCI+PC9hPicgK1xuICAgICAgICAgICAgJzxhIGNsYXNzPVwiZGctbXVzZXVtLWJyb3dzZXIgZGctbXVzZXVtX19maXJlZm94XCIgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj1cImh0dHBzOi8vd3d3Lm1vemlsbGEub3JnL2ZpcmVmb3gvbmV3L1wiPjwvYT4nICtcbiAgICAgICAgICAgICc8YSBjbGFzcz1cImRnLW11c2V1bS1icm93c2VyIGRnLW11c2V1bV9fc2FmYXJpXCIgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj1cImh0dHBzOi8vc3VwcG9ydC5hcHBsZS5jb20vZG93bmxvYWRzL3NhZmFyaVwiPjwvYT4nICtcbiAgICAgICAgICAgICc8YSBjbGFzcz1cImRnLW11c2V1bS1icm93c2VyIGRnLW11c2V1bV9fb3BlcmFcIiB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPVwiaHR0cHM6Ly93d3cub3BlcmEuY29tL1wiPjwvYT4nICtcbiAgICAgICAgICAgICc8YSBjbGFzcz1cImRnLW11c2V1bS1icm93c2VyIGRnLW11c2V1bV9faWVcIiB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPVwiaHR0cHM6Ly93aW5kb3dzLm1pY3Jvc29mdC5jb20vaW50ZXJuZXQtZXhwbG9yZXIvZG93bmxvYWQtaWVcIj48L2E+JztcblxuICAgICAgICB0aGlzLl90ZXh0ID0gdGhpcy5fZWxlbWVudC5jaGlsZHJlblswXTtcblxuICAgICAgICB0aGlzLl9jbG9zZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgdGhpcy5fY2xvc2VCdXR0b24uY2xhc3NOYW1lID0gJ2RnLW11c2V1bV9fY2xvc2UnO1xuICAgICAgICB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2Nsb3NlQnV0dG9uKTtcblxuICAgICAgICB0aGlzLl9yZW5kZXJUcmFuc2xhdGlvbigpO1xuICAgIH0sXG5cbiAgICBhZGRIb29rczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50KTtcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdsYW5nY2hhbmdlJywgdGhpcy5fcmVuZGVyVHJhbnNsYXRpb24sIHRoaXMpO1xuICAgICAgICBERy5Eb21FdmVudC5vbih0aGlzLl9jbG9zZUJ1dHRvbiwgJ2NsaWNrJywgdGhpcy5fb25DbG9zZUJ1dHRvbkNsaWNrLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlSG9va3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkucmVtb3ZlQ2hpbGQodGhpcy5fZWxlbWVudCk7XG4gICAgICAgIHRoaXMuX21hcC5vZmYoJ2xhbmdjaGFuZ2UnLCB0aGlzLl9yZW5kZXJUcmFuc2xhdGlvbiwgdGhpcyk7XG4gICAgICAgIERHLkRvbUV2ZW50Lm9mZih0aGlzLl9jbG9zZUJ1dHRvbiwgJ2NsaWNrJywgdGhpcy5fb25DbG9zZUJ1dHRvbkNsaWNrLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX29uQ2xvc2VCdXR0b25DbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICBERy5Eb21FdmVudC5zdG9wKGUpO1xuXG4gICAgICAgIC8vIE9sZCBTYWZhcmkgdGhyb3dzIGVycm9yIHdoZW4gbG9jYWxTdG9yYWdlLmdldEl0ZW0gaXMgY2FsbGVkIGluIHByaXZhdGUgbW9kZVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ0RHTXVzZXVtJywgJ2ZhbHNlJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgfSxcblxuICAgIF9yZW5kZXJUcmFuc2xhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsYW5nID0gdGhpcy5fbWFwLmdldExhbmcoKTtcbiAgICAgICAgdGhpcy5fdGV4dC5pbm5lckhUTUwgPSB0aGlzLnQoJ3dlYXJlc29ycnknKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RpcicsIGxhbmcgPT09ICdhcicgPyAncnRsJzogJ2x0cicpO1xuICAgIH1cbn0pO1xuXG5ERy5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnbXVzZXVtJywgREcuTWFwLk11c2V1bSk7XG4iLCJERy5jb25maWdUaGVtZSA9IERHLmNvbmZpZ1RoZW1lIHx8IHt9O1xuXG5ERy5jb25maWdUaGVtZS5tYXJrZXJzRGF0YSA9IHtcbiAgICBpY29uU2l6ZTogWzIyLCAzNF0sXG4gICAgY2xhc3NOYW1lOiAnZGctY3VzdG9taXphdGlvbl9fbWFya2VyIGRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29tJyxcbiAgICBpY29uQW5jaG9yOiBbMTAsIDMyXVxufTtcbiIsIi8vIEZpeCBhIGxvdCBvZiBidWdzIHdpdGggcGluY2gtem9vbWluZ1xuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS8yZ2lzL21hcHNhcGkvaXNzdWVzLzMyN1xuREcuTWFwLm1lcmdlT3B0aW9ucyh7XG4gICAgYm91bmNlQXRab29tTGltaXRzOiBmYWxzZVxufSk7XG5cbi8vSW5qZWN0IG9ic2VydmluZyBsb2NhbGl6YXRpb24gY2hhbmdlXG52YXIgY29udHJvbEFkZFRvID0gREcuQ29udHJvbC5wcm90b3R5cGUuYWRkVG87XG5cbkRHLkNvbnRyb2wuaW5jbHVkZSh7XG4gICAgYWRkVG86IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICBtYXAub24oJ2xhbmdjaGFuZ2UnLCB0aGlzLl9yZW5kZXJUcmFuc2xhdGlvbiwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xBZGRUby5jYWxsKHRoaXMsIG1hcCk7XG4gICAgfSxcbiAgICBfcmVuZGVyVHJhbnNsYXRpb246IGZ1bmN0aW9uKCkge31cbn0pO1xuXG4vLyBBZGQgc29tZSBicm93c2VyIGRldGVjdGlvblxuREcuQnJvd3Nlci5zYWZhcmk1MSA9IERHLkJyb3dzZXIuc2FmYXJpICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVmVyc2lvbi81LjEnKSAhPT0gLTE7XG5cbi8vIERHLkJyb3dzZXIudG91Y2ggY2hlY2tzIHdoZXRoZXIgdG91Y2ggZXZlbnRzIHN1cHBvcnRlZCBvciBub3Q7IHRvdWNoRW5hYmxlZCBjaGVja3MgaWYgaXQncyBhIHRvdWNoIGRldmljZVxudmFyIG1zUG9pbnRlciA9IG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkICYmIG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzICYmICF3aW5kb3cuUG9pbnRlckV2ZW50O1xudmFyIHBvaW50ZXIgPSAod2luZG93LlBvaW50ZXJFdmVudCAmJiBuYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzKSB8fCBtc1BvaW50ZXI7XG52YXIgZG9jdW1lbnRUb3VjaCA9IHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2g7XG5ERy5Ccm93c2VyLnRvdWNoRW5hYmxlZCA9IHBvaW50ZXIgfHwgJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8IGRvY3VtZW50VG91Y2g7XG5cbi8vIEFwcGxpZXMgMkdJUyBkaXZJY29uIHRvIG1hcmtlclxuREcuTWFya2VyLnByb3RvdHlwZS5vcHRpb25zLmljb24gPSBERy5kaXZJY29uKERHLmNvbmZpZ1RoZW1lLm1hcmtlcnNEYXRhKTtcblxuLy8gc3VwcG9ydCBvbGQgb3B0aW9uIGNsaWNrYWJsZVxudmFyIHV0aWxTZXRPcHRpb25zID0gREcuVXRpbC5zZXRPcHRpb25zO1xuXG5ERy5zZXRPcHRpb25zID0gTC5zZXRPcHRpb25zID0gREcuVXRpbC5zZXRPcHRpb25zID0gZnVuY3Rpb24ob2JqLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuY2xpY2thYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvcHRpb25zLmludGVyYWN0aXZlID0gb3B0aW9ucy5jbGlja2FibGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxTZXRPcHRpb25zLmNhbGwodGhpcywgb2JqLCBvcHRpb25zKTtcbn07XG5cbkRHLkxheWVyLm1lcmdlT3B0aW9ucyh7XG4gICAgbm9uQnViYmxpbmdFdmVudHM6IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ2NvbnRleHRtZW51J11cbn0pO1xuXG5MLkNhbnZhcy5pbmNsdWRlKHtcbiAgICAvLyBvdmVyd3JpdGUgdGhlIGZ1bmN0aW9uIHdpdGhvdXQgbW91c2Vtb3ZlIGRlYm91bmNlIGFzIGl0IGJyZWFrcyBtZXRhbGF5ZXJzIGV2ZW50c1xuICAgIF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgICAgIEwuRG9tRXZlbnRcbiAgICAgICAgICAgIC5vbihjb250YWluZXIsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcylcbiAgICAgICAgICAgIC5vbihjb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBjb250ZXh0bWVudScsIHRoaXMuX29uQ2xpY2ssIHRoaXMpXG4gICAgICAgICAgICAub24oY29udGFpbmVyLCAnbW91c2VvdXQnLCB0aGlzLl9oYW5kbGVNb3VzZU91dCwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5fY3R4ID0gY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG4gICAgfVxufSk7XG4iLCJ2YXIgaW5pdE1hcCA9IERHLk1hcC5wcm90b3R5cGUuaW5pdGlhbGl6ZSxcbiAgICBwYW5CeSA9IERHLk1hcC5wcm90b3R5cGUucGFuQnksXG4gICAgZ2V0Qm91bmRzWm9vbSA9IERHLk1hcC5wcm90b3R5cGUuZ2V0Qm91bmRzWm9vbSxcbiAgICBzZXRNYXhab29tID0gREcuTWFwLnByb3RvdHlwZS5zZXRNYXhab29tO1xuXG4vLyBSZXN0cmljdCB6b29tIGxldmVsIGFjY29yZGluZyB0byAyZ2lzIHByb2plY3RzLCBpbiBjYXNlIGlmIGRnVGlsZUxheWVyIGlzIG9ubHkgb25lXG5ERy5NYXAuaW5jbHVkZSh7XG5cbiAgICAvLyBudW1iZXIgb2YgdGlsZUxheWVycyB3aXRob3V0IDJnaXMgbGF5ZXJzXG4gICAgX3RpbGVMYXllcnNOdW1iZXI6IDAsXG5cbiAgICBfbWFwTWF4Wm9vbUNhY2hlOiBudWxsLFxuXG4gICAgLy9UT0RPIHRyeSByZWZhY3RvciBpdCBhZnRlciB1cCBvbiBuZXcgbGVhZmxldCAoPiAwLjcpXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oaWQsIG9wdGlvbnMpIHsgLy8gKEhUTUxFbGVtZW50IG9yIFN0cmluZywgT2JqZWN0KVxuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0IHdoZWVsUHhQZXJab29tTGV2ZWwgdmFsdWUgdG8gYXZvaWQgem9vbWluZyB0b28gZmFzdFxuICAgICAgICAvLyBvbiBtb3VzZSB3aGVlbCByb3RhdGlvblxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tLzJnaXMvbWFwc2FwaS9pc3N1ZXMvMzQzXG4gICAgICAgIG9wdGlvbnMgPSBERy5leHRlbmQoe3doZWVsUHhQZXJab29tTGV2ZWw6IDEwMDAwfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5tZXRhTGF5ZXJzID0gW107XG5cbiAgICAgICAgaW5pdE1hcC5jYWxsKHRoaXMsIGlkLCBvcHRpb25zKTtcblxuICAgICAgICAvLyAgUHJvamVjdCBtdXN0IGJlIGNoZWNrZWQgYWZ0ZXIgQmFzZUxheWVyIGluaXQgd2hpY2ggb2NjdXJzIGluIEluaXRIb29rIChzZWUgb3JpZyBtZXRob2QgZGVmaW5pdGlvbilcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jZW50ZXIgJiYgdGhpcy5vcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRWaWV3KERHLmxhdExuZyh0aGlzLm9wdGlvbnMuY2VudGVyKSwgdGhpcy5vcHRpb25zLnpvb20sIHtyZXNldDogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGFzdE1ldGFsYXllciA9IHtcbiAgICAgICAgICAgIGxheWVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBlbnRpdHk6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBzZXRWaWV3OiBmdW5jdGlvbihjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcmVzdHJpY3Rab29tKGNlbnRlciwgem9vbSk7XG5cbiAgICAgICAgem9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB0aGlzLl9saW1pdFpvb20oem9vbSk7XG4gICAgICAgIGNlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKERHLmxhdExuZyhjZW50ZXIpLCB6b29tLCB0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5hbmltYXRlID0gdGhpcy5fdGVzdEFuaW1hdGlvbihjZW50ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RvcCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9sb2FkZWQgJiYgIW9wdGlvbnMucmVzZXQgJiYgb3B0aW9ucyAhPT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnpvb20gPSBERy5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRlOiBvcHRpb25zLmFuaW1hdGUsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uXG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucy56b29tKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhbiA9IERHLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb25cbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zLnBhbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRyeSBhbmltYXRpbmcgcGFuIG9yIHpvb21cbiAgICAgICAgICAgIHZhciBhbmltYXRlZCA9ICh0aGlzLl96b29tICE9PSB6b29tKSA/XG4gICAgICAgICAgICB0aGlzLl90cnlBbmltYXRlZFpvb20gJiYgdGhpcy5fdHJ5QW5pbWF0ZWRab29tKGNlbnRlciwgem9vbSwgb3B0aW9ucy56b29tKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5QW5pbWF0ZWRQYW4oY2VudGVyLCBvcHRpb25zLnBhbik7XG5cbiAgICAgICAgICAgIGlmIChhbmltYXRlZCkge1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgcmVzaXplIGhhbmRsZXIgY2FsbCwgdGhlIHZpZXcgd2lsbCByZWZyZXNoIGFmdGVyIGFuaW1hdGlvbiBhbnl3YXlcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XG4gICAgICAgIHRoaXMuX3Jlc2V0VmlldyhjZW50ZXIsIHpvb20pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBwYW5CeTogZnVuY3Rpb24ob2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtYXAgPSBwYW5CeS5jYWxsKHRoaXMsIG9mZnNldCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHpvb20gPSB0aGlzLl9yZXN0cmljdFpvb20odGhpcy5nZXRDZW50ZXIoKSk7XG4gICAgICAgIGlmICh0aGlzLmdldFpvb20oKSA+IHpvb20pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Wm9vbSh6b29tKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSxcblxuICAgIGdldEJvdW5kc1pvb206IGZ1bmN0aW9uKGJvdW5kcywgaW5zaWRlLCBwYWRkaW5nKSB7XG4gICAgICAgIGJvdW5kcyA9IERHLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xuICAgICAgICB0aGlzLl9yZXN0cmljdFpvb20oYm91bmRzKTtcbiAgICAgICAgcmV0dXJuIGdldEJvdW5kc1pvb20uY2FsbCh0aGlzLCBib3VuZHMsIGluc2lkZSwgcGFkZGluZyk7XG4gICAgfSxcblxuICAgIGdldFRpbGVMYXllcnNOdW1iZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZUxheWVyc051bWJlcjtcbiAgICB9LFxuXG4gICAgc2V0TWF4Wm9vbTogZnVuY3Rpb24oem9vbSkge1xuICAgICAgICB0aGlzLl9tYXBNYXhab29tQ2FjaGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gc2V0TWF4Wm9vbS5jYWxsKHRoaXMsIHpvb20pO1xuICAgIH0sXG5cbiAgICBfdGVzdEFuaW1hdGlvbjogZnVuY3Rpb24oY29vcmRzKSB7Ly9pZiB3ZSBqdW1wIHRvIG90aGVyIHByb2plY3QgLSBkaXNhYmxlIGFuaW1hdGlvblxuICAgICAgICBpZiAodGhpcy5wcm9qZWN0RGV0ZWN0b3IuZW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB2YXIgcHJvamVjdEZyb20gPSB0aGlzLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCksXG4gICAgICAgICAgICAgICAgcHJvamVjdFRvID0gdGhpcy5wcm9qZWN0RGV0ZWN0b3IuaXNQcm9qZWN0SGVyZShjb29yZHMpO1xuXG4gICAgICAgICAgICBpZiAocHJvamVjdEZyb20gJiYgcHJvamVjdFRvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2plY3RGcm9tLmNvZGUgPT09IHByb2plY3RUby5jb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIF91cGRhdGVUaWxlTGF5ZXJzOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghKGUubGF5ZXIgaW5zdGFuY2VvZiBERy5UaWxlTGF5ZXIpIHx8IGUubGF5ZXIuX2lzRGcpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2xheWVyYWRkJykge1xuICAgICAgICAgICAgdGhpcy5fdGlsZUxheWVyc051bWJlcisrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGlsZUxheWVyc051bWJlci0tO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9nZXROZXdCb3VuZHM6IGZ1bmN0aW9uKGNvb3Jkcywgem9vbSkge1xuICAgICAgICBpZiAoY29vcmRzIGluc3RhbmNlb2YgREcuTGF0TG5nQm91bmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5wcm9qZWN0KGNvb3Jkcywgem9vbSk7XG4gICAgICAgIHZhciBzY3JlZW5TaXplID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMik7XG5cbiAgICAgICAgdmFyIHN3ID0gdGhpcy51bnByb2plY3QocG9pbnQuc3VidHJhY3Qoc2NyZWVuU2l6ZSksIHpvb20pO1xuICAgICAgICB2YXIgbmUgPSB0aGlzLnVucHJvamVjdChwb2ludC5hZGQoc2NyZWVuU2l6ZSksIHpvb20pO1xuXG4gICAgICAgIHJldHVybiBERy5sYXRMbmdCb3VuZHMoc3csIG5lKTtcbiAgICB9LFxuXG4gICAgX3Jlc3RyaWN0Wm9vbTogZnVuY3Rpb24oY29vcmRzLCB6b29tKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXllcnMgJiZcbiAgICAgICAgICAgIHRoaXMucHJvamVjdERldGVjdG9yLmVuYWJsZWQoKSAmJlxuICAgICAgICAgICAgKHRoaXMuX3RpbGVMYXllcnNOdW1iZXIgPT09IDApKSB7XG5cbiAgICAgICAgICAgIHZhciBtYXBPcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGlzTWFwTWF4Wm9vbSA9ICEhbWFwT3B0aW9ucy5tYXhab29tLFxuICAgICAgICAgICAgICAgIGRnVGlsZUxheWVyID0gdGhpcy5iYXNlTGF5ZXIsXG4gICAgICAgICAgICAgICAgYm91bmRzID0gdGhpcy5fZ2V0TmV3Qm91bmRzKGNvb3Jkcywgem9vbSksXG4gICAgICAgICAgICAgICAgcHJvamVjdCA9IHRoaXMucHJvamVjdERldGVjdG9yLmlzUHJvamVjdEhlcmUoYm91bmRzKTtcblxuICAgICAgICAgICAgaWYgKGlzTWFwTWF4Wm9vbSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbWFwTWF4Wm9vbUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJhc2VMYXllci5vcHRpb25zLmRldGVjdFJldGluYSAmJiBERy5Ccm93c2VyLnJldGluYSAmJiBtYXBPcHRpb25zLm1heFpvb20gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBPcHRpb25zLm1heFpvb20tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcE1heFpvb21DYWNoZSA9IG1hcE9wdGlvbnMubWF4Wm9vbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwT3B0aW9ucy5tYXhab29tID0gKHRoaXMuX21hcE1heFpvb21DYWNoZSAmJiBwcm9qZWN0KSA/IHRoaXMuX21hcE1heFpvb21DYWNoZSA6ICBERy5jb25maWcucHJvamVjdExlYXZlTWF4Wm9vbTtcbiAgICAgICAgICAgICAgICBpZiAocHJvamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBNYXhab29tQ2FjaGUgPSBtYXBPcHRpb25zLm1heFpvb207XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcE9wdGlvbnMubWF4Wm9vbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2plY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRnVGlsZUxheWVyLm9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIERHLkJyb3dzZXIucmV0aW5hICYmIHByb2plY3QubWF4Wm9vbSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRnVGlsZUxheWVyLm9wdGlvbnMubWF4Wm9vbSA9IHByb2plY3QubWF4Wm9vbSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZ1RpbGVMYXllci5vcHRpb25zLm1heFpvb20gPSBwcm9qZWN0Lm1heFpvb207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZ1RpbGVMYXllci5vcHRpb25zLm1heFpvb20gPSBERy5jb25maWcucHJvamVjdExlYXZlTWF4Wm9vbTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZ1RpbGVMYXllci5vcHRpb25zLm1heE5hdGl2ZVpvb20gPSBkZ1RpbGVMYXllci5vcHRpb25zLm1heFpvb207XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRnVGlsZUxheWVyLm9wdGlvbnMubWF4Wm9vbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBBZGRlZCBtZXRhIGxheWVycyBldmVudHMgcHJvY2Vzc2luZyBiZWZvcmUgbWFwIGV2ZW50c1xuICAgIF9maXJlRE9NRXZlbnQ6IGZ1bmN0aW9uKGUsIHR5cGUsIHRhcmdldHMpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzU0OTlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICAvLyBGaXJlIGEgc3ludGhldGljICdwcmVjbGljaycgZXZlbnQgd2hpY2ggcHJvcGFnYXRlcyB1cCAobWFpbmx5IGZvciBjbG9zaW5nIHBvcHVwcykuXG4gICAgICAgICAgICAvLyBAZXZlbnQgcHJlY2xpY2s6IE1vdXNlRXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIGJlZm9yZSBtb3VzZSBjbGljayBvbiB0aGUgbWFwIChzb21ldGltZXMgdXNlZnVsIHdoZW4geW91XG4gICAgICAgICAgICAvLyB3YW50IHNvbWV0aGluZyB0byBoYXBwZW4gb24gY2xpY2sgYmVmb3JlIGFueSBleGlzdGluZyBjbGlja1xuICAgICAgICAgICAgLy8gaGFuZGxlcnMgc3RhcnQgcnVubmluZykuXG4gICAgICAgICAgICB2YXIgc3ludGggPSBMLlV0aWwuZXh0ZW5kKHt9LCBlKTtcbiAgICAgICAgICAgIHN5bnRoLnR5cGUgPSAncHJlY2xpY2snO1xuICAgICAgICAgICAgdGhpcy5fZmlyZURPTUV2ZW50KHN5bnRoLCBzeW50aC50eXBlLCB0YXJnZXRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLl9zdG9wcGVkKSB7IHJldHVybjsgfVxuXG4gICAgICAgIC8vIEZpbmQgdGhlIGxheWVyIHRoZSBldmVudCBpcyBwcm9wYWdhdGluZyBmcm9tIGFuZCBpdHMgcGFyZW50cy5cbiAgICAgICAgdGFyZ2V0cyA9ICh0YXJnZXRzIHx8IFtdKS5jb25jYXQodGhpcy5fZmluZEV2ZW50VGFyZ2V0cyhlLCB0eXBlKSk7XG5cbiAgICAgICAgaWYgKCF0YXJnZXRzLmxlbmd0aCkgeyByZXR1cm47IH1cblxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0c1swXTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb250ZXh0bWVudScgJiYgdGFyZ2V0Lmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZS50eXBlICE9PSAna2V5cHJlc3MnKSB7XG4gICAgICAgICAgICB2YXIgaXNNYXJrZXIgPSB0YXJnZXQgaW5zdGFuY2VvZiBMLk1hcmtlcjtcbiAgICAgICAgICAgIGRhdGEuY29udGFpbmVyUG9pbnQgPSBpc01hcmtlciA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludCh0YXJnZXQuZ2V0TGF0TG5nKCkpIDogdGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcbiAgICAgICAgICAgIGRhdGEubGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoZGF0YS5jb250YWluZXJQb2ludCk7XG4gICAgICAgICAgICBkYXRhLmxhdGxuZyA9IGlzTWFya2VyID8gdGFyZ2V0LmdldExhdExuZygpIDogdGhpcy5sYXllclBvaW50VG9MYXRMbmcoZGF0YS5sYXllclBvaW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgbWV0YWxheWVycyBiZWZvcmUgZGlzcGF0Y2ggdGhlIGV2ZW50IHRvIHRoZSBtYXBcbiAgICAgICAgICAgIGlmICh0YXJnZXRzW2ldID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1ldGFsYXllciA9IHRoaXMuX2dldEN1cnJlbnRNZXRhTGF5ZXIoZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RNZXRhbGF5ZXIuZW50aXR5ICYmIG1ldGFsYXllci5lbnRpdHkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RNZXRhbGF5ZXIuZW50aXR5LmlkID09PSBtZXRhbGF5ZXIuZW50aXR5LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJlTWV0YWxheWVyRXZlbnQoJ21vdXNlbW92ZScsIG1ldGFsYXllciwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJlTWV0YWxheWVyRXZlbnQoJ21vdXNlb3V0JywgdGhpcy5fbGFzdE1ldGFsYXllciwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJlTWV0YWxheWVyRXZlbnQoJ21vdXNlb3ZlcicsIG1ldGFsYXllciwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJlTWV0YWxheWVyRXZlbnQoJ21vdXNlbW92ZScsIG1ldGFsYXllciwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0TWV0YWxheWVyID0gbWV0YWxheWVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlyZU1ldGFsYXllckV2ZW50KHR5cGUsIG1ldGFsYXllciwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGV2ZW50IHdhc24ndCBzdG9wcGVkIGluIG1ldGFsYXllcnMsIGRpc3BhdGNoIGl0IHRvIHRoZSBtYXBcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEub3JpZ2luYWxFdmVudC5fc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRzW2ldLmZpcmUodHlwZSwgZGF0YSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzW2ldLmZpcmUodHlwZSwgZGF0YSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RNZXRhbGF5ZXIuZW50aXR5ICYmIGRhdGEub3JpZ2luYWxFdmVudC5fc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaXhlcyBMLmNpcmNsZShbNTQuOTgzMTM2ODMxNDU1LCA4Mi44OTc0NDA3MjUwOTRdLCAyMDApLmFkZFRvKG1hcCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVNZXRhbGF5ZXJFdmVudCgnbW91c2VvdXQnLCB0aGlzLl9sYXN0TWV0YWxheWVyLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdE1ldGFsYXllciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRpdHk6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEub3JpZ2luYWxFdmVudC5fc3RvcHBlZCB8fFxuICAgICAgICAgICAgICAgICh0YXJnZXRzW2ldLm9wdGlvbnMubm9uQnViYmxpbmdFdmVudHMgJiYgTC5VdGlsLmluZGV4T2YodGFyZ2V0c1tpXS5vcHRpb25zLm5vbkJ1YmJsaW5nRXZlbnRzLCB0eXBlKSAhPT0gLTEpKSB7IHJldHVybjsgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9nZXRDdXJyZW50TWV0YUxheWVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIC8vIE5vdCBmb3JnZXQgZm9yIElFOCB3aXRoIHNyY0VsZW1lbnRcbiAgICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gZGF0YS5vcmlnaW5hbEV2ZW50LnRhcmdldCB8fCBkYXRhLm9yaWdpbmFsRXZlbnQuc3JjRWxlbWVudDtcblxuICAgICAgICAvLyBTdXBwb3NlIHRoYXQgdXNlciBjYW4gaW50ZXJhY3Qgd2l0aCB0aGUgbWV0YWxheWVyIG9ubHkgaWYgdGhlcmUgYXJlIG5vIGxheWVycyBiZXR3ZWVuIGN1cnNvciBhbmQgbWFwXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIEZvciBhbGwgYnJvd3NlcnMgd2hpY2ggc3VwcG9ydCBwb2ludGVyLWV2ZW50czogbm9uZSBvbiB0aWxlc1xuICAgICAgICAgICAgZXZlbnRUYXJnZXQgPT09IHRoaXMuX2NvbnRhaW5lciB8fFxuICAgICAgICAgICAgLy8gQW5kIGZvciBJRTEwIG9yIGxlc3Mgd2hlcmUgdGFyZ2V0cyBhcmUgdGlsZXNcbiAgICAgICAgICAgIERHLkJyb3dzZXIuaWUgJiYgZXZlbnRUYXJnZXQuY2xhc3NOYW1lID09PSAnbGVhZmxldC10aWxlIGxlYWZsZXQtdGlsZS1sb2FkZWQnIHx8XG4gICAgICAgICAgICAvLyBUaGUgb25seSBleGNlcHRpb24gaXMgY2FudmFzLCBiZWNhdXNlIGEgY2FudmFzIGxheWVyIG9jY3VwaWVzIHRoZSB3aG9sZSBzY3JlZW5cbiAgICAgICAgICAgIGV2ZW50VGFyZ2V0LnRhZ05hbWUgPT09ICdDQU5WQVMnXG4gICAgICAgICkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IHRoaXMubWV0YUxheWVycy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIHZhciBtZXRhRW50aXR5ID0gdGhpcy5tZXRhTGF5ZXJzW2pdLmdldEhvdmVyZWRPYmplY3QoZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFFbnRpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzLm1ldGFMYXllcnNbal0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRpdHk6IG1ldGFFbnRpdHlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxheWVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBlbnRpdHk6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBfZmlyZU1ldGFsYXllckV2ZW50OiBmdW5jdGlvbih0eXBlLCBtZXRhbGF5ZXIsIGRhdGEpIHtcbiAgICAgICAgaWYgKCFtZXRhbGF5ZXIuZW50aXR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3RlbmVyID0gbWV0YWxheWVyLmxheWVyLm1hcEV2ZW50c1t0eXBlXTtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEuZW50aXR5ID0gbWV0YWxheWVyLmVudGl0eTtcbiAgICAgICAgbGlzdGVuZXIuY2FsbChtZXRhbGF5ZXIubGF5ZXIsIGRhdGEpO1xuICAgIH1cbn0pO1xuXG5ERy5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vbignbGF5ZXJhZGQgbGF5ZXJyZW1vdmUnLCB0aGlzLl91cGRhdGVUaWxlTGF5ZXJzKTtcbn0pO1xuXG4vLyBTZXQgY3NzIHByb3BlcnR5IHRvdWNoLWFjdGlvbiB0byBhdXRvIGlmIGRyYWdnaW5nIGlzIGZhbHNlLlxuLy8gTmVlZCBmb3Igc2Nyb2xsaW5nIHBhZ2UgaW4gbW9iaWxlIHVzaW5nIG91ciBtYXAgZG9tIGVsZW1lbnQuXG4vLyB0b2RvOiBJIG1hZGUgaXNzdWUgaW4gbGVhZmxldCBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy80NDE1XG5ERy5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kcmFnZ2luZyA9PSBmYWxzZSAmJiB0aGlzLm9wdGlvbnMudGFwID09IGZhbHNlKSB7XG4gICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnZGctZHJhZ2dpbmctZmFsc2UnKTtcbiAgICB9XG59KTtcbiIsIkRHLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbigpIHtcbiAgICB2YXIgZXJyb3JVcmwgPSAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFRQUFBQUVBQVFNQUFBQm12RG9sQUFBQUExQk1WRVgyOHQ1UjBrNVVBQUFBSDBsRVFWUjRYdTNBQVFrQUFBRENNUHVuTnNkaFd4d0FBQUFBQUFBQXdBRWhBQUFCZzJVUDVBQUFBQUJKUlU1RXJrSmdnZz09JztcbiAgICB2YXIgZXJyb3JSdVVybCA9IERHLmNvbmZpZy5wcm90b2NvbCArIERHLmNvbmZpZy5iYXNlVXJsICsgJy9pbWcvbm9tYXBfcnUucG5nJztcblxuICAgIHZhciBUaWxlTGF5ZXIgPSBERy5Ccm93c2VyLm1vYmlsZSA/IERHLk1vYmlsZVRpbGVMYXllciA6IERHLlRpbGVMYXllcjtcblxuICAgIHZhciBCYXNlTGF5ZXIgPSBUaWxlTGF5ZXIuZXh0ZW5kKHtcbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RnID0gdHJ1ZTtcbiAgICAgICAgICAgIFRpbGVMYXllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHVybCwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VGlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVzO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdGlsZVVybCA9IERHLmNvbmZpZy5wcm90b2NvbCArIChERy5Ccm93c2VyLnJldGluYSA/IERHLmNvbmZpZy5yZXRpbmFUaWxlU2VydmVyIDogREcuY29uZmlnLnRpbGVTZXJ2ZXIpO1xuICAgIHZhciBhcmFiaWNUaWxlVXJsID0gREcuY29uZmlnLnByb3RvY29sICtcbiAgICAgICAgKERHLkJyb3dzZXIucmV0aW5hID8gREcuY29uZmlnLmFyYWJpY1JldGluYVRpbGVTZXJ2ZXIgOiBERy5jb25maWcuYXJhYmljVGlsZVNlcnZlcik7XG5cbiAgICB2YXIgcHJldmlld1RpbGVVcmwgPSBERy5jb25maWcucHJvdG9jb2wgK1xuICAgICAgICAoREcuQnJvd3Nlci5yZXRpbmEgPyBERy5jb25maWcucHJldmlld1JldGluYVRpbGVTZXJ2ZXIgOiBERy5jb25maWcucHJldmlld1RpbGVTZXJ2ZXIpO1xuICAgIHZhciBhcmFiaWNQcmV2aWV3VGlsZVVybCA9IERHLmNvbmZpZy5wcm90b2NvbCArXG4gICAgICAgIChERy5Ccm93c2VyLnJldGluYSA/IERHLmNvbmZpZy5hcmFiaWNQcmV2aWV3UmV0aW5hVGlsZVNlcnZlciA6IERHLmNvbmZpZy5hcmFiaWNQcmV2aWV3VGlsZVNlcnZlcik7XG5cbiAgICB0aGlzLmJhc2VMYXllciA9IG5ldyBCYXNlTGF5ZXIodGlsZVVybCwge1xuICAgICAgICBzdWJkb21haW5zOiAnMDEyMycsXG4gICAgICAgIGVycm9yVGlsZVVybDogdGhpcy5nZXRMYW5nKCkgPT09ICdydScgPyBlcnJvclJ1VXJsIDogZXJyb3JVcmwsXG4gICAgICAgIGRldGVjdFJldGluYTogREcuY29uZmlnLmRldGVjdFJldGluYSxcbiAgICAgICAgbWF4Wm9vbTogMTksXG4gICAgICAgIG1heE5hdGl2ZVpvb206IDE5LFxuICAgICAgICB6SW5kZXg6IDAsXG4gICAgICAgIHVwZGF0ZVdoZW5JZGxlOiBmYWxzZSwgLy8gaXQncyBva2F5IHdpdGggcHJldmlldyB0aWxlc1xuICAgICAgICBwcmV2aWV3VXJsOiBwcmV2aWV3VGlsZVVybCxcbiAgICB9KTtcblxuICAgIHZhciBjdXJyZW50VGlsZXNMYW5nID0gJyc7IC8vICdhcicgfCAnJ1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlVGlsZVVybCgpIHtcbiAgICAgICAgdmFyIGxhbmcgPSB0aGlzLmdldExhbmcoKTtcbiAgICAgICAgdmFyIHByb2plY3QgPSB0aGlzLnByb2plY3REZXRlY3RvciAmJiB0aGlzLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCk7XG5cbiAgICAgICAgaWYgKGxhbmcgPT09ICdydScgJiYgIXByb2plY3QpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZUxheWVyLm9wdGlvbnMuZXJyb3JUaWxlVXJsID0gZXJyb3JSdVVybDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZUxheWVyLm9wdGlvbnMuZXJyb3JUaWxlVXJsID0gZXJyb3JVcmw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGFuZ2UgMkdJUyB0aWxlcyBmb3IgQXJhYmljIGxhbmd1YWdlIGluIER1YmFpIHByb2plY3RcbiAgICAgICAgaWYgKGN1cnJlbnRUaWxlc0xhbmcgPT09ICcnICYmIGxhbmcgPT09ICdhcicgJiYgcHJvamVjdCAmJiBwcm9qZWN0LmNvdW50cnlfY29kZSA9PT0gJ2FlJykge1xuICAgICAgICAgICAgY3VycmVudFRpbGVzTGFuZyA9ICdhcic7XG4gICAgICAgICAgICB0aGlzLmJhc2VMYXllci5zZXRVcmwoYXJhYmljVGlsZVVybCk7XG4gICAgICAgICAgICBpZiAodGhpcy5iYXNlTGF5ZXIuc2V0UHJldmlld1VybCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmFzZUxheWVyLnNldFByZXZpZXdVcmwoYXJhYmljUHJldmlld1RpbGVVcmwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFRpbGVzTGFuZyA9PT0gJ2FyJyAmJiAobGFuZyAhPT0gJ2FyJyB8fCAoIXByb2plY3QgfHwgcHJvamVjdC5jb3VudHJ5X2NvZGUgIT09ICdhZScpKSkge1xuICAgICAgICAgICAgY3VycmVudFRpbGVzTGFuZyA9ICcnO1xuICAgICAgICAgICAgdGhpcy5iYXNlTGF5ZXIuc2V0VXJsKHRpbGVVcmwpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmFzZUxheWVyLnNldFByZXZpZXdVcmwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2VMYXllci5zZXRQcmV2aWV3VXJsKHByZXZpZXdUaWxlVXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZVRpbGVVcmwuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuYmFzZUxheWVyLmFkZFRvKHRoaXMpO1xuXG4gICAgdGhpcy5vbih7XG4gICAgICAgIGxhbmdjaGFuZ2U6IHVwZGF0ZVRpbGVVcmwsXG4gICAgICAgIHByb2plY3RjaGFuZ2U6IHVwZGF0ZVRpbGVVcmwsXG4gICAgICAgIHByb2plY3RsZWF2ZTogdXBkYXRlVGlsZVVybFxuICAgIH0sIHRoaXMpO1xufSk7XG4iLCJERy5NYXAubWVyZ2VPcHRpb25zKHtcbiAgICB0aWxlc0NoZWNrOiB0cnVlXG59KTtcblxuREcuTWFwLlRpbGVzQ2hlY2sgPSBERy5IYW5kbGVyLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5fbGF5ZXIgPSBtYXAuYmFzZUxheWVyO1xuXG4gICAgICAgIHRoaXMuX21vdmVTdGFydEV2ZW50Q291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX21vdmVFbmRFdmVudENvdW50ZXIgPSAwO1xuXG4gICAgICAgIHRoaXMuX2xvYWRpbmdFdmVudENvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLl9sb2FkRXZlbnRDb3VudGVyID0gMDtcbiAgICB9LFxuXG4gICAgYWRkSG9va3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9tYXAub24odGhpcy5fbWFwRXZlbnRzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fbGF5ZXIub24odGhpcy5fbGF5ZXJFdmVudHMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICByZW1vdmVIb29rczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX21hcC5vZmYodGhpcy5fbWFwRXZlbnRzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fbGF5ZXIub2ZmKHRoaXMuX2xheWVyRXZlbnRzLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX21hcEV2ZW50czoge1xuICAgICAgICBsYXllcmFkZDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGUubGF5ZXIgPT0gdGhpcy5fbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxheWVycmVtb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoZS5sYXllciA9PSB0aGlzLl9sYXllcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1vdmVzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wV2FpdGluZygpO1xuXG4gICAgICAgICAgICB0aGlzLl9tb3ZlU3RhcnRFdmVudENvdW50ZXIrKztcbiAgICAgICAgICAgIHRoaXMuX2lzV2FpdGluZyA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW92ZWVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9tb3ZlRW5kRXZlbnRDb3VudGVyKys7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNXYWl0aW5nICYmIHRoaXMuX21vdmVTdGFydEV2ZW50Q291bnRlciAhPT0gdGhpcy5fbW92ZUVuZEV2ZW50Q291bnRlcikgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgdGhpcy5faXNNb3ZlRW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5fY2hlY2tXYWl0aW5nKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2xheWVyRXZlbnRzOiB7XG4gICAgICAgIGxvYWRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fbG9hZGluZ0V2ZW50Q291bnRlcisrO1xuICAgICAgICB9LFxuXG4gICAgICAgIGxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fbG9hZEV2ZW50Q291bnRlcisrO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzV2FpdGluZyAmJiB0aGlzLl9sb2FkaW5nRXZlbnRDb3VudGVyICE9PSB0aGlzLl9sb2FkRXZlbnRDb3VudGVyKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICB0aGlzLl9pc0xvYWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLl9jaGVja1dhaXRpbmcoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfc3RvcFdhaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9pc1dhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNNb3ZlRW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzTG9hZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBfY2hlY2tXYWl0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzV2FpdGluZyAmJiB0aGlzLl9pc0xvYWQgJiYgdGhpcy5faXNNb3ZlRW5kKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wV2FpdGluZygpO1xuICAgICAgICAgICAgdGhpcy5fcmVzZXRDb3VudGVycygpO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tUaWxlcygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jaGVja1RpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hcC5nZXRUaWxlTGF5ZXJzTnVtYmVyKCkgIT09IDAgfHwgIXRoaXMuX21hcC5fbG9hZGVkKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgICAgICAgdmFyIGVycm9yVXJsID0gdGhpcy5fbGF5ZXIub3B0aW9ucy5lcnJvclRpbGVVcmw7XG4gICAgICAgIHZhciB0aWxlcyA9IHRoaXMuX2xheWVyLmdldFRpbGVzKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aWxlcykge1xuICAgICAgICAgICAgaWYgKHRpbGVzW2ldLmNvb3Jkcy56ID09PSB6b29tICYmIHRpbGVzW2ldLmVsLnNyYyAhPT0gZXJyb3JVcmwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tYXAuem9vbU91dCgpO1xuICAgIH0sXG5cbiAgICBfcmVzZXRDb3VudGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX21vdmVTdGFydEV2ZW50Q291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX21vdmVFbmRFdmVudENvdW50ZXIgPSAwO1xuXG4gICAgICAgIHRoaXMuX2xvYWRpbmdFdmVudENvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLl9sb2FkRXZlbnRDb3VudGVyID0gMDtcbiAgICB9XG59KTtcblxuREcuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RpbGVzQ2hlY2snLCBERy5NYXAuVGlsZXNDaGVjayk7XG4iLCIvKipcbiAqIFRoaXMgY3VzdG9taXphdGlvbiBmaXhlcyB1bndhbnRlZCBpbmVydGlhIG1vdmVtZW50IGFmdGVyIHN1ZGRlbiBkcmFnIHN0b3BzXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9wdWxsLzQwNDguXG4gKiBJZiB0aGlzIFBSIGV2ZXIgZ2V0cyBtZXJnZWQsIHRoaXMgZmlsZSBjYW4gYmUgcmVtb3ZlZC5cbiAqL1xudmFyIG9uRHJhZ0VuZCA9IERHLk1hcC5EcmFnLnByb3RvdHlwZS5fb25EcmFnRW5kO1xuXG5ERy5NYXAuRHJhZy5pbmNsdWRlKHtcbiAgICBfcmVtZW1iZXJUaW1lQW5kUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXG4gICAgICAgICAgICBwb3MgPSB0aGlzLl9sYXN0UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgfHwgdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3M7XG5cbiAgICAgICAgdGhpcy5fcG9zaXRpb25zLnB1c2gocG9zKTtcbiAgICAgICAgdGhpcy5fdGltZXMucHVzaCh0aW1lKTtcblxuICAgICAgICAvLyBSZW1vdmUgYWxsIGRhdGEgcG9pbnRzIG9sZGVyIHRoYW4gNTAgbXNcbiAgICAgICAgd2hpbGUgKHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDUwKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uRHJhZzogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGhpcy5fbWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuICAgICAgICAgICAgdGhpcy5fcmVtZW1iZXJUaW1lQW5kUG9zaXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hcFxuICAgICAgICAgICAgLmZpcmUoJ21vdmUnLCBlKVxuICAgICAgICAgICAgLmZpcmUoJ2RyYWcnLCBlKTtcbiAgICB9LFxuXG4gICAgX29uRHJhZ0VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhICYmICFERy5Ccm93c2VyLnRvdWNoKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1lbWJlclRpbWVBbmRQb3NpdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgb25EcmFnRW5kLmNhbGwodGhpcyk7XG4gICAgfVxufSk7XG4iLCIvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9UdXJmanMvdHVyZi1pbnNpZGUvYmxvYi9tYXN0ZXIvaW5kZXguanNcbkRHLlBvbHlVdGlsLmluc2lkZSA9IGZ1bmN0aW9uKHBvaW50LCBwb2x5Z29uLCBwb2ludFJlZHVjZSkge1xuICAgIHBvaW50UmVkdWNlID0gcG9pbnRSZWR1Y2UgfHwgREcuUG9seVV0aWwuX2RlZmF1bHRQb2ludFJlZHVjZTtcbiAgICB2YXIgcG9seXMgPSBwb2x5Z29uLmNvb3JkaW5hdGVzO1xuICAgIHZhciBwdCA9IHBvaW50UmVkdWNlKHBvaW50KTtcblxuICAgIC8vIG5vcm1hbGl6ZSB0byBtdWx0aXBvbHlnb25cbiAgICBpZiAocG9seWdvbi50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgcG9seXMgPSBbcG9seXNdO1xuICAgIH1cblxuICAgIHZhciBpbnNpZGVQb2x5ID0gZmFsc2U7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgcG9seXMubGVuZ3RoICYmICFpbnNpZGVQb2x5KSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGl0IGlzIGluIHRoZSBvdXRlciByaW5nIGZpcnN0XG4gICAgICAgIGlmICh0aGlzLl9pblJpbmcocHQsIHBvbHlzW2ldWzBdLCBwb2ludFJlZHVjZSkpIHtcbiAgICAgICAgICAgIHZhciBpbkhvbGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBrID0gMTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciB0aGUgcG9pbnQgaW4gYW55IG9mIHRoZSBob2xlc1xuICAgICAgICAgICAgd2hpbGUgKGsgPCBwb2x5c1tpXS5sZW5ndGggJiYgIWluSG9sZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pblJpbmcocHQsIHBvbHlzW2ldW2tdLCBwb2ludFJlZHVjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Ib2xlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbkhvbGUpICB7XG4gICAgICAgICAgICAgICAgaW5zaWRlUG9seSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gaW5zaWRlUG9seTtcbn07XG5cbi8vIHB0IGlzIFt4LHldIGFuZCByaW5nIGlzIFtbeCx5XSwgW3gseV0sLi5dXG5ERy5Qb2x5VXRpbC5faW5SaW5nID0gZnVuY3Rpb24ocHQsIHJpbmcsIHBvaW50UmVkdWNlKSB7XG4gICAgdmFyIGlzSW5zaWRlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSByaW5nLmxlbmd0aCAtIDE7IGkgPCByaW5nLmxlbmd0aDsgaiA9IGkrKykge1xuICAgICAgICB2YXIgcGkgPSBwb2ludFJlZHVjZShyaW5nW2ldKTtcbiAgICAgICAgdmFyIHBqID0gcG9pbnRSZWR1Y2UocmluZ1tqXSk7XG4gICAgICAgIHZhciB4aSA9IHBpWzBdLCB5aSA9IHBpWzFdO1xuICAgICAgICB2YXIgeGogPSBwalswXSwgeWogPSBwalsxXTtcbiAgICAgICAgdmFyIGludGVyc2VjdCA9ICgoeWkgPiBwdFsxXSkgIT09ICh5aiA+IHB0WzFdKSkgJiZcbiAgICAgICAgICAgIChwdFswXSA8ICh4aiAtIHhpKSAqIChwdFsxXSAtIHlpKSAvICh5aiAtIHlpKSArIHhpKTtcblxuICAgICAgICBpZiAoaW50ZXJzZWN0KSB7XG4gICAgICAgICAgICBpc0luc2lkZSA9ICFpc0luc2lkZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNJbnNpZGU7XG59O1xuXG5ERy5Qb2x5VXRpbC5fZGVmYXVsdFBvaW50UmVkdWNlID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICByZXR1cm4gcG9pbnQ7XG59O1xuIiwiLyoqXG4gKiDQkiDRhNCw0LnQu9C1INGB0L7QtNC10LbQsNGC0YHRjyDQuNC30LzQtdC90LXQvdC40Y8g0LTQu9GPINGD0YHQutC+0YDQtdC90LjRjyDQu9C40YTQu9C10YLQsCDQvdCwINC80L7QsdC40LvRjNC90YvRhSDQtNC10LLQsNC50YHQsNGFXG4gKi9cblxuaWYgKERHLkJyb3dzZXIubW9iaWxlKSB7XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICog0KXQsNC60LDQtdC8IGFkZENsYXNzINC4IHJlbW92ZUNsYXNzLCDRh9GC0L7QsdGLINC+0L3QuCDQvdC1INGA0LDQsdC+0YLQsNC70Lgg0LTQu9GPINC+0L/RgNC10LTQtdC70ZHQvdC90YvRhSDQutC70LDRgdGB0L7QslxuICAgICAgICAgKiDQodC00LXQu9Cw0L3QviDRgtCw0LosINGH0YLQvtCx0Ysg0L3QtSDQvNC10L3Rj9GC0Ywg0LrRg9GH0YMg0LzQtdGC0L7QtNC+0LIg0LIg0LrQuNGI0LrQsNGFINC70LjRhNC70LXRgtCwXG4gICAgICAgICAqXG4gICAgICAgICAqIGxlYWZsZXQtZHJhZ2dpbmcg0LggbGVhZmxldC1kcmFnLXRhcmdldCDQstGL0LfRi9Cy0LDQtdGCINC00LvQuNC90L3Ri9C5IHJlY2FsY3VsYXRlIHN0eWxlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgYWRkQ2xhc3MgPSBMLkRvbVV0aWwuYWRkQ2xhc3M7XG4gICAgICAgIEwuRG9tVXRpbC5hZGRDbGFzcyA9IGZ1bmN0aW9uKGVsLCBuYW1lKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2xlYWZsZXQtZHJhZ2dpbmcnIHx8XG4gICAgICAgICAgICAgICAgbmFtZSA9PT0gJ2xlYWZsZXQtZHJhZy10YXJnZXQnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFkZENsYXNzKGVsLCBuYW1lKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVtb3ZlQ2xhc3MgPSBMLkRvbVV0aWwucmVtb3ZlQ2xhc3M7XG4gICAgICAgIEwuRG9tVXRpbC5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKGVsLCBuYW1lKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2xlYWZsZXQtZHJhZ2dpbmcnIHx8XG4gICAgICAgICAgICAgICAgbmFtZSA9PT0gJ2xlYWZsZXQtZHJhZy10YXJnZXQnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsLCBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEwuRHJhZ2dhYmxlLmluY2x1ZGUoe1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDQlNC+0LHQsNCy0LvQtdC90L4g0L7QutGA0YPQs9C70LXQvdC40LUg0L/QvtC30LjRhtC40LggdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCkuX3JvdW5kKClcbiAgICAgICAgICAgICAqINCYINGB0YDQsNCy0L3QtdC90LjQtSDRgSDQv9GA0LXQtNGD0LTRi9GJ0LXQuSBpZiAodGhpcy5fbmV3UG9zICYmIHRoaXMuX25ld1Bvcy54ID09IHBvcy54ICYmIHRoaXMuX25ld1Bvcy55ID09IHBvcy55KSB7XG4gICAgICAgICAgICAgKiDQp9GC0L7QsdGLINC+0LHQvdC+0LLQu9C10L3QuNC1IGRvbSDQv9GA0L7QuNGB0YXQvtC00LjQu9C+INGC0L7Qu9GM0LrQviDQv9GA0Lgg0YDQtdCw0LvRjNC90L7QvCDQuNC30LzQtdC90LXQvdC40LhcbiAgICAgICAgICAgICAqINCj0LHRgNCw0L3RiyDQutC70LDRgdGB0YsgbGVhZmxldC1kcmFnZ2luZyDQuCBsZWFmbGV0LWRyYWctdGFyZ2V0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9vbk1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXG4gICAgICAgICAgICAgICAgLy8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXG4gICAgICAgICAgICAgICAgLy8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxuICAgICAgICAgICAgICAgIC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxuICAgICAgICAgICAgICAgIGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSA/IGUudG91Y2hlc1swXSA6IGUpLFxuICAgICAgICAgICAgICAgICAgICBuZXdQb2ludCA9IG5ldyBMLlBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBuZXdQb2ludC5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvaW50KTtcblxuICAgICAgICAgICAgICAgIGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhvZmZzZXQueCkgKyBNYXRoLmFicyhvZmZzZXQueSkgPCB0aGlzLm9wdGlvbnMuY2xpY2tUb2xlcmFuY2UpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9tb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxuICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgZHJhZyBzdGFydHNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdkcmFnc3RhcnQnKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0UG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQpLnN1YnRyYWN0KG9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSUUgYW5kIEVkZ2UgZG8gbm90IGdpdmUgdGhlIDx1c2U+IGVsZW1lbnQsIHNvIGZldGNoIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICBpZiAoKHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UpICYmICh0aGlzLl9sYXN0VGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudEluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFRhcmdldCA9IHRoaXMuX2xhc3RUYXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCkuX3JvdW5kKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92aW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RFdmVudCA9IGU7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmV3UG9zICYmIHRoaXMuX25ld1Bvcy54ID09IHBvcy54ICYmIHRoaXMuX25ld1Bvcy55ID09IHBvcy55KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9uZXdQb3MgPSBwb3M7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbVJlcXVlc3QgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVQb3NpdGlvbiwgdGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDQlNC70LjRgtC10LvRjNC90L7RgdGC0Ywg0LLRgdC10YUg0LjQvdC10YDRhtC40Lkg0L/RgNC4INC00LLQuNC20LXQvdC40Lgg0LrQsNGA0YLRiyDRgtC10L/QtdGA0YwgMSDRgdC10LrRg9C90LTQsFxuICAgICAgICAgKi9cbiAgICAgICAgTC5NYXAuRHJhZy5pbmNsdWRlKHtcbiAgICAgICAgICAgIF9vbkRyYWdFbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gbWFwLm9wdGlvbnMsXG5cbiAgICAgICAgICAgICAgICAgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCB0aGlzLl90aW1lcy5sZW5ndGggPCAyO1xuXG4gICAgICAgICAgICAgICAgbWFwLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblxuICAgICAgICAgICAgICAgIGlmIChub0luZXJ0aWEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2xhc3RQb3Muc3VidHJhY3QodGhpcy5fcG9zaXRpb25zWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gKHRoaXMuX2xhc3RUaW1lIC0gdGhpcy5fdGltZXNbMF0pIC8gMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhc2UgPSBvcHRpb25zLmVhc2VMaW5lYXJpdHksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWVkVmVjdG9yID0gZGlyZWN0aW9uLm11bHRpcGx5QnkoZWFzZSAvIGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWVkID0gc3BlZWRWZWN0b3IuZGlzdGFuY2VUbyhbMCwgMF0pLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW1pdGVkU3BlZWQgPSBNYXRoLm1pbihvcHRpb25zLmluZXJ0aWFNYXhTcGVlZCwgc3BlZWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGltaXRlZFNwZWVkVmVjdG9yID0gc3BlZWRWZWN0b3IubXVsdGlwbHlCeShsaW1pdGVkU3BlZWQgLyBzcGVlZCksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2VsZXJhdGlvbkR1cmF0aW9uID0gMSwgLy8gbGltaXRlZFNwZWVkIC8gKG9wdGlvbnMuaW5lcnRpYURlY2VsZXJhdGlvbiAqIGVhc2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbGltaXRlZFNwZWVkVmVjdG9yLm11bHRpcGx5QnkoLWRlY2VsZXJhdGlvbkR1cmF0aW9uIC8gMikucm91bmQoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldChvZmZzZXQsIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5wYW5CeShvZmZzZXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGRlY2VsZXJhdGlvbkR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXNlTGluZWFyaXR5OiBlYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub01vdmVTdGFydDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSkoKTtcbn1cblxuTC5Nb2JpbGVUaWxlTGF5ZXIgPSBMLlRpbGVMYXllci5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHVybCwgb3B0aW9ucykge1xuICAgICAgICBMLlRpbGVMYXllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHVybCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fcHJldmlld1VybCA9IG9wdGlvbnMucHJldmlld1VybDtcbiAgICB9LFxuXG4gICAgc2V0UHJldmlld1VybDogZnVuY3Rpb24odXJsKSB7XG4gICAgICAgIHRoaXMuX3ByZXZpZXdVcmwgPSB1cmw7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqINCR0YvRgdGC0YDQvtC1INC90LDQstC10YjQuNCy0LDQvdC40LUg0YHQvtCx0YvRgtC40LksINCy0LzQtdGB0YLQviBMLkRvbVV0aWwub24g0LjRgdC/0L7Qu9GM0LfRg9C10Lwg0L/RgNC+0YHRgtC+0LUg0L/RgNC40YHQstCw0LjQstCw0L3QuNC1XG4gICAgICovXG4gICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzLCBkb25lLCB1cmwpIHtcbiAgICAgICAgdmFyIHRpbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgdGlsZS5vbmxvYWQgPSBMLmJpbmQodGhpcy5fdGlsZU9uTG9hZCwgdGhpcywgZG9uZSwgdGlsZSk7XG4gICAgICAgIHRpbGUub25lcnJvciA9IEwuYmluZCh0aGlzLl90aWxlT25FcnJvciwgdGhpcywgZG9uZSwgdGlsZSk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbikge1xuICAgICAgICAgICAgdGlsZS5jcm9zc09yaWdpbiA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgIEFsdCB0YWcgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyB0byBrZWVwIHNjcmVlbiByZWFkZXJzIGZyb20gcmVhZGluZyBVUkwgYW5kIGZvciBjb21wbGlhbmNlIHJlYXNvbnNcbiAgICAgICAgIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC1URUNIUy9INjdcbiAgICAgICAgKi9cbiAgICAgICAgdGlsZS5hbHQgPSAnJztcbiAgICAgICAgdGlsZS5zcmMgPSB0aGlzLmdldFRpbGVVcmwoY29vcmRzLCB1cmwpO1xuXG4gICAgICAgIHJldHVybiB0aWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDQo9Cx0YDQsNC9INC60LvQsNGB0YEgbGVhZmxldC10aWxlXG4gICAgICog0JTQvtCx0LDQstC70LXQvSDRhdCw0Log0LTQu9GPINC/0YDQtdCy0YzRjiDRgtCw0LnQu9C+0LJcbiAgICAgKi9cbiAgICBfaW5pdFRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGlsZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgICAgICAgdmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICAgICAgICB0aWxlLnN0eWxlLndpZHRoID0gdGlsZVNpemUueCArICdweCc7XG4gICAgICAgIHRpbGUuc3R5bGUuaGVpZ2h0ID0gdGlsZVNpemUueSArICdweCc7XG5cbiAgICAgICAgdGlsZS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIHRpbGUuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcblxuICAgICAgICB0aWxlLm9uc2VsZWN0c3RhcnQgPSBMLlV0aWwuZmFsc2VGbjtcbiAgICAgICAgdGlsZS5vbm1vdXNlbW92ZSA9IEwuVXRpbC5mYWxzZUZuO1xuXG4gICAgICAgIC8vIHdpdGhvdXQgdGhpcyBoYWNrLCB0aWxlcyBkaXNhcHBlYXIgYWZ0ZXIgem9vbSBvbiBDaHJvbWUgZm9yIEFuZHJvaWRcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjA3OFxuICAgICAgICBpZiAoTC5Ccm93c2VyLmFuZHJvaWQgJiYgIUwuQnJvd3Nlci5hbmRyb2lkMjMpIHtcbiAgICAgICAgICAgIHRpbGUuc3R5bGUuV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog0KPQsdGA0LDQvSDQutC70LDRgdGBIGxlYWZsZXQtdGlsZS1jb250YWluZXJcbiAgICAgKi9cbiAgICBfdXBkYXRlTGV2ZWxzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxuICAgICAgICAgICAgbWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xuXG4gICAgICAgIGlmICh6b29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG4gICAgICAgIGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGV2ZWxzW3pdLmVsLmNoaWxkcmVuLmxlbmd0aCB8fCB6ID09PSB6b29tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGV2ZWxzW3pdLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb20gLSBNYXRoLmFicyh6b29tIC0geik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVUaWxlc0F0Wm9vbSh6KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dLFxuICAgICAgICAgICAgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIGlmICghbGV2ZWwpIHtcbiAgICAgICAgICAgIGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dID0ge307XG5cbiAgICAgICAgICAgIGxldmVsLmVsID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGxldmVsLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb207XG5cbiAgICAgICAgICAgIGxldmVsLm9yaWdpbiA9IG1hcC5wcm9qZWN0KG1hcC51bnByb2plY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpLCB6b29tKS5yb3VuZCgpO1xuICAgICAgICAgICAgbGV2ZWwuem9vbSA9IHpvb207XG5cbiAgICAgICAgICAgIHRoaXMuX3NldFpvb21UcmFuc2Zvcm0obGV2ZWwsIG1hcC5nZXRDZW50ZXIoKSwgbWFwLmdldFpvb20oKSk7XG5cbiAgICAgICAgICAgIC8vIGZvcmNlIHRoZSBicm93c2VyIHRvIGNvbnNpZGVyIHRoZSBuZXdseSBhZGRlZCBlbGVtZW50IGZvciB0cmFuc2l0aW9uXG4gICAgICAgICAgICBMLlV0aWwuZmFsc2VGbihsZXZlbC5lbC5vZmZzZXRXaWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sZXZlbCA9IGxldmVsO1xuXG4gICAgICAgIHJldHVybiBsZXZlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog0KPQsdGA0LDQvdC+INC00L7QsdCw0LLQu9C10L3QuNC1INGC0LDQudC70L7QsiDRh9C10YDQtdC3IGRvY3VtZW50RnJhZ21lbnRcbiAgICAgKi9cbiAgICBfdXBkYXRlOiBmdW5jdGlvbihjZW50ZXIpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgaWYgKCFtYXApIHsgcmV0dXJuOyB9XG4gICAgICAgIHZhciB6b29tID0gbWFwLmdldFpvb20oKTtcblxuICAgICAgICBpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIHsgY2VudGVyID0gbWFwLmdldENlbnRlcigpOyB9XG4gICAgICAgIGlmICh0aGlzLl90aWxlWm9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfVx0Ly8gaWYgb3V0IG9mIG1pbnpvb20vbWF4em9vbVxuXG4gICAgICAgIHZhciBwaXhlbEJvdW5kcyA9IHRoaXMuX2dldFRpbGVkUGl4ZWxCb3VuZHMoY2VudGVyKSxcbiAgICAgICAgICAgIHRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UocGl4ZWxCb3VuZHMpLFxuICAgICAgICAgICAgdGlsZUNlbnRlciA9IHRpbGVSYW5nZS5nZXRDZW50ZXIoKSxcbiAgICAgICAgICAgIHF1ZXVlID0gW10sXG4gICAgICAgICAgICBtYXJnaW4gPSB0aGlzLm9wdGlvbnMua2VlcEJ1ZmZlcixcbiAgICAgICAgICAgIG5vUHJ1bmVSYW5nZSA9IG5ldyBMLkJvdW5kcyh0aWxlUmFuZ2UuZ2V0Qm90dG9tTGVmdCgpLnN1YnRyYWN0KFttYXJnaW4sIC1tYXJnaW5dKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZVJhbmdlLmdldFRvcFJpZ2h0KCkuYWRkKFttYXJnaW4sIC1tYXJnaW5dKSk7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuX3RpbGVzW2tleV0uY29vcmRzO1xuICAgICAgICAgICAgaWYgKGMueiAhPT0gdGhpcy5fdGlsZVpvb20gfHwgIW5vUHJ1bmVSYW5nZS5jb250YWlucyhMLnBvaW50KGMueCwgYy55KSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aWxlc1trZXldLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIF91cGRhdGUganVzdCBsb2FkcyBtb3JlIHRpbGVzLiBJZiB0aGUgdGlsZSB6b29tIGxldmVsIGRpZmZlcnMgdG9vIG11Y2hcbiAgICAgICAgLy8gZnJvbSB0aGUgbWFwJ3MsIGxldCBfc2V0VmlldyByZXNldCBsZXZlbHMgYW5kIHBydW5lIG9sZCB0aWxlcy5cbiAgICAgICAgaWYgKE1hdGguYWJzKHpvb20gLSB0aGlzLl90aWxlWm9vbSkgPiAxKSB7IHRoaXMuX3NldFZpZXcoY2VudGVyLCB6b29tKTsgcmV0dXJuOyB9XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgcXVldWUgb2YgY29vcmRpbmF0ZXMgdG8gbG9hZCB0aWxlcyBmcm9tXG4gICAgICAgIGZvciAodmFyIGogPSB0aWxlUmFuZ2UubWluLnk7IGogPD0gdGlsZVJhbmdlLm1heC55OyBqKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aWxlUmFuZ2UubWluLng7IGkgPD0gdGlsZVJhbmdlLm1heC54OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRzID0gbmV3IEwuUG9pbnQoaSwgaik7XG4gICAgICAgICAgICAgICAgY29vcmRzLnogPSB0aGlzLl90aWxlWm9vbTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNWYWxpZFRpbGUoY29vcmRzKSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRpbGUgPSB0aGlzLl90aWxlc1t0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKV07XG4gICAgICAgICAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGlsZS5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc29ydCB0aWxlIHF1ZXVlIHRvIGxvYWQgdGlsZXMgaW4gb3JkZXIgb2YgdGhlaXIgZGlzdGFuY2UgdG8gY2VudGVyXG4gICAgICAgIHF1ZXVlLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKSAtIGIuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgLy8gaWYgaXQncyB0aGUgZmlyc3QgYmF0Y2ggb2YgdGlsZXMgdG8gbG9hZFxuICAgICAgICAgICAgaWYgKCF0aGlzLl9sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gQGV2ZW50IGxvYWRpbmc6IEV2ZW50XG4gICAgICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBzdGFydHMgbG9hZGluZyB0aWxlcy5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2xvYWRpbmcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVGlsZShxdWV1ZVtpXSwgdGhpcy5fbGV2ZWwuZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdlIGRvbid0IGxvYWQgcHJldmlldyB0aWxlOlxuICAgICAqIC0gYWZ0ZXIgem9vbS1pbiBpZiBhIHRpbGUgZnJvbSBhIGxvd2VyIHpvb20gaXMgYWxyZWFkeSBzaG93blxuICAgICAqIC0gYWZ0ZXIgem9vbS1vdXQgaWYgZm91ciB0aWxlcyBmcm9tIGEgaGlnaGVyIHpvb20gaXMgYWxyZWFkeSBzaG93blxuICAgICAqL1xuICAgIF9uZWVkUHJldmlld1RpbGU6IGZ1bmN0aW9uKGNvb3Jkcykge1xuICAgICAgICBpZiAodGhpcy5fdGlsZVpvb20gLSB0aGlzLl9tYXAuZ2V0Wm9vbSgpID4gMCkge1xuICAgICAgICAgICAgLy8gem9vbSBpblxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl9leGlzdFRpbGVGcm9tTG93ZXJab29tKGNvb3Jkcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB6b29tIG91dFxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl9leGlzdFRpbGVzRnJvbUhpZ2hlclpvb20oY29vcmRzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZXhpc3RUaWxlRnJvbUxvd2VyWm9vbTogZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICAgIHZhciBjb29yZHMyID0gTC5wb2ludChjb29yZHMueCAvIDIsIGNvb3Jkcy55IC8gMikuX2Zsb29yKCk7XG5cbiAgICAgICAgY29vcmRzMi56ID0gY29vcmRzLnogLSAxO1xuXG4gICAgICAgIHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzMik7XG4gICAgICAgIHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcbiAgICAgICAgcmV0dXJuIHRpbGUgJiYgIXRpbGUucHJldmlldztcbiAgICB9LFxuXG4gICAgX2V4aXN0VGlsZXNGcm9tSGlnaGVyWm9vbTogZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICAgIHZhciB4ID0gY29vcmRzLng7XG4gICAgICAgIHZhciB5ID0gY29vcmRzLnk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDIgKiB4OyBpIDwgMiAqIHggKyAyOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAyICogeTsgaiA8IDIgKiB5ICsgMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBuZXcgTC5Qb2ludChpLCBqKTtcbiAgICAgICAgICAgICAgICBjLnogPSBjb29yZHMueiArIDE7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3RpbGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDQlNC+0LHQsNCy0LvQtdC90LAg0LvQvtCz0LjQutCwINGBINC/0YDQtdCy0YzRjiDRgtCw0LnQu9Cw0LzQuFxuICAgICAqL1xuICAgIF9hZGRUaWxlOiBmdW5jdGlvbihjb29yZHMsIGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgdGlsZVBvcyA9IHRoaXMuX2dldFRpbGVQb3MoY29vcmRzKSxcbiAgICAgICAgICAgIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG4gICAgICAgIHZhciB3cmFwQ29vcmRzID0gdGhpcy5fd3JhcENvb3Jkcyhjb29yZHMpO1xuICAgICAgICB2YXIgbmVlZFByZXZpZXcgPSB0aGlzLl9uZWVkUHJldmlld1RpbGUod3JhcENvb3Jkcyk7XG5cbiAgICAgICAgdmFyIHVybCA9IG5lZWRQcmV2aWV3ID8gdGhpcy5fcHJldmlld1VybCA6IHRoaXMuX3VybDtcbiAgICAgICAgdmFyIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGUod3JhcENvb3JkcywgTC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzKSwgdXJsKTtcblxuICAgICAgICB0aGlzLl9pbml0VGlsZSh0aWxlKTtcblxuICAgICAgICBMLkRvbVV0aWwuc2V0UG9zaXRpb24odGlsZSwgdGlsZVBvcyk7XG5cbiAgICAgICAgLy8gc2F2ZSB0aWxlIGluIGNhY2hlXG4gICAgICAgIHRoaXMuX3RpbGVzW2tleV0gPSB7XG4gICAgICAgICAgICBlbDogdGlsZSxcbiAgICAgICAgICAgIHByZXZpZXc6IG5lZWRQcmV2aWV3LFxuICAgICAgICAgICAgY29vcmRzOiBjb29yZHMsXG4gICAgICAgICAgICBjdXJyZW50OiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRpbGUpO1xuICAgICAgICAvLyBAZXZlbnQgdGlsZWxvYWRzdGFydDogVGlsZUV2ZW50XG4gICAgICAgIC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlcXVlc3RlZCBhbmQgc3RhcnRzIGxvYWRpbmcuXG4gICAgICAgIHRoaXMuZmlyZSgndGlsZWxvYWRzdGFydCcsIHtcbiAgICAgICAgICAgIHRpbGU6IHRpbGUsXG4gICAgICAgICAgICBjb29yZHM6IGNvb3Jkc1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog0KPQsdGA0LDQvSBmYWRlQW5pbWF0ZWQg0Lgg0LrQu9Cw0YHRgSBsZWFmbGV0LXRpbGUtbG9hZGVkXG4gICAgICovXG4gICAgX3RpbGVSZWFkeTogZnVuY3Rpb24oY29vcmRzLCBlcnIsIHRpbGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgLy8gQGV2ZW50IHRpbGVlcnJvcjogVGlsZUVycm9yRXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgbG9hZGluZyBhIHRpbGUuXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGVlcnJvcicsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgICAgIHRpbGU6IHRpbGUsXG4gICAgICAgICAgICAgICAgY29vcmRzOiBjb29yZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG4gICAgICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuICAgICAgICBpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgLy8g0JXRgdC70Lgg0YMg0YLQsNC50LvQsCDRg9C20LUg0LXRgdGC0Ywg0L7RgNC40LPQuNC90LDQu9GM0L3QsNGPICjQvdC1INC/0L7QttCw0YLQsNGPKSDQutCw0YDRgtC40L3QutCwLFxuICAgICAgICAvLyDRgtC+INC30LDQvNC10L3QuNC8INC/0YDQtdCy0YzRjiDQvdCwINC90LXQtVxuICAgICAgICBpZiAodGlsZS5vcmlnaW5hbEVsICYmIHRpbGUuZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGlsZS5lbC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0aWxlLm9yaWdpbmFsRWwsIHRpbGUuZWwpO1xuICAgICAgICAgICAgdGlsZS5lbCA9IHRpbGUub3JpZ2luYWxFbDtcblxuICAgICAgICAgICAgdGlsZS5vcmlnaW5hbEVsID0gbnVsbDtcbiAgICAgICAgICAgIHRpbGUucHJldmlldyA9IGZhbHNlO1xuXG4gICAgICAgIC8vINCV0YHQu9C4INGDINGC0LDQudC70LAg0LXRgdGC0Ywg0YLQvtC70YzQutC+INC/0YDQtdCy0YzRjiwg0YLQviDQtNC+0LHQsNCy0LjQvCDQtdCz0L4g0L3QsCDQutCw0YDRgtGDXG4gICAgICAgIC8vINCYINC90LDRh9C90LXQvCDQs9GA0YPQt9C40YLRjCDQvtGA0LjQs9C40L3QsNC70YzQvdGL0LlcbiAgICAgICAgfSBlbHNlIGlmICh0aWxlLnByZXZpZXcpIHtcbiAgICAgICAgICAgIHRpbGUub3JpZ2luYWxFbCA9IHRoaXMuY3JlYXRlVGlsZSh0aGlzLl93cmFwQ29vcmRzKGNvb3JkcyksIEwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcyksIHRoaXMuX3VybCk7XG4gICAgICAgICAgICB0aGlzLl9pbml0VGlsZSh0aWxlLm9yaWdpbmFsRWwpO1xuICAgICAgICAgICAgTC5Eb21VdGlsLnNldFBvc2l0aW9uKHRpbGUub3JpZ2luYWxFbCwgdGhpcy5fZ2V0VGlsZVBvcyhjb29yZHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbGUubG9hZGVkID0gK25ldyBEYXRlKCk7XG4gICAgICAgIHRpbGUuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJ1bmVUaWxlcygpO1xuXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICB0aWxlLmVsLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcblxuICAgICAgICAgICAgLy8gQGV2ZW50IHRpbGVsb2FkOiBUaWxlRXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYSB0aWxlIGxvYWRzLlxuICAgICAgICAgICAgdGhpcy5maXJlKCd0aWxlbG9hZCcsIHtcbiAgICAgICAgICAgICAgICB0aWxlOiB0aWxlLmVsLFxuICAgICAgICAgICAgICAgIHByZXZpZXc6IHRpbGUucHJldmlldyxcbiAgICAgICAgICAgICAgICBjb29yZHM6IGNvb3Jkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbm9UaWxlc1RvTG9hZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBAZXZlbnQgbG9hZDogRXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgbG9hZGVkIGFsbCB2aXNpYmxlIHRpbGVzLlxuICAgICAgICAgICAgdGhpcy5maXJlKCdsb2FkJyk7XG5cbiAgICAgICAgICAgIGlmIChMLkJyb3dzZXIuaWVsdDkgfHwgIXRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG4gICAgICAgICAgICAgICAgTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdhaXQgYSBiaXQgbW9yZSB0aGFuIDAuMiBzZWNzICh0aGUgZHVyYXRpb24gb2YgdGhlIHRpbGUgZmFkZS1pbilcbiAgICAgICAgICAgICAgICAvLyB0byB0cmlnZ2VyIGEgcHJ1bmluZy5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKSwgMjUwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDQkiDQvtGC0LvQuNGH0LjQtSDQvtGCINC+0YDQuNCz0LjQvdCw0LvRjNC90L7Qs9C+INC80LXRgtC+0LTQsCwg0LfQtNC10YHRjCB1cmwg0L/RgNC+0LrQuNC00YvQstCw0LXRgtGB0Y8g0L/QsNGA0LDQvNC10YLRgNC+0LxcbiAgICAgKi9cbiAgICBnZXRUaWxlVXJsOiBmdW5jdGlvbihjb29yZHMsIHVybCkge1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIHI6IEwuQnJvd3Nlci5yZXRpbmEgPyAnQDJ4JyA6ICcnLFxuICAgICAgICAgICAgczogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3JkcyksXG4gICAgICAgICAgICB4OiBjb29yZHMueCxcbiAgICAgICAgICAgIHk6IGNvb3Jkcy55LFxuICAgICAgICAgICAgejogdGhpcy5fZ2V0Wm9vbUZvclVybCgpXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5vcHRpb25zLmNycy5pbmZpbml0ZSkge1xuICAgICAgICAgICAgdmFyIGludmVydGVkWSA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZS5tYXgueSAtIGNvb3Jkcy55O1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50bXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhWyd5J10gPSBpbnZlcnRlZFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhWycteSddID0gaW52ZXJ0ZWRZO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEwuVXRpbC50ZW1wbGF0ZSh1cmwsIEwuZXh0ZW5kKGRhdGEsIHRoaXMub3B0aW9ucykpO1xuICAgIH0sXG59KTtcbiIsIkRHLkNvbnRyb2wuWm9vbS5pbmNsdWRlKERHLkxvY2FsZSk7XG5ERy5Db250cm9sLlpvb20uRGljdGlvbmFyeSA9IHt9O1xuXG5ERy5Db250cm9sLlpvb20uaW5jbHVkZSh7XG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB2YXIgem9vbU5hbWUgPSAnZGctem9vbScsXG4gICAgICAgICAgICBidXR0b25UZW1wbGF0ZSA9ICc8ZGl2IGNsYXNzPVwiZGctY29udHJvbC1yb3VuZF9faWNvbiAnICsgem9vbU5hbWUgKyAnX19jb250cm9sICcgKyB6b29tTmFtZSArICdfX2J1dHRvbiAnICsgem9vbU5hbWUgKyAnX19idXR0b25fdHlwZV97dHlwZX1cIj48L2Rpdj4nLFxuICAgICAgICAgICAgY29udGFpbmVyID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHpvb21OYW1lKTtcblxuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG5cbiAgICAgICAgdGhpcy5fem9vbUluQnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKERHLlV0aWwudGVtcGxhdGUoYnV0dG9uVGVtcGxhdGUsIHt0eXBlIDogJ2luJ30pLCB0aGlzLnQoJ3pvb21faW4nKSwgJ2RnLWNvbnRyb2wtcm91bmQgJyArIHpvb21OYW1lICsgJ19faW4nLCBjb250YWluZXIsIHRoaXMuX3pvb21JbiwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oREcuVXRpbC50ZW1wbGF0ZShidXR0b25UZW1wbGF0ZSwge3R5cGUgOiAnb3V0J30pLCB0aGlzLnQoJ3pvb21fb3V0JyksICdkZy1jb250cm9sLXJvdW5kICcgKyB6b29tTmFtZSArICdfX291dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcbiAgICAgICAgbWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgX29yaWdpbmFsQ3JlYXRlQnV0dG9uOiBERy5Db250cm9sLlpvb20ucHJvdG90eXBlLl9jcmVhdGVCdXR0b24sXG5cbiAgICAvLyBzZXQgYWN0aXZlIHN0YXRlIGNvbnRyb2wgb24gbW9iaWxlIGRldmljZXNcbiAgICBfY3JlYXRlQnV0dG9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICB2YXIgbGluayA9IHRoaXMuX29yaWdpbmFsQ3JlYXRlQnV0dG9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICAgIHZhciBpY29uID0gbGluay5jaGlsZHJlblswXTtcbiAgICAgICAgdmFyIGxpbmtBY3RpdmVDbGFzcyA9ICdkZy1jb250cm9sLXJvdW5kX3N0YXRlX2FjdGl2ZSc7XG4gICAgICAgIHZhciBpY29uQWN0aXZlQ2xhc3MgPSAnZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUnO1xuXG4gICAgICAgIERHLkRvbUV2ZW50XG4gICAgICAgICAgICAub24obGluaywgJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKGxpbmssIGxpbmtBY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyhpY29uLCBpY29uQWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihsaW5rLCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKGxpbmssIGxpbmtBY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyhpY29uLCBpY29uQWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgfSxcblxuICAgIF9yZW5kZXJUcmFuc2xhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fem9vbUluQnV0dG9uIHx8ICF0aGlzLl96b29tT3V0QnV0dG9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl96b29tSW5CdXR0b24udGl0bGUgPSB0aGlzLnQoJ3pvb21faW4nKTtcbiAgICAgICAgdGhpcy5fem9vbU91dEJ1dHRvbi50aXRsZSA9IHRoaXMudCgnem9vbV9vdXQnKTtcbiAgICB9XG59KTtcbiIsIkRHLkNvbnRyb2wuWm9vbS5EaWN0aW9uYXJ5LnJ1ID0ge1xuICAgIHpvb21faW4gOiAn0J/RgNC40LHQu9C40LfQuNGC0YwnLFxuICAgIHpvb21fb3V0IDogJ9Ce0YLQtNCw0LvQuNGC0YwnXG59O1xuIiwiREcuQ29udHJvbC5ab29tLkRpY3Rpb25hcnkuaXQgPSB7XG4gICAgem9vbV9pbiA6ICdab29tIGF2YW50aScsXG4gICAgem9vbV9vdXQgOiAnWm9vbSBpbmRpZXRybydcbn07XG4iLCJERy5Db250cm9sLlpvb20uRGljdGlvbmFyeS5jcyA9IHtcbiAgICB6b29tX2luIDogJ1DFmWlibMOtxb5pdCcsXG4gICAgem9vbV9vdXQgOiAnT2Rkw6FsaXQnXG59O1xuIiwiREcuQ29udHJvbC5ab29tLkRpY3Rpb25hcnkuZW4gPSB7XG4gICAgem9vbV9pbiA6ICdab29tIGluJyxcbiAgICB6b29tX291dCA6ICdab29tIG91dCdcbn07XG4iLCJERy5Db250cm9sLlpvb20uRGljdGlvbmFyeS5lcyA9IHtcbiAgICB6b29tX2luIDogJ0FjZXJjYXInLFxuICAgIHpvb21fb3V0IDogJ0FsZWphcidcbn07XG4iLCJERy5Db250cm9sLlpvb20uRGljdGlvbmFyeS5hciA9IHtcbiAgICB6b29tX2luIDogJycsXG4gICAgem9vbV9vdXQgOiAnJ1xufTtcbiIsInZhciBkdXN0ID0gcmVxdWlyZSgnZHVzdGpzLWxpbmtlZGluJyk7XG5yZXF1aXJlKCdkdXN0anMtaGVscGVycycpO1xuXG5ERy5kdXN0ID0gZnVuY3Rpb24obmFtZSwgZGF0YSkge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICAvLyBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHN5bmNocm9ub3VzbHksIHNvIHRoaXMgd29ya3NcbiAgICBkdXN0LnJlbmRlcihuYW1lLCBkYXRhLCBmdW5jdGlvbihlcnIsIGh0bWwpIHtcbiAgICAgICAgcmVzdWx0ID0gaHRtbDtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuIiwiREcuQ29udHJvbC5BdHRyaWJ1dGlvbi5pbmNsdWRlKERHLkxvY2FsZSk7XG5ERy5Db250cm9sLkF0dHJpYnV0aW9uLkRpY3Rpb25hcnkgPSB7fTtcbkRHLkNvbnRyb2wuQXR0cmlidXRpb24uaW5jbHVkZSh7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBwb3NpdGlvbjogJ2JvdHRvbXJpZ2h0J1xuICAgIH0sXG5cbiAgICBfZ2V0TGluazogZnVuY3Rpb24obGlua1R5cGUpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gICAgICAgIHZhciBkaWN0aW9uYXJ5ID0ge1xuICAgICAgICAgICAgcnU6IHtcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfbG9nbzogJ2h0dHA6Ly9pbmZvLjJnaXMucnUvP3V0bV9zb3VyY2U9Y29weXJpZ2h0JnV0bV9tZWRpdW09bWFwJnV0bV9jYW1wYWlnbj1wYXJ0bmVycycsXG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2FwaWxpbms6ICdodHRwOi8vYXBpLjJnaXMucnUvP3V0bV9zb3VyY2U9Y29weXJpZ2h0JnV0bV9tZWRpdW09bWFwJnV0bV9jYW1wYWlnbj1wYXJ0bmVycycsXG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2xpY2Vuc2U6ICdodHRwOi8vbGF3LjJnaXMucnUvYXBpLXJ1bGVzLydcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGl0OiB7XG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2xvZ286ICdodHRwOi8vMmdpcy5pdC8/dXRtX3NvdXJjZT1jb3B5cmlnaHQmdXRtX21lZGl1bT1tYXAmdXRtX2NhbXBhaWduPXBhcnRuZXJzJyxcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfYXBpbGluazogJ2h0dHA6Ly8yZ2lzLml0Lz91dG1fc291cmNlPWNvcHlyaWdodCZ1dG1fbWVkaXVtPW1hcCZ1dG1fY2FtcGFpZ249cGFydG5lcnMnLFxuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9saWNlbnNlOiAnaHR0cDovL2xhdy4yZ2lzLml0L2xpY2Vuc2luZy1hZ3JlZW1lbnQvJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY3o6IHtcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfbG9nbzogJ2h0dHA6Ly9wcmFoYS4yZ2lzLmN6Lz91dG1fc291cmNlPWNvcHlyaWdodCZ1dG1fbWVkaXVtPW1hcCZ1dG1fY2FtcGFpZ249cGFydG5lcnMnLFxuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9hcGlsaW5rOiAnaHR0cDovL3ByYWhhLjJnaXMuY3ovP3V0bV9zb3VyY2U9Y29weXJpZ2h0JnV0bV9tZWRpdW09bWFwJnV0bV9jYW1wYWlnbj1wYXJ0bmVycycsXG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2xpY2Vuc2U6ICdodHRwOi8vbGF3LjJnaXMuY3ovYXBpLXJ1bGVzLydcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsOiB7XG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2xvZ286ICdodHRwOi8vc2FudGlhZ28uMmdpcy5jbC8/dXRtX3NvdXJjZT1jb3B5cmlnaHQmdXRtX21lZGl1bT1tYXAmdXRtX2NhbXBhaWduPXBhcnRuZXJzJyxcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfYXBpbGluazogJ2h0dHA6Ly9zYW50aWFnby4yZ2lzLmNsLz91dG1fc291cmNlPWNvcHlyaWdodCZ1dG1fbWVkaXVtPW1hcCZ1dG1fY2FtcGFpZ249cGFydG5lcnMnLFxuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9saWNlbnNlOiAnaHR0cDovL2xhdy4yZ2lzLmNsL2FwaS1ydWxlcy8nXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjeToge1xuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9sb2dvOiAnaHR0cDovL2luZm8uMmdpcy5jb20uY3kvbGVtZXNvcz91dG1fc291cmNlPWNvcHlyaWdodCZ1dG1fbWVkaXVtPW1hcCZ1dG1fY2FtcGFpZ249cGFydG5lcnMnLFxuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9hcGlsaW5rOiAnaHR0cDovL2luZm8uMmdpcy5jb20uY3kvbGVtZXNvcz91dG1fc291cmNlPWNvcHlyaWdodCZ1dG1fbWVkaXVtPW1hcCZ1dG1fY2FtcGFpZ249cGFydG5lcnMnLFxuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9saWNlbnNlOiAnaHR0cDovL2xhdy4yZ2lzLmNvbS5jeS9hcGktcnVsZXMvJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWU6IHtcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfbG9nbzogJ2h0dHA6Ly9pbmZvLjJnaXMuYWUvZHViYWk/dXRtX3NvdXJjZT1jb3B5cmlnaHQmdXRtX21lZGl1bT1tYXAmdXRtX2NhbXBhaWduPXBhcnRuZXJzJyxcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfYXBpbGluazogJ2h0dHA6Ly9pbmZvLjJnaXMuYWUvZHViYWk/dXRtX3NvdXJjZT1jb3B5cmlnaHQmdXRtX21lZGl1bT1tYXAmdXRtX2NhbXBhaWduPXBhcnRuZXJzJyxcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfbGljZW5zZTogJ2h0dHA6Ly9sYXcuMmdpcy5hZS9hcGktcnVsZXMvJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuXG4gICAgICAgIHZhciBjb3VudHJ5Q29kZSA9ICh0aGlzLl9jb3VudHJ5Q29kZSBpbiBkaWN0aW9uYXJ5KSA/IHRoaXMuX2NvdW50cnlDb2RlIDogJ3J1JztcblxuICAgICAgICByZXR1cm4gZGljdGlvbmFyeVtjb3VudHJ5Q29kZV1bbGlua1R5cGVdO1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIGlmICghbWFwLl9jb3B5cmlnaHQpIHtcbiAgICAgICAgICAgIG1hcC5fY29weXJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wgPSB0aGlzO1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2RnLWF0dHJpYnV0aW9uJyk7XG4gICAgICAgIERHLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRoaXMuX2NvbnRhaW5lcik7XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiBtYXAuX2xheWVycykge1xuICAgICAgICAgICAgaWYgKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGlvbihtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgfSxcblxuICAgIF91cGRhdGU6IGZ1bmN0aW9uKGxhbmcsIG9zbSwgY291bnRyeUNvZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvc20gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9vc20gPSBvc207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvdW50cnlDb2RlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5fY291bnRyeUNvZGUgPSBjb3VudHJ5Q29kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdHRyaWJzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbaV0pIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlZml4QW5kQXR0cmlicyA9IFtdLFxuICAgICAgICAgICAgY29weXJpZ2h0ID0gJyc7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZpcnN0KSB7XG4gICAgICAgICAgICBjb3B5cmlnaHQgPSB0aGlzLl9nZXRBdHRyaWJ1dGlvbkhUTUwobGFuZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByZWZpeCkge1xuICAgICAgICAgICAgcHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcHJlZml4QW5kQXR0cmlicy5wdXNoKGF0dHJpYnMuam9pbignLCAnKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gY29weXJpZ2h0ICsgcHJlZml4QW5kQXR0cmlicy5qb2luKCcgfCAnKTtcbiAgICB9LFxuICAgIF9nZXREYXRhOiBmdW5jdGlvbihsYW5nKSB7XG4gICAgICAgIGxhbmcgPSBsYW5nIHx8IHRoaXMuX21hcC5nZXRMYW5nKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdvc20nOiB0aGlzLl9vc20sXG4gICAgICAgICAgICAnd29ya19vbic6IHRoaXMudCgnd29ya19vbicpLFxuICAgICAgICAgICAgJ3dvcmtfb25fd2l0aF9vc20nOiB0aGlzLnQoJ3dvcmtfb25fd2l0aF9vc20nKSxcbiAgICAgICAgICAgICdsYW5nJzogbGFuZyxcbiAgICAgICAgICAgICdjb3B5cmlnaHRfYXBpbGluayc6IHRoaXMuX2dldExpbmsoJ2NvcHlyaWdodF9hcGlsaW5rJyksXG4gICAgICAgICAgICAnY29weXJpZ2h0X2xpY2Vuc2UnOiB0aGlzLl9nZXRMaW5rKCdjb3B5cmlnaHRfbGljZW5zZScpLFxuICAgICAgICAgICAgJ2NvcHlyaWdodF9sb2dvJzogdGhpcy5fZ2V0TGluaygnY29weXJpZ2h0X2xvZ28nKSxcbiAgICAgICAgICAgICdsaWNlbnNlX2FncmVlbWVudCc6IHRoaXMudCgnbGljZW5zZV9hZ3JlZW1lbnQnKSxcbiAgICAgICAgICAgICdkaXInOiBsYW5nICE9PSAnYXInID8gJ2x0cicgOiAncnRsJyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIF9nZXRBdHRyaWJ1dGlvbkhUTUw6IGZ1bmN0aW9uKGxhbmcpIHtcbiAgICAgICAgcmV0dXJuIERHLmR1c3QoJ0RHQXR0cmlidXRpb24vY29weXJpZ2h0JywgdGhpcy5fZ2V0RGF0YShsYW5nKSk7XG4gICAgfSxcbiAgICBfcmVuZGVyVHJhbnNsYXRpb246IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKGUubGFuZyk7XG4gICAgfVxufSk7XG5cbkRHLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2NvcHlyaWdodCkge1xuICAgICAgICBERy5jb250cm9sLmF0dHJpYnV0aW9uKCkuYWRkVG8odGhpcyk7XG4gICAgfVxufSk7XG4iLCJERy5Db250cm9sLkF0dHJpYnV0aW9uLkRpY3Rpb25hcnkucnUgPSB7XG4gICAgbGljZW5zZV9hZ3JlZW1lbnQ6ICfQm9C40YbQtdC90LfQuNC+0L3QvdC+0LUg0YHQvtCz0LvQsNGI0LXQvdC40LUnLFxuICAgIHdvcmtfb246ICfQoNCw0LHQvtGC0LDQtdGCINC90LAgQVBJIDLQk9CY0KEnLFxuICAgIHdvcmtfb25fd2l0aF9vc206ICdBUEkgMtCT0JjQoSdcbn07XG4iLCJERy5Db250cm9sLkF0dHJpYnV0aW9uLkRpY3Rpb25hcnkuaXQgPSB7XG4gICAgbGljZW5zZV9hZ3JlZW1lbnQgOiAnQWNjb3JkbyBkaSBsaWNlbnphJyxcbiAgICB3b3JrX29uOiAnMkdJUyBBUEknLFxuICAgIHdvcmtfb25fd2l0aF9vc206ICcyR0lTIEFQSSdcbn07XG4iLCJERy5Db250cm9sLkF0dHJpYnV0aW9uLkRpY3Rpb25hcnkuY3MgPSB7XG4gICAgbGljZW5zZV9hZ3JlZW1lbnQ6ICdMaWNlbsSNbsOtIHNtbG91dmEnLFxuICAgIHdvcmtfb246ICdQcmFjdWplIG5hIEFQSSAyR0lTJyxcbiAgICB3b3JrX29uX3dpdGhfb3NtOiAnQVBJIDJHSVMnXG59O1xuIiwiREcuQ29udHJvbC5BdHRyaWJ1dGlvbi5EaWN0aW9uYXJ5LmVuID0ge1xuICAgIGxpY2Vuc2VfYWdyZWVtZW50OiAnTGljZW5zZSBhZ3JlZW1lbnQnLFxuICAgIHdvcmtfb246ICdVc2VzIDJHSVMgQVBJJyxcbiAgICB3b3JrX29uX3dpdGhfb3NtOiAnMkdJUyBBUEknXG59O1xuIiwiREcuQ29udHJvbC5BdHRyaWJ1dGlvbi5EaWN0aW9uYXJ5LmVzID0ge1xuICAgIGxpY2Vuc2VfYWdyZWVtZW50IDogJ0FjdWVyZG8gZGUgbGljZW5jaWEnLFxuICAgIHdvcmtfb246ICcyR0lTIEFQSScsXG4gICAgd29ya19vbl93aXRoX29zbTogJzJHSVMgQVBJJ1xufTtcbiIsIkRHLkNvbnRyb2wuQXR0cmlidXRpb24uRGljdGlvbmFyeS5hciA9IHtcbiAgICBsaWNlbnNlX2FncmVlbWVudDogJ9il2KrZgdin2YLZitipINiq2LHYrtmK2LUnLFxuICAgIHdvcmtfb246ICfZiti52YXZhCDYqNiq2LfYqNmK2YIgMkdJUycsXG4gICAgd29ya19vbl93aXRoX29zbTogJ0FQSSAyR0lTJ1xufTtcbiIsIkRHLkNvbnRyb2wuTG9jYXRpb24gPSBERy5Sb3VuZENvbnRyb2wuZXh0ZW5kKHtcblxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgRGljdGlvbmFyeToge31cbiAgICB9LFxuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBpY29uQ2xhc3M6ICdsb2NhdGUnLFxuICAgICAgICBwb3NpdGlvbjogREcuQnJvd3Nlci5tb2JpbGUgPyAnYm90dG9tcmlnaHQnIDogJ3RvcGxlZnQnLFxuICAgICAgICBkcmF3Q2lyY2xlOiB0cnVlLFxuICAgICAgICBmb2xsb3c6IHRydWUsICAvLyBmb2xsb3cgd2l0aCB6b29tIGFuZCBwYW4gdGhlIHVzZXIncyBsb2NhdGlvblxuICAgICAgICBzdG9wRm9sbG93aW5nT25EcmFnOiBmYWxzZSwgLy8gaWYgZm9sbG93IGlzIHRydWUsIHN0b3AgZm9sbG93aW5nIHdoZW4gbWFwIGlzIGRyYWdnZWRcbiAgICAgICAgbWV0cmljOiB0cnVlLFxuICAgICAgICBvbkxvY2F0aW9uRXJyb3I6IGZ1bmN0aW9uKC8qZXJyKi8pIHtcbiAgICAgICAgICAgIC8vIHRoaXMgZXZlbnQgaXMgY2FsbGVkIGluIGNhc2Ugb2YgYW55IGxvY2F0aW9uIGVycm9yXG4gICAgICAgICAgICAvLyB0aGF0IGlzIG5vdCBhIHRpbWUgb3V0IGVycm9yLlxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9LFxuICAgICAgICBvbkxvY2F0aW9uT3V0c2lkZU1hcEJvdW5kczogZnVuY3Rpb24oLypjb250ZXh0Ki8pIHtcbiAgICAgICAgICAgIC8vIHRoaXMgZXZlbnQgaXMgcmVwZWF0ZWRseSBjYWxsZWQgd2hlbiB0aGUgbG9jYXRpb24gY2hhbmdlc1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coY29udGV4dC50KCdvdXRzaWRlTWFwQm91bmRzTXNnJykpO1xuICAgICAgICB9LFxuICAgICAgICBsb2NhdGVPcHRpb25zOiB7fVxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIERHLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoIW5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ldmVudCA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0aGlzLl9sb2NhdGVPcHRpb25zID0ge1xuICAgICAgICAgICAgd2F0Y2g6IHRydWUsICAvLyBpZiB5b3Ugb3ZlcndyaXRlIHRoaXMsIHZpc3VhbGl6YXRpb24gY2Fubm90IGJlIHVwZGF0ZWRcbiAgICAgICAgICAgIHNldFZpZXc6IHRydWUsXG4gICAgICAgICAgICBtYXhpbXVtQWdlOiBJbmZpbml0eSxcbiAgICAgICAgICAgIG1heFpvb206IEluZmluaXR5XG4gICAgICAgIH07XG4gICAgICAgIERHLmV4dGVuZCh0aGlzLl9sb2NhdGVPcHRpb25zLCB0aGlzLm9wdGlvbnMubG9jYXRlT3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fcmVzZXRWYXJpYWJsZXMoKTtcblxuICAgICAgICB0aGlzLm9uKHtcbiAgICAgICAgICAgICdjbGljayc6IHRoaXMuX2hhbmRsZUxvY2F0ZSxcbiAgICAgICAgICAgICdhZGQnOiB0aGlzLl9pbml0TG9jYXRlXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfaW5pdExvY2F0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2xheWVyID0gbmV3IERHLkxheWVyR3JvdXAoKTtcbiAgICAgICAgdGhpcy5fbGF5ZXIuYWRkVG8odGhpcy5fbWFwKTtcblxuICAgICAgICAvLyBldmVudCBob29rc1xuICAgICAgICB0aGlzLl9tYXAub24oe1xuICAgICAgICAgICAgJ2xvY2F0aW9uZm91bmQnOiB0aGlzLl9vbkxvY2F0aW9uRm91bmQsXG4gICAgICAgICAgICAnbG9jYXRpb25lcnJvcic6IHRoaXMuX29uTG9jYXRpb25FcnJvclxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX2hhbmRsZUxvY2F0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmUgJiYgKCF0aGlzLl9ldmVudCB8fFxuICAgICAgICAgICAgKHRoaXMuX21hcC5nZXRCb3VuZHMoKS5jb250YWlucyh0aGlzLl9ldmVudC5sYXRsbmcpIHx8XG4gICAgICAgICAgICB0aGlzLl9pc091dHNpZGVNYXBCb3VuZHMoKSkpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wTG9jYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhdGVPbk5leHRMb2NhdGlvbkZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAubG9jYXRlKHRoaXMuX2xvY2F0ZU9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvbGxvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0Rm9sbG93aW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2NsZWFyRXJyb3IoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlzdWFsaXplTG9jYXRpb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgncmVxdWVzdGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9vbkxvY2F0aW9uRm91bmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBkbyBhbnl0aGluZyBpZiB0aGUgbG9jYXRpb24gaGFzIG5vdCBjaGFuZ2VkXG4gICAgICAgIGlmICh0aGlzLl9ldmVudCAmJlxuICAgICAgICAgICAgKHRoaXMuX2V2ZW50LmxhdGxuZy5sYXQgPT09IGUubGF0bG5nLmxhdCAmJlxuICAgICAgICAgICAgIHRoaXMuX2V2ZW50LmxhdGxuZy5sbmcgPT09IGUubGF0bG5nLmxuZyAmJlxuICAgICAgICAgICAgIHRoaXMuX2V2ZW50LmFjY3VyYWN5ID09PSBlLmFjY3VyYWN5KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2V2ZW50ID0gZTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvbGxvdyAmJiB0aGlzLl9mb2xsb3dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2F0ZU9uTmV4dExvY2F0aW9uRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmlzdWFsaXplTG9jYXRpb24oKTtcbiAgICB9LFxuXG4gICAgX3N0YXJ0Rm9sbG93aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZm9sbG93aW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdG9wRm9sbG93aW5nT25EcmFnKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAub24oJ2RyYWdzdGFydCcsIHRoaXMuX3N0b3BGb2xsb3dpbmcpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zdG9wRm9sbG93aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZm9sbG93aW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RvcEZvbGxvd2luZ09uRHJhZykge1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9mZignZHJhZ3N0YXJ0JywgdGhpcy5fc3RvcEZvbGxvd2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzdWFsaXplTG9jYXRpb24oKTtcbiAgICB9LFxuXG4gICAgX2lzT3V0c2lkZU1hcEJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9ldmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyAmJlxuICAgICAgICAgICAgIXRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcy5jb250YWlucyh0aGlzLl9ldmVudC5sYXRsbmcpO1xuICAgIH0sXG5cbiAgICBfdmlzdWFsaXplTG9jYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZXZlbnQuYWNjdXJhY3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnQuYWNjdXJhY3kgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMuX2V2ZW50LmFjY3VyYWN5O1xuXG4gICAgICAgIGlmICh0aGlzLl9sb2NhdGVPbk5leHRMb2NhdGlvbkZvdW5kKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNPdXRzaWRlTWFwQm91bmRzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25Mb2NhdGlvbk91dHNpZGVNYXBCb3VuZHModGhpcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0Vmlldykge1xuICAgICAgICAgICAgICAgIHZhciB6b29tID0gdGhpcy5fbWFwLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCkubWF4Wm9vbSB8fCBERy5jb25maWcucHJvamVjdExlYXZlTWF4Wm9vbTtcbiAgICAgICAgICAgICAgICB6b29tID0gTWF0aC5taW4odGhpcy5fbG9jYXRlT3B0aW9ucy5tYXhab29tLCB6b29tKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAuc2V0Vmlldyh0aGlzLl9ldmVudC5sYXRsbmcsIHpvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9jYXRlT25OZXh0TG9jYXRpb25Gb3VuZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2lyY2xlIHdpdGggdGhlIHJhZGl1cyBvZiB0aGUgbG9jYXRpb24ncyBhY2N1cmFjeVxuICAgICAgICB2YXIgc3R5bGUgPSB7XG4gICAgICAgICAgICBjbGlja2FibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29sb3I6ICcjRkZGJyxcbiAgICAgICAgICAgIGZpbGxDb2xvcjogJyNGRkYnLFxuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuNCxcbiAgICAgICAgICAgIHdlaWdodDogMCxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuM1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRyYXdDaXJjbGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2lyY2xlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlID0gREcuY2lyY2xlKHRoaXMuX2V2ZW50LmxhdGxuZywgcmFkaXVzLCBzdHlsZSlcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRvKHRoaXMuX2xheWVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlLnNldExhdExuZyh0aGlzLl9ldmVudC5sYXRsbmcpLnNldFJhZGl1cyhyYWRpdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hcmtlckNsYXNzID0gJ2RnLWxvY2F0aW9uX19waW4nO1xuXG4gICAgICAgIG1hcmtlckNsYXNzICs9IHRoaXMuX2ZvbGxvd2luZyA/ICgnICcgKyBtYXJrZXJDbGFzcyArICdzdGF0ZV9mb2xsb3dpbmcnKSA6ICcnO1xuICAgICAgICAvLyBzbWFsbCBpbm5lciBtYXJrZXJcbiAgICAgICAgdmFyIG0gPSB7XG4gICAgICAgICAgICBpY29uOiBERy5kaXZJY29uKHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IG1hcmtlckNsYXNzLFxuICAgICAgICAgICAgICAgIGljb25TaXplOiBbMjAsIDIwXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIXRoaXMuX21hcmtlcikge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyID0gREcubWFya2VyKHRoaXMuX2V2ZW50LmxhdGxuZywgbSlcbiAgICAgICAgICAgICAgICAuYmluZExhYmVsKHRoaXMudCgneW91X2FyZV9oZXJlJykpXG4gICAgICAgICAgICAgICAgLmFkZFRvKHRoaXMuX2xheWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlci5zZXRMYXRMbmcodGhpcy5fZXZlbnQubGF0bG5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIERHLkRvbUV2ZW50Lm9uKHRoaXMuX21hcmtlciwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZmlyZUV2ZW50KCdkZ0xvY2F0ZUNsaWNrJyk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmICghdGhpcy5fY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKCdhY3RpdmUnKTtcbiAgICB9LFxuXG4gICAgX3Jlc2V0VmFyaWFibGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZvbGxvd2luZyA9IGZhbHNlO1xuICAgIH0sXG5cblxuICAgIF9zdG9wTG9jYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbWFwLnN0b3BMb2NhdGUoKTtcbiAgICAgICAgdGhpcy5fbWFwLm9mZignZHJhZ3N0YXJ0JywgdGhpcy5fc3RvcEZvbGxvd2luZyk7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSgpO1xuICAgICAgICB0aGlzLl9yZXNldFZhcmlhYmxlcygpO1xuXG4gICAgICAgIHRoaXMuX2xheWVyLmNsZWFyTGF5ZXJzKCk7XG4gICAgICAgIHRoaXMuX21hcmtlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY2lyY2xlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9ldmVudCA9IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgX29uTG9jYXRpb25FcnJvcjogZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIC8vIGlnbm9yZSB0aW1lIG91dCBlcnJvciBpZiB0aGUgbG9jYXRpb24gaXMgd2F0Y2hlZFxuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDMgJiYgdGhpcy5fbG9jYXRlT3B0aW9ucy53YXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RvcExvY2F0ZSgpO1xuICAgICAgICB0aGlzLl9lcnJvciA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnZGctbGFiZWwgZGctbGFiZWxfbmFtZV9sb2NhdGlvbi1lcnJvcicsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuX2Vycm9yVGV4dCA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnZGctbGFiZWxfX2NvbnRlbnQnLCB0aGlzLl9lcnJvcik7XG4gICAgICAgIHRoaXMuX2Vycm9yVGV4dC5pbm5lckhUTUwgPSB0aGlzLnQoJ2NhbnRfZmluZCcpO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuX2NsZWFyRXJyb3IoKTtcbiAgICAgICAgfSwgMzAwMCk7XG5cbiAgICAgICAgLy9zaG93IGxvY2F0aW9uIGVycm9yXG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkxvY2F0aW9uRXJyb3IoZXJyKTtcbiAgICB9LFxuXG4gICAgX2NsZWFyRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9lcnJvcik7XG4gICAgICAgICAgICB0aGlzLl9lcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yVGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVuZGVyVHJhbnNsYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluaykge1xuICAgICAgICAgICAgdGhpcy5fbGluay50aXRsZSA9IHRoaXMudCgnYnV0dG9uX3RpdGxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21hcmtlcikge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyLmJpbmRMYWJlbCh0aGlzLnQoJ3lvdV9hcmVfaGVyZScpKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5ERy5jb250cm9sLmxvY2F0aW9uID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuQ29udHJvbC5Mb2NhdGlvbihvcHRpb25zKTtcbn07XG5cbkRHLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9uQ29udHJvbCkge1xuICAgICAgICB0aGlzLmxvY2F0aW9uQ29udHJvbCA9IERHLmNvbnRyb2wubG9jYXRpb24odGhpcy5vcHRpb25zLmxvY2F0aW9uQ29udHJvbCk7XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbCh0aGlzLmxvY2F0aW9uQ29udHJvbCk7XG4gICAgfVxufSk7XG4iLCJERy5Db250cm9sLkxvY2F0aW9uLkRpY3Rpb25hcnkucnUgPSB7XG4gICAgY2FudF9maW5kIDogJ9Cc0Ysg0L3QtSDRgdC80L7Qs9C70Lgg0JLQsNGBINC90LDQudGC0LgnLFxuICAgIHlvdV9hcmVfaGVyZSA6ICfQktGLINC30LTQtdGB0YwnLFxuICAgIGJ1dHRvbl90aXRsZSA6ICfQndCw0LnRgtC4INCS0LDRgSDQvdCwINC60LDRgNGC0LUnXG59O1xuIiwiREcuQ29udHJvbC5Mb2NhdGlvbi5EaWN0aW9uYXJ5Lml0ID0ge1xuICAgIGNhbnRfZmluZCA6ICdOb24gc2lhbW8gcml1c2NpdGkgYSBsb2NhbGl6emFydGknLFxuICAgIHlvdV9hcmVfaGVyZSA6ICdWb2kgc2lldGUgcXVpJyxcbiAgICBidXR0b25fdGl0bGUgOiAnVHJvdmEgbGEgdHVhIHBvc2l6aW9uZSBzdWxsYSBtYXBwYSdcbn07XG4iLCJERy5Db250cm9sLkxvY2F0aW9uLkRpY3Rpb25hcnkuY3MgPSB7XG4gICAgY2FudF9maW5kIDogJ05lcG9kYcWZaWxvIHNlIG7DoW0gdXLEjWl0IFZhxaFpIHBvbG9odScsXG4gICAgeW91X2FyZV9oZXJlIDogJ0pzdGUgdGFkeScsXG4gICAgYnV0dG9uX3RpdGxlIDogJ1VyxI1pdCBWYcWhaSBwb2xvaHUgbmEgbWFwxJsnXG59O1xuIiwiREcuQ29udHJvbC5Mb2NhdGlvbi5EaWN0aW9uYXJ5LmVuID0ge1xuICAgIGNhbnRfZmluZCA6ICdXZSBjYW5cXCd0IGZpbmQgeW91JyxcbiAgICB5b3VfYXJlX2hlcmUgOiAnWW91IGFyZSBoZXJlJyxcbiAgICBidXR0b25fdGl0bGUgOiAnU2hvdyB5b3VyIGxvY2F0aW9uJ1xufTtcbiIsIkRHLkNvbnRyb2wuTG9jYXRpb24uRGljdGlvbmFyeS5lcyA9IHtcbiAgICBjYW50X2ZpbmQgOiAnTm8gcHVkaW1vcyBlbmNvbnRyYXJ0ZScsXG4gICAgeW91X2FyZV9oZXJlIDogJ1TDuiBlc3TDoXMgYXF1w60nLFxuICAgIGJ1dHRvbl90aXRsZSA6ICdFbmNvbnRyYXJ0ZSBlbiBlbCBtYXBhJ1xufTtcbiIsIkRHLkNvbnRyb2wuTG9jYXRpb24uRGljdGlvbmFyeS5hciA9IHtcbiAgICBjYW50X2ZpbmQgOiAn2YTZhSDZhtiz2KrYt9i5INiq2K3Yr9mK2K8g2YXZiNmC2LnZgycsXG4gICAgeW91X2FyZV9oZXJlIDogJ9ij2YbYqiDZh9mG2KcnLFxuICAgIGJ1dHRvbl90aXRsZSA6ICfZhdmI2YLYudmKJ1xufTtcbiIsIi8vIEluc3BpcmVkIGJ5IFNpbmRyZSBTb3JodXMgc2NyZWVuZnVsbFxuLypnbG9iYWwgRWxlbWVudCAqL1xuREcuU2NyZWVuZnVsbCA9IERHLkNsYXNzLmV4dGVuZCh7XG4gICAgX2FwaU1hcDogW1xuICAgICAgICBbXG4gICAgICAgICAgICAncmVxdWVzdEZ1bGxzY3JlZW4nLFxuICAgICAgICAgICAgJ2V4aXRGdWxsc2NyZWVuJyxcbiAgICAgICAgICAgICdmdWxsc2NyZWVuRWxlbWVudCcsXG4gICAgICAgICAgICAnZnVsbHNjcmVlbkVuYWJsZWQnLFxuICAgICAgICAgICAgJ2Z1bGxzY3JlZW5jaGFuZ2UnLFxuICAgICAgICAgICAgJ2Z1bGxzY3JlZW5lcnJvcidcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgJ3dlYmtpdFJlcXVlc3RGdWxsc2NyZWVuJyxcbiAgICAgICAgICAgICd3ZWJraXRFeGl0RnVsbHNjcmVlbicsXG4gICAgICAgICAgICAnd2Via2l0RnVsbHNjcmVlbkVsZW1lbnQnLFxuICAgICAgICAgICAgJ3dlYmtpdEZ1bGxzY3JlZW5FbmFibGVkJyxcbiAgICAgICAgICAgICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJyxcbiAgICAgICAgICAgICd3ZWJraXRmdWxsc2NyZWVuZXJyb3InXG5cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgJ21velJlcXVlc3RGdWxsU2NyZWVuJyxcbiAgICAgICAgICAgICdtb3pDYW5jZWxGdWxsU2NyZWVuJyxcbiAgICAgICAgICAgICdtb3pGdWxsU2NyZWVuRWxlbWVudCcsXG4gICAgICAgICAgICAnbW96RnVsbFNjcmVlbkVuYWJsZWQnLFxuICAgICAgICAgICAgJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLFxuICAgICAgICAgICAgJ21vemZ1bGxzY3JlZW5lcnJvcidcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgJ21zUmVxdWVzdEZ1bGxzY3JlZW4nLFxuICAgICAgICAgICAgJ21zRXhpdEZ1bGxzY3JlZW4nLFxuICAgICAgICAgICAgJ21zRnVsbHNjcmVlbkVsZW1lbnQnLFxuICAgICAgICAgICAgJ21zRnVsbHNjcmVlbkVuYWJsZWQnLFxuICAgICAgICAgICAgJ01TRnVsbHNjcmVlbkNoYW5nZScsXG4gICAgICAgICAgICAnTVNGdWxsc2NyZWVuRXJyb3InXG4gICAgICAgIF1cbiAgICBdLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYXBpID0gdGhpcy5fYXBpKCk7XG4gICAgfSxcblxuICAgIHJlcXVlc3Q6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLmFwaS5yZXF1ZXN0RnVsbHNjcmVlbjtcblxuICAgICAgICBlbGVtID0gZWxlbSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIGVsZW1bcmVxdWVzdF0oRWxlbWVudC5BTExPV19LRVlCT0FSRF9JTlBVVCk7XG4gICAgfSxcblxuICAgIGV4aXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBkb2N1bWVudFt0aGlzLmFwaS5leGl0RnVsbHNjcmVlbl0oKTtcbiAgICB9LFxuXG4gICAgaXNGdWxsc2NyZWVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhZG9jdW1lbnRbdGhpcy5hcGkuZnVsbHNjcmVlbkVsZW1lbnRdO1xuICAgIH0sXG5cbiAgICBpc0F2YWlsYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuYXBpKTtcbiAgICB9LFxuXG4gICAgX2FwaTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcGkgPSB7fSxcbiAgICAgICAgICAgIGFwaU1hcCA9IHRoaXMuX2FwaU1hcDtcblxuICAgICAgICBhcGlNYXAuZm9yRWFjaChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwgJiYgdmFsWzFdIGluIGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFsLmZvckVhY2goZnVuY3Rpb24obWV0aG9kLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaVthcGlNYXBbMF1baV1dID0gbWV0aG9kO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXBpLnJlcXVlc3RGdWxsc2NyZWVuID8gYXBpIDogZmFsc2U7XG4gICAgfVxufSk7XG5cbkRHLnNjcmVlbmZ1bGwgPSBuZXcgREcuU2NyZWVuZnVsbCgpO1xuIiwiREcuQ29udHJvbC5GdWxsc2NyZWVuID0gREcuUm91bmRDb250cm9sLmV4dGVuZCh7XG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIERpY3Rpb25hcnk6IHt9XG4gICAgfSxcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcG9zaXRpb246ICd0b3ByaWdodCcsXG4gICAgICAgIGljb25DbGFzczogJ2Z1bGxzY3JlZW4nXG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgREcuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9pc0Z1bGxzY3JlZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbignY2xpY2snLCB0aGlzLl90b2dnbGVGdWxsc2NyZWVuKTtcbiAgICB9LFxuXG4gICAgX3RvZ2dsZUZ1bGxzY3JlZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzRnVsbHNjcmVlbikge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlKHRydWUsICdyZXF1ZXN0JywgJ29uJywgJ3JlcXVlc3RmdWxsc2NyZWVuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGUoZmFsc2UsICdleGl0JywgJ29uJywgJ2NhbmNlbGZ1bGxzY3JlZW4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbmRlclRyYW5zbGF0aW9uKCk7XG4gICAgICAgIHRoaXMuX21hcC5pbnZhbGlkYXRlU2l6ZSgpO1xuICAgIH0sXG5cbiAgICBfcmVuZGVyVHJhbnNsYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9saW5rLnRpdGxlID0gdGhpcy50KHRoaXMuX2lzRnVsbHNjcmVlbiA/ICd0aXRsZV9taW4nIDogJ3RpdGxlX21heCcpO1xuICAgIH0sXG5cbiAgICBfdG9nZ2xlOiBmdW5jdGlvbihpc0VuYWJsZWQsIG1ldGhvZCwgbGlzdCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX21hcC5fY29udGFpbmVyO1xuXG4gICAgICAgIHRoaXMuX2lzRnVsbHNjcmVlbiA9IGlzRW5hYmxlZDtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShpc0VuYWJsZWQgPyAnYWN0aXZlJyA6ICcnKTtcblxuICAgICAgICBERy5zY3JlZW5mdWxsW21ldGhvZF0oY29udGFpbmVyKTtcbiAgICAgICAgREcuRG9tRXZlbnRbbGlzdF0oZG9jdW1lbnQsIERHLnNjcmVlbmZ1bGwuYXBpLmZ1bGxzY3JlZW5jaGFuZ2UsIHRoaXMuX29uRnVsbFNjcmVlblN0YXRlQ2hhbmdlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fbWFwLmZpcmUoZXZlbnQpO1xuICAgIH0sXG5cbiAgICBfb25GdWxsU2NyZWVuU3RhdGVDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIURHLnNjcmVlbmZ1bGwuaXNGdWxsc2NyZWVuKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZShmYWxzZSwgJ2V4aXQnLCAnb24nLCAnY2FuY2VsZnVsbHNjcmVlbicpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkRHLmNvbnRyb2wuZnVsbHNjcmVlbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERHLkNvbnRyb2wuRnVsbHNjcmVlbihvcHRpb25zKTtcbn07XG5cbkRHLk1hcC5tZXJnZU9wdGlvbnMoe1xuICAgIGZ1bGxzY3JlZW5Db250cm9sOiB0cnVlXG59KTtcblxuREcuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZnVsbHNjcmVlbkNvbnRyb2wpIHtcbiAgICAgICAgdGhpcy5mdWxsc2NyZWVuQ29udHJvbCA9IERHLmNvbnRyb2wuZnVsbHNjcmVlbih0aGlzLm9wdGlvbnMuZnVsbHNjcmVlbkNvbnRyb2wpO1xuXG4gICAgICAgIGlmIChERy5zY3JlZW5mdWxsLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQ29udHJvbCh0aGlzLmZ1bGxzY3JlZW5Db250cm9sKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiREcuQ29udHJvbC5GdWxsc2NyZWVuLkRpY3Rpb25hcnkucnUgPSB7XG4gICAgdGl0bGVfbWF4IDogJ9Cg0LDQt9Cy0LXRgNC90YPRgtGMJyxcbiAgICB0aXRsZV9taW4gOiAn0JLQvtGB0YHRgtCw0L3QvtCy0LjRgtGMJ1xufTtcbiIsIkRHLkNvbnRyb2wuRnVsbHNjcmVlbi5EaWN0aW9uYXJ5Lml0ID0ge1xuICAgIHRpdGxlX21heCA6ICdFc3BhbmRpJyxcbiAgICB0aXRsZV9taW4gOiAnUmlwcmlzdGluYSdcbn07XG4iLCJERy5Db250cm9sLkZ1bGxzY3JlZW4uRGljdGlvbmFyeS5jcyA9IHtcbiAgICB0aXRsZV9tYXggOiAnUm96YmFsaXQnLFxuICAgIHRpdGxlX21pbiA6ICdPYm5vdml0J1xufTtcbiIsIkRHLkNvbnRyb2wuRnVsbHNjcmVlbi5EaWN0aW9uYXJ5LmVuID0ge1xuICAgIHRpdGxlX21heCA6ICdFeHBhbmQnLFxuICAgIHRpdGxlX21pbiA6ICdSZXN0b3JlJ1xufTtcbiIsIkRHLkNvbnRyb2wuRnVsbHNjcmVlbi5EaWN0aW9uYXJ5LmVzID0ge1xuICAgIHRpdGxlX21heCA6ICdNYXhpbWl6YXInLFxuICAgIHRpdGxlX21pbiA6ICdSZXN0YXVyYXInXG59O1xuIiwiREcuQ29udHJvbC5GdWxsc2NyZWVuLkRpY3Rpb25hcnkuYXIgPSB7XG4gICAgdGl0bGVfbWF4IDogJycsXG4gICAgdGl0bGVfbWluIDogJydcbn07XG4iLCJERy5NZXRhID0ge307XG5cbkRHLk1ldGEuTGF5ZXIgPSBERy5MYXllci5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICB0aWxlU2l6ZTogMjU2LFxuXG4gICAgICAgIG1pblpvb206IDAsXG4gICAgICAgIG1heFpvb206IDE5LFxuICAgICAgICB6b29tT2Zmc2V0OiAwLFxuICAgICAgICBldmVudEJ1YmJsaW5nOiAndHJhbnNwYXJlbnQnXG4gICAgICAgIC8vIG1heE5hdGl2ZVpvb206IDxOdW1iZXI+LFxuICAgICAgICAvLyBkZXRlY3RSZXRpbmE6IDxOdW1iZXI+LFxuICAgICAgICAvLyB6b29tUmV2ZXJzZTogPE51bWJlcj5cbiAgICAgICAgLy8gYXR0cmlidXRpb246IDxTdHJpbmc+LFxuICAgICAgICAvLyB6SW5kZXg6IDxOdW1iZXI+LFxuICAgICAgICAvLyBib3VuZHM6IDxMYXRMbmdCb3VuZHM+XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHNvdXJjZSwgb3B0aW9ucykgeyAvLyAoU3RyaW5nLCBPYmplY3QpXG4gICAgICAgIERHLlRpbGVMYXllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICBkZWxldGUgdGhpcy5fdXJsO1xuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlS2V5ID0gJyc7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlRGF0YSA9IFtdO1xuICAgICAgICB0aGlzLl9sYXN0RW50aXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnRzID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9vcmlnaW4gPSBERy5NZXRhLm9yaWdpbihzb3VyY2UsIHtcbiAgICAgICAgICAgIGRhdGFGaWx0ZXI6IHRoaXMub3B0aW9ucy5kYXRhRmlsdGVyXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRPcmlnaW46IGZ1bmN0aW9uKCkgeyAvLyAoKSAtPiBPYmplY3RcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbjtcbiAgICB9LFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB0aGlzLl9yZXNldFZpZXcoKTtcblxuICAgICAgICBtYXAubWV0YUxheWVycy5wdXNoKHRoaXMpO1xuXG4gICAgICAgIG1hcC5vbigncnVsZXJzdGFydCcsIHRoaXMuX2Rpc2FibGVEaXNwYXRjaE1vdXNlRXZlbnRzLCB0aGlzKTtcbiAgICAgICAgbWFwLm9uKCdydWxlcmVuZCcsIHRoaXMuX2VuYWJsZURpc3BhdGNoTW91c2VFdmVudHMsIHRoaXMpO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBpZiAoREcuQnJvd3Nlci50b3VjaEVuYWJsZWQgJiYgdGhpcy5vcHRpb25zLmlzUG9pKSB7XG4gICAgICAgICAgICBtYXAuZWFjaExheWVyKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyIGluc3RhbmNlb2YgTC5UaWxlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT24gZXZlcnkgdGlsZSB3aWxsIGJlIGxvYWQgbWV0YSB0aWxlLlxuICAgICAgICAgICAgICAgICAgICBsYXllci5vbigndGlsZWxvYWRzdGFydCcsIHNlbGYuX29uVGlsZUxvYWRTdGFydCwgc2VsZik7XG4gICAgICAgICAgICAgICAgICAgIC8vIExvYWQgbWV0YXRpbGVzIGZvciBhbHJlYWR5IGxvYWRlZCB0aWxlcy5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdGlsZSBpbiBsYXllci5fdGlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uVGlsZUxvYWRTdGFydCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRzOiBsYXllci5fdGlsZXNbdGlsZV0uY29vcmRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uUmVtb3ZlOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmIChERy5Ccm93c2VyLnRvdWNoRW5hYmxlZCAmJiB0aGlzLm9wdGlvbnMuaXNQb2kpIHtcbiAgICAgICAgICAgIG1hcC5lYWNoTGF5ZXIoZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLlRpbGVMYXllcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbiBldmVyeSB0aWxlIHdpbGwgYmUgbG9hZCBtZXRhIHRpbGUuXG4gICAgICAgICAgICAgICAgICAgIGxheWVyLm9mZigndGlsZWxvYWRzdGFydCcsIHNlbGYuX29uVGlsZUxvYWRTdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90aWxlWm9vbSA9IG51bGw7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gbWFwLm1ldGFMYXllcnMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgbWFwLm1ldGFMYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcC5vZmYoJ3J1bGVyc3RhcnQnLCB0aGlzLl9kaXNhYmxlRGlzcGF0Y2hNb3VzZUV2ZW50cywgdGhpcyk7XG4gICAgICAgIG1hcC5vZmYoJ3J1bGVyZW5kJywgdGhpcy5fZW5hYmxlRGlzcGF0Y2hNb3VzZUV2ZW50cywgdGhpcyk7XG4gICAgfSxcblxuICAgIGdldEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2aWV3cHJlcmVzZXQ6IHRoaXMuX2ludmFsaWRhdGVBbGwsXG4gICAgICAgICAgICB2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0VmlldyxcbiAgICAgICAgICAgIHpvb206IHRoaXMuX3Jlc2V0VmlldyxcbiAgICAgICAgICAgIG1vdmVlbmQ6IHRoaXMuX29uTW92ZUVuZFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBzZXRVcmw6IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50VGlsZUtleSA9ICcnO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGlsZURhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5fbGFzdEVudGl0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgICAgIHRoaXMuX29yaWdpbi5zZXRVUkwodXJsLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgZ2V0SG92ZXJlZE9iamVjdDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuICAgICAgICAgICAgbGF5ZXJQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGV2ZW50Lm9yaWdpbmFsRXZlbnQpLFxuICAgICAgICAgICAgdGlsZU9yaWdpblBvaW50ID0gdGhpcy5fbWFwLmdldFBpeGVsT3JpZ2luKCkuYWRkKGxheWVyUG9pbnQpLFxuICAgICAgICAgICAgdGlsZUNvb3JkID0gdGlsZU9yaWdpblBvaW50LnVuc2NhbGVCeSh0aWxlU2l6ZSkuZmxvb3IoKSxcbiAgICAgICAgICAgIG1vdXNlVGlsZU9mZnNldCA9IERHLnBvaW50KHRpbGVPcmlnaW5Qb2ludC54ICUgdGlsZVNpemUueCwgdGlsZU9yaWdpblBvaW50LnkgJSB0aWxlU2l6ZS55KSxcbiAgICAgICAgICAgIHRpbGVLZXksXG4gICAgICAgICAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmICh6b29tID4gKHRoaXMub3B0aW9ucy5tYXhab29tICsgdGhpcy5vcHRpb25zLnpvb21PZmZzZXQpIHx8XG4gICAgICAgICAgICB6b29tIDwgKHRoaXMub3B0aW9ucy5taW5ab29tIC0gdGhpcy5vcHRpb25zLnpvb21PZmZzZXQpIHx8XG4gICAgICAgICAgICAhdGhpcy5faXNWYWxpZFRpbGUodGlsZUNvb3JkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fd3JhcENvb3Jkcyh0aWxlQ29vcmQpO1xuXG4gICAgICAgIHRpbGVDb29yZC56ID0gdGhpcy5fZ2V0Wm9vbUZvclVybCgpO1xuICAgICAgICB0aWxlQ29vcmQua2V5ID0gdGlsZVNpemUueCArICd4JyArIHRpbGVTaXplLnk7XG4gICAgICAgIHRpbGVLZXkgPSB0aGlzLl9vcmlnaW4uZ2V0VGlsZUtleSh0aWxlQ29vcmQpO1xuXG4gICAgICAgIGlmICh0aWxlS2V5ID09PSB0aGlzLl9jdXJyZW50VGlsZUtleSkge1xuICAgICAgICAgICAgc2VsZi5fbGFzdEVudGl0eSA9IHNlbGYuX2dldEhvdmVyZWRPYmplY3QobW91c2VUaWxlT2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbi5nZXRUaWxlRGF0YSh0aWxlQ29vcmQsIGZ1bmN0aW9uKHRpbGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fY3VycmVudFRpbGVLZXkgPSB0aWxlS2V5O1xuICAgICAgICAgICAgICAgIHNlbGYuX2N1cnJlbnRUaWxlRGF0YSA9IHRpbGVEYXRhO1xuICAgICAgICAgICAgICAgIHNlbGYuX2xhc3RFbnRpdHkgPSBzZWxmLl9nZXRIb3ZlcmVkT2JqZWN0KG1vdXNlVGlsZU9mZnNldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9sYXN0RW50aXR5O1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlQWxsVGlsZXM6IERHLkdyaWRMYXllci5wcm90b3R5cGUuX3JlbW92ZUFsbFRpbGVzLFxuICAgIF9nZXRab29tRm9yVXJsOiBERy5UaWxlTGF5ZXIucHJvdG90eXBlLl9nZXRab29tRm9yVXJsLFxuICAgIGdldFRpbGVTaXplOiBERy5UaWxlTGF5ZXIucHJvdG90eXBlLmdldFRpbGVTaXplLFxuICAgIF9pc1ZhbGlkVGlsZTogREcuR3JpZExheWVyLnByb3RvdHlwZS5faXNWYWxpZFRpbGUsXG4gICAgX3dyYXBDb29yZHM6IERHLkdyaWRMYXllci5wcm90b3R5cGUuX3dyYXBDb29yZHMsXG4gICAgX3Jlc2V0VmlldzogREcuR3JpZExheWVyLnByb3RvdHlwZS5fcmVzZXRWaWV3LFxuICAgIF9yZXNldEdyaWQ6IERHLkdyaWRMYXllci5wcm90b3R5cGUuX3Jlc2V0R3JpZCxcbiAgICBfaW52YWxpZGF0ZUFsbDogREcuR3JpZExheWVyLnByb3RvdHlwZS5faW52YWxpZGF0ZUFsbCxcbiAgICBfcHhCb3VuZHNUb1RpbGVSYW5nZTogREcuR3JpZExheWVyLnByb3RvdHlwZS5fcHhCb3VuZHNUb1RpbGVSYW5nZSxcblxuICAgIC8vIEZpeCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9jb21wYXJlLzA3MjZmMTJiYmYzM2ZjYjE4ZmU4YmI1NDFkNWUzMjEyYmIxZjVhYjIuLi5jMjYzZjJkOGIxYmQ5NjJiNjA0NzQzNzZjYzQ4MTZhNjg4MDUyNTEzI2RpZmYtZjFlNmJlNjc1OTljNTk0NzMxZmZmNjE5MWM3MTA0MjBMNTc5XG4gICAgX29uTW92ZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuICAgICAgICB0aGlzLl9yZXNldFZpZXcoKTtcbiAgICB9LFxuXG4gICAgX29uVGlsZUxvYWRTdGFydDogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gICAgICAgIGUuY29vcmRzLmtleSA9IHRpbGVTaXplLnggKyAneCcgKyB0aWxlU2l6ZS55O1xuICAgICAgICB0aGlzLl9vcmlnaW4uZ2V0VGlsZURhdGEoZS5jb29yZHMpO1xuICAgIH0sXG5cbiAgICBfZW5hYmxlRGlzcGF0Y2hNb3VzZUV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudHMgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBfZGlzYWJsZURpc3BhdGNoTW91c2VFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgfSxcblxuICAgIG1hcEV2ZW50czoge1xuICAgICAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlTWV0YWxheWVyRXZlbnQoJ21vdXNlbW92ZScsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3VzZW92ZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlTWV0YWxheWVyRXZlbnQoJ21vdXNlb3ZlcicsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3VzZW91dDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVNZXRhbGF5ZXJFdmVudCgnbW91c2VvdXQnLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VGlsZUtleSA9ICcnO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsaWNrOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuICAgICAgICAgICAgICAgIGxheWVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChldmVudC5vcmlnaW5hbEV2ZW50KSxcbiAgICAgICAgICAgICAgICB0aWxlT3JpZ2luUG9pbnQgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxPcmlnaW4oKS5hZGQobGF5ZXJQb2ludCksXG4gICAgICAgICAgICAgICAgdGlsZUNvb3JkID0gdGlsZU9yaWdpblBvaW50LnVuc2NhbGVCeSh0aWxlU2l6ZSkuZmxvb3IoKSxcbiAgICAgICAgICAgICAgICBtb3VzZVRpbGVPZmZzZXQgPSBERy5wb2ludCh0aWxlT3JpZ2luUG9pbnQueCAlIHRpbGVTaXplLngsIHRpbGVPcmlnaW5Qb2ludC55ICUgdGlsZVNpemUueSksXG4gICAgICAgICAgICAgICAgdGlsZUtleSA9IHRoaXMuX29yaWdpbi5nZXRUaWxlS2V5KHRpbGVDb29yZCk7XG4gICAgICAgICAgICB0aWxlQ29vcmQueiA9IHRoaXMuX2dldFpvb21Gb3JVcmwoKTtcbiAgICAgICAgICAgIHRpbGVDb29yZC5rZXkgPSB0aWxlU2l6ZS54ICsgJ3gnICsgdGlsZVNpemUueTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbi5nZXRUaWxlRGF0YSh0aWxlQ29vcmQsIGZ1bmN0aW9uKHRpbGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fY3VycmVudFRpbGVEYXRhID0gdGlsZURhdGE7XG4gICAgICAgICAgICAgICAgc2VsZi5fY3VycmVudFRpbGVLZXkgPSB0aWxlS2V5O1xuICAgICAgICAgICAgICAgIHNlbGYuX2xhc3RFbnRpdHkgPSBzZWxmLl9nZXRIb3ZlcmVkT2JqZWN0KG1vdXNlVGlsZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgc2VsZi5fbW91c2VEb3duID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBldmVudC5lbnRpdHkgPSBzZWxmLl9sYXN0RW50aXR5O1xuICAgICAgICAgICAgICAgIHNlbGYuX2ZpcmVNZXRhbGF5ZXJFdmVudCgnY2xpY2snLCBldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBkYmxjbGljazogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVNZXRhbGF5ZXJFdmVudCgnZGJsY2xpY2snLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW91c2Vkb3duOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVNZXRhbGF5ZXJFdmVudCgnbW91c2Vkb3duJywgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRleHRtZW51OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fZmlyZU1ldGFsYXllckV2ZW50KCdjb250ZXh0bWVudScsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZmlyZU1ldGFsYXllckV2ZW50OiBmdW5jdGlvbih0eXBlLCBtb3VzZUV2ZW50KSB7XG4gICAgICAgIGlmICghbW91c2VFdmVudC5lbnRpdHkgfHwgIXRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpcmUodHlwZSwge1xuICAgICAgICAgICAgbWV0YTogbW91c2VFdmVudC5lbnRpdHksXG4gICAgICAgICAgICBsYXRsbmc6IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXRMbmcobW91c2VFdmVudC5vcmlnaW5hbEV2ZW50KVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlzRHJhZ2dpbmcgPSB0eXBlID09PSAnbW91c2Vkb3duJyB8fCAodGhpcy5fbW91c2VEb3duICYmIHR5cGUgPT09ICdtb3VzZW1vdmUnKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ldmVudEJ1YmJsaW5nID09PSAnbGF5ZXInICYmICFpc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICBERy5Eb21FdmVudC5zdG9wKG1vdXNlRXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9nZXRIb3ZlcmVkT2JqZWN0OiBmdW5jdGlvbihtb3VzZVRpbGVPZmZzZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jdXJyZW50VGlsZURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY3VycmVudFRpbGVEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoREcuUG9seVV0aWwuaW5zaWRlKG1vdXNlVGlsZU9mZnNldCwgdGhpcy5fY3VycmVudFRpbGVEYXRhW2ldLmdlb21ldHJ5LCB0aGlzLl9wb2ludFJlZHVjZUhlbHBlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFRpbGVEYXRhW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9wb2ludFJlZHVjZUhlbHBlcjogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIFtwb2ludC54LCBwb2ludC55XTtcbiAgICB9LFxuXG4gICAgX3NldFZpZXc6IGZ1bmN0aW9uKGNlbnRlciwgem9vbSwgbm9QcnVuZSwgbm9VcGRhdGUpIHtcbiAgICAgICAgdmFyIHRpbGVab29tID0gTWF0aC5yb3VuZCh6b29tKSxcbiAgICAgICAgICAgIHRpbGVab29tQ2hhbmdlZCA9IHRoaXMuX3RpbGVab29tICE9PSB0aWxlWm9vbTtcblxuICAgICAgICBpZiAoIW5vVXBkYXRlICYmIHRpbGVab29tQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5fdGlsZVpvb20gPSB0aWxlWm9vbTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0R3JpZCgpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkRHLk1ldGEubGF5ZXIgPSBmdW5jdGlvbihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERHLk1ldGEuTGF5ZXIoc291cmNlLCBvcHRpb25zKTtcbn07XG4iLCJERy5NZXRhLk9yaWdpbiA9IERHLkNsYXNzLmV4dGVuZCh7XG5cbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHN1YmRvbWFpbnM6ICcwMTIzJyxcbiAgICAgICAgZGF0YUZpbHRlcjogbnVsbFxuICAgIH0sXG5cbiAgICBfdXJsOiBmYWxzZSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHVybCwgb3B0aW9ucykgeyAvLyAoU3RyaW5nLCBPYmplY3QpXG4gICAgICAgIHRoaXMuX3VybCA9IHVybDtcbiAgICAgICAgdGhpcy5fcmVxdWVzdHMgPSB7fTtcblxuICAgICAgICB0aGlzLl90aWxlU3RvcmFnZSA9IHt9O1xuXG4gICAgICAgIG9wdGlvbnMgPSBERy5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zdWJkb21haW5zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3B0aW9ucy5zdWJkb21haW5zID0gb3B0aW9ucy5zdWJkb21haW5zLnNwbGl0KCcnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRUaWxlRGF0YTogZnVuY3Rpb24oY29vcmQsIGNsYikgeyAvLyAoT2JqZWN0KSAtPiBPYmplY3RcbiAgICAgICAgdmFyIHRpbGVLZXkgPSB0aGlzLmdldFRpbGVLZXkoY29vcmQpLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBjYWxsYmFjayA9IHR5cGVvZiBjbGIgPT09ICdmdW5jdGlvbicgPyBjbGIgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fdGlsZVN0b3JhZ2VbdGlsZUtleV0gPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0aGlzLl9yZXF1ZXN0c1t0aWxlS2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVTdG9yYWdlW3RpbGVLZXldID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY3VycmVudFJlcXVlc3QgPSB0aGlzLl9yZXF1ZXN0c1t0aWxlS2V5XSA9IHRoaXMuX3JlcXVlc3REYXRhKGNvb3JkKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcmVxdWVzdHNbdGlsZUtleV0gIT09IGN1cnJlbnRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnNldFRpbGVEYXRhKHRpbGVLZXksIHNlbGYub3B0aW9ucy5kYXRhRmlsdGVyID8gc2VsZi5vcHRpb25zLmRhdGFGaWx0ZXIoZGF0YSwgY29vcmQpIDogZGF0YSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYuX3JlcXVlc3RzW3RpbGVLZXldO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHNlbGYuX3RpbGVTdG9yYWdlW3RpbGVLZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5fdGlsZVN0b3JhZ2VbdGlsZUtleV0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldFRpbGVEYXRhOiBmdW5jdGlvbihrZXksIGRhdGEpIHsgLy8gKE9iamVjdC9TdHJpbmcsIE9iamVjdCkgLT4gT2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAga2V5ID0gdGhpcy5nZXRUaWxlS2V5KGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZW50aXR5KSB7XG4gICAgICAgICAgICBpZiAoZW50aXR5Lmdlb21ldHJ5LmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBlbnRpdHkuZ2VvbWV0cnkgPSBERy5Xa3QudG9HZW9KU09OKGVudGl0eS5nZW9tZXRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RpbGVTdG9yYWdlW2tleV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aWxlU3RvcmFnZVtrZXldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90aWxlU3RvcmFnZVtrZXldLnB1c2goZW50aXR5KTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZsdXNoOiBmdW5jdGlvbigpIHsgLy8gKCkgLT4gT2JqZWN0XG4gICAgICAgIHRoaXMuX3RpbGVTdG9yYWdlID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlcXVlc3RzKS5mb3JFYWNoKGZ1bmN0aW9uKHRpbGVLZXkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW3RpbGVLZXldLmFib3J0KSB7XG4gICAgICAgICAgICAgICAgdGhpc1t0aWxlS2V5XS5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLl9yZXF1ZXN0cyk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RzID0ge307XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFVSTDogZnVuY3Rpb24odXJsLCBmbHVzaCkgeyAvLyAoU3RyaW5nLCBCb29sZWFuKSAtPiBPYmplY3RcbiAgICAgICAgdGhpcy5fdXJsID0gdXJsO1xuICAgICAgICBpZiAoZmx1c2gpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRUaWxlS2V5OiBmdW5jdGlvbihjb29yZCkgeyAvLyAoT2JqZWN0KS0+IFN0cmluZ1xuICAgICAgICByZXR1cm4gW2Nvb3JkLngsIGNvb3JkLnksIGNvb3JkLnosIGNvb3JkLmtleV0uam9pbignOicpO1xuICAgIH0sXG5cbiAgICBfcmVxdWVzdERhdGE6IGZ1bmN0aW9uKGtleSkgeyAvLyAoU3RyaW5nKVxuICAgICAgICBpZiAodGhpcy5fdXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVyZm9ybVJlcXVlc3Qoa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9wZXJmb3JtUmVxdWVzdDogZnVuY3Rpb24oY29vcmRzKSB7IC8vIChPYmplY3QpIC0+IFByb21pc2VcbiAgICAgICAgcmV0dXJuIERHLmFqYXgodGhpcy5fcHJlcGFyZVVSTChjb29yZHMpLCB7XG4gICAgICAgICAgICB0eXBlOiAnZ2V0JyxcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbidcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9wcmVwYXJlVVJMOiBmdW5jdGlvbihjb29yZHMpIHsgLy8gKE9iamVjdCkgLT4gU3RyaW5nXG4gICAgICAgIHJldHVybiBERy5VdGlsLnRlbXBsYXRlKHRoaXMuX3VybCwge1xuICAgICAgICAgICAgeDogY29vcmRzLngsXG4gICAgICAgICAgICB5OiBjb29yZHMueSxcbiAgICAgICAgICAgIHo6IGNvb3Jkcy56LFxuICAgICAgICAgICAgczogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3JkcylcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9nZXRTdWJkb21haW46IERHLlRpbGVMYXllci5wcm90b3R5cGUuX2dldFN1YmRvbWFpblxuXG59KTtcblxuREcuTWV0YS5vcmlnaW4gPSBmdW5jdGlvbihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERHLk1ldGEuT3JpZ2luKHNvdXJjZSwgb3B0aW9ucyk7XG59O1xuIiwiREcuTWFwLm1lcmdlT3B0aW9ucyh7XG4gICAgcG9pOiB0cnVlXG59KTtcblxuREcuUG9pID0gREcuSGFuZGxlci5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBkaXNhYmxlTGFiZWw6IGZhbHNlXG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG1hcCwgb3B0aW9ucykgeyAvLyAoT2JqZWN0KVxuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgICAgIERHLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICB2YXIgdXJsID0gREcuY29uZmlnLnByb3RvY29sICsgKERHLkJyb3dzZXIucmV0aW5hID8gREcuY29uZmlnLnJldGluYVBvaU1ldGFTZXJ2ZXIgOiBERy5jb25maWcucG9pTWV0YVNlcnZlcik7XG5cbiAgICAgICAgdGhpcy5fbWV0YUxheWVyID0gREcuTWV0YS5sYXllcih1cmwsIHtcbiAgICAgICAgICAgIG1pblpvb206IERHLmNvbmZpZy5wb2lMYXllck1pblpvb20sXG4gICAgICAgICAgICBtYXhOYXRpdmVab29tOiAxOSxcbiAgICAgICAgICAgIGRldGVjdFJldGluYTogREcuY29uZmlnLmRldGVjdFJldGluYSxcbiAgICAgICAgICAgIGV2ZW50QnViYmxpbmc6ICdsYXllcicsXG4gICAgICAgICAgICBkYXRhRmlsdGVyOiBERy5iaW5kKHRoaXMuX3Byb2Nlc3NEYXRhLCB0aGlzKSxcbiAgICAgICAgICAgIGlzUG9pOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlc0xhbmcgPSAnJzsgLy8gJ2FyJyB8ICcnXG4gICAgfSxcblxuICAgIGFkZEhvb2tzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbWFwLmFkZExheWVyKHRoaXMuX21ldGFMYXllcik7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWxIZWxwZXIgPSBERy5sYWJlbCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21ldGFMYXllci5vbih0aGlzLl9sYXllckV2ZW50c0xpc3RlbmVycywgdGhpcyk7XG4gICAgICAgIHRoaXMuX21hcC5vbignbGFuZ2NoYW5nZScsIHRoaXMuX3VwZGF0ZVVybCwgdGhpcyk7XG4gICAgICAgIHRoaXMuX21hcC5vbigncHJvamVjdGNoYW5nZScsIHRoaXMuX3VwZGF0ZVVybCwgdGhpcyk7XG4gICAgICAgIHRoaXMuX21hcC5vbigncHJvamVjdGxlYXZlJywgdGhpcy5fdXBkYXRlVXJsLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlSG9va3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbWV0YUxheWVyKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZUxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGFiZWxIZWxwZXIpO1xuICAgICAgICAgICAgdGhpcy5fbGFiZWxIZWxwZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21ldGFMYXllci5vZmYodGhpcy5fbGF5ZXJFdmVudHNMaXN0ZW5lcnMsIHRoaXMpO1xuICAgICAgICB0aGlzLl9tYXAub2ZmKCdsYW5nY2hhbmdlJywgdGhpcy5fdXBkYXRlVXJsLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fbWFwLm9mZigncHJvamVjdGNoYW5nZScsIHRoaXMuX3VwZGF0ZVVybCwgdGhpcyk7XG4gICAgICAgIHRoaXMuX21hcC5vZmYoJ3Byb2plY3RsZWF2ZScsIHRoaXMuX3VwZGF0ZVVybCwgdGhpcyk7XG4gICAgfSxcblxuICAgIGdldE1ldGFMYXllcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRhTGF5ZXI7XG4gICAgfSxcblxuICAgIF91cGRhdGVVcmw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdXJsID0gREcuY29uZmlnLnByb3RvY29sICsgKERHLkJyb3dzZXIucmV0aW5hID8gREcuY29uZmlnLnJldGluYVBvaU1ldGFTZXJ2ZXIgOiBERy5jb25maWcucG9pTWV0YVNlcnZlcik7XG4gICAgICAgIHZhciBhcmFiaWNVcmwgPSBERy5jb25maWcucHJvdG9jb2wgK1xuICAgICAgICAgICAgKERHLkJyb3dzZXIucmV0aW5hID8gREcuY29uZmlnLmFyYWJpY1JldGluYVBvaU1ldGFTZXJ2ZXIgOiBERy5jb25maWcuYXJhYmljUG9pTWV0YVNlcnZlcik7XG4gICAgICAgIHZhciBsYW5nID0gdGhpcy5fbWFwLmdldExhbmcoKTtcbiAgICAgICAgdmFyIHByb2plY3QgPSB0aGlzLl9tYXAucHJvamVjdERldGVjdG9yICYmIHRoaXMuX21hcC5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpO1xuXG4gICAgICAgIC8vIENoYW5nZSBQT0kgZm9yIEFyYWJpYyBsYW5ndWFnZSBpbiBEdWJhaSBwcm9qZWN0XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50VGlsZXNMYW5nID09PSAnJyAmJiBsYW5nID09PSAnYXInICYmIHByb2plY3QgJiYgcHJvamVjdC5jb3VudHJ5X2NvZGUgPT09ICdhZScpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlc0xhbmcgPSAnYXInO1xuICAgICAgICAgICAgdGhpcy5fbWV0YUxheWVyLnNldFVybChhcmFiaWNVcmwpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY3VycmVudFRpbGVzTGFuZyA9PT0gJ2FyJyAmJiAobGFuZyAhPT0gJ2FyJyB8fCAoIXByb2plY3QgfHwgcHJvamVjdC5jb3VudHJ5X2NvZGUgIT09ICdhZScpKSkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbGVzTGFuZyA9ICcnO1xuICAgICAgICAgICAgdGhpcy5fbWV0YUxheWVyLnNldFVybCh1cmwpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9wcm9jZXNzRGF0YTogZnVuY3Rpb24oZGF0YSwgY29vcmQpIHtcbiAgICAgICAgdmFyIHRpbGVPcmlnaW5Qb2ludCA9IGNvb3JkLnNjYWxlQnkodGhpcy5fbWV0YUxheWVyLmdldFRpbGVTaXplKCkpO1xuICAgICAgICB2YXIgcG9seWdvbkxuZ0xhdFRvUG9pbnRzID0gREcuYmluZCh0aGlzLl9wb2x5Z29uTG5nTGF0VG9Qb2ludHMsIHRoaXMsIHRpbGVPcmlnaW5Qb2ludCwgY29vcmQueik7XG5cbiAgICAgICAgaWYgKGRhdGEucmVzcG9uc2VUZXh0ID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGEucmVzdWx0LnBvaVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhvdmVycyA9IGl0ZW0uaG92ZXJzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBpdGVtLmhvdmVyc1xuICAgICAgICAgICAgICAgICAgICA6IFtpdGVtLmhvdmVyXTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICBoaW50OiBpdGVtLmxpbmtzWzBdLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGxpbmtlZDogaXRlbS5saW5rc1swXSxcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGhvdmVycy5tYXAoREcuV2t0LnRvR2VvSlNPTiksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBpdGVtLmdlb21ldHJ5LnJlZHVjZShmdW5jdGlvbihyZXN1bHQsIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwb2x5Z29uTG5nTGF0VG9Qb2ludHMoaXRlbS5jb29yZGluYXRlcykpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoaXRlbS5jb29yZGluYXRlcy5tYXAocG9seWdvbkxuZ0xhdFRvUG9pbnRzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0sIFtdKTtcblxuICAgICAgICAgICAgICAgIGl0ZW0uZ2VvbWV0cnkgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNdWx0aVBvbHlnb24nLFxuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9wb2x5Z29uTG5nTGF0VG9Qb2ludHM6IGZ1bmN0aW9uKG9yaWdpblBvaW50LCB6b29tLCBwb2x5Z29uKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgcmV0dXJuIHBvbHlnb24ubWFwKGZ1bmN0aW9uKGNvbnRvdXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250b3VyLm1hcChmdW5jdGlvbihsbmdMYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwXG4gICAgICAgICAgICAgICAgICAgIC5wcm9qZWN0KFtsbmdMYXRbMV0sIGxuZ0xhdFswXV0sIHpvb20pLnJvdW5kKClcbiAgICAgICAgICAgICAgICAgICAgLnN1YnRyYWN0KG9yaWdpblBvaW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2xheWVyRXZlbnRzTGlzdGVuZXJzIDoge1xuICAgICAgICBtb3VzZW92ZXI6IGZ1bmN0aW9uKGUpIHsgLy8gKE9iamVjdClcbiAgICAgICAgICAgIHRoaXMuX3NldEN1cnNvcigncG9pbnRlcicpO1xuICAgICAgICAgICAgaWYgKGUubWV0YS5oaW50ICYmIGUubWV0YS5oaW50Lmxlbmd0aCAmJiAhdGhpcy5vcHRpb25zLmRpc2FibGVMYWJlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsSGVscGVyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRQb3NpdGlvbihlLmxhdGxuZylcbiAgICAgICAgICAgICAgICAgICAgLnNldENvbnRlbnQoZS5tZXRhLmhpbnQpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRaSW5kZXhPZmZzZXQoMzAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAuYWRkTGF5ZXIodGhpcy5fbGFiZWxIZWxwZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFwLmZpcmUoJ3BvaWhvdmVyJywge1xuICAgICAgICAgICAgICAgIGxhdGxuZzogZS5sYXRsbmcsXG4gICAgICAgICAgICAgICAgbWV0YTogZS5tZXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3VzZW91dDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0Q3Vyc29yKCcnKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVMYWJlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYWJlbEhlbHBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYXAuZmlyZSgncG9pbGVhdmUnLCB7XG4gICAgICAgICAgICAgICAgbGF0bG5nOiBlLmxhdGxuZyxcbiAgICAgICAgICAgICAgICBtZXRhOiBlLm1ldGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24oZSkgeyAvLyAoT2JqZWN0KVxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZUxhYmVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWxIZWxwZXIuc2V0UG9zaXRpb24oZS5sYXRsbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRDdXJzb3I6IGZ1bmN0aW9uKGN1cnNvcikgeyAvLyAoU3RyaW5nKVxuICAgICAgICB0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICAgIH1cblxufSk7XG5cbkRHLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdwb2knLCBERy5Qb2kpO1xuIiwiREcuTWFwLm1lcmdlT3B0aW9ucyh7XG4gICAgZ2VvY2xpY2tlcjogZmFsc2Vcbn0pO1xuXG5ERy5HZW9jbGlja2VyID0gREcuSGFuZGxlci5leHRlbmQoe1xuICAgIGNsaWNrQ291bnQ6IDAsXG4gICAgcGVuZGluZ0NsaWNrOiAwLFxuICAgIHRpbWVvdXQ6IDI1MCwgLy8gc2hvdWxkIGJlIGVxdWFsIHRvICdkZWxheScgdmFsdWUgaW4gRG91YmxlVGFwIGV2ZW50XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihtYXAsIG9wdGlvbnMpIHsgLy8gKE9iamVjdClcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl9jb250cm9sbGVyID0gbmV3IERHLkdlb2NsaWNrZXIuQ29udHJvbGxlcihtYXAsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBhZGRIb29rczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZUV2ZW50cyh0cnVlKTtcblxuICAgICAgICB0aGlzLl9tYXBcbiAgICAgICAgICAgIC5vbigncnVsZXJzdGFydCcsIHRoaXMuX3BhdXNlLCB0aGlzKVxuICAgICAgICAgICAgLm9uKCdydWxlcmVuZCcsIHRoaXMuX3VucGF1c2UsIHRoaXMpO1xuICAgIH0sXG5cbiAgICByZW1vdmVIb29rczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZUV2ZW50cygpO1xuXG4gICAgICAgIHRoaXMuX21hcFxuICAgICAgICAgICAgLm9mZigncnVsZXJzdGFydCcsIHRoaXMuX3BhdXNlLCB0aGlzKVxuICAgICAgICAgICAgLm9mZigncnVsZXJlbmQnLCB0aGlzLl91bnBhdXNlLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX2NoZWNrT3BlblBvcHVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKERHLkJyb3dzZXIubW9iaWxlICYmIHRoaXMuX21hcC5fcG9wdXAgJiZcbiAgICAgICAgICAgICh0aGlzLl9tYXAuX3BvcHVwLm9wdGlvbnMuY2xvc2VPbkNsaWNrIHx8XG4gICAgICAgICAgICB0aGlzLl9tYXAub3B0aW9ucy5jbG9zZVBvcHVwT25DbGljaykpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBXYXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl90b2dnbGVFdmVudHMoKTtcbiAgICB9LFxuXG4gICAgX3VucGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBSZWVuYWJsZSBldmVudCBoYW5kbGluZyBvbmx5IGluIGNhc2UgZ2VvY2xpY2tlciBpcyBlbmFibGVkXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRXZlbnRzKHRydWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF90b2dnbGVFdmVudHM6IGZ1bmN0aW9uKGZsYWcpIHtcbiAgICAgICAgdGhpcy5fbWFwW2ZsYWcgPyAnb24nIDogJ29mZiddKHRoaXMuX21hcEV2ZW50c0xpc3RlbmVycywgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9tYXAucG9pKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAucG9pLmdldE1ldGFMYXllcigpW2ZsYWcgPyAnb24nIDogJ29mZiddKCdjbGljaycsIHRoaXMuX29uTWV0YUNsaWNrLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRDb250cm9sbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xsZXI7XG4gICAgfSxcblxuICAgIF9vbk1ldGFDbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmNsaWNrQ291bnQgPSAwO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wZW5kaW5nQ2xpY2spO1xuICAgICAgICB0aGlzLnBvcHVwV2FzT3BlbiA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX21hcEV2ZW50c0xpc3RlbmVycy5jbGljay5jYWxsKHRoaXMsIGUpO1xuICAgIH0sXG5cbiAgICBfbWFwRXZlbnRzTGlzdGVuZXJzOiB7XG4gICAgICAgIGxhbmdjaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbGxlci5yZWludm9rZUhhbmRsZXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb3B1cGNsb3NlOiBmdW5jdGlvbihlKSB7IC8vIChPYmplY3QpXG4gICAgICAgICAgICB0aGlzLl9jb250cm9sbGVyLmhhbmRsZVBvcHVwQ2xvc2UoZS5wb3B1cCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKGUpIHsgLy8gKE9iamVjdClcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaWNrQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWNrQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NpbmdsZUNsaWNrKGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWNrQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBlbmRpbmdDbGljayk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cFdhc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkYmxjbGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoREcuQnJvd3Nlci5pZWx0OSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpY2tDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cFdhc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wZW5kaW5nQ2xpY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zaW5nbGVDbGljazogZnVuY3Rpb24oZSkgeyAvLyAoT2JqZWN0KVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGVuZGluZ0NsaWNrKTtcblxuICAgICAgICB0aGlzLnBlbmRpbmdDbGljayA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZS5tZXRhKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fY2hlY2tPcGVuUG9wdXAoKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9tYXAuY2xvc2VQb3B1cCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAgREdQb3B1cCdzICdfY2xvc2UnIG1ldGhvZCBpcyB0aGUgb25seSBwbGFjZSB3aGVyZSAucG9wdXBXYXNPcGVuIGlzIG1vZGlmaWVkXG4gICAgICAgICAgICAvLyAgSXQgc2lnbmFscyBnZW9jbGlja2VyIHRoYXQgcG9wdXAgd2FzIG9wZW4gYmVmb3JlIHVzZXIgZG8gYSAnY2xpY2snIG9uIG1hcFxuICAgICAgICAgICAgLy8gIE11bHRpc3RhZ2UgYmVoYXZpb3IgaXMgbmVlZGVkIGFzIHRoaXMgcHJvY2Vzc2luZyBvY2N1cnMgYWZ0ZXIgcG9wdXAgd2FzIGFscmVhZHkgY2xvc2VkXG4gICAgICAgICAgICBpZiAoIXNlbGYucG9wdXBXYXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHpvb20gPSBzZWxmLl9tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2NvbnRyb2xsZXIuaGFuZGxlQ2xpY2soZS5sYXRsbmcsIHpvb20sIGUubWV0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY2xpY2tDb3VudCA9IDA7XG4gICAgICAgICAgICBzZWxmLnBvcHVwV2FzT3BlbiA9IGZhbHNlO1xuICAgICAgICB9LCB0aGlzLnRpbWVvdXQpO1xuICAgIH1cbn0pO1xuXG5ERy5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZ2VvY2xpY2tlcicsIERHLkdlb2NsaWNrZXIpO1xuIiwiREcuR2VvY2xpY2tlci5jbGFtcEhlbHBlciA9IGZ1bmN0aW9uKGVsLCBsaW5lQ2xhbXApIHtcbiAgICB2YXIgbWVhc3VyZSwgdGV4dCwgbGluZVdpZHRoLFxuICAgICAgICBsaW5lU3RhcnQsIGxpbmVDb3VudCwgd29yZFN0YXJ0LFxuICAgICAgICBsaW5lLCBsaW5lVGV4dCwgd2FzTmV3TGluZSxcbiAgICAgICAgY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50LmJpbmQoZG9jdW1lbnQpLFxuICAgICAgICBjdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZS5iaW5kKGRvY3VtZW50KTtcblxuICAgIC8vIG1lYXN1cmVtZW50IGVsZW1lbnQgaXMgbWFkZSBhIGNoaWxkIG9mIHRoZSBjbGFtcGVkIGVsZW1lbnQgdG8gZ2V0IGl0J3Mgc3R5bGVcbiAgICBtZWFzdXJlID0gY2UoJ3NwYW4nKTtcblxuICAgIChmdW5jdGlvbihzKSB7XG4gICAgICAgIHMucG9zaXRpb24gPSAnYWJzb2x1dGUnOyAvLyBwcmV2ZW50IHBhZ2UgcmVmbG93XG4gICAgICAgIHMud2hpdGVTcGFjZSA9ICdwcmUnOyAvLyBjcm9zcy1icm93c2VyIHdpZHRoIHJlc3VsdHNcbiAgICAgICAgcy52aXNpYmlsaXR5ID0gJ2hpZGRlbic7IC8vIHByZXZlbnQgZHJhd2luZ1xuICAgICAgICBzLm1hcmdpbiA9ICcwIDE4cHggOHB4IDAnO1xuICAgIH0pKG1lYXN1cmUuc3R5bGUpO1xuXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBlbGVtZW50IGJlbG9uZ3MgdG8gdGhlIGRvY3VtZW50XG4gICAgaWYgKCFlbC5vd25lckRvY3VtZW50IHx8IGVsLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gcmVzZXQgdG8gc2FmZSBzdGFydGluZyB2YWx1ZXNcbiAgICBsaW5lU3RhcnQgPSB3b3JkU3RhcnQgPSAwO1xuICAgIGxpbmVDb3VudCA9IDE7XG4gICAgd2FzTmV3TGluZSA9IGZhbHNlO1xuICAgIGxpbmVXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgIC8vIGdldCBhbGwgdGhlIHRleHQsIHJlbW92ZSBhbnkgbGluZSBjaGFuZ2VzXG4gICAgdGV4dCA9IChlbC50ZXh0Q29udGVudCB8fCBlbC5pbm5lclRleHQpLnJlcGxhY2UoL1xcbi9nLCAnICcpO1xuICAgIC8vIHJlbW92ZSBhbGwgY29udGVudFxuICAgIHdoaWxlIChlbC5maXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICAvLyBhZGQgbWVhc3VyZW1lbnQgZWxlbWVudCB3aXRoaW4gc28gaXQgaW5oZXJpdHMgc3R5bGVzXG4gICAgZWwuYXBwZW5kQ2hpbGQobWVhc3VyZSk7XG4gICAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL3NlYXJjaC1hbmQtZG9udC1yZXBsYWNlL1xuICAgIHRleHQucmVwbGFjZSgvIHwtL2csIGZ1bmN0aW9uKG0sIHBvcykge1xuICAgICAgICAvLyBpZ25vcmUgYW55IGZ1cnRoZXIgcHJvY2Vzc2luZyBpZiB3ZSBoYXZlIHRvdGFsIGxpbmVzXG4gICAgICAgIGlmIChsaW5lQ291bnQgPT09IGxpbmVDbGFtcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBhIHRleHQgbm9kZSBhbmQgcGxhY2UgaXQgaW4gdGhlIG1lYXN1cmVtZW50IGVsZW1lbnRcbiAgICAgICAgbWVhc3VyZS5hcHBlbmRDaGlsZChjdG4odGV4dC5zdWJzdHIobGluZVN0YXJ0LCBwb3MgLSBsaW5lU3RhcnQpKSk7XG4gICAgICAgIC8vIGhhdmUgd2UgZXhjZWVkZWQgYWxsb3dlZCBsaW5lIHdpZHRoP1xuICAgICAgICBpZiAobGluZVdpZHRoIDwgbWVhc3VyZS5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgaWYgKHdhc05ld0xpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGEgbG9uZyB3b3JkIHNvIGl0IGdldHMgYSBsaW5lIG9mIGl0J3Mgb3duXG4gICAgICAgICAgICAgICAgbGluZVRleHQgPSB0ZXh0LnN1YnN0cihsaW5lU3RhcnQsIHBvcyArIDEgLSBsaW5lU3RhcnQpO1xuICAgICAgICAgICAgICAgIC8vIG5leHQgbGluZSBzdGFydCBwb3NpdGlvblxuICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IHBvcyArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdyYWIgdGhlIHRleHQgdW50aWwgdGhpcyB3b3JkXG4gICAgICAgICAgICAgICAgbGluZVRleHQgPSB0ZXh0LnN1YnN0cihsaW5lU3RhcnQsIHdvcmRTdGFydCAtIGxpbmVTdGFydCk7XG4gICAgICAgICAgICAgICAgLy8gbmV4dCBsaW5lIHN0YXJ0IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gd29yZFN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgbGluZSBlbGVtZW50XG4gICAgICAgICAgICBsaW5lID0gY2UoJ3NwYW4nKTtcbiAgICAgICAgICAgIC8vIGFkZCB0ZXh0IHRvIHRoZSBsaW5lIGVsZW1lbnRcbiAgICAgICAgICAgIGxpbmUuYXBwZW5kQ2hpbGQoY3RuKGxpbmVUZXh0KSk7XG4gICAgICAgICAgICAvLyBhZGQgdGhlIGxpbmUgZWxlbWVudCB0byB0aGUgY29udGFpbmVyXG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChsaW5lKTtcbiAgICAgICAgICAgIGxpbmUuY2xhc3NOYW1lID0gJ2RnLW1hcC1nZW9jbGlja2VyX19jbGFtcGVkLWxpbmUnO1xuICAgICAgICAgICAgLy8geWVzLCB3ZSBjcmVhdGVkIGEgbmV3IGxpbmVcbiAgICAgICAgICAgIHdhc05ld0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgbGluZUNvdW50Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkaWQgbm90IGNyZWF0ZSBhIG5ldyBsaW5lXG4gICAgICAgICAgICB3YXNOZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtZW1iZXIgbGFzdCB3b3JkIHN0YXJ0IHBvc2l0aW9uXG4gICAgICAgIHdvcmRTdGFydCA9IHBvcyArIDE7XG4gICAgICAgIC8vIGNsZWFyIG1lYXN1cmVtZW50IGVsZW1lbnRcbiAgICAgICAgbWVhc3VyZS5yZW1vdmVDaGlsZChtZWFzdXJlLmZpcnN0Q2hpbGQpO1xuICAgIH0pO1xuICAgIC8vIHJlbW92ZSB0aGUgbWVhc3VyZW1lbnQgZWxlbWVudCBmcm9tIHRoZSBjb250YWluZXJcbiAgICBlbC5yZW1vdmVDaGlsZChtZWFzdXJlKTtcbiAgICAvLyBjcmVhdGUgdGhlIGxhc3QgbGluZSBlbGVtZW50XG4gICAgbGluZSA9IGNlKCdzcGFuJyk7XG4gICAgLy8gZ2l2ZSBzdHlsZXMgcmVxdWlyZWQgZm9yIHRleHQtb3ZlcmZsb3cgdG8ga2ljayBpblxuICAgIGxpbmUuY2xhc3NOYW1lID0gJ2RnLW1hcC1nZW9jbGlja2VyX19jbGFtcGVkLWxpbmUgZGctbWFwLWdlb2NsaWNrZXJfX2NsYW1wZWQtbGluZV9sYXN0JztcbiAgICAvLyBhZGQgYWxsIHJlbWFpbmluZyB0ZXh0IHRvIHRoZSBsaW5lIGVsZW1lbnRcbiAgICBsaW5lLmFwcGVuZENoaWxkKGN0bih0ZXh0LnN1YnN0cihsaW5lU3RhcnQpKSk7XG4gICAgLy8gYWRkIHRoZSBsaW5lIGVsZW1lbnQgdG8gdGhlIGNvbnRhaW5lclxuICAgIGVsLmFwcGVuZENoaWxkKGxpbmUpO1xufTtcbiIsIkRHLkdlb2NsaWNrZXIuUHJvdmlkZXIgPSB7fTtcbiIsIkRHLkdlb2NsaWNrZXIuUHJvdmlkZXIuQ2F0YWxvZ0FwaSA9IERHLkNsYXNzLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obWFwKSB7IC8vIChPYmplY3QpXG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcblxuICAgICAgICB2YXIgYXBpVXJsID0gREcuY29uZmlnLnByb3RvY29sICtcbiAgICAgICAgICAgIERHLmNvbmZpZy53ZWJBcGlTZXJ2ZXIgKyAnLycgK1xuICAgICAgICAgICAgREcuY29uZmlnLndlYkFwaVZlcnNpb24gKyAnLyc7XG5cbiAgICAgICAgdGhpcy5fdXJsR2VvU2VhcmNoID0gYXBpVXJsICsgJ2dlby9zZWFyY2gnO1xuICAgICAgICB0aGlzLl91cmxHZW9HZXQgPSBhcGlVcmwgKyAnZ2VvL2dldCc7XG4gICAgICAgIHRoaXMuX3VybERldGFpbHMgPSBhcGlVcmwgKyAnY2F0YWxvZy9icmFuY2gvZ2V0JztcbiAgICAgICAgdGhpcy5fdXJsRmlybXNJbkhvdXNlID0gYXBpVXJsICsgJ2NhdGFsb2cvYnJhbmNoL2xpc3QnO1xuXG4gICAgICAgIHRoaXMuX2tleSA9IERHLmNvbmZpZy5nZW9jbGlja2VyQ2F0YWxvZ0FwaUtleTtcbiAgICAgICAgdGhpcy5fZ2VvRmllbGRzID0gREcuY29uZmlnLmdlb0FkZGl0aW9uYWxGaWVsZHM7XG4gICAgICAgIHRoaXMuX2Zpcm1JbmZvRmllbGRzID0gREcuY29uZmlnLmZpcm1JbmZvRmllbGRzO1xuICAgIH0sXG5cbiAgICBnZXRMb2NhdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHsgLy8gKE9iamVjdClcbiAgICAgICAgLy8gQ2FsbGJhY2sgd2lsbCByZWNlaXZlIGFycmF5IG9mIGZvdW5kIHJlc3VsdHMgb3Igdm9pZCBpZiBlcnJvcnMgb2NjdXJyZWQgb3Igbm90aGluZyB3YXMgZm91bmQuXG4gICAgICAgIHZhciB6b29tID0gb3B0aW9ucy56b29tLFxuICAgICAgICAgICAgbGF0bG5nID0gb3B0aW9ucy5sYXRsbmcsXG4gICAgICAgICAgICBiZWZvcmVSZXF1ZXN0ID0gb3B0aW9ucy5iZWZvcmVSZXF1ZXN0IHx8IGZ1bmN0aW9uKCkge30sXG4gICAgICAgICAgICB0eXBlcyA9IHRoaXMuZ2V0VHlwZXNCeVpvb20oem9vbSksXG4gICAgICAgICAgICBxID0gbGF0bG5nLmxuZyArICcsJyArIGxhdGxuZy5sYXQ7XG5cbiAgICAgICAgaWYgKCF0eXBlcykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdubyB0eXBlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBiZWZvcmVSZXF1ZXN0KCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvU2VhcmNoKHEsIHR5cGVzLCB6b29tKS50aGVuKERHLmJpbmQoZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyUmVzcG9uc2UocmVzdWx0LCB0eXBlcyk7XG4gICAgICAgIH0sIHRoaXMpKTtcbiAgICB9LFxuXG4gICAgZmlybXNJbkhvdXNlOiBmdW5jdGlvbihob3VzZUlkLCBwYXJhbWV0ZXJzKSB7IC8vIChTdHJpbmcsIEZ1bmN0aW9uLCBOdW1iZXIpXG4gICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgYnVpbGRpbmdfaWQ6IGhvdXNlSWQsXG4gICAgICAgICAgICBwYWdlOiBwYXJhbWV0ZXJzLnBhZ2UgfHwgMVxuICAgICAgICB9O1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9wZXJmb3JtUmVxdWVzdChwYXJhbXMsIHRoaXMuX3VybEZpcm1zSW5Ib3VzZSk7XG4gICAgfSxcblxuICAgIGdldEZpcm1JbmZvOiBmdW5jdGlvbihmaXJtSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BlcmZvcm1SZXF1ZXN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdmaWxpYWwnLFxuICAgICAgICAgICAgaWQ6IGZpcm1JZCxcbiAgICAgICAgICAgIGZpZWxkczogdGhpcy5fZmlybUluZm9GaWVsZHNcbiAgICAgICAgfSwgdGhpcy5fdXJsRGV0YWlscyk7XG4gICAgfSxcblxuICAgIGdlb1NlYXJjaDogZnVuY3Rpb24ocSwgdHlwZXMsIHpvb21sZXZlbCkgeyAvLyAoU3RyaW5nLCBTdHJpbmcsIE51bWJlcilcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBwb2ludDogcSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGVzLFxuICAgICAgICAgICAgem9vbV9sZXZlbDogem9vbWxldmVsLFxuICAgICAgICAgICAgZmllbGRzOiB0aGlzLl9nZW9GaWVsZHNcbiAgICAgICAgfTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cblxuICAgICAgICByZXR1cm4gdGhpcy5fcGVyZm9ybVJlcXVlc3QocGFyYW1zLCB0aGlzLl91cmxHZW9TZWFyY2gpO1xuICAgIH0sXG5cbiAgICBnZW9HZXQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBmaWVsZHM6IHRoaXMuX2dlb0ZpZWxkc1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9wZXJmb3JtUmVxdWVzdChwYXJhbXMsIHRoaXMuX3VybEdlb0dldCk7XG4gICAgfSxcblxuICAgIGNhbmNlbExhc3RSZXF1ZXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RSZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0UmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFR5cGVzQnlab29tOiBmdW5jdGlvbih6b29tKSB7IC8vIChOdW1iZXIpIC0+IFN0cmluZ3xOdWxsXG4gICAgICAgIHZhciB0eXBlcyA9IHtcbiAgICAgICAgICAgICAgICAnYWRtX2Rpdi5zZXR0bGVtZW50JzogICA4LFxuICAgICAgICAgICAgICAgICdhZG1fZGl2LmNpdHknOiAgICAgICAgIDgsXG4gICAgICAgICAgICAgICAgJ2FkbV9kaXYuZGl2aXNpb24nOiAgICAgMTEsXG4gICAgICAgICAgICAgICAgJ2FkbV9kaXYuZGlzdHJpY3QnOiAgICAgMTIsXG4gICAgICAgICAgICAgICAgJ3N0cmVldCc6ICAgICAgICAgICAgICAgMTQsXG4gICAgICAgICAgICAgICAgJ2J1aWxkaW5nJzogICAgICAgICAgICAgMTQsXG4gICAgICAgICAgICAgICAgJ2FkbV9kaXYucGxhY2UnOiAgICAgICAgMTUsXG4gICAgICAgICAgICAgICAgJ3BvaSc6ICAgICAgICAgICAgICAgICAgMTUsXG4gICAgICAgICAgICAgICAgJ2F0dHJhY3Rpb24nOiAgICAgICAgICAgMTdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxlY3RlZFR5cGVzID0gW107XG5cbiAgICAgICAgT2JqZWN0LmtleXModHlwZXMpLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgaWYgKHpvb20gPj0gdHlwZXNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzZWxlY3RlZFR5cGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkVHlwZXMuam9pbignLCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3BlcmZvcm1SZXF1ZXN0OiBmdW5jdGlvbihwYXJhbXMsIHVybCkgeyAvLyAoT2JqZWN0LCBTdHJpbmcsIEZ1bmN0aW9uLCBGdW5jdGlvbilcbiAgICAgICAgdmFyIGRhdGEgPSBERy5leHRlbmQoe2tleTogdGhpcy5fa2V5fSwgcGFyYW1zKTtcbiAgICAgICAgdmFyIHR5cGUgPSAnZ2V0JztcblxuICAgICAgICB0aGlzLmNhbmNlbExhc3RSZXF1ZXN0KCk7XG5cbiAgICAgICAgaWYgKCFERy5hamF4LmNvcnNTdXBwb3J0KSB7XG4gICAgICAgICAgICB0eXBlID0gZGF0YS5mb3JtYXQgPSAnanNvbnAnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGFzdFJlcXVlc3QgPSBERy5hamF4KHVybCwge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICB0aW1lb3V0OiB0aGlzLl90aW1lb3V0TXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhc3RSZXF1ZXN0O1xuICAgIH0sXG5cbiAgICBfZmlsdGVyUmVzcG9uc2U6IGZ1bmN0aW9uKHJlc3BvbnNlLCBhbGxvd2VkVHlwZXMpIHsgLy8gKE9iamVjdCwgQXJyYXkpIC0+IEJvb2xlYW58T2JqZWN0XG4gICAgICAgIHZhciByZXN1bHQgPSB7fSwgaSwgaXRlbSwgZm91bmQsIGRhdGEsIHR5cGU7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzTm90Rm91bmQocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhID0gcmVzcG9uc2UucmVzdWx0Lml0ZW1zO1xuXG4gICAgICAgIGZvciAoaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGl0ZW0gPSBkYXRhW2ldO1xuXG4gICAgICAgICAgICB0eXBlID0gaXRlbS50eXBlO1xuICAgICAgICAgICAgaWYgKGl0ZW0uc3VidHlwZSkge1xuICAgICAgICAgICAgICAgIHR5cGUgKz0gJy4nICsgaXRlbS5zdWJ0eXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsb3dlZFR5cGVzICYmIGFsbG93ZWRUeXBlcy5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRbdHlwZV0gPSBpdGVtO1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9pc05vdEZvdW5kOiBmdW5jdGlvbihyZXNwb25zZSkgeyAvLyAoT2JqZWN0KSAtPiBCb29sZWFuXG4gICAgICAgIHJldHVybiAhcmVzcG9uc2UgfHxcbiAgICAgICAgICAgICAgICEhcmVzcG9uc2UubWV0YSAmJiAhIXJlc3BvbnNlLm1ldGEuZXJyb3IgfHxcbiAgICAgICAgICAgICAgICFyZXNwb25zZS5yZXN1bHQgfHxcbiAgICAgICAgICAgICAgICFyZXNwb25zZS5yZXN1bHQuaXRlbXMgfHxcbiAgICAgICAgICAgICAgICFyZXNwb25zZS5yZXN1bHQuaXRlbXMubGVuZ3RoO1xuICAgIH1cblxufSk7XG4iLCJERy5HZW9jbGlja2VyLkhhbmRsZXIgPSB7fTtcbiIsIkRHLkdlb2NsaWNrZXIuSGFuZGxlci5EZWZhdWx0ID0gREcuQ2xhc3MuZXh0ZW5kKHtcblxuICAgIGluY2x1ZGVzOiBERy5Mb2NhbGUsXG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIERpY3Rpb25hcnk6IHt9XG4gICAgfSxcblxuICAgIF9ldmVudEhhbmRsZXJzOiB7fSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvbnRyb2xsZXIsIHZpZXcsIG1hcCkgeyAvLyAoT2JqZWN0LCBPYmplY3QsIE9iamVjdClcbiAgICAgICAgdGhpcy5fY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMuX3ZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgfSxcblxuICAgIGhhbmRsZTogZnVuY3Rpb24oKSB7IC8vICgpIC0+IFByb21pc2VcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICB0bXBsOiAncG9wdXBIZWFkZXInLFxuICAgICAgICAgICAgZGF0YTogeyd0aXRsZSc6IHRoaXMudCgnd2VfaGF2ZV9ub3QnKX1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFkZENsaWNrRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl92aWV3Ll9wb3B1cC5vbignY2xpY2snLCB0aGlzLl9ydW5FdmVudEhhbmRsZXJzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fbWFwLm9uY2UoJ3BvcHVwY2xvc2UnLCB0aGlzLl9yZW1vdmVDbGlja0V2ZW50LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUNsaWNrRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl92aWV3Ll9wb3B1cC5vZmYoJ2NsaWNrJywgdGhpcy5fcnVuRXZlbnRIYW5kbGVycywgdGhpcyk7XG4gICAgfSxcblxuICAgIF9hZGRFdmVudEhhbmRsZXI6IGZ1bmN0aW9uKGVsLCBoYW5kbGVyKSB7IC8vIChTdHJpbmcsIEZ1bmN0aW9uKVxuICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXJzW2VsXSA9IGhhbmRsZXI7XG4gICAgfSxcblxuICAgIF9ydW5FdmVudEhhbmRsZXJzOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0O1xuXG4gICAgICAgIGZvciAodmFyIGV2ZW50Q2xhc3MgaW4gdGhpcy5fZXZlbnRIYW5kbGVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50SGFuZGxlcnMuaGFzT3duUHJvcGVydHkoZXZlbnRDbGFzcykgJiYgdGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKGV2ZW50Q2xhc3MpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBERy5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcnNbZXZlbnRDbGFzc10uY2FsbCh0aGlzLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2xlYXJFdmVudEhhbmRsZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVycyA9IHt9O1xuICAgIH0sXG5cbiAgICBfZ2V0RGlyZWN0aW9uc1VybDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gREcuVXRpbC50ZW1wbGF0ZShERy5jb25maWcucHBub3RMaW5rLCB7XG4gICAgICAgICAgICAnZG9tYWluJzogdGhpcy5fbWFwLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCkuZG9tYWluLFxuICAgICAgICAgICAgJ3Byb2plY3RDb2RlJzogdGhpcy5fbWFwLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCkuY29kZSxcbiAgICAgICAgICAgICdjZW50ZXInOiB0aGlzLl9tYXAuZ2V0Q2VudGVyKCkubG5nICsgJywnICsgdGhpcy5fbWFwLmdldENlbnRlcigpLmxhdCxcbiAgICAgICAgICAgICd6b29tJzogdGhpcy5fbWFwLmdldFpvb20oKSxcbiAgICAgICAgICAgICduYW1lJzogZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpLFxuICAgICAgICAgICAgJ3JzVHlwZSc6IHRoaXMuX21hcC5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpLnRyYW5zcG9ydCA/ICdidXMnIDogJ2NhcicsXG4gICAgICAgICAgICAncG9pbnQnOiB0aGlzLl9wb3B1cC5fbGF0bG5nLmxuZyArICcsJyArIHRoaXMuX3BvcHVwLl9sYXRsbmcubGF0XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZ2V0RHJpbGxkb3duOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIGFkbURpdnMgPSBbXSxcbiAgICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgICBpZiAob2JqZWN0LmFkbV9kaXYpIHtcbiAgICAgICAgICAgIGFkbURpdnMgPSBvYmplY3QuYWRtX2RpdlxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24oYWRtRGl2cywgYWRtRGl2KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZG1EaXYubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRtRGl2cy5wdXNoKGFkbURpdi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZG1EaXZzO1xuICAgICAgICAgICAgICAgIH0sIFtdKVxuICAgICAgICAgICAgICAgIC5yZXZlcnNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWRtRGl2cy5sZW5ndGggJiYgb2JqZWN0LmFkZHJlc3MgJiYgb2JqZWN0LmFkZHJlc3MucG9zdGNvZGUpIHtcbiAgICAgICAgICAgIGFkbURpdnMucHVzaChvYmplY3QuYWRkcmVzcy5wb3N0Y29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBhZG1EaXZzLmpvaW4oJywgJyk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbn0pO1xuXG5cbkRHLkdlb2NsaWNrZXIuSGFuZGxlci5IYW5kbGVyRXhhbXBsZSA9IERHLkdlb2NsaWNrZXIuSGFuZGxlci5EZWZhdWx0LmV4dGVuZCh7XG5cbiAgICBoYW5kbGU6IGZ1bmN0aW9uKHJlc3VsdHMsIHR5cGUpIHsgLy8gKE9iamVjdCwgU3RyaW5nKSAtPiBQcm9taXNlXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgdG1wbDogdHlwZSArICc6PGJyLz4nICsgcmVzdWx0c1t0eXBlXS5pZFxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbiIsIkRHLkdlb2NsaWNrZXIuSGFuZGxlci5BcGlFcnJvciA9IERHLkdlb2NsaWNrZXIuSGFuZGxlci5EZWZhdWx0LmV4dGVuZCh7XG4gICAgaGFuZGxlOiBmdW5jdGlvbigpIHsgLy8gKCkgLT4gUHJvbWlzZVxuICAgICAgICB2YXIgaGVhZGVyID0gdGhpcy5fdmlldy5yZW5kZXIoe1xuICAgICAgICAgICAgdG1wbDogJ3BvcHVwSGVhZGVyJyxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogdGhpcy50KCdhcGlFcnJvclRpdGxlJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBoZWFkZXI6IGhlYWRlcixcbiAgICAgICAgICAgIHRtcGw6IHRoaXMudCgnYXBpRXJyb3JCb2R5JylcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4iLCJERy5HZW9jbGlja2VyLkhhbmRsZXIuQ2l0eUFyZWEgPSBERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdC5leHRlbmQoe1xuXG4gICAgX3BvbHlsaW5lU3R5bGVEZWZhdWx0IDoge1xuICAgICAgICBmaWxsQ29sb3I6ICcjZmY5Mzg3JyxcbiAgICAgICAgY29sb3I6ICcjZmY5Mzg3JyxcbiAgICAgICAgbm9DbGlwOiB0cnVlLFxuICAgICAgICBvcGFjaXR5OiAxXG4gICAgfSxcblxuICAgIF9wb2x5bGluZVN0eWxlcyA6IHtcbiAgICAgICAgMTEgOiB7XG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogMC4xOCxcbiAgICAgICAgICAgIHdlaWdodDogMVxuICAgICAgICB9LFxuICAgICAgICAxMiA6IHtcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjEyLFxuICAgICAgICAgICAgd2VpZ2h0OiAxXG4gICAgICAgIH0sXG4gICAgICAgIDEzIDoge1xuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuMDgsXG4gICAgICAgICAgICB3ZWlnaHQ6IDJcbiAgICAgICAgfSxcbiAgICAgICAgMTggOiB7XG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogMCxcbiAgICAgICAgICAgIHdlaWdodDogM1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZTogZnVuY3Rpb24ocmVzdWx0cywgdHlwZSkgeyAvLyAoT2JqZWN0LCBTdHJpbmcpIC0+IFByb21pc2VcbiAgICAgICAgaWYgKCFyZXN1bHRzW3R5cGVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3N0eWxlc0luaXRlZCkge1xuICAgICAgICAgICAgdGhpcy5faW5pdFN0eWxlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIHByZXZpb3VzIGdlb21ldHJ5IHNlZSBodHRwczovL2dpdGh1Yi5jb20vMmdpcy9tYXBzYXBpL2lzc3Vlcy8yMTNcbiAgICAgICAgaWYgKHRoaXMuX2dlb21ldHJ5KSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fZ2VvbWV0cnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcG9wdXAgPSB0aGlzLl92aWV3LmdldFBvcHVwKCk7XG5cbiAgICAgICAgdGhpcy5fZ2VvbWV0cnlab29tU3R5bGUgPSB0aGlzLl9nZXRQb2x5U3R5bGVOdW0oKTtcbiAgICAgICAgdGhpcy5fZ2VvbWV0cnkgPSBERy5Xa3QuZ2VvSnNvbkxheWVyKHJlc3VsdHNbdHlwZV0uZ2VvbWV0cnkuc2VsZWN0aW9uLCB7XG4gICAgICAgICAgICBzdHlsZTogdGhpcy5fcG9seWxpbmVTdHlsZXNbdGhpcy5fZ2VvbWV0cnlab29tU3R5bGVdLFxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlXG4gICAgICAgIH0pLmFkZFRvKHRoaXMuX21hcCk7XG5cbiAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAub24oJ3pvb21lbmQnLCB0aGlzLl91cGRhdGVHZW9tZXRyeSwgdGhpcylcbiAgICAgICAgICAgIC5vbmNlKCdwb3B1cGNsb3NlJywgdGhpcy5fY2xlYXJQb3B1cCwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9maWxsQ2l0eUFyZWFPYmplY3QocmVzdWx0cywgdHlwZSkpO1xuICAgIH0sXG5cbiAgICBfZmlsbENpdHlBcmVhT2JqZWN0OiBmdW5jdGlvbihyZXN1bHRzLCB0eXBlKSB7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy50KCdub25hbWUnKSxcbiAgICAgICAgICAgIGRyaWxsZG93bjogJycsXG4gICAgICAgICAgICBwdXJwb3NlOiB0aGlzLnQodHlwZSksXG4gICAgICAgICAgICB0eXBlOiB0eXBlLnNwbGl0KCcuJykuam9pbignXycpXG4gICAgICAgIH07XG5cbiAgICAgICAgZGF0YS5kcmlsbGRvd24gPSB0aGlzLl9nZXREcmlsbGRvd24ocmVzdWx0c1t0eXBlXSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdHNbdHlwZV0ubmFtZSkge1xuICAgICAgICAgICAgZGF0YS5uYW1lID0gcmVzdWx0c1t0eXBlXS5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRtcGw6ICdjaXR5YXJlYScsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgaGVhZGVyOiB0aGlzLl92aWV3LnJlbmRlcih7XG4gICAgICAgICAgICAgICAgdG1wbDogJ3BvcHVwSGVhZGVyJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7J3RpdGxlJzogZGF0YS5uYW1lfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX2luaXRTdHlsZXMgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc3R5bGVzSW5pdGVkID0gdHJ1ZTtcblxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9wb2x5bGluZVN0eWxlcykuZm9yRWFjaChmdW5jdGlvbih6b29tKSB7XG4gICAgICAgICAgICBERy5leHRlbmQodGhpcy5fcG9seWxpbmVTdHlsZXNbem9vbV0sIHRoaXMuX3BvbHlsaW5lU3R5bGVEZWZhdWx0KTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIF9nZXRQb2x5U3R5bGVOdW06IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWFwWm9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3BvbHlsaW5lU3R5bGVzKS5maWx0ZXIoZnVuY3Rpb24oem9vbSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcFpvb20gPD0gem9vbTtcbiAgICAgICAgfSlbMF0gfHwgZmFsc2U7XG4gICAgfSxcblxuICAgIF91cGRhdGVHZW9tZXRyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuZXdTdHlsZSA9IHRoaXMuX2dldFBvbHlTdHlsZU51bSgpO1xuXG4gICAgICAgIGlmIChuZXdTdHlsZSAmJiBuZXdTdHlsZSAhPT0gdGhpcy5fZ2VvbWV0cnlab29tU3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2dlb21ldHJ5Wm9vbVN0eWxlID0gbmV3U3R5bGU7XG4gICAgICAgICAgICB0aGlzLl9nZW9tZXRyeS5zZXRTdHlsZSh0aGlzLl9wb2x5bGluZVN0eWxlc1tuZXdTdHlsZV0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jbGVhclBvcHVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAgICAgLnJlbW92ZUxheWVyKHRoaXMuX2dlb21ldHJ5KVxuICAgICAgICAgICAgICAgIC5vZmYoJ3pvb21lbmQnLCB0aGlzLl91cGRhdGVHZW9tZXRyeSwgdGhpcyk7XG4gICAgfVxuXG59KTtcbiIsIi8qZ2xvYmFsIEZpcm1DYXJkICovXG5ERy5HZW9jbGlja2VyLkhhbmRsZXIuSG91c2UgPSBERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdC5leHRlbmQoe1xuXG4gICAgX2Zpcm1zT25QYWdlOiAyMCxcbiAgICBfc2Nyb2xsVGhyb3R0bGVJbnRlcnZhbDogNDAwLFxuICAgIF9zY3JvbGxIZWlnaHRSZXNlcnZlOiA2MCxcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgJ3Nob3dCb29rbGV0JzogdHJ1ZSxcbiAgICAgICAgJ3Nob3dQaG90b3MnOiB0cnVlLFxuICAgICAgICAnc2hvd1JvdXRlU2VhcmNoJzogdHJ1ZVxuICAgIH0sXG5cbiAgICBoYW5kbGU6IGZ1bmN0aW9uKHJlc3VsdHMpIHsgLy8gKE9iamVjdCkgLT4gUHJvbWlzZVxuICAgICAgICBpZiAoIXJlc3VsdHMuYnVpbGRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluaXRpYWxpemF0aW9uIHNldHVwXG4gICAgICAgIHRoaXMuZmlybUNhcmQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYWdlID0gMTtcbiAgICAgICAgdGhpcy5faG91c2VPYmplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9maXJtTGlzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Zpcm1MaXN0T2JqZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmlybUNhcmRPYmplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9vblNjcm9sbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0Zpcm1saXN0T3BlbiA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2lkID0gcmVzdWx0cy5idWlsZGluZy5pZDtcbiAgICAgICAgdGhpcy5fdG90YWxQYWdlcyA9IDE7XG4gICAgICAgIHRoaXMuX2FwaSA9IHRoaXMuX2NvbnRyb2xsZXIuZ2V0Q2F0YWxvZ0FwaSgpO1xuICAgICAgICB0aGlzLl9wb3B1cCA9IHRoaXMuX3ZpZXcuZ2V0UG9wdXAoKTtcbiAgICAgICAgdGhpcy5faW5pdGVkUG9wdXBDbG9zZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb25zVXJsID0gdGhpcy5fZ2V0RGlyZWN0aW9uc1VybChyZXN1bHRzLmJ1aWxkaW5nLm5hbWUpO1xuICAgICAgICB0aGlzLl9maXJtTGlzdExvYWRlciA9IHRoaXMuX3ZpZXcuaW5pdExvYWRlcih0cnVlKTtcblxuICAgICAgICB0aGlzLl9ob3VzZU9iamVjdCA9IHRoaXMuX2ZpbGxIb3VzZU9iamVjdChyZXN1bHRzLmJ1aWxkaW5nKTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2hvdXNlT2JqZWN0KTtcbiAgICB9LFxuXG4gICAgX2lzUm91dGVTZWFyY2hBbGxvd2VkOiBmdW5jdGlvbigpIHsgLy8oKSAtPiBCb29sZWFuXG4gICAgICAgIHZhciBwcm9qZWN0ID0gdGhpcy5fY29udHJvbGxlci5nZXRNYXAoKS5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpO1xuICAgICAgICByZXR1cm4gcHJvamVjdC50cmFuc3BvcnQgfHwgcHJvamVjdC5yb2FkcztcbiAgICB9LFxuXG4gICAgX2Zpcm1DYXJkU2V0dXA6IGZ1bmN0aW9uKCkgeyAvLygpIC0+IE9iamVjdFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVuZGVyOiB0aGlzLl92aWV3LnJlbmRlclRlbXBsYXRlLFxuICAgICAgICAgICAgbGFuZzogdGhpcy5fbWFwLmdldExhbmcoKSxcbiAgICAgICAgICAgIGRvbWFpbjogdGhpcy5fY29udHJvbGxlci5nZXRNYXAoKS5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpLmRvbWFpbixcbiAgICAgICAgICAgIGFqYXg6IERHLmJpbmQodGhpcy5fYXBpLmdldEZpcm1JbmZvLCB0aGlzLl9hcGkpLFxuICAgICAgICAgICAgdGltZXpvbmVPZmZzZXQ6IHRoaXMuX2NvbnRyb2xsZXIuZ2V0TWFwKCkucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKS50aW1lT2Zmc2V0LFxuICAgICAgICAgICAgbWFwOiB0aGlzLl9tYXAsXG4gICAgICAgICAgICBwb3B1cDogdGhpcy5fcG9wdXAsXG4gICAgICAgICAgICBpc01vYmlsZTogREcuQnJvd3Nlci5tb2JpbGUsXG4gICAgICAgICAgICBzaG93RW50cmFuY2U6IERHLkVudHJhbmNlLFxuICAgICAgICAgICAgZ290b1VybDogdGhpcy5fZGlyZWN0aW9uc1VybCxcbiAgICAgICAgICAgIG9uRmlybVJlYWR5OiBERy5iaW5kKHRoaXMuX29uRmlybVJlYWR5LCB0aGlzKSxcbiAgICAgICAgICAgIG9uVG9nZ2xlOiBERy5iaW5kKHRoaXMuX3BvcHVwLnJlc2l6ZSwgdGhpcy5fcG9wdXApLFxuICAgICAgICAgICAgc2hvd0Jvb2tsZXQ6IHRoaXMub3B0aW9ucy5zaG93Qm9va2xldCxcbiAgICAgICAgICAgIHNob3dQaG90b3M6IHRoaXMub3B0aW9ucy5zaG93UGhvdG9zLFxuICAgICAgICAgICAgc2hvd1JvdXRlU2VhcmNoOiB0aGlzLm9wdGlvbnMuc2hvd1JvdXRlU2VhcmNoICYmIHRoaXMuX2lzUm91dGVTZWFyY2hBbGxvd2VkKCksXG4gICAgICAgICAgICB0OiBERy5iaW5kKHRoaXMudCwgdGhpcylcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8gaW5pdCBzaW5nbGUgZmlybSBjYXJkIGluIGNhc2Ugb2YgcG9pXG4gICAgX2ZpbGxGaXJtQ2FyZE9iamVjdDogZnVuY3Rpb24oZmlybUlkKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fZmlybUNhcmRTZXR1cCgpO1xuXG4gICAgICAgIHRoaXMuZmlybUNhcmQgPSBuZXcgRmlybUNhcmQoZmlybUlkLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faW5pdFBvcHVwQ2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlybUNhcmQuZ2V0Q29udGFpbmVyKCk7XG4gICAgfSxcblxuICAgIF9maXJtTGlzdFNldHVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9maXJtQ2FyZFNldHVwKCk7XG5cbiAgICAgICAgREcuZXh0ZW5kKG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGJhY2tCdG46IERHLmJpbmQodGhpcy5fc2hvd0hvdXNlUG9wdXAsIHRoaXMpLFxuICAgICAgICAgICAgb25GaXJtQ2xpY2s6IERHLmJpbmQodGhpcy5fb25GaXJtTGlzdENsaWNrLCB0aGlzKSxcbiAgICAgICAgICAgIG9uU2hvd0xlc3M6IERHLmJpbmQodGhpcy5fc2hvd0hvdXNlUG9wdXAsIHRoaXMpLFxuICAgICAgICAgICAgcGFzdGVMb2FkZXI6IERHLmJpbmQodGhpcy5fcGFzdGVMb2FkZXIsIHRoaXMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaXJtQ2FyZDogb3B0aW9ucyxcbiAgICAgICAgICAgIGZpcm1saXN0SXRlbVRtcGw6ICdmaXJtbGlzdEl0ZW0nLFxuICAgICAgICAgICAgb25MaXN0UmVhZHk6IERHLmJpbmQodGhpcy5fcmVuZGVyRmlybUxpc3QsIHRoaXMpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIF9pbml0U2hvcnRGaXJtTGlzdDogZnVuY3Rpb24oZmlybXMpIHsgLy8oT2JqZWN0KSAtPiBET01FbGVtZW50XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fZmlybUxpc3RTZXR1cCgpO1xuXG4gICAgICAgIHRoaXMuX3Nob3J0RmlybUxpc3QgPSBuZXcgRmlybUNhcmQuTGlzdChmaXJtcywgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3J0RmlybUxpc3QucmVuZGVyTGlzdCgpO1xuICAgIH0sXG5cbiAgICBfaW5pdEZpcm1MaXN0OiBmdW5jdGlvbihyZXMpIHsgLy8oT2JqZWN0KSAtPiBQcm9taXNlXG4gICAgICAgIGlmICghcmVzKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgIHZhciByZXN1bHRzID0gcmVzLnJlc3VsdC5pdGVtcyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLl9maXJtTGlzdFNldHVwKCk7XG5cbiAgICAgICAgb3B0aW9ucy5maXJtQ2FyZC5iYWNrQnRuID0gREcuYmluZCh0aGlzLl9zaG93TGlzdFBvcHVwLCB0aGlzKTtcblxuICAgICAgICB0aGlzLl9zaG9ydEZpcm1MaXN0Ll90b2dnbGVFdmVudEhhbmRsZXJzKHRydWUpO1xuXG4gICAgICAgIHRoaXMuX2Zpcm1MaXN0ID0gbmV3IEZpcm1DYXJkLkxpc3QocmVzdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fZmlybUxpc3RPYmplY3QgPSB0aGlzLl9maWxsRmlybUxpc3RPYmplY3QodGhpcy5fZmlybUxpc3QucmVuZGVyTGlzdCgpKTtcbiAgICAgICAgdGhpcy5fY2xlYXJBbmRSZW5kZXJQb3B1cCh0aGlzLl9maXJtTGlzdE9iamVjdCk7XG4gICAgfSxcblxuICAgIF9maWxsRmlybUxpc3RPYmplY3Q6IGZ1bmN0aW9uKGZpcm1MaXN0KSB7IC8vKERPTUVsZW1lbnQpIC0+IE9iamVjdFxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRtcGw6IGZpcm1MaXN0LFxuICAgICAgICAgICAgaGVhZGVyOiB0aGlzLl9oZWFkZXIsXG4gICAgICAgICAgICBmb290ZXI6IHRoaXMuX3ZpZXcucmVuZGVyKHtcbiAgICAgICAgICAgICAgICB0bXBsOiAncG9wdXBGb290ZXJCdG5zJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGJ0bnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYmFjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMudCgnYmFja19idXR0b24nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFmdGVyUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbml0UG9wdXBDbG9zZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3RvdGFsUGFnZXMgPiAxICYmIHNlbGYuX2Zpcm1MaXN0TG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFwidGhpc1wiIGhlcmUgaXMgc2VsZi5fZmlybUxpc3RPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50bXBsLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoc2VsZi5fZmlybUxpc3RMb2FkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX29uRmlybVJlYWR5OiBmdW5jdGlvbihmaXJtQ29udGVudE9iamVjdCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGZpcm1Db250ZW50T2JqZWN0LmFmdGVyUmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVyVGl0bGUgPSBzZWxmLl9wb3B1cC5fcG9wdXBTdHJ1Y3R1cmUuaGVhZGVyLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoIURHLkJyb3dzZXIuaWVsdDkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyVGl0bGUub2Zmc2V0SGVpZ2h0ID4gNzIpIHsgLy9UT0RPOiBtYWdpYyBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyhoZWFkZXJUaXRsZSwgJ2RnLXBvcHVwX19oZWFkZXItdGVhc2VyJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghREcuQnJvd3Nlci53ZWJraXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIERHLkdlb2NsaWNrZXIuY2xhbXBIZWxwZXIoaGVhZGVyVGl0bGUsIDMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jbGVhckFuZFJlbmRlclBvcHVwKGZpcm1Db250ZW50T2JqZWN0KTtcbiAgICB9LFxuXG4gICAgX3Nob3dIb3VzZVBvcHVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fcG9wdXAub2ZmKCdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCk7XG4gICAgICAgIHRoaXMuX2NsZWFyQW5kUmVuZGVyUG9wdXAodGhpcy5faG91c2VPYmplY3QpO1xuICAgICAgICB0aGlzLl9zaG9ydEZpcm1MaXN0Ll90b2dnbGVFdmVudEhhbmRsZXJzKCk7XG4gICAgfSxcblxuICAgIF9vbkZpcm1MaXN0Q2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9wb3B1cC5vZmYoJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsKTtcbiAgICB9LFxuXG4gICAgX3Bhc3RlTG9hZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxvYWRlcldyYXBwZXIgID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdkZy1tYXAtZ2VvY2xpY2tlcl9fcHJlbG9hZGVyLXdyYXBwZXInKSxcbiAgICAgICAgICAgIGxvYWRlciA9IHRoaXMuX3ZpZXcuaW5pdExvYWRlcigpO1xuXG4gICAgICAgIGxvYWRlcldyYXBwZXIuaW5zZXJ0QmVmb3JlKGxvYWRlciwgbG9hZGVyV3JhcHBlci5maXJzdENoaWxkKTtcbiAgICAgICAgbG9hZGVyV3JhcHBlci5zdHlsZS5oZWlnaHQgPSB0aGlzLl9wb3B1cC5fY29udGVudE5vZGUub2Zmc2V0SGVpZ2h0IC0gMSArICdweCc7IC8vIE1BR0lDXG4gICAgICAgIGxvYWRlcldyYXBwZXIuc3R5bGUud2lkdGggPSB0aGlzLl9wb3B1cC5fY29udGVudE5vZGUub2Zmc2V0V2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLl9jbGVhckFuZFJlbmRlclBvcHVwKHt0bXBsOiBsb2FkZXJXcmFwcGVyfSk7XG4gICAgfSxcblxuICAgIF9pbml0UG9wdXBDbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0ZWRQb3B1cENsb3NlKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRyb2xsZXIuZ2V0TWFwKCkub25jZSgncG9wdXBjbG9zZScsIERHLmJpbmQodGhpcy5fb25Qb3B1cENsb3NlLCB0aGlzKSk7XG4gICAgICAgIHRoaXMuX2luaXRlZFBvcHVwQ2xvc2UgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBfc2hvd0xpc3RQb3B1cDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaXJtTGlzdCA9IHRoaXMuX2Zpcm1MaXN0T2JqZWN0O1xuXG4gICAgICAgIHRoaXMuX3Bhc3RlTG9hZGVyKCk7XG5cbiAgICAgICAgaWYgKCFmaXJtTGlzdCkge1xuICAgICAgICAgICAgZmlybUxpc3QgPSB0aGlzLl9hcGkuZmlybXNJbkhvdXNlKHRoaXMuX2lkKS50aGVuKERHLmJpbmQodGhpcy5faW5pdEZpcm1MaXN0LCB0aGlzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhckFuZFJlbmRlclBvcHVwKGZpcm1MaXN0KTtcbiAgICAgICAgICAgIHRoaXMuX2Zpcm1MaXN0Ll90b2dnbGVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX29uU2Nyb2xsKSB7XG4gICAgICAgICAgICB0aGlzLl9vblNjcm9sbCA9IERHLlV0aWwudGhyb3R0bGUodGhpcy5faGFuZGxlUG9wdXBTY3JvbGwsIHRoaXMuX3Njcm9sbFRocm90dGxlSW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcG9wdXAub24oJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsKTtcbiAgICB9LFxuXG4gICAgX3JlbmRlckZpcm1MaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0Zpcm1saXN0T3Blbikge1xuICAgICAgICAgICAgdGhpcy5fcG9wdXAucmVzaXplKCk7XG4gICAgICAgICAgICB0aGlzLl9pc0Zpcm1saXN0T3BlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uUG9wdXBDbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2luaXRlZFBvcHVwQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2Zpcm1MaXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9maXJtTGlzdC5jbGVhckxpc3QoKTtcbiAgICAgICAgICAgIHRoaXMuX2Zpcm1MaXN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwLm9mZignc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Zpcm1JZCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmZpcm1DYXJkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcm1DYXJkLl90b2dnbGVFdmVudEhhbmRsZXJzKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5maXJtQ2FyZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlybUxpc3RMb2FkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYWdlID0gMTtcbiAgICAgICAgdGhpcy5fY2xlYXJFdmVudEhhbmRsZXJzKCk7XG4gICAgfSxcblxuICAgIF9pbml0U2hvd01vcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGluayA9IHRoaXMuX3BvcHVwLmZpbmRFbGVtZW50KCcuZGctcG9wdXBfX2J1dHRvbl9uYW1lX2FsbCcpO1xuXG4gICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRFdmVudEhhbmRsZXIoJ2RnLXBvcHVwX19idXR0b25fbmFtZV9hbGwnLCBERy5iaW5kKHRoaXMuX3Nob3dMaXN0UG9wdXAsIHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2xlYXJBbmRSZW5kZXJQb3B1cDogZnVuY3Rpb24ocG9wdXBPYmplY3QpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuX3BvcHVwLmNsZWFyKCdoZWFkZXInLCAnZm9vdGVyJyk7XG4gICAgICAgIHRoaXMuX3ZpZXcucmVuZGVyUG9wdXAocG9wdXBPYmplY3QpO1xuICAgIH0sXG5cbiAgICBfYXBwZW5kRmlybUxpc3Q6IGZ1bmN0aW9uKHJlcykgeyAvLyAoT2JqZWN0KVxuICAgICAgICB0aGlzLl9maXJtTGlzdC5hZGRGaXJtcyhyZXMucmVzdWx0Lml0ZW1zKTtcbiAgICAgICAgdGhpcy5fcG9wdXAuX3VwZGF0ZVNjcm9sbFBvc2l0aW9uKCk7XG4gICAgfSxcblxuICAgIF9oYW5kbGVQb3B1cFNjcm9sbDogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgc2Nyb2xsZXIgPSBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0IHx8IGUudGFyZ2V0Ll9zY3JvbGxlcjtcblxuICAgICAgICBERy5Eb21FdmVudC5zdG9wKGUpO1xuXG4gICAgICAgIGlmICh0aGlzLl90b3RhbFBhZ2VzIDw9IDEpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmIChzY3JvbGxlciAmJiBzY3JvbGxlci5zY3JvbGxIZWlnaHQgPD0gc2Nyb2xsZXIuc2Nyb2xsVG9wICsgc2Nyb2xsZXIub2Zmc2V0SGVpZ2h0ICsgdGhpcy5fc2Nyb2xsSGVpZ2h0UmVzZXJ2ZSkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlUGFnaW5nKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2hhbmRsZVBhZ2luZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3BhZ2UrKztcblxuICAgICAgICBpZiAodGhpcy5fdG90YWxQYWdlcyAmJiB0aGlzLl9wYWdlIDw9IHRoaXMuX3RvdGFsUGFnZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwaS5maXJtc0luSG91c2UodGhpcy5faWQsIHtwYWdlOiB0aGlzLl9wYWdlfSkudGhlbihERy5iaW5kKHRoaXMuX2FwcGVuZEZpcm1MaXN0LCB0aGlzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcGFnZSA9PT0gdGhpcy5fdG90YWxQYWdlcykge1xuICAgICAgICAgICAgdmFyIGxvYWRlciA9IHRoaXMuX2Zpcm1MaXN0TG9hZGVyO1xuXG4gICAgICAgICAgICBpZiAobG9hZGVyICYmIGxvYWRlci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgbG9hZGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobG9hZGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fcG9wdXAub2ZmKCdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIkRHLkdlb2NsaWNrZXIuSGFuZGxlci5Ib3VzZS5pbmNsdWRlKHtcbiAgICBfZ2V0QWRkcmVzc1N0cmluZzogZnVuY3Rpb24oaG91c2UpIHtcbiAgICAgICAgaWYgKCFob3VzZS5hZGRyZXNzIHx8ICFob3VzZS5hZGRyZXNzLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBob3VzZS5hZGRyZXNzLmNvbXBvbmVudHNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudC50eXBlID09PSAnc3RyZWV0X251bWJlcic7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50LnN0cmVldCArICcsICcgKyBjb21wb25lbnQubnVtYmVyO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcgLyAnKTtcbiAgICB9LFxuXG4gICAgX2ZpbGxCb2R5OiBmdW5jdGlvbihob3VzZSkgeyAvLyAvLyAoT2JqZWN0KSAtPiAoRE9NRWxlbWVudClcbiAgICAgICAgdmFyIGRhdGEgPSB7fSxcbiAgICAgICAgICAgIHdyYXBwZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2RnLWJ1aWxkaW5nLWNhbGxvdXRfX2JvZHknKSxcbiAgICAgICAgICAgIGZpbGlhbHMgPSBob3VzZS5saW5rcyAmJiBob3VzZS5saW5rcy5icmFuY2hlcztcblxuICAgICAgICB2YXIgZHJpbGxkb3duID0gdGhpcy5fZ2V0RHJpbGxkb3duKGhvdXNlKTtcblxuICAgICAgICBpZiAoaG91c2UuYnVpbGRpbmdfbmFtZSkge1xuICAgICAgICAgICAgZGF0YS5hZGRyZXNzID0ge1xuICAgICAgICAgICAgICAgIGhlYWRlcjogdGhpcy5fZ2V0QWRkcmVzc1N0cmluZyhob3VzZSksXG4gICAgICAgICAgICAgICAgZHJpbGxkb3duOiBkcmlsbGRvd25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHJpbGxkb3duKSB7XG4gICAgICAgICAgICBkYXRhLmFkZHJlc3MgPSB7XG4gICAgICAgICAgICAgICAgZHJpbGxkb3duOiBkcmlsbGRvd25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnB1cnBvc2UgPSBob3VzZS5wdXJwb3NlX25hbWUgK1xuICAgICAgICAgICAgKGhvdXNlLmZsb29ycyA/ICcsICcgKyB0aGlzLnQoJ25fZmxvb3JzJywgaG91c2UuZmxvb3JzLmdyb3VuZF9jb3VudCkgOiAnJyk7XG5cbiAgICAgICAgaWYgKGZpbGlhbHMgJiYgZmlsaWFscy5jb3VudCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsUGFnZXMgPSBNYXRoLmNlaWwoaG91c2UubGlua3MuYnJhbmNoZXMuY291bnQgLyB0aGlzLl9maXJtc09uUGFnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaG91c2UubGlua3MgJiYgaG91c2UubGlua3MuYXR0cmFjdGlvbnMgJiYgaG91c2UubGlua3MuYXR0cmFjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkYXRhLmF0dHJhY3Rpb25zID0gaG91c2UubGlua3MuYXR0cmFjdGlvbnMucmVkdWNlKGZ1bmN0aW9uKGF0dHJhY3Rpb25zLCBhdHRyYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJhY3Rpb24ubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyYWN0aW9ucy5wdXNoKGF0dHJhY3Rpb24ubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJhY3Rpb25zO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgd3JhcHBlci5pbm5lckhUTUwgPSB0aGlzLl92aWV3LnJlbmRlcih7XG4gICAgICAgICAgICB0bXBsOiAnaG91c2UnLFxuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZmlsaWFscyAmJiBmaWxpYWxzLml0ZW1zKSB7XG4gICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuX2luaXRTaG9ydEZpcm1MaXN0KGZpbGlhbHMuaXRlbXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH0sXG5cbiAgICBfZmlsbEhlYWRlcjogZnVuY3Rpb24oaG91c2UpIHsgLy8gKE9iamVjdCkgLT4gKEhUTUxTdHJpbmcpXG4gICAgICAgIHZhciBoZWFkZXIgPSB7fTtcblxuICAgICAgICBpZiAoaG91c2UuYnVpbGRpbmdfbmFtZSkge1xuICAgICAgICAgICAgaGVhZGVyLnRpdGxlID0gaG91c2UuYnVpbGRpbmdfbmFtZTtcbiAgICAgICAgfSBlbHNlIGlmIChob3VzZS5hZGRyZXNzICYmIGhvdXNlLmFkZHJlc3MuY29tcG9uZW50cykge1xuICAgICAgICAgICAgaGVhZGVyLnRpdGxlID0gdGhpcy5fZ2V0QWRkcmVzc1N0cmluZyhob3VzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkZXIudGl0bGUgPSBob3VzZS5wdXJwb3NlX25hbWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9oZWFkZXIgPSB0aGlzLl92aWV3LnJlbmRlcih7XG4gICAgICAgICAgICB0bXBsOiAncG9wdXBIZWFkZXInLFxuICAgICAgICAgICAgZGF0YTogaGVhZGVyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXI7XG4gICAgfSxcblxuICAgIF9maWxsRm9vdGVyOiBmdW5jdGlvbihob3VzZSkgeyAvLyAoT2JqZWN0KSAtPiAoSFRNTFN0cmluZylcbiAgICAgICAgdmFyIGJ0bnMgPSBbXTtcbiAgICAgICAgdmFyIGhvdXNlRmlsaWFscyA9IGhvdXNlLmxpbmtzICYmIGhvdXNlLmxpbmtzLmJyYW5jaGVzO1xuXG4gICAgICAgIC8vIERlY2lkZSBpZiB3ZSBuZWVkIHRvIGRpc3BsYXkgJ21vcmUgb3JnYW5pc2F0aW9ucycgYnV0dG9uXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGhvdXNlRmlsaWFscyAmJlxuICAgICAgICAgICAgaG91c2VGaWxpYWxzLml0ZW1zICYmXG4gICAgICAgICAgICBob3VzZUZpbGlhbHMuaXRlbXMubGVuZ3RoICYmXG4gICAgICAgICAgICBob3VzZUZpbGlhbHMuY291bnQgPiBob3VzZUZpbGlhbHMuaXRlbXMubGVuZ3RoXG4gICAgICAgICkge1xuICAgICAgICAgICAgYnRucy5wdXNoKHRoaXMuX2dldFNob3dBbGxEYXRhKGhvdXNlRmlsaWFscy5jb3VudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzUm91dGVTZWFyY2hBbGxvd2VkKCkpIHtcbiAgICAgICAgICAgIGJ0bnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2dvdG8nLFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLnQoJ2dvX3RvJyksXG4gICAgICAgICAgICAgICAgaWNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBocmVmOiB0aGlzLl9kaXJlY3Rpb25zVXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3LnJlbmRlcih7XG4gICAgICAgICAgICB0bXBsOiAncG9wdXBGb290ZXJCdG5zJyxcbiAgICAgICAgICAgIGRhdGE6IHsnYnRucyc6IGJ0bnN9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZ2V0U2hvd0FsbERhdGE6IGZ1bmN0aW9uKGZpbGlhbHNDb3VudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJ2FsbCcsXG4gICAgICAgICAgICBsYWJlbDogdGhpcy50KCdzaG93X29yZ2FuaXphdGlvbl9pbl9idWlsZGluZycsIGZpbGlhbHNDb3VudClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX2ZpbGxIb3VzZU9iamVjdDogZnVuY3Rpb24oaG91c2UpIHsgLy8gKE9iamVjdCkgLT4gKE9iamVjdClcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWFkZXI6IHRoaXMuX2ZpbGxIZWFkZXIoaG91c2UpLFxuICAgICAgICAgICAgdG1wbDogdGhpcy5fZmlsbEJvZHkoaG91c2UpLFxuICAgICAgICAgICAgZm9vdGVyOiB0aGlzLl9maWxsRm9vdGVyKGhvdXNlKSxcbiAgICAgICAgICAgIGFmdGVyUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbml0U2hvd01vcmUoKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbml0UG9wdXBDbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuIiwiREcuR2VvY2xpY2tlci5IYW5kbGVyLlBvaSA9IERHLkdlb2NsaWNrZXIuSGFuZGxlci5Ib3VzZS5leHRlbmQoe1xuXG4gICAgaGFuZGxlOiBmdW5jdGlvbihyZXN1bHRzKSB7IC8vIChPYmplY3QpIC0+IFByb21pc2VcbiAgICAgICAgaWYgKCFyZXN1bHRzLnBvaSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24gc2V0dXBcbiAgICAgICAgdGhpcy5maXJtQ2FyZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhZ2UgPSAxO1xuICAgICAgICB0aGlzLl9ob3VzZU9iamVjdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Zpcm1MaXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmlybUxpc3RPYmplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9maXJtQ2FyZE9iamVjdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX29uU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzRmlybWxpc3RPcGVuID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5faWQgPSByZXN1bHRzLnBvaS5yZWZlcmVuY2UuaWQ7XG4gICAgICAgIHRoaXMuX3RvdGFsUGFnZXMgPSAxO1xuICAgICAgICB0aGlzLl9hcGkgPSB0aGlzLl9jb250cm9sbGVyLmdldENhdGFsb2dBcGkoKTtcbiAgICAgICAgdGhpcy5fcG9wdXAgPSB0aGlzLl92aWV3LmdldFBvcHVwKCk7XG4gICAgICAgIHRoaXMuX2luaXRlZFBvcHVwQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uc1VybCA9IHRoaXMuX2dldERpcmVjdGlvbnNVcmwocmVzdWx0cy5wb2kucmVmZXJlbmNlLm5hbWUpO1xuICAgICAgICB0aGlzLl9maXJtTGlzdExvYWRlciA9IHRoaXMuX3ZpZXcuaW5pdExvYWRlcih0cnVlKTtcblxuICAgICAgICAvLyBJZiB0aGUgUE9JIHJlZmVycyB0byBhIGJ1aWxkaW5nIChlLmcuIGdhbGxlcmllcyBpbiBTYW50aWFnbyksXG4gICAgICAgIC8vIHNob3cgYSBidWlsZGluZyBjYWxsb3V0XG4gICAgICAgIGlmIChyZXN1bHRzLnBvaS5yZWZlcmVuY2UudHlwZSA9PT0gJ2J1aWxkaW5nJykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fYXBpLmdlb0dldChyZXN1bHRzLnBvaS5yZWZlcmVuY2UuaWQpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2hvdXNlT2JqZWN0ID0gc2VsZi5fZmlsbEhvdXNlT2JqZWN0KHJlc3VsdC5yZXN1bHQuaXRlbXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNlbGYuX2hvdXNlT2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2hvdyBhIGZpcm0gY2FsbG91dFxuICAgICAgICBpZiAocmVzdWx0cy5wb2kucmVmZXJlbmNlLnR5cGUgPT09ICdicmFuY2gnKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsRmlybUNhcmRPYmplY3QocmVzdWx0cy5wb2kucmVmZXJlbmNlLmlkKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxufSk7XG4iLCJERy5HZW9jbGlja2VyLkhhbmRsZXIuU2lnaHQgPSBERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdC5leHRlbmQoe1xuXG4gICAgaGFuZGxlOiBmdW5jdGlvbihyZXN1bHRzKSB7IC8vIChPYmplY3QsIFN0cmluZykgLT4gUHJvbWlzZVxuICAgICAgICBpZiAoIXJlc3VsdHMuYXR0cmFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcG9wdXAgPSB0aGlzLl92aWV3LmdldFBvcHVwKCk7XG4gICAgICAgIHRoaXMuX2luaXRlZFBvcHVwQ2xvc2UgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2ZpbGxTaWdodE9iamVjdChyZXN1bHRzKSk7XG4gICAgfSxcblxuICAgIF9maWxsU2lnaHRPYmplY3Q6IGZ1bmN0aW9uKHJlc3VsdHMpIHsgLy8gKE9iamVjdCkgLT4gT2JqZWN0XG4gICAgICAgIHZhciBhdHRyYWN0aW9uID0gcmVzdWx0cy5hdHRyYWN0aW9uLFxuICAgICAgICAgICAgZGF0YSA9IHt9LFxuICAgICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBmb290ZXIgPSB7XG4gICAgICAgICAgICAgICAgYnRuczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZ290bycsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy50KCdnb190bycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAoYXR0cmFjdGlvbi5uYW1lKSB7XG4gICAgICAgICAgICBkYXRhLmJ1aWxkaW5nTmFtZSA9IGF0dHJhY3Rpb24ubmFtZTtcbiAgICAgICAgICAgIGRhdGEucHVycG9zZSA9IGF0dHJhY3Rpb24uc3VidHlwZV9uYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YS5idWlsZGluZ05hbWUgPSBhdHRyYWN0aW9uLnN1YnR5cGVfbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuZGVzY3JpcHRpb24gPSBhdHRyYWN0aW9uLmRlc2NyaXB0aW9uO1xuXG4gICAgICAgIGRhdGEuZHJpbGxEb3duID0gdGhpcy5fZ2V0RHJpbGxkb3duKGF0dHJhY3Rpb24pO1xuXG4gICAgICAgIGlmICh0aGlzLl9jaGVja0Rlc2NGaWVsZEhlaWdodChkYXRhLmRlc2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgZGF0YS5zaG93TW9yZVRleHQgPSB0aGlzLnQoJ3Nob3dfbW9yZV9hYm91dF9zaWdodCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9vdGVyLmJ0bnNbMF0uaHJlZiA9IHRoaXMuX2dldERpcmVjdGlvbnNVcmwoZGF0YS5idWlsZGluZ05hbWUpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0bXBsOiAnc2lnaHQnLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGhlYWRlcjogdGhpcy5fdmlldy5yZW5kZXIoe1xuICAgICAgICAgICAgICAgIHRtcGw6ICdwb3B1cEhlYWRlcicsXG4gICAgICAgICAgICAgICAgZGF0YTogeyd0aXRsZSc6IGRhdGEuYnVpbGRpbmdOYW1lfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBmb290ZXI6IHRoaXMuX3ZpZXcucmVuZGVyKHtcbiAgICAgICAgICAgICAgICB0bXBsOiAncG9wdXBGb290ZXJCdG5zJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBmb290ZXJcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYWZ0ZXJSZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9uZWVkU2hvd01vcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faW5pdFNob3dNb3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuX2luaXRQb3B1cENsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIF9pbml0UG9wdXBDbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0ZWRQb3B1cENsb3NlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb250cm9sbGVyLmdldE1hcCgpLm9uY2UoJ3BvcHVwY2xvc2UnLCBERy5iaW5kKHRoaXMuX2NsZWFyUG9wdXAsIHRoaXMpKTtcbiAgICAgICAgdGhpcy5faW5pdGVkUG9wdXBDbG9zZSA9IHRydWU7XG4gICAgfSxcblxuICAgIF9jbGVhclBvcHVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5faW5pdGVkUG9wdXBDbG9zZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jbGVhckV2ZW50SGFuZGxlcnMoKTtcbiAgICB9LFxuXG4gICAgX3Nob3dNb3JlVGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2Rlc2Muc3R5bGUubWF4SGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLl9saW5rLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fbGluayk7XG4gICAgICAgIHRoaXMuX3BvcHVwLnJlc2l6ZSgpO1xuICAgIH0sXG5cbiAgICBfaW5pdFNob3dNb3JlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbGluayA9IHRoaXMuX3BvcHVwLmZpbmRFbGVtZW50KCcuZGctbWFwLWdlb2NsaWNrZXJfX3Nob3ctbW9yZS1zaWdodHMtbGluaycpO1xuICAgICAgICB0aGlzLl9kZXNjID0gdGhpcy5fcG9wdXAuZmluZEVsZW1lbnQoJy5kZy1tYXAtZ2VvY2xpY2tlcl9fc2lnaHQtZGVzY3JpcHRpb24nKTtcblxuICAgICAgICBpZiAodGhpcy5fbGluayAmJiB0aGlzLl9kZXNjKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRFdmVudEhhbmRsZXIoJ2RnLW1hcC1nZW9jbGlja2VyX19zaG93LW1vcmUtc2lnaHRzLWxpbmsnLCBERy5iaW5kKHRoaXMuX3Nob3dNb3JlVGV4dCwgdGhpcykpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jaGVja0Rlc2NGaWVsZEhlaWdodDogZnVuY3Rpb24oZGVzYykge1xuICAgICAgICB2YXIgZWwgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJycpLFxuICAgICAgICAgICAgaGVpZ2h0O1xuXG4gICAgICAgIGVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gZGVzYztcblxuICAgICAgICB0aGlzLl9wb3B1cC5fY29udGVudE5vZGUuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICBoZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHRoaXMuX3BvcHVwLl9jb250ZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgIHRoaXMuX25lZWRTaG93TW9yZSA9IChoZWlnaHQgPiA0MCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX25lZWRTaG93TW9yZTtcbiAgICB9XG59KTtcbiIsIkRHLkdlb2NsaWNrZXIuVmlldyA9IERHLkNsYXNzLmV4dGVuZCh7XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihtYXAsIG9wdGlvbnMpIHsgLy8gKE9iamVjdCwgT2JqZWN0KVxuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgICAgIHRoaXMuX3BvcHVwID0gREcucG9wdXAoe1xuICAgICAgICAgICAgbWF4SGVpZ2h0OiAzMDAsXG4gICAgICAgICAgICBtaW5IZWlnaHQ6IDUwLFxuICAgICAgICAgICAgbWF4V2lkdGg6IDM4NSxcbiAgICAgICAgICAgIG1pbldpZHRoOiAzMTAsXG4gICAgICAgICAgICBzcHJhd2xpbmc6IHRydWUsXG4gICAgICAgICAgICBjbG9zZU9uQ2xpY2s6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIERHLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpbml0TG9hZGVyOiBmdW5jdGlvbihpc1NtYWxsKSB7XG4gICAgICAgIHZhciBsb2FkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbG9hZGVyLmlubmVySFRNTCA9IERHLmR1c3QoJ0RHR2VvY2xpY2tlci9sb2FkZXInLCB7XG4gICAgICAgICAgICBzbWFsbDogaXNTbWFsbCxcbiAgICAgICAgICAgIGFuaW06IHRoaXMuX2RldGVjdENzc0FuaW1hdGlvbigpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBsb2FkZXIuZmlyc3RDaGlsZDtcbiAgICB9LFxuXG4gICAgc2hvd1BvcHVwOiBmdW5jdGlvbihsYXRsbmcsIGNvbnRlbnQpIHsgLy8gKE9iamVjdClcbiAgICAgICAgdGhpcy5fcG9wdXBcbiAgICAgICAgICAgIC5zZXRDb250ZW50KGNvbnRlbnQpXG4gICAgICAgICAgICAuc2V0TGF0TG5nKGxhdGxuZylcbiAgICAgICAgICAgIC5vcGVuT24odGhpcy5fbWFwKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7IC8vIChPYmplY3QpIC0+IFN0cmluZ1xuICAgICAgICB2YXIgaHRtbCxcbiAgICAgICAgICAgIGRhdGEgPSB7fTtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy50bXBsID0gb3B0aW9ucy50bXBsIHx8ICcnO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgICAgICAgIGh0bWwgPSB0aGlzLnJlbmRlclRlbXBsYXRlKG9wdGlvbnMudG1wbCwgb3B0aW9ucy5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0bWwgPSBvcHRpb25zLnRtcGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5iZWZvcmVSZW5kZXIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYmVmb3JlUmVuZGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wb3B1cCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5oZWFkZXIgPSBvcHRpb25zLmhlYWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZvb3Rlcikge1xuICAgICAgICAgICAgICAgIGRhdGEuZm9vdGVyID0gb3B0aW9ucy5mb290ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLmJvZHkgPSBodG1sO1xuICAgICAgICAgICAgdGhpcy5fcG9wdXAuc2V0Q29udGVudChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hZnRlclJlbmRlcikge1xuICAgICAgICAgICAgb3B0aW9ucy5hZnRlclJlbmRlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfSxcblxuICAgIHJlbmRlclRlbXBsYXRlOiBmdW5jdGlvbihuYW1lLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBERy5kdXN0KCdER0dlb2NsaWNrZXIvJyArIG5hbWUsIGRhdGEpO1xuICAgIH0sXG5cbiAgICByZW5kZXJQb3B1cDogZnVuY3Rpb24ob3B0aW9ucykgeyAvLyAoT2JqZWN0KSAtPiBTdHJpbmdcbiAgICAgICAgb3B0aW9ucy5wb3B1cCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcihvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgZ2V0UG9wdXA6IGZ1bmN0aW9uKCkgeyAvLyAoKSAtPiBPYmplY3RcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcHVwO1xuICAgIH0sXG5cbiAgICBfZGV0ZWN0Q3NzQW5pbWF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGZhbHNlLFxuICAgICAgICAgICAgZG9tUHJlZml4ZXMgPSAnV2Via2l0IE1veiBPIG1zIEtodG1sJy5zcGxpdCgnICcpLFxuICAgICAgICAgICAgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgaWYgKGVsbS5zdHlsZS5hbmltYXRpb25OYW1lKSB7IGFuaW1hdGlvbiA9IHRydWU7IH1cblxuICAgICAgICBpZiAoYW5pbWF0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21QcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChlbG0uc3R5bGVbZG9tUHJlZml4ZXNbaV0gKyAnQW5pbWF0aW9uTmFtZSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmltYXRpb247XG4gICAgfVxufSk7XG4iLCJERy5HZW9jbGlja2VyLkNvbnRyb2xsZXIgPSBERy5DbGFzcy5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICAvLyBpZiBoYW5kbGVyIHdvcmtlZCBzdWNjZXNzZnVsbHksIGl0IHNob3VsZCByZXR1cm4gcmVuZGVyaW5nIG9iamVjdCB0aGF0IHdpbGwgYmUgcHJvY2Vzc2VkIGluIFZpZXcgLCBvdGhlcndpc2UgaXQgc2hvdWxkIHJldHVybiBmYWxzZVxuICAgICAgICAvLyBkZWZhdWx0IGhhbmRsZXIgYWx3YXlzIHNob3VsZCByZXR1cm4gcmVuZGVyaW5nIG9iamVjdFxuICAgICAgICAnaGFuZGxlcnNTZXF1ZW5jZSc6IHtcbiAgICAgICAgICAgICdwb2knOiBERy5HZW9jbGlja2VyLkhhbmRsZXIuUG9pLFxuICAgICAgICAgICAgJ2F0dHJhY3Rpb24nOiBERy5HZW9jbGlja2VyLkhhbmRsZXIuU2lnaHQsXG4gICAgICAgICAgICAnYnVpbGRpbmcnOiBERy5HZW9jbGlja2VyLkhhbmRsZXIuSG91c2UsXG4gICAgICAgICAgICAnc3RyZWV0JzogREcuR2VvY2xpY2tlci5IYW5kbGVyLkNpdHlBcmVhLFxuICAgICAgICAgICAgJ2FkbV9kaXYucGxhY2UnOiBERy5HZW9jbGlja2VyLkhhbmRsZXIuQ2l0eUFyZWEsXG4gICAgICAgICAgICAnYWRtX2Rpdi5kaXN0cmljdCc6IERHLkdlb2NsaWNrZXIuSGFuZGxlci5DaXR5QXJlYSxcbiAgICAgICAgICAgICdhZG1fZGl2LmRpdmlzaW9uJzogREcuR2VvY2xpY2tlci5IYW5kbGVyLkNpdHlBcmVhLFxuICAgICAgICAgICAgJ2FkbV9kaXYuc2V0dGxlbWVudCc6IERHLkdlb2NsaWNrZXIuSGFuZGxlci5DaXR5QXJlYSxcbiAgICAgICAgICAgICdhZG1fZGl2LmNpdHknOiBERy5HZW9jbGlja2VyLkhhbmRsZXIuQ2l0eUFyZWEsXG5cbiAgICAgICAgICAgICdkZWZhdWx0JzogREcuR2VvY2xpY2tlci5IYW5kbGVyLkRlZmF1bHQsXG5cbiAgICAgICAgICAgICdhcGlFcnJvcic6IERHLkdlb2NsaWNrZXIuSGFuZGxlci5BcGlFcnJvclxuXG4vLyAgICAgICAgICAgIHN0YXRpb25fcGxhdGZvcm1cbi8vICAgICAgICAgICAgcHJvamVjdFxuLy8gICAgICAgICAgICBzdGF0aW9uXG4vLyAgICAgICAgICAgIGNyb3NzYnJvYWRcbi8vICAgICAgICAgICAgbWV0cm9cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihtYXAsIG9wdGlvbnMpIHsgLy8gKE9iamVjdCwgT2JqZWN0KVxuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fY2F0YWxvZ0FwaSA9IG5ldyBERy5HZW9jbGlja2VyLlByb3ZpZGVyLkNhdGFsb2dBcGkobWFwKTtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl92aWV3ID0gbmV3IERHLkdlb2NsaWNrZXIuVmlldyhtYXApO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlckhhbmRsZXJSZXN1bHQgPSBERy5iaW5kKHRoaXMuX3JlbmRlckhhbmRsZXJSZXN1bHQsIHRoaXMpO1xuICAgICAgICB0aGlzLl9sYXN0SGFuZGxlQ2xpY2tBcmd1bWVudHMgPSBudWxsO1xuICAgIH0sXG5cbiAgICBoYW5kbGVQb3B1cENsb3NlOiBmdW5jdGlvbihwb3B1cCkgeyAvLyAoT2JqZWN0KVxuICAgICAgICBpZiAocG9wdXAgPT09IHRoaXMuX3ZpZXcuZ2V0UG9wdXAoKSkge1xuICAgICAgICAgICAgdGhpcy5fbGFzdEhhbmRsZUNsaWNrQXJndW1lbnRzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NhdGFsb2dBcGkuY2FuY2VsTGFzdFJlcXVlc3QoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24obGF0bG5nLCB6b29tLCBtZXRhKSB7IC8vIChPYmplY3QsIE51bWJlciwgT2JqZWN0KVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICBmdW5jdGlvbiBiZWZvcmVSZXF1ZXN0KCkge1xuICAgICAgICAgICAgdmFyIGxvYWRlciA9IHNlbGYuX3ZpZXcuaW5pdExvYWRlcigpO1xuICAgICAgICAgICAgc2VsZi5fdmlldy5fcG9wdXAuY2xlYXIoKTtcbiAgICAgICAgICAgIHNlbGYuX3ZpZXcuc2hvd1BvcHVwKGxhdGxuZywgbG9hZGVyKTtcbiAgICAgICAgICAgIHNlbGYuX2xhc3RIYW5kbGVDbGlja0FyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0YSAmJiBtZXRhLmxpbmtlZCAmJiBtZXRhLmxpbmtlZC50eXBlICE9ICdzaWdodCcgJiYgbWV0YS5saW5rZWQudHlwZSAhPSAnYXR0cmFjdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChtZXRhLmxpbmtlZC50eXBlICE9ICdicmFuY2gnICYmIG1ldGEubGlua2VkLnR5cGUgIT0gJ2J1aWxkaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmVmb3JlUmVxdWVzdCgpO1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgcG9pOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogbWV0YS5saW5rZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NhdGFsb2dBcGkuZ2V0TG9jYXRpb25zKHtcbiAgICAgICAgICAgICAgICBsYXRsbmc6IGxhdGxuZyxcbiAgICAgICAgICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICAgICAgICAgIGJlZm9yZVJlcXVlc3Q6IGJlZm9yZVJlcXVlc3RcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5oYW5kbGVSZXNwb25zZShyZXN1bHQpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmhhbmRsZVJlc3BvbnNlKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZVJlc3BvbnNlOiBmdW5jdGlvbihyZXN1bHQpIHsgLy8gKE9iamVjdClcbiAgICAgICAgdmFyIHR5cGU7XG5cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3J1bkhhbmRsZXIoJ2RlZmF1bHQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgPT09ICdubyB0eXBlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gJ2Fib3J0ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9ydW5IYW5kbGVyKCdhcGlFcnJvcicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdHlwZSA9IHRoaXMuZmluZEhhbmRsZXIocmVzdWx0KTtcblxuICAgICAgICB3aGlsZSAodHlwZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3J1bkhhbmRsZXIodHlwZSwgcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRbdHlwZV07XG5cbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLmZpbmRIYW5kbGVyKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcnVuSGFuZGxlcignZGVmYXVsdCcpO1xuICAgIH0sXG5cbiAgICBmaW5kSGFuZGxlcjogZnVuY3Rpb24ocmVzdWx0KSB7IC8vIChPYmplY3QpIC0+IFN0cmluZ3xOdWxsXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5vcHRpb25zLmhhbmRsZXJzU2VxdWVuY2UpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBnZXRDYXRhbG9nQXBpOiBmdW5jdGlvbigpIHsgLy8gKCkgLT4gT2JqZWN0XG4gICAgICAgIHJldHVybiB0aGlzLl9jYXRhbG9nQXBpO1xuICAgIH0sXG5cbiAgICBnZXRNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwO1xuICAgIH0sXG5cbiAgICByZWludm9rZUhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fbGFzdEhhbmRsZUNsaWNrQXJndW1lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNsaWNrLmFwcGx5KHRoaXMsIHRoaXMuX2xhc3RIYW5kbGVDbGlja0FyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3J1bkhhbmRsZXI6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHsgLy8gKFN0cmluZywgT2JqZWN0KSAtPiBCb29sZWFuXG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgICB0aGlzLl9pbml0SGFuZGxlck9uY2UodHlwZSk7XG4gICAgICAgIHRoaXMuX2hhbmRsZXJzW3R5cGVdLmFkZENsaWNrRXZlbnQoKTtcblxuICAgICAgICB2YXIgaGFuZGxlclJlc3VsdCA9IHRoaXMuX2hhbmRsZXJzW3R5cGVdLmhhbmRsZShkYXRhLCB0eXBlKTtcblxuICAgICAgICByZXR1cm4gaGFuZGxlclJlc3VsdCAmJiBoYW5kbGVyUmVzdWx0LnRoZW4gP1xuICAgICAgICAgICAgaGFuZGxlclJlc3VsdC50aGVuKHRoaXMuX3JlbmRlckhhbmRsZXJSZXN1bHQpIDpcbiAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQ7XG4gICAgfSxcblxuICAgIF9yZW5kZXJIYW5kbGVyUmVzdWx0OiBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgdGhpcy5fdmlldy5yZW5kZXJQb3B1cChyZXN1bHQpO1xuICAgIH0sXG5cbiAgICBfaW5pdEhhbmRsZXJPbmNlOiBmdW5jdGlvbih0eXBlKSB7IC8vIChTdHJpbmcpXG4gICAgICAgIGlmICghdGhpcy5faGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW3R5cGVdID0gbmV3IHRoaXMub3B0aW9ucy5oYW5kbGVyc1NlcXVlbmNlW3R5cGVdKHRoaXMsIHRoaXMuX3ZpZXcsIHRoaXMuX21hcCwgdGhpcy5fb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIkRHLkdlb2NsaWNrZXIuSGFuZGxlci5EZWZhdWx0LkRpY3Rpb25hcnkuaXQgPSBERy5leHRlbmQoe1xuICAgIGFwaUVycm9yVGl0bGU6ICdPaCBvaCwgY1xcJ8OoJm5ic3A7dW4mbmJzcDtlcnJvcmUnLFxuICAgIGFwaUVycm9yQm9keTogJ0kgbm9zdHJpIHNlcnZlciBzaSByaWZpdXRhbm8gZGkgcmlzcG9uZGVyZS4gU3RpYW1vIGZhY2VuZG8gZGVsIG5vc3RybyBtZWdsaW8gcGVyIGNvbnZpbmNlcmxpIGEmbmJzcDtjb21wb3J0YXJzaSBiZW5lLiBSaXRvcm5hIHRyYSBxdWFsY2hlIG1pbnV0by4nLFxuICAgIHdlX2hhdmVfbm90IDogJ05vbiBkaXNwb25pYW1vIGFuY29yYSBkaSBpbmZvcm1hemlvbmkgc3UgcXVlc3RvIHBvc3RvJyxcbiAgICBub25hbWUgOiAnTm9tZSBub24gaW5kaWNhdG8nLFxuICAgICdhZG1fZGl2LnBsYWNlJyA6ICdMdW9nbycsXG4gICAgJ2FkbV9kaXYuZGl2aXNpb24nIDogJ1pvbmEnLFxuICAgICdhZG1fZGl2LnNldHRsZW1lbnQnIDogJ0NvbXVuZScsXG4gICAgc3RyZWV0IDogJ1ZpYScsXG4gICAgJ2FkbV9kaXYuZGlzdHJpY3QnIDogJ011bmljaXBhbGl0w6AnLFxuICAgICdhZG1fZGl2LmNpdHknIDogJ9ChaXR0w6AnLFxuICAgIGdvX3RvIDogJ0NvbWUgYXJyaXZhcmUnLFxuICAgIHNob3dfb3JnYW5pemF0aW9uX2luX2J1aWxkaW5nIDogWyd7bn0gYXppZW5kYSBpbiB0dXR0bycsICd7bn0gYXppZW5kZSBpbiB0dXR0byddLFxuICAgIHNob3dfbW9yZV9hYm91dF9zaWdodCA6ICdNYWdnaW9yaSBpbmZvcm1hemlvbmknLFxuICAgIGJhY2tfYnV0dG9uOiAnSW5kaWV0cm8nLFxuICAgIG5fZmxvb3JzIDogWyd7bn0gcGlhbm8nLCAne259IHBpYW5pJ11cbn0sIERHLkRpY3Rpb25hcnkuaXQpO1xuIiwiREcuR2VvY2xpY2tlci5IYW5kbGVyLkRlZmF1bHQuRGljdGlvbmFyeS5ydSA9IERHLmV4dGVuZCh7XG4gICAgYXBpRXJyb3JUaXRsZTogJ9Ce0YjQuNCx0L7Rh9C60LAg0LLRi9GI0LvQsCcsXG4gICAgYXBpRXJyb3JCb2R5OiAn0J3QsNGI0Lgg0YHQtdGA0LLQtdGA0Ysg0L7RgtC60LDQt9GL0LLQsNGO0YLRgdGPINC+0YLQstC10YfQsNGC0YwuINCc0Ysg0YPQttC1INC/0YDQuNC60LvQsNC00YvQstCw0LXQvCDQstGB0LUg0YHQuNC70YssINGH0YLQvtCx0Ysg0LLRgNCw0LfRg9C80LjRgtGMINC40YUuINCS0L7Qt9Cy0YDQsNGJ0LDQudGC0LXRgdGMINC6Jm5ic3A70L3QsNC8INGH0LXRgNC10LcmbmJzcDvQvdC10YHQutC+0LvRjNC60L4g0LzQuNC90YPRgi4nLFxuICAgIHdlX2hhdmVfbm90IDogJ9Ct0YLQviDQvNC10YHRgtC+INC80Ysg0LXRidGRINC90LUg0YPRgdC/0LXQu9C4INC40LfRg9GH0LjRgtGMJyxcbiAgICBub25hbWU6ICfQkdC10Lcg0L3QsNC30LLQsNC90LjRjycsXG4gICAgJ2FkbV9kaXYucGxhY2UnOiAn0JzQtdGB0YLQvicsXG4gICAgJ2FkbV9kaXYuZGl2aXNpb24nOiAn0J7QutGA0YPQsycsXG4gICAgJ2FkbV9kaXYuc2V0dGxlbWVudCc6ICfQndCw0YHQtdC70LXQvdC90YvQuSDQv9GD0L3QutGCJyxcbiAgICBzdHJlZXQ6ICfQo9C70LjRhtCwJyxcbiAgICAnYWRtX2Rpdi5kaXN0cmljdCc6ICfQoNCw0LnQvtC9JyxcbiAgICAnYWRtX2Rpdi5jaXR5JzogJ9CT0L7RgNC+0LQnLFxuICAgIGdvX3RvOiAn0J/RgNC+0LXRhdCw0YLRjCDRgdGO0LTQsCcsXG4gICAgc2hvd19vcmdhbml6YXRpb25faW5fYnVpbGRpbmc6IFsn0JLRgdC10LPQviB7bn0g0L7RgNCz0LDQvdC40LfQsNGG0LjRjycsICfQktGB0LXQs9C+IHtufSDQvtGA0LPQsNC90LjQt9Cw0YbQuNC4JywgJ9CS0YHQtdCz0L4ge259INC+0YDQs9Cw0L3QuNC30LDRhtC40LknXSxcbiAgICBzaG93X21vcmVfYWJvdXRfc2lnaHQ6ICfQn9C+0LTRgNC+0LHQvdC10LUnLFxuICAgIGJhY2tfYnV0dG9uOiAn0J3QsNC30LDQtCcsXG4gICAgbl9mbG9vcnM6IFsne259INGN0YLQsNC2JywgJ3tufSDRjdGC0LDQttCwJywgJ3tufSDRjdGC0LDQttC10LknXVxufSwgREcuRGljdGlvbmFyeS5ydSk7XG4iLCJERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdC5EaWN0aW9uYXJ5LmVuID0gREcuZXh0ZW5kKHtcbiAgICBhcGlFcnJvclRpdGxlOiAnT29wcyEgRXJyb3IgZGV0ZWN0ZWQuJyxcbiAgICBhcGlFcnJvckJvZHk6ICdPdXIgc2VydmVycyBhcmUgbm90IHJlc3BvbmRpbmcuIFdlIGFyZSBkb2luZyBvdXIgYmVzdCB0byBzdHJhaWdodGVuIHRoZW0gb3V0LiBQbGVhc2UgcmV0dXJuIHRvIHVzIGluIGEgZmV3IG1pbnV0ZXMuJyxcbiAgICB3ZV9oYXZlX25vdDogJ1dlIGhhdmVuXFwndCBjb2xsZWN0ZWQgaW5mbyBhYm91dCB0aGlzIHBsYWNlIHlldCcsXG4gICAgbm9uYW1lIDogJ05vIG5hbWUnLFxuICAgICdhZG1fZGl2LnBsYWNlJyA6ICdQbGFjZScsXG4gICAgJ2FkbV9kaXYuZGl2aXNpb24nIDogJ0FyZWEnLFxuICAgICdhZG1fZGl2LnNldHRsZW1lbnQnIDogJ1ZpbGxhZ2UnLFxuICAgIHN0cmVldCA6ICdTdHJlZXQnLFxuICAgICdhZG1fZGl2LmRpc3RyaWN0JyA6ICdEaXN0cmljdCcsXG4gICAgJ2FkbV9kaXYuY2l0eScgOiAnQ2l0eScsXG4gICAgZ29fdG8gOiAnRGlyZWN0aW9ucyB0byBoZXJlJyxcbiAgICBzaG93X29yZ2FuaXphdGlvbl9pbl9idWlsZGluZyA6IFsne259IG9yZ2FuaXphdGlvbiB0b3RhbCcsICd7bn0gb3JnYW5pemF0aW9ucyB0b3RhbCddLFxuICAgIGJhY2tfYnV0dG9uIDogJ0JhY2snLFxuICAgIHNob3dfbW9yZV9hYm91dF9zaWdodCA6ICdNb3JlIGluZm9ybWF0aW9uJyxcbiAgICBuX2Zsb29ycyA6IFsne259IGZsb29yJywgJ3tufSBmbG9vcnMnXVxufSwgREcuRGljdGlvbmFyeS5lbik7XG4iLCJERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdC5EaWN0aW9uYXJ5LmNzID0gREcuZXh0ZW5kKHtcbiAgICBhcGlFcnJvclRpdGxlOiAnQ2h5YmnEjWthIHNlJm5ic3A7dmxvdWRpbGEnLFxuICAgIGFwaUVycm9yQm9keTogJ05hxaFlIHNlcnZlcnkgb2Rtw610YWrDrSByZWFnb3ZhdC4gSmnFviBueW7DrSB2eW5ha2zDoWTDoW1lIHZlxaFrZXLDqSDDunNpbMOtLCBhYnljaG9tIGplIHDFmWl2ZWRsaSBrIHJvenVtdS4gWmt1c3RlIGFrY2kgb3Bha292YXQgemEgbsSba29saWsgbWludXQuJyxcbiAgICB3ZV9oYXZlX25vdCA6ICdPIHRvbXRvIG3DrXN0xJsgemF0w61tIG5lbcOhbWUgaW5mb3JtYWNlJyxcbiAgICBub25hbWUgOiAnQmV6IG7DoXp2dScsXG4gICAgJ2FkbV9kaXYucGxhY2UnIDogJ03DrXN0bycsXG4gICAgJ2FkbV9kaXYuZGl2aXNpb24nIDogJ1NwcsOhdm7DrSBvYnZvZCcsXG4gICAgJ2FkbV9kaXYuc2V0dGxlbWVudCcgOiAnT2JlYycsXG4gICAgc3RyZWV0IDogJ1VsaWNlJyxcbiAgICAnYWRtX2Rpdi5kaXN0cmljdCcgOiAnTcSbc3Rza8OhIMSNw6FzdCcsXG4gICAgJ2FkbV9kaXYuY2l0eScgOiAnTcSbc3RvJyxcbiAgICBnb190byA6ICdDZXN0YSBzZW0nLFxuICAgIHNob3dfb3JnYW5pemF0aW9uX2luX2J1aWxkaW5nIDogWydDZWxrZW0ge259IG9yZ2FuaXphY2UnLCAnQ2Vsa2VtIHtufSBvcmdhbml6YWNlJywgJ0NlbGtlbSB7bn0gb3JnYW5pemFjw60nXSxcbiAgICBiYWNrX2J1dHRvbiA6ICdacMSbdCcsXG4gICAgc2hvd19tb3JlX2Fib3V0X3NpZ2h0IDogJ1bDrWNlJyxcbiAgICBuX2Zsb29ycyA6IFsne259IHBhdHJvJywgJ3tufSBwYXRyYScsICd7bn0gcGF0ZXInXVxufSwgREcuRGljdGlvbmFyeS5jcyk7XG4iLCJERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdC5EaWN0aW9uYXJ5LmVzID0gREcuZXh0ZW5kKHtcbiAgICBhcGlFcnJvclRpdGxlOiAnVmF5YSwgaGEgb2N1cnJpZG8gdW4gZXJyb3InLFxuICAgIGFwaUVycm9yQm9keTogJ051ZXN0cm9zIHNlcnZpZG9yZXMgc2UgbmllZ2FuIGEgcmVzcG9uZGVyLiBZYSBub3MgZXN0YW1vcyBlc2ZvcnphbmRvIHBvciBoYWNlcmxvcyBlbnRyYXIgZW4gcmF6w7NuLiBWdWVsdmEgY29uIG5vc290cm9zwqBwYXNhZG9zIHVub3MgbWludXRvcy4nLFxuICAgIHdlX2hhdmVfbm90IDogJ1RvZGF2w61hIG5vIGhlbW9zIHJlY29waWxhZG8gbGEgaW5mb3JtYWNpw7NuIHNvYnJlIGVzdGUgbHVnYXInLFxuICAgIG5vbmFtZSA6ICdTaW4gbm9tYnJlJyxcbiAgICAnYWRtX2Rpdi5wbGFjZScgOiAnTHVnYXInLFxuICAgICdhZG1fZGl2LmRpdmlzaW9uJyA6ICdDb211bmEnLFxuICAgICdhZG1fZGl2LnNldHRsZW1lbnQnIDogJ1BvYmxhY2nDs24nLFxuICAgIHN0cmVldCA6ICdDYWxsZScsXG4gICAgJ2FkbV9kaXYuZGlzdHJpY3QnIDogJ0NvbXVuYScsXG4gICAgJ2FkbV9kaXYuY2l0eScgOiAnQ2l1ZGFkJyxcbiAgICBnb190byA6ICdJciBwYXJhIGFsbMOhJyxcbiAgICBzaG93X29yZ2FuaXphdGlvbl9pbl9idWlsZGluZyA6IFsnVG90YWwge259IG9yZ2FuaXphY2nDs24nLCAnVG90YWwge259IG9yZ2FuaXphY2lvbmVzJywgJ1RvdGFsIHtufSBvcmdhbml6YWNpb25lcyddLFxuICAgIHNob3dfbW9yZV9hYm91dF9zaWdodCA6ICdSZWFkIG1vcmUnLFxuICAgIGJhY2tfYnV0dG9uOiAnQXRyw6FzJyxcbiAgICBuX2Zsb29ycyA6IFsne259IHBpc28nLCAne259IHBpc29zJ11cbn0sIERHLkRpY3Rpb25hcnkuZXMpO1xuIiwidmFyIEZpcm1DYXJkID0gZnVuY3Rpb24gKGZpcm0sIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuX2Zpcm1Db250ZW50T2JqZWN0ID0ge307XG4gICAgdGhpcy5fc2NoZWR1bGUgPSBuZXcgRmlybUNhcmQuU2NoZWR1bGUoe1xuICAgICAgICBsb2NhbExhbmc6IHRoaXMub3B0aW9ucy5sYW5nLFxuICAgICAgICBkaWN0OiB0aGlzLmRpY3RcbiAgICB9KTtcblxuICAgIHRoaXMucmVuZGVyKGZpcm0pO1xufTtcblxuRmlybUNhcmQucHJvdG90eXBlID0ge1xuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoZmlybUlkKSB7XG4gICAgICAgIGlmICghZmlybUlkKSB7IHJldHVybjsgfVxuXG4gICAgICAgIGlmIChmaXJtSWQgIT09IHRoaXMuX2Zpcm1JZCkge1xuICAgICAgICAgICAgdGhpcy5fZmlybUNvbnRlbnRPYmplY3QgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckNhcmRCeUlkKGZpcm1JZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZmlybUNvbnRlbnRPYmplY3Q7XG4gICAgfSxcblxuICAgIGdldFNjaGVkdWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZTtcbiAgICB9LFxuXG4gICAgZ2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgfSxcblxuICAgIF9yZW5kZXJDYXJkQnlJZDogZnVuY3Rpb24gKGZpcm1JZCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLmFqYXgoZmlybUlkKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgIGlmICghcmVzKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIGRhdGEgPSByZXMucmVzdWx0Lml0ZW1zO1xuICAgICAgICAgICAgaWYgKGRhdGEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fZmlybURhdGEgPSBkYXRhWzBdO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydCBmb3Igb2xkIFdlYkFQSSBmb3JtYXQuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgY2FsbCBhZnRlciBXZWJBUEkgcmVsZWFzZVxuICAgICAgICAgICAgICAgIHNlbGYuX2NvbnZlcnRXZWJzaXRlKCk7XG5cbiAgICAgICAgICAgICAgICBzZWxmLl9maXJtSWQgPSBmaXJtSWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5fcmVuZGVyRmlybUNhcmQoKTtcbiAgICAgICAgICAgICAgICBzZWxmLl90b2dnbGVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5fcmVuZGVyRXJyb3IoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9jcmVhdGVGaXJtQ29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaXJtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGZpcm0uc2V0QXR0cmlidXRlKCdpZCcsICdkZy1tYXAtZmlybS1mdWxsLScgKyB0aGlzLl9maXJtSWQpO1xuICAgICAgICBmaXJtLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZGctbWFwLWZpcm0tZnVsbCcpO1xuXG4gICAgICAgIHJldHVybiBmaXJtO1xuICAgIH0sXG5cbiAgICBfZ2V0UGF5bWVudFR5cGVzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICBncm91cE5hbWUgPSAnZ2VuZXJhbF9wYXltZW50X3R5cGUnO1xuXG4gICAgICAgIGlmICghZGF0YS5hdHRyaWJ1dGVfZ3JvdXBzKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5hdHRyaWJ1dGVfZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXAubmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JvdXAuYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIudGFnLnN1YnN0cmluZygwLCBncm91cE5hbWUubGVuZ3RoKSA9PT0gZ3JvdXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGF0dHIubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIF9ncm91cFJ1YnJpY3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBwcmltYXJ5OiBbXSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWw6IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFkYXRhLnJ1YnJpY3MgfHwgIWRhdGEucnVicmljcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnJ1YnJpY3MuZm9yRWFjaChmdW5jdGlvbiAocnVicmljKSB7XG4gICAgICAgICAgICByZXN1bHRbcnVicmljLmtpbmRdLnB1c2gocnVicmljKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLy8gU3VwcG9ydCBmb3Igb2xkIFdlYkFQSSBmb3JtYXQuXG4gICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgZnVuY3Rpb24gYWZ0ZXIgV2ViQVBJIHJlbGVhc2VcbiAgICBfY29udmVydFdlYnNpdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maXJtRGF0YS5jb250YWN0X2dyb3Vwcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZmlybURhdGEuY29udGFjdF9ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgICAgIGlmICghZ3JvdXAuY29udGFjdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyb3VwLmNvbnRhY3RzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFjdC50eXBlICE9ICd3ZWJzaXRlJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWN0LnVybCkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWN0LnVybCA9IGNvbnRhY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfcmVuZGVyRmlybUNhcmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZpcm1DYXJkQm9keSwgc2NoZWR1bGUsIGZvcmVjYXN0LCBsaW5rcywgYnRucywgcGF5bWVudFR5cGVzLCBydWJyaWNzLFxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2Zpcm1EYXRhLFxuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5fY3JlYXRlRmlybUNvbnRhaW5lcigpO1xuXG4gICAgICAgIHNjaGVkdWxlID0gdGhpcy5fc2NoZWR1bGUudHJhbnNmb3JtKGRhdGEuc2NoZWR1bGUsIHtcbiAgICAgICAgICAgIHpvbmVPZmZzZXQ6IHRoaXMub3B0aW9ucy50aW1lem9uZU9mZnNldCxcbiAgICAgICAgICAgIGFwaUxhbmc6IHRoaXMub3B0aW9ucy5sYW5nLFxuICAgICAgICAgICAgbG9jYWxMYW5nOiB0aGlzLm9wdGlvbnMubGFuZ1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3JlY2FzdCA9IHRoaXMuX3NjaGVkdWxlLmZvcmVjYXN0KHNjaGVkdWxlKTtcblxuICAgICAgICBwYXltZW50VHlwZXMgPSB0aGlzLl9nZXRQYXltZW50VHlwZXMoZGF0YSk7XG4gICAgICAgIHJ1YnJpY3MgPSB0aGlzLl9ncm91cFJ1YnJpY3MoZGF0YSk7XG5cbiAgICAgICAgZmlybUNhcmRCb2R5ID0gdGhpcy5fYnVpbGRGaXJtQ2FyZEJvZHkoXG4gICAgICAgICAgICB0aGlzLl9nZXRDb25maWdGaXJtQ2FyZEJvZHkoZGF0YSwgc2NoZWR1bGUsIGZvcmVjYXN0LCBwYXltZW50VHlwZXMsIHJ1YnJpY3MpXG4gICAgICAgICk7XG5cbiAgICAgICAgbGlua3MgPSB0aGlzLl9maWxsSGVhZGVyTGlua3MoKTtcbiAgICAgICAgYnRucyA9IHRoaXMuX2ZpbGxGb290ZXJCdXR0b25zKCk7XG5cbiAgICAgICAgLy9maWxsIG9iamVjdCBmb3IgdmlldyByZW5kZXJcbiAgICAgICAgdGhpcy5fZmlybUNvbnRlbnRPYmplY3QuaGVhZGVyID0gdGhpcy5vcHRpb25zLnJlbmRlcignZmlybUNhcmRIZWFkZXInLCB7J2Zpcm1OYW1lJzogZGF0YS5uYW1lLCAnbGlua3MnOiBsaW5rc30pO1xuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gZmlybUNhcmRCb2R5O1xuICAgICAgICB0aGlzLl9maXJtQ29udGVudE9iamVjdC50bXBsID0gY29udGFpbmVyO1xuICAgICAgICBpZiAoYnRucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zvb3RlckNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgICAgICB0aGlzLl9mb290ZXJDb250YWluZXIuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnJlbmRlcigncG9wdXBGb290ZXJCdG5zJywgeydidG5zJzogYnRuc30pO1xuICAgICAgICAgICAgdGhpcy5fZmlybUNvbnRlbnRPYmplY3QuZm9vdGVyID0gdGhpcy5fZm9vdGVyQ29udGFpbmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkZpcm1SZWFkeSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uRmlybVJlYWR5KHRoaXMuX2Zpcm1Db250ZW50T2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVuZGVyRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9maXJtQ29udGVudE9iamVjdC5oZWFkZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyKCdwb3B1cEhlYWRlcicsIHtcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLm9wdGlvbnMudCgnYXBpRXJyb3JUaXRsZScpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2Zpcm1Db250ZW50T2JqZWN0LnRtcGwgPSB0aGlzLm9wdGlvbnMudCgnYXBpRXJyb3JCb2R5Jyk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkZpcm1SZWFkeSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uRmlybVJlYWR5KHRoaXMuX2Zpcm1Db250ZW50T2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZ2V0Q29uZmlnRmlybUNhcmRCb2R5OiBmdW5jdGlvbiAoZGF0YSwgc2NoZWR1bGUsIGZvcmVjYXN0LCBhdHRyaWJ1dGVzLCBydWJyaWNzKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG1wbDogJ2Zpcm1DYXJkQWRkcicsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBkYXRhLmFkZHJlc3NfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudDogZGF0YS5hZGRyZXNzX2NvbW1lbnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRtcGw6ICdmaXJtQ2FyZENvbnRhY3RzJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwczogZGF0YS5jb250YWN0X2dyb3Vwc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG1wbDogJ2Zpcm1DYXJkU2NoZWR1bGUnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGU6IHNjaGVkdWxlLFxuICAgICAgICAgICAgICAgICAgICBmb3JlY2FzdDogZm9yZWNhc3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRtcGw6ICdmcmltQ2FyZFBheW1lbnRzJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHBheW1lbnRzOiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0bXBsOiAnZmlybUNhcmRSdWJyaWMnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcnVicmljczogcnVicmljc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgX2J1aWxkRmlybUNhcmRCb2R5OiBmdW5jdGlvbiAocGFydHMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gcGFydHMucmVkdWNlKGZ1bmN0aW9uIChib2R5LCBpdGVtKSB7XG4gICAgICAgICAgICB2YXIgaHRtbCA9IHNlbGYub3B0aW9ucy5yZW5kZXIoaXRlbS50bXBsLCBpdGVtLmRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGJvZHkgKyBodG1sO1xuICAgICAgICB9LCAnJyk7XG4gICAgfSxcblxuICAgIF9maWxsRm9vdGVyQnV0dG9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnRucyA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja0J0bikge1xuICAgICAgICAgICAgYnRucy5wdXNoKHsgbmFtZTogJ2Zpcm0tY2FyZC1iYWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmRpY3QudCh0aGlzLm9wdGlvbnMubGFuZywgJ2J0bkJhY2snKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93Um91dGVTZWFyY2gpIHtcbiAgICAgICAgICAgIGJ0bnMucHVzaCh7IG5hbWU6ICdnb3RvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmRpY3QudCh0aGlzLm9wdGlvbnMubGFuZywgJ2J0bkZpbmRXYXknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiB0aGlzLm9wdGlvbnMuZ290b1VybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLl9maXJtRGF0YS5saW5rcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2Zpcm1EYXRhLmxpbmtzLmVudHJhbmNlcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zaG93RW50cmFuY2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBidG5zLnB1c2goeyBuYW1lOiAnc2hvdy1lbnRyYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5kaWN0LnQodGhpcy5vcHRpb25zLmxhbmcsICdidG5FbnRyYW5jZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnRucztcbiAgICB9LFxuXG4gICAgX2ZpbGxIZWFkZXJMaW5rczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGlua3MgPSBbXSxcbiAgICAgICAgICAgIHJldmlld0RhdGEgPSB0aGlzLl9maXJtRGF0YS5yZXZpZXdzLFxuICAgICAgICAgICAgYm9va2xldCxcbiAgICAgICAgICAgIGxpbms7XG5cbiAgICAgICAgaWYgKHRoaXMuX2Zpcm1EYXRhLmV4dGVybmFsX2NvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zpcm1EYXRhLmV4dGVybmFsX2NvbnRlbnQuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgZWwudHlwZSA9PSAnYm9va2xldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9va2xldCA9IGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldmlld0RhdGEgJiYgcmV2aWV3RGF0YS5pc19yZXZpZXdhYmxlKSB7XG4gICAgICAgICAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnZmxhbXBfc3RhcnMnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiByZXZpZXdEYXRhLnJhdGluZyAqIDIwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdmbGFtcF9yZXZpZXdzJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5kaWN0LnQodGhpcy5vcHRpb25zLmxhbmcsICdsaW5rUmV2aWV3cycsIHJldmlld0RhdGEucmV2aWV3X2NvdW50ID8gcmV2aWV3RGF0YS5yZXZpZXdfY291bnQgOiAwKSxcbiAgICAgICAgICAgICAgICBocmVmOiBGaXJtQ2FyZC5EYXRhSGVscGVyLmdldEZsYW1wVXJsKHRoaXMuX2Zpcm1JZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0cmlldmUgcGhvdG8gZGF0YSBmcm9tIGV4dGVybmFsIGNvbnRlbnQgYmxvY2tcbiAgICAgICAgdmFyIHBob3RvcztcbiAgICAgICAgdmFyIGV4dGVybmFsQ29udGVudCA9IHRoaXMuX2Zpcm1EYXRhLmV4dGVybmFsX2NvbnRlbnQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHRlcm5hbENvbnRlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBleHRlcm5hbENvbnRlbnRbaV0udHlwZSA9PSAncGhvdG9fYWxidW0nICYmXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxDb250ZW50W2ldLnN1YnR5cGUgPT0gJ2NvbW1vbidcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHBob3RvcyA9IGV4dGVybmFsQ29udGVudFtpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmlzTW9iaWxlICYmIHBob3RvcyAmJiBwaG90b3MuY291bnQgJiYgdGhpcy5vcHRpb25zLnNob3dQaG90b3MpIHtcbiAgICAgICAgICAgIGxpbmsgPSBMLlV0aWwudGVtcGxhdGUoREcuY29uZmlnLnBob3Rvc0xpbmssIHtcbiAgICAgICAgICAgICAgICAnaWQnOiB0aGlzLl9maXJtSWQsXG4gICAgICAgICAgICAgICAgJ2RvbWFpbic6IHRoaXMub3B0aW9ucy5kb21haW5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsaW5rcy5wdXNoKHtuYW1lOiAncGhvdG9zJyxcbiAgICAgICAgICAgICAgICBocmVmOiBsaW5rLFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmRpY3QudCh0aGlzLm9wdGlvbnMubGFuZywgJ2xpbmtQaG90bycsIHBob3Rvcy5jb3VudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNNb2JpbGUgJiYgYm9va2xldCAmJiBib29rbGV0LnVybCAmJiB0aGlzLm9wdGlvbnMuc2hvd0Jvb2tsZXQpIHtcbiAgICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdib29rbGV0JyxcbiAgICAgICAgICAgICAgICBocmVmOiAgYm9va2xldC51cmwsXG4gICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZGljdC50KHRoaXMub3B0aW9ucy5sYW5nLCAnbGlua0Jvb2tsZXQnKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBsaW5rcztcbiAgICB9LFxuXG4gICAgX2V2ZW50czoge1xuICAgICAgICAnZGctcG9wdXBfX2J1dHRvbl9uYW1lX2Zpcm0tY2FyZC1iYWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYmFja0J0bigpO1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRXZlbnRIYW5kbGVycyh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2RnLXBvcHVwX19idXR0b25fbmFtZV9zaG93LWVudHJhbmNlJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZW50ID0gbmV3IHRoaXMub3B0aW9ucy5zaG93RW50cmFuY2Uoeyd2ZWN0b3JzJzogdGhpcy5fZmlybURhdGEubGlua3MuZW50cmFuY2VzWzBdLmdlb21ldHJ5LnZlY3RvcnN9KTtcbiAgICAgICAgICAgIGVudC5hZGRUbyh0aGlzLm9wdGlvbnMubWFwKTtcbiAgICAgICAgICAgIGVudC5maXRCb3VuZHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUV2ZW50SGFuZGxlcnModHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgICdkZy1zY2hlZHVsZV9fdG9kYXknOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX29uVG9nZ2xlU2NoZWR1bGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdG9nZ2xlRXZlbnRIYW5kbGVyczogZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBvcHVwW2ZsYWcgPyAnb2ZmJyA6ICdvbiddKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMubWFwW2ZsYWcgPyAnb2ZmJyA6ICdvbiddKCdwb3B1cGNsb3NlJywgdGhpcy5fb25DbG9zZSwgdGhpcyk7XG4gICAgfSxcblxuICAgIF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZS5vcmlnaW5hbEV2ZW50LnRhcmdldDtcblxuICAgICAgICBmb3IgKHZhciBldmVudENsYXNzIGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudENsYXNzKSAmJiB0YXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoZXZlbnRDbGFzcykgPiAtMSkge1xuICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50Q2xhc3NdLmNhbGwodGhpcywgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uQ2xvc2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZUV2ZW50SGFuZGxlcnModHJ1ZSk7XG4gICAgfSxcblxuICAgIF9vblRvZ2dsZVNjaGVkdWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY2hlZHVsZSA9IHRoaXMuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuZGctc2NoZWR1bGVfX3RhYmxlJyksXG4gICAgICAgICAgICBmb3JlY2FzdCA9IHRoaXMuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuZGctc2NoZWR1bGVfX25vdycpLFxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5kZy1zY2hlZHVsZV9fdG9kYXknKSxcbiAgICAgICAgICAgIHNob3dDbGFzcyA9ICcgZGctc2NoZWR1bGVfX3RvZGF5X3Nob3duX3RydWUnO1xuXG4gICAgICAgIGlmICghc2NoZWR1bGUpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgaWYgKHNjaGVkdWxlLnN0eWxlLmRpc3BsYXkgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICBmb3JlY2FzdC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIHRhcmdldC5jbGFzc05hbWUgPSB0YXJnZXQuY2xhc3NOYW1lLnJlcGxhY2Uoc2hvd0NsYXNzLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JlY2FzdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgc2NoZWR1bGUuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB0YXJnZXQuY2xhc3NOYW1lICs9IHNob3dDbGFzcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMub25Ub2dnbGUpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vblRvZ2dsZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0aW9uLFxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucy5sYW5nID0gb3B0aW9ucy5sYW5nIHx8ICdydSc7XG5cbiAgICAgICAgZm9yIChvcHRpb24gaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1tvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9oYXNUb3VjaDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKCgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHx8XG4gICAgICAgICAgICAgICAgKG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDApIHx8XG4gICAgICAgICAgICAgICAgKG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzID4gMCkpO1xuICAgIH1cbn07XG4iLCJGaXJtQ2FyZC5EYXRhSGVscGVyID0ge1xuXHRwYXlNZXRob2RzIDogW1xuXHRcdCdhbWVyaWNhbmV4cHJlc3MnLFxuXHRcdCdjYXNoJyxcblx0XHQnZGluZXJzY2x1YicsXG5cdFx0J2dvbGRjcm93bicsXG5cdFx0J2ludGVybmV0Jyxcblx0XHQnbWFzdGVyY2FyZCcsXG5cdFx0J25vbmNhc2gnLFxuXHRcdCd2aXNhJ1xuXHRdLFxuXG5cdF9tc2dzIDoge30sXG5cblx0Z2V0RmxhbXBVcmwgOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHJldHVybiBERy5jb25maWcuZmxhbXBVcmwuY29uY2F0KGlkLCAnPycsIERHLmNvbmZpZy5mbGFtcEdvb2dsZUFuYWx5dGljcyk7XG5cdH0sXG5cblx0bXNnIDogZnVuY3Rpb24gKG1zZykge1xuXHRcdGlmICh0aGlzLl9tc2dzLmhhc093blByb3BlcnR5KG1zZykpIHtcblx0XHRcdHJldHVybiB0aGlzLl9tc2dzW21zZ107XG5cdFx0fVxuXHRcdGNvbnNvbGUgJiYgY29uc29sZS5sb2coXCJDYW50J3QgZmluZCB0cmFuc2xhdGlvbiBmb3IgJ1wiICsgbXNnICsgXCInLlwiKTtcblx0XHRyZXR1cm4gbXNnLnRvU3RyaW5nKCkucmVwbGFjZSgnXycsICcgJyk7XG5cdH0sXG5cblx0Z2V0UHJvamVjdFRpbWU6IGZ1bmN0aW9uICh0aW1lem9uZU9mZnNldCwgdGltZSkge1xuICAgICAgICB2YXIgbm93LCB1dGM7XG5cbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICAgIG5vdyA9IG5ldyBEYXRlKHRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aW1lem9uZU9mZnNldCkge1xuICAgICAgICAgICAgdXRjID0gbm93LmdldFRpbWUoKSArIChub3cuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh1dGMgKyAoNjAwMDAgKiB0aW1lem9uZU9mZnNldCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vdztcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIvKiBnbG9iYWxcbiAgICBGaXJtQ2FyZDogZmFsc2VcbiovXG4oZnVuY3Rpb24gKCkge1xuICAgIEZpcm1DYXJkLkxpc3QgPSBmdW5jdGlvbiAoZmlybXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fZmlybXMgPSB7fTsgLy8geydmaXJtSUQnOiBmaXJtRG9tT2JqfVxuICAgICAgICB0aGlzLl9zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZGctYnVpbGRpbmctY2FsbG91dF9fbGlzdCcpO1xuXG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcnNJbml0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmlybUNhcmQgPSB0aGlzLl9jcmVhdGVGaXJtKCk7XG4gICAgICAgIHRoaXMucmVuZGVyTGlzdChmaXJtcyk7XG4gICAgfTtcblxuICAgIEZpcm1DYXJkLkxpc3QucHJvdG90eXBlID0ge1xuXG4gICAgICAgIHJlbmRlckxpc3Q6IGZ1bmN0aW9uIChmaXJtcykge1xuICAgICAgICAgICAgaWYgKGZpcm1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRmlybXMoZmlybXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkxpc3RSZWFkeSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkxpc3RSZWFkeSh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9wcm9jZXNzRmlybXM6IGZ1bmN0aW9uIChmaXJtcywgYWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWZpcm1zKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgdmFyIG1ldGhvZCA9ICdfJyArIGFjdGlvbiArICdGaXJtJztcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0FycmF5KGZpcm1zKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZmlybXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kXShmaXJtc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZF0oZmlybXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkRmlybXM6IGZ1bmN0aW9uKGZpcm1zKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzRmlybXMoZmlybXMsICdhZGQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVGaXJtczogZnVuY3Rpb24oZmlybXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NGaXJtcyhmaXJtcywgJ3JlbW92ZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldExhbmc6IGZ1bmN0aW9uIChuZXdMYW5nKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlybUNhcmQubGFuZyA9IG5ld0xhbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGFuZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maXJtQ2FyZC5sYW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhckxpc3QgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9maXJtcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRXZlbnRIYW5kbGVycyh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyQ29udGFpbmVyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlbW92ZUZpcm06IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9maXJtc1tpZF0pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fZmlybXNbaWRdKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9maXJtc1tpZF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FkZEZpcm06IGZ1bmN0aW9uIChmaXJtRGF0YSkge1xuICAgICAgICAgICAgdmFyIHRtcGwgPSB0aGlzLm9wdGlvbnMuZmlybWxpc3RJdGVtVG1wbCxcbiAgICAgICAgICAgICAgICBkb21GaXJtLCBmaXJtLCBjb250ZW50O1xuXG4gICAgICAgICAgICBmaXJtID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGZpcm1EYXRhLm5hbWUsXG4gICAgICAgICAgICAgICAgaWQ6IGZpcm1EYXRhLmlkLnNwbGl0KCdfJykuc2xpY2UoMCwgMSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICghKGZpcm0uaWQgaW4gdGhpcy5fZmlybXMpKSB7XG5cbiAgICAgICAgICAgICAgICBkb21GaXJtID0gdGhpcy5fY3JlYXRlTGlzdEl0ZW0oKTtcblxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0bXBsID8gdGhpcy5vcHRpb25zLmZpcm1DYXJkLnJlbmRlcih0bXBsLCB7J2Zpcm0nOiBmaXJtfSkgOiBmaXJtLm5hbWU7XG5cbiAgICAgICAgICAgICAgICBkb21GaXJtLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgY29udGVudCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9maXJtc1tmaXJtLmlkXSA9IGRvbUZpcm07XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGRvbUZpcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9jcmVhdGVMaXN0SXRlbTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2RnLWJ1aWxkaW5nLWNhbGxvdXRfX2xpc3QtaXRlbScpO1xuXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSxcblxuICAgICAgICBfaXNBcnJheTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICAgICAgfSxcblxuICAgICAgICBfY3JlYXRlRmlybTogZnVuY3Rpb24gKGZpcm1EYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpcm1DYXJkKGZpcm1EYXRhLCB0aGlzLm9wdGlvbnMuZmlybUNhcmQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pc0VtcHR5T2JqOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2V2ZW50czoge1xuICAgICAgICAgICAgJ2RnLXBvcHVwX19saW5rJzogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLl9maXJtQ2FyZC5yZW5kZXIodGFyZ2V0LmlkKTtcblxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maXJtQ2FyZFt0aGlzLl9pc0VtcHR5T2JqKHMpID8gJ3Bhc3RlTG9hZGVyJyA6ICdvbkZpcm1SZWFkeSddKHMpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpcm1DYXJkLm9uRmlybUNsaWNrICYmIHRoaXMub3B0aW9ucy5maXJtQ2FyZC5vbkZpcm1DbGljaygpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRXZlbnRIYW5kbGVycyh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZGctYnVpbGRpbmctY2FsbG91dF9fbGlzdC1pdGVtJzogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzWydkZy1wb3B1cF9fbGluayddLmNhbGwodGhpcywgdGFyZ2V0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZGctcG9wdXBfX2J1dHRvbl9uYW1lX2JhY2snOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlybUNhcmQub25TaG93TGVzcygpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRXZlbnRIYW5kbGVycyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfdG9nZ2xlRXZlbnRIYW5kbGVycyA6IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlybUNhcmQucG9wdXBbZmxhZyA/ICdvZmYnIDogJ29uJ10oJ2NsaWNrJywgdGhpcy5fb25DbGljaywgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS5vcmlnaW5hbEV2ZW50LnRhcmdldDtcblxuICAgICAgICAgICAgZm9yICh2YXIgZXZlbnRDbGFzcyBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50Q2xhc3MpICYmIHRhcmdldC5jbGFzc05hbWUuaW5kZXhPZihldmVudENsYXNzKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1tldmVudENsYXNzXS5jYWxsKHRoaXMsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NsZWFyQ29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuXG4gICAgICAgICAgICB3aGlsZSAoY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3NldE9wdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maXJtQ2FyZCB8fCAodGhpcy5vcHRpb25zLmZpcm1DYXJkID0ge30pO1xuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZmlybUNhcmQubGFuZykge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maXJtQ2FyZC5sYW5nID0gJ3J1JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1tvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuIiwiLypnbG9iYWxcbiAgICBGaXJtQ2FyZDpmYWxzZVxuKi9cbkZpcm1DYXJkLlNjaGVkdWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMubG9jYWxMYW5nID0gb3B0aW9ucy5sb2NhbExhbmcgfHwgJ3J1JztcbiAgICB0aGlzLmRpY3QgPSBvcHRpb25zLmRpY3Q7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5GaXJtQ2FyZC5TY2hlZHVsZS5wcm90b3R5cGUgPSB7XG5cbiAgICBzZXRMYW5nOiBmdW5jdGlvbiAobGFuZykge1xuICAgICAgICB0aGlzLmxvY2FsTGFuZyA9IGxhbmcgfHwgJ3J1JztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gKG1vZGVsLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgICAgICBmdW5jdGlvbiBiaW5kKGZuLCBvYmopIHsgLy8gKEZ1bmN0aW9uLCBPYmplY3QpIC0+IEZ1bmN0aW9uXG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MgfHwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9kYXlLZXksIC8vIE1vbiwgVHVlIC4uLlxuICAgICAgICAgICAgdG9kYXksIC8vINCe0LHRitC10LrRgiDQvNC+0LTQtdC70LggLSDRgtC10LrRg9GJ0LjQuSDQtNC10L3RjCDQvdC10LTQtdC70LhcbiAgICAgICAgICAgIGZyb20sIC8vINCh0LDQvNC+0LUg0YDQsNC90L3QtdC1INCy0YDQtdC80Y8g0L7RgtC60YDRi9GC0LjRjyDQt9CwINC00LXQvdGMXG4gICAgICAgICAgICB0bywgLy8g0KHQsNC80L7QtSDQv9C+0LfQtNC90LXQtSDQstGA0LXQvNGPINC30LDQutGA0YvRgtC40Y8g0LfQsCDQtNC10L3RjFxuICAgICAgICAgICAgem9uZU9mZnNldCA9IHBhcmFtcy56b25lT2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBzY2hlZHVsZSA9IHt9LCAvLyDQntCx0YrQtdC60YIt0YDQsNGB0L/QuNGB0LDQvdC40LUsINGE0L7RgNC80LjRgNGD0LXQvNGL0Lkg0L/QvtC0INGI0LDQsdC70L7QvVxuICAgICAgICAgICAgbm93ID0gcGFyYW1zLm5vdyB8fCBGaXJtQ2FyZC5EYXRhSGVscGVyLmdldFByb2plY3RUaW1lKHpvbmVPZmZzZXQpLmdldFRpbWUoKSwgLy8gQ3VycmVudCB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICB3ZWVrS2V5cyA9IFtdLCAvLyDQmtC70Y7Rh9C4INC00L3QtdC5INC90LXQtNC10LvQuCwg0L7Qv9GA0LXQtNC10LvRj9GO0YIg0L/QvtGA0Y/QtNC+0Log0LTQvdC10Lkg0Lgg0L/QtdGA0LLRi9C5INC00LXQvdGMINC90LXQtNC10LvQuC4gMCAtINC/0LXRgNCy0YvQuSDQtNC10L3RjCDQvdC10LTQtdC70Lgg0LIg0YDQtdCz0LjQvtC90LUgKNC90LUg0L7QsdGP0LfQsNGC0LXQu9GM0L3QviBNb24pXG4gICAgICAgICAgICB3ZWVrS2V5c0xvY2FsID0gW10sXG4gICAgICAgICAgICB3ZWVrRnVsbEtleXNMb2NhbCA9IFtdLFxuICAgICAgICAgICAgd2Vla0tleXNTaG9ydCA9ICBbICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCcsICdTdW4nIF0sXG4gICAgICAgICAgICB3ZWVrS2V5c0Z1bGwgPSBbJ21vbmRheScsJ3R1ZXNkYXknLCd3ZWRuZXNkYXknLCd0aHVyc2RheScsJ2ZyaWRheScsJ3NhdHVyZGF5Jywnc3VuZGF5J10sXG4gICAgICAgICAgICBsb2NhbExhbmcgPSBwYXJhbXMubG9jYWxMYW5nIHx8IHRoaXMubG9jYWxMYW5nLFxuICAgICAgICAgICAgbG9jYWxXb3JraW5nRGF5cyA9IHBhcmFtcy5sb2NhbFdvcmtpbmdEYXlzIHx8IFswLCAxLCAxLCAxLCAxLCAxLCAwXSxcbiAgICAgICAgICAgIGZpcnN0ZGF5T2Zmc2V0ID0gcGFyYW1zLmZpcnN0ZGF5T2Zmc2V0IHx8IDEsXG4gICAgICAgICAgICBtaW5Ib3Vyc1RvRGlzcGxheUNsb3N1cmUgPSBwYXJhbXMubWluSG91cnNUb0Rpc3BsYXlDbG9zdXJlIHx8IDQsXG4gICAgICAgICAgICB0ID0gYmluZCh0aGlzLmRpY3QudCwgdGhpcy5kaWN0KTtcblxuXG4gICAgICAgIGZ1bmN0aW9uIGNhcGl0YWxpc2VGaXJzdExldHRlcihzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRIb3VycyhzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TWludXRlcyhzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyKDMsIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g0JrQvtC90LLQtdGA0YLQsNGG0LjRjyDQstGA0LXQvNC10L3QvdC+0Lkg0YLQvtGH0LrQuCDRhNC+0YDQvNCw0YLQsCDQsNC/0Lgg0LIg0YTQvtGA0LzQsNGCINC+0YLQvtCx0YDQsNC20LXQvdC40Y8gKDI1OjAwIC0+IDAxOjAwKVxuICAgICAgICBmdW5jdGlvbiBmb3JtYXRUaW1lKHN0cikge1xuICAgICAgICAgICAgdmFyIGhvdXJzID0gK2dldEhvdXJzKHN0cikgJSAyNCArICcnO1xuXG4gICAgICAgICAgICBpZiAoaG91cnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaG91cnMgPSAnMCcgKyBob3VycztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGhvdXJzICsgJzonICsgZ2V0TWludXRlcyhzdHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g0JrQvtC90LLQtdGA0YLQsNGG0LjRjyBpbnQg0YfQuNGB0LvQsCDQsiDQvdC+0LzQtdGAINC00L3RjyDQvdC10LTQtdC70LggKNC00LjQsNC/0LDQt9C+0L0gMC02KVxuICAgICAgICAvLyDQvtGC0YDQuNGG0LDRgtC10LvRjNC90YvQtSDRh9C40LvQsDogLTEg0LLQtdGA0L3RkdGCIDYsIC0yIC0+IDUg0Lgg0YIu0LRcbiAgICAgICAgLy8g0L/QvtC70L7QttC40YLQtdC70YzQvdGL0LU6IDcgLT4gMCwgOCAtPiAxXG4gICAgICAgIGZ1bmN0aW9uIGRheU51bShuKSB7XG4gICAgICAgICAgICByZXR1cm4gKG4gKyA3MCkgJSA3O1xuICAgICAgICB9XG5cblxuICAgICAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICAgICAgIC8vINCS0L7Qt9Cy0YDQsNGJ0LDQtdGCINC/0L7RgdC70LXQtNC90LjQuSDRjdC70LXQvNC10L3RgiDQvNCw0YHRgdC40LLQsFxuICAgICAgICAvLyDQktC30Y/RgtC+INC40LcgVW5kZXJzY29yZS5qcyBodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jbGFzdFxuICAgICAgICBmdW5jdGlvbiBnZXRBcnJheUxhc3QoYXJyLCBuKSB7XG4gICAgICAgICAgICBpZiAoIGFyciA9PSBudWxsICkgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgIGlmICggICBuID09IG51bGwgKSByZXR1cm4gYXJyWyBhcnIubGVuZ3RoIC0gMSBdO1xuICAgICAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoIGFyciwgTWF0aC5tYXgoYXJyLmxlbmd0aCAtIG4gLCAwKSApO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyDQktGL0L/QvtC70L3Rj9C10YIg0LPQu9GD0LHQvtC60L7QtSDRgdGA0LDQstC90LXQvdC40LUg0L7QsdGK0LXQutGC0L7QslxuICAgICAgICAvLyDQktC30Y/RgtC+INC40LcgVW5kZXJzY29yZS5qcyBodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jaXNFcXVhbFxuICAgICAgICAvLyDQo9C/0YDQvtGJ0LXQvdC+INC00LvRjyDRgtC10YUg0YLRgNGR0YUg0YHRgNCw0LLQvdC10L3QuNC5LCDQutC+0YLQvtGA0YvQtSDQstGL0L/QvtC70L3Rj9GO0YLRgdGPINCyIFNoZWR1bGUuanNcbiAgICAgICAgZnVuY3Rpb24gaXNFcXVhbChvYmoxLCBvYmoyKSB7XG4gICAgICAgICAgICBpZiAoIG9iajEgPT09IG9iajIgKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICggISAoIG9iajEgaW5zdGFuY2VvZiBPYmplY3QgKSB8fCAhICggb2JqMiBpbnN0YW5jZW9mIE9iamVjdCApICkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCBvYmoxLmNvbnN0cnVjdG9yICE9PSBvYmoyLmNvbnN0cnVjdG9yICkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yICggdmFyIHByb3AgaW4gb2JqMSApIHtcbiAgICAgICAgICAgICAgICBpZiAoICEgb2JqMS5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKCAhIG9iajIuaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIG9iajFbIHByb3AgXSA9PT0gb2JqMlsgcHJvcCBdICkgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YoIG9iajFbIHByb3AgXSApICE9PSBcIm9iamVjdFwiICkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICggISBpc0VxdWFsKCBvYmoxWyBwcm9wIF0sICBvYmoyWyBwcm9wIF0gKSApIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoIHByb3AgaW4gb2JqMiApIHtcbiAgICAgICAgICAgIGlmICggb2JqMi5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICYmICEgb2JqMS5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgICAgICAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgICAgICAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgICAgICAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcCA9IGFyZ3VtZW50c1syXSB8fCAxO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgd2hpbGUoaWR4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByYW5nZVtpZHgrK10gPSBzdGFydDtcbiAgICAgICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8v0JfQsNC/0L7Qu9C90Y/QtdGCINGB0LLQvtC50YHRgtCy0LAg0L7QsdGK0LXQutGC0LAg0LfQvdCw0YfQtdC90LjRj9C80Lgg0L/QviDRg9C80L7Qu9GH0LDQvdC40Y5cbiAgICAgICAgLy/QktC30Y/RgtC+INC40LcgVW5kZXJzY29yZS5qcyBodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jZGVmYXVsdHNcbiAgICAgICAgZnVuY3Rpb24gZmlsbERlZmF1bHRzKG9iaikge1xuICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmpbcHJvcF0gPT09IHZvaWQgMCkgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cblxuICAgICAgICAvL9Ch0L7RgNGC0LjRgNGD0LXRgiDQt9C90LDRh9C10L3QuNGPINGB0L7Qs9C70LDRgdC90L4g0YEg0LjRgtC10YDQsNGC0L7RgNC+0LxcbiAgICAgICAgLy/QktC30Y/RgtC+INGBIFVuZGVyc2NvcmUuanMgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI3NvcnRCeVxuICAgICAgICBmdW5jdGlvbiBzb3J0Qnkob2JqLCBpdGVyYXRvcil7XG4gICAgICAgICAgICByZXR1cm4gcGx1Y2sob2JqLm1hcCggZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyaXRlcmlhOiBpdGVyYXRvci5jYWxsKHRoaXMsIHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgICAgICAgICAgICAgIH0pLCAndmFsdWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbiAgICAgICAgZnVuY3Rpb24gcGx1Y2soYXJyLCBrZXkpe1xuICAgICAgICAgICAgdmFyIGksIHJ2ID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBydltpXSA9IGFycltpXVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyDQn9GA0LXQvtCx0YDQsNC30L7QstCw0YLRjCDRgNCw0YHQv9C40YHQsNC90LjQtSDQvdCwINC00LXQvdGMINCyINGD0L/QvtGA0Y/QtNC+0YfQtdC90L3Ri9C5INC80LDRgdGB0LjQsiDQstGA0LXQvNC10L3QvdGL0YUg0L7RgtGB0LXRh9C10LogKHN0cmluZylcbiAgICAgICAgLy8g0KHQtdC50YfQsNGBINC/0L7Qu9Cw0LPQsNC10YLRgdGPLCDRh9GC0L4gQVBJINGD0LbQtSDQstGL0LTQsNGR0YIg0YHQvtGA0YLQuNGA0L7QstCw0L3QvdGL0Lkg0LzQsNGB0YHQuNCyXG4gICAgICAgIGZ1bmN0aW9uIGdldFNvcnRlZFRpbWVQb2ludHMoZGF5KSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW10sXG4gICAgICAgICAgICAgICAgZnJvbSwgdG8sXG4gICAgICAgICAgICAgICAgZGVsdGFIb3VycywgZGVsdGFNaW51dGVzO1xuXG4gICAgICAgICAgICBpZiAoIWRheSB8fCAhZGF5LndvcmtpbmdfaG91cnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGRheS53b3JraW5nX2hvdXJzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgICAgIGZyb20gPSBkYXkud29ya2luZ19ob3Vyc1tpXS5mcm9tO1xuICAgICAgICAgICAgICAgIHRvID0gZGF5LndvcmtpbmdfaG91cnNbaV0udG87XG5cbiAgICAgICAgICAgICAgICBkZWx0YUhvdXJzID0gZ2V0SG91cnModG8pIC0gZ2V0SG91cnMoZnJvbSk7XG4gICAgICAgICAgICAgICAgZGVsdGFNaW51dGVzID0gZ2V0TWludXRlcyh0bykgLSBnZXRNaW51dGVzKGZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChkZWx0YUhvdXJzIDwgMCB8fCAoZGVsdGFIb3VycyA9PT0gMCAmJiBkZWx0YU1pbnV0ZXMgPD0gMCkpIHsgLy8g0JXRgdC70LggXCLQtNC+XCIg0LzQtdC90YzRiNC1INC40LvQuCDRgNCw0LLQvdC+IFwi0L7RglwiIC0g0LfQvdCw0YfQuNGCINGD0LrQsNC30YvQstCw0LXRgiDQvdCwINC30LDQstGC0YDQsFxuICAgICAgICAgICAgICAgICAgICB0byA9ICgrZ2V0SG91cnModG8pICsgMjQpICsgJzonICsgZ2V0TWludXRlcyh0byk7IC8vICgwMTowMCAtPiAyNTowMClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwb2ludHNbaSAqIDJdID0ge1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiBmcm9tLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnb3BlbidcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvaW50c1tpICogMiArIDFdID0ge1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiB0byxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZGF5LndvcmtpbmdfaG91cnMubGVuZ3RoIC0gMSA9PT0gaSA/ICdjbG9zZScgOiAnbHVuY2gnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vINCS0L7Qt9Cy0YDQsNGJ0LDQtdGCINC80LDRgdGB0LjQsiB0aW1lc3RhbXAg0LLRgdC10YUg0YLQvtGH0LXQuiwg0LLRgdC10YUg0LTQvdC10Lkg0L3QtdC00LXQu9C4LCDQvtGCINGB0LXQs9C+0LTQvdGP0YjQvdC10LPQviDQuCDQsiDQsdGD0LTRg9GJ0LXQtVxuICAgICAgICAvLyDQndCw0L/RgNC40LzQtdGALCDRgdC10LPQvtC00L3RjyDRgdGA0LXQtNCwLCDQvtGC0YHQtdGH0LrQuCDQsdGD0LTRg9GCINCy0LfRj9GC0Ysg0LTQu9GPINC00LDRgiDRgdC+INGB0YDQtdC00YsgKNGB0LXQs9C+0LTQvdGPKSDQv9C+INGB0LvQtdC00YPRjtGJ0LjQuSDQstGC0L7RgNC90LjQuiDQstC60LvRjtGH0LjRgtC10LvRjNC90L5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VGltZVN0YW1wcyhtb2RlbCkge1xuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcHMgPSBbXSxcbiAgICAgICAgICAgICAgICBvdXQgPSBbXSxcbiAgICAgICAgICAgICAgICB0aW1lUG9pbnRzLFxuICAgICAgICAgICAgICAgIG51bSA9IHdlZWtLZXlzLmluZGV4T2YodG9kYXlLZXkpOyAvLyDQndC+0LzQtdGAINGB0LXQs9C+0LTQvdGP0YjQvdC10LPQviDQtNC90Y8g0L3QtdC00LXQu9C4ICjQtNC70Y8g0LTQsNC90L3QvtCz0L4g0YDQtdCz0LjQvtC90LApXG5cblxuICAgICAgICAgICAgLy8g0KbQuNC60Lsg0L/QviDQtNC90Y/QvCDQvdC10LTQtdC70Lgg0L3QsNGH0LjQvdCw0Y8g0YEg0YHQtdCz0L7QtNC90Y/RiNC90LXQs9C+XG4gICAgICAgICAgICB2YXIgajsgLy8g0J3QvtC80LXRgCDRgtC10LrRg9GJ0LXQs9C+INC00L3RjyDQsiDQvNCw0YHRgdC40LLQtSB3ZWVrS2V5c1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgNyA7IGkrKykge1xuICAgICAgICAgICAgICAgIGogPSBkYXlOdW0obnVtICsgaSk7XG4gICAgICAgICAgICAgICAgdGltZVBvaW50cyA9IGdldFNvcnRlZFRpbWVQb2ludHMobW9kZWxbd2Vla0tleXNbal1dKTtcbiAgICAgICAgICAgICAgICAvLyDQptC40LrQuyDQv9C+INGC0L7Rh9C60LDQvCDQstGA0LXQvNC10L3QuCDRgSDQutC+0L3QstC10YDRgtCw0YbQuNC10Lkg0LIgdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgdGltZVBvaW50cy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgICAvKiBqc2hpbnQgLVcwODMgKi9cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdyAtINC+0LHRj9C30LDRgtC10LvRjNC90L4hINC40L3QsNGH0LUg0LHRg9C00LXRgiDQsdGA0LDRgtGM0YHRjyDRgtC10LrRg9GJ0LjQuSB0aW1lc3RhbXAg0YfRgtC+INGH0YDQtdCy0LDRgtC+INC90LXRgdC+0LLQv9Cw0LTQtdC90LjRj9C80Lgg0L/RgNC4INC80LXQtNC70LXQvdC90L7QvCDQsdGL0YHRgtGA0L7QtNC10LnRgdGC0LLQuNC4XG4gICAgICAgICAgICAgICAgICAgIC8vINCS0YvRh9C40YHQu9C40YLRjCDRgtCw0LnQvNGB0YLQtdC80L8g0LTQu9GPINC00LDQvdC90L7Qs9C+INC00L3RjyDQvdC10LTQtdC70LgsINGH0LDRgdCwINC4INC80LjQvdGD0YLRiywg0LIg0LHRg9C00YPRidC10LwsINC90L4g0LHQu9C40LbQsNC50YjQuNC5INC6IG5vd1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHNwID0gbmV3IERhdGUobm93KTtcbiAgICAgICAgICAgICAgICAgICAgdHNwLnNldERhdGUodHNwLmdldERhdGUoKStpKTtcbiAgICAgICAgICAgICAgICAgICAgdHNwLnNldEhvdXJzKGdldEhvdXJzKHBvaW50LnRpbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgdHNwLnNldE1pbnV0ZXMoZ2V0TWludXRlcyhwb2ludC50aW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cyA9IHRzcC5nZXRUaW1lKCk7XG5cblxuXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0czogdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBwb2ludC50eXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0gJiYgdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDQn9Cw0YDQvdC+INGD0LTQsNC70Y/QtdC8INGB0L7QstC/0LDQtNCw0Y7RidC40LUg0YLQvtGH0LrQuCAo0L7QvdC4INC90LUg0LjQvNC10Y7RgiDRgdC80YvRgdC70LAgLSDRjdGC0L4g0YHQtdCz0L7QtNC90Y8gMjQ6MDAg0Lgg0LfQsNCy0YLRgNCwIDAwOjAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXS50cyA9PT0gdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDJdLnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXBzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXSAmJiB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vINCf0LDRgNC90L4g0L/QtdGA0LXQvdC+0YHQuNC8INGC0L7Rh9C60Lgg0LIg0LHRg9C00YPRidC10LUsINC10YHQu9C4INC+0L3QuCDQvtCx0LUg0LIg0L/RgNC+0YjQu9C+0LwgKNC/0LXRgNCy0LDRjyDRgtC+0YfQutCwIChbMF0pINC00L7Qu9C20L3QsCDQsdGL0YLRjCDQstGB0LXQs9C00LAg0L7RgtC60YDRi9GC0LjQtdC8ISlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0udHMgPD0gbm93ICYmIHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAyXS50cyA8PSBub3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0udHMgKz0gKDcgKiAyNCAqIDYwICogNjAgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMl0udHMgKz0gKDcgKiAyNCAqIDYwICogNjAgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgK1cwODMgKi9cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDQodC+0YDRgtC40YDRg9C10Lwg0L3QsCDQstC+0LfRgNCw0YHRgtCw0L3QuNC1LCDQstC10LTRjCDQstC+0LfQvNC+0LbQvdC+INCx0YvQu9C4INC/0LXRgNC10L3QvtGB0Ysg0LIg0LHRg9C00YPRidC10LVcbiAgICAgICAgICAgIHRpbWVzdGFtcHMgPSBzb3J0QnkodGltZXN0YW1wcywgZnVuY3Rpb24gKHRpbWVzdGFtcCkgeyByZXR1cm4gdGltZXN0YW1wLnRzOyB9KTtcblxuICAgICAgICAgICAgLy8g0KPQtNCw0LvRj9C10Lwg0L/QvtC/0LDRgNC90L4g0YHQvtCy0L/QsNC00LDRjtGJ0LjQtSDRgtC+0YfQutC4INCy0YDQtdC80LXQvdC4XG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZXN0YW1wc1tpICsgMV0gJiYgdGltZXN0YW1wc1tpXS50cyA9PT0gdGltZXN0YW1wc1tpICsgMV0udHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKHRpbWVzdGFtcHNbaV0udHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vINCf0YDQvtCy0LXRgNC60LAg0L3QsCDQtdC20LXQtNC90LXQstC90L4t0LrRgNGD0LPQu9C+0YHRg9GC0L7Rh9C90L7RgdGC0YxcbiAgICAgICAgICAgIGlmIChvdXQubGVuZ3RoID09PSAyICYmIChvdXRbMV0gLSBvdXRbMF0pID09PSAoNyAqIDI0ICogNjAgKiA2MCAqIDEwMDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHdoZW5PcGVuSW52ZXJzZShoLCBkLCBudW0pIHtcbiAgICAgICAgICAgIGlmIChkID09PSAxICYmIGggPiBtaW5Ib3Vyc1RvRGlzcGxheUNsb3N1cmUgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQobG9jYWxMYW5nLCAndG9tbW9yb3cnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgLVcwMTUgKi9cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG51bSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiB0KGxvY2FsTGFuZywgJ25leHRTdW4nKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gdChsb2NhbExhbmcsICduZXh0TW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIHQobG9jYWxMYW5nLCAnbmV4dFR1ZScpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiB0KGxvY2FsTGFuZywgJ25leHRXZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gdChsb2NhbExhbmcsICduZXh0VGh1Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHQobG9jYWxMYW5nLCAnbmV4dEZyaScpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiB0KGxvY2FsTGFuZywgJ25leHRTYXQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyoganNoaW50ICtXMDE1ICovXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy/QktC+0LfQstGA0LDRidCw0LXRgiDQuNC90YLQtdGA0LLQsNC7INCyINGG0LXQu9GL0YUg0LTQvdGP0YUsINGBINC/0L7Qv9GA0LDQstC60L7QuSDQvdCwINGB0LzQtdC90YMg0LTQvdGPINCyINC/0L7Qu9C90L7Rh9GMLCDQvNC10LbQtNGDXG4gICAgICAgIC8vIEBwYXJhbSB0aW1lc3RhbXBFbmQg0LggQHBhcmFtIGRhdGVTdGFydFxuICAgICAgICBmdW5jdGlvbiBkYXlJbnRlcnZhbCh0aW1lc3RhbXBFbmQsIGRhdGVTdGFydCkge1xuXG4gICAgICAgICAgICB2YXIgb25lRGF5ID0gMTAwMCAqIDYwICogNjAgKiAyNCxcbiAgICAgICAgICAgICAgICBkYXRlRW5kID0gbmV3IERhdGUodGltZXN0YW1wRW5kLnRzKTtcblxuICAgICAgICAgICAgdmFyIGRpZmY7XG5cbiAgICAgICAgICAgIGRpZmYgPSBNYXRoLnJvdW5kKChkYXRlRW5kIC0gZGF0ZVN0YXJ0KSAvIG9uZURheSk7XG5cbiAgICAgICAgICAgIGlmKCB0aW1lc3RhbXBFbmQudHlwZT09PSdvcGVuJyAmJiBkYXRlRW5kLmdldEhvdXJzKCkgPCAxIClcbiAgICAgICAgICAgICAgICB7IGRpZmYgKys7IH1cblxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vINCf0L7QvNC10YHRgtC40YLRjCDQtNCw0L3QvdGL0LUg0LIg0L7QsdGK0LXQutGCINC00LvRjyDRiNCw0LHQu9C+0L3QsCDQviDRgdC10LPQvtC00L3Rj9GI0L3QtdC8INC00L3QtVxuICAgICAgICBmdW5jdGlvbiBzZXRUb2RheVN0cmluZyh0b2RheSkge1xuXG4gICAgICAgICAgICB2YXIgdGltZVBvaW50cyxcbiAgICAgICAgICAgICAgICBwZXJpb2RzID0gW10sXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wcztcblxuICAgICAgICAgICAgc2NoZWR1bGUubm93ID0ge307XG5cbiAgICAgICAgICAgIC8vIFRpbWVzdGFtcHMg0LLRgdC10YUg0L7RgtGB0LXRh9C10LpcbiAgICAgICAgICAgIHRpbWVzdGFtcHMgPSBnZXRUaW1lU3RhbXBzKG1vZGVsKTtcblxuICAgICAgICAgICAgaWYgKCF0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlLmFsd2F5cyA9IHRydWU7IC8vINCg0LDQsdC+0YLQsNC10YIg0LXQttC10LTQvdC10LLQvdC+INC60YDRg9Cz0LvQvtGB0YPRgtC+0YfQvdC+XG4gICAgICAgICAgICAgICAgc2NoZWR1bGUubm93Lm9wZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IHRpbWVzdGFtcHMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8g0J/QvtC/0LDQu9C4INC80LXQttC00YMg0YLQvtGH0LrQsNC80LggaS0xINC4IGkgLy8g0JzRiyDQvdCw0YXQvtC00LjQvNGB0Y8g0LfQsNCy0LXQtNC+0LzQviDQsiDQsdGD0LTRg9GJ0LXQvCDQvtGC0L3QvtGB0LjRgtC10LvRjNC90L4gMVxuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gKHRpbWVzdGFtcHNbaSAtIDFdICYmIHRpbWVzdGFtcHNbaSAtIDFdLnRzIHx8IDApICYmIG5vdyA8IHRpbWVzdGFtcHNbaV0udHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBNYXRoLmZsb29yKCh0aW1lc3RhbXBzW2ldLnRzIC0gbm93KSAvICgxMDAwICogNjAgKiA2MCkpLCAvLyDQmtC+0LvQuNGH0LXRgdGC0LLQviDRh9Cw0YHQvtCyINC00L4g0YHQu9C10LTRg9GO0YnQtdCz0L4gdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gTWF0aC5mbG9vcigodGltZXN0YW1wc1tpXS50cyAtIG5vdykgLyAoMTAwMCAqIDYwKSAtIGggKiA2MCksIC8vINCa0L7Qu9C40YfQtdGB0YLQstC+INC80LjQvdGD0YIgKNCx0LXQtyDRh9Cw0YHQvtCyKSDQtNC+INGB0LvQtdC00YPRjtGJ0LXQs9C+IHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF5Tm93ID0gbmV3IERhdGUobm93KSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g0L7RgtC60YDRi9GC0L4g0LXRgdC70Lgg0YHQu9C10LTRg9GO0YnQsNGPINC40YLQtdGA0LDRhtC40Y8g0L3QtSDQvtGC0LrRgNGL0YLQuNC1XG4gICAgICAgICAgICAgICAgICAgICAgICBub3dJc09wZW4gPSB0aW1lc3RhbXBzW2ldLnR5cGUgIT09ICdvcGVuJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgZCA9IGRheU9mWWVhcihkYXlUcykgLSBkYXlPZlllYXIoZGF5Tm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFyIGQgPSBkYXlJbnRlcnZhbChkYXlUcywgZGF5Tm93LCBub3dJc09wZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBkYXlJbnRlcnZhbCh0aW1lc3RhbXBzW2ldLCBkYXlOb3cpO1xuXG5cblxuICAgICAgICAgICAgICAgICAgICAvLyDQvtC60YDRg9Cz0LvRj9C10Lwg0LzQuNC90YPRgtGLINC00L4g0LrRgNCw0YLQvdGL0YUgNVxuICAgICAgICAgICAgICAgICAgICBtID0gTWF0aC5mbG9vcihtIC8gMTApICogMTAgPyBNYXRoLmZsb29yKG0gLyAxMCkgKiAxMCA6IDU7XG5cbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGUubm93Lm9wZW4gPSBub3dJc09wZW47XG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlLm5vdy5sdW5jaCA9ICEhKHRpbWVzdGFtcHNbaSAtIDFdICYmIHRpbWVzdGFtcHNbaSAtIDFdLnR5cGUgPT09ICdsdW5jaCcgfHwgZ2V0QXJyYXlMYXN0KHRpbWVzdGFtcHMpLnR5cGUgPT09ICdsdW5jaCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlLndpbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWxsVHlwZTogdGltZXN0YW1wc1tpXS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGg6IGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBtOiBtXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8g0JrQvtCz0LTQsCDQt9Cw0LrRgNC+0LXRgtGB0Y8g0LjQu9C4INC+0YLQutGA0L7QtdGC0YHRj1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2lsbFdoZW4gPSBuZXcgRGF0ZSh0aW1lc3RhbXBzW2ldLnRzKTtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGUud2lsbC53aGVuID0gd2hlbk9wZW5JbnZlcnNlKGgsIGQsIHdpbGxXaGVuLmdldERheSgpKTtcblxuXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWxsVGlsbCA9IG5ldyBEYXRlKHRpbWVzdGFtcHNbaV0udHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RySG91cnMgPSB3aWxsVGlsbC5nZXRIb3VycygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyTWludXRlcyA9IHdpbGxUaWxsLmdldE1pbnV0ZXMoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RySG91cnMgPCAxMCkgeyBzdHJIb3VycyA9ICcwJyArIHN0ckhvdXJzOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJNaW51dGVzIDwgMTApIHsgc3RyTWludXRlcyA9ICcwJyArIHN0ck1pbnV0ZXM7IH1cblxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZS53aWxsLnRpbGwgPSBzdHJIb3VycysnOicrc3RyTWludXRlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdG9kYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vINCd0LAg0YHQtdCz0L7QtNC90Y8g0YDQsNGB0L/QuNGB0LDQvdC40Y8g0L3QtdGCIC0g0YHQtdC50YfQsNGBINC30LDQutGA0YvRgtC+XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRpbWVQb2ludHMgPSBwbHVjayhnZXRTb3J0ZWRUaW1lUG9pbnRzKHRvZGF5KSwgJ3RpbWUnKTtcblxuICAgICAgICAgICAgLy8g0KbQuNC60Lsg0L/QviDQv9C10YDQuNC+0LTQsNC8INGA0LDQsdC+0YLRiyDQt9CwINC00LXQvdGMXG4gICAgICAgICAgICBmb3IgKGkgPSAyIDsgaSA8IHRpbWVQb2ludHMubGVuZ3RoIDsgaSA9IGkgKyAyKSB7XG4gICAgICAgICAgICAgICAgcGVyaW9kcy5wdXNoKHsgZnJvbTogdGltZVBvaW50c1tpIC0gMV0sIHRvOiB0aW1lUG9pbnRzW2ldIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcm9tID0gZm9ybWF0VGltZSh0aW1lUG9pbnRzWzBdKTtcbiAgICAgICAgICAgIHRvID0gZm9ybWF0VGltZSh0aW1lUG9pbnRzW3RpbWVQb2ludHMubGVuZ3RoIC0gMV0pO1xuXG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHsgLy8g0JrRgNGD0LPQu9C+0YHRg9GC0L7Rh9C90L5cbiAgICAgICAgICAgICAgICBzY2hlZHVsZS50b2RheSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYWxsdGltZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsdGltZVN0cjogdChsb2NhbExhbmcsICd3b3Jrc0Fyb3VuZFRoZUNsb2NrJyksXG4gICAgICAgICAgICAgICAgICAgIGZyb206ICcwMDowMCcsXG4gICAgICAgICAgICAgICAgICAgIHRvOiAnMjQ6MDAnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vINCe0YIgZnJvbSDQtNC+IHRvXG4gICAgICAgICAgICAgICAgc2NoZWR1bGUudG9kYXkgPSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0b1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwZXJpb2RzLmxlbmd0aCA+IDApIHsgLy8g0J/QtdGA0LXRgNGL0LLRiyDQvdCwINC+0LHQtdC0XG4gICAgICAgICAgICAgICAgc2NoZWR1bGUubHVuY2ggPSBwZXJpb2RzO1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlLmx1bmNoU3RyID0gdChsb2NhbExhbmcsICdsdW5jaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g0KTQvtGA0LzQuNGA0L7QstCw0L3QuNC1INC+0LHRitC10LrRgtCwLdGC0LDQsdC70LjRhtGLLdGA0LDRgdC/0LjRgdCw0L3QuNGPINC00LvRjyDRiNCw0LHQu9C+0L3QsFxuICAgICAgICBmdW5jdGlvbiBtYWtlVGFibGUoKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gW10sXG4gICAgICAgICAgICAgICAgaGFzTHVuY2ggPSBmYWxzZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAgOyBqIDwgNyA7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBkYXlLZXkgPSB3ZWVrS2V5c1tqXSxcbiAgICAgICAgICAgICAgICAgICAgbHVuY2hNYXhMZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgICAgY29sdW1uW2pdID0ge307XG5cbiAgICAgICAgICAgICAgICBpZiAobW9kZWxbZGF5S2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF5ID0gbW9kZWxbZGF5S2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVQb2ludHMgPSBwbHVjayhnZXRTb3J0ZWRUaW1lUG9pbnRzKGRheSksICd0aW1lJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBsdW5jaCA9IFtdOyAvLyDQntGC0YDQtdC30LrQuCDQstGA0LXQvNC10L3QuCAo0L7RgtGB0L7RgNGC0LjRgNC+0LLQsNC90L3Ri9C1INC80L7QvNC10L3RgtGLKSDQvdCwINC+0LHQtdC00YtcblxuICAgICAgICAgICAgICAgICAgICAvLyDQptC40LrQuyDQv9C+INC/0LXRgNC40L7QtNCw0Lwg0YDQsNCx0L7RgtGLINC30LAg0LTQtdC90YxcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDIgOyBpIDwgdGltZVBvaW50cy5sZW5ndGggOyBpID0gaSArIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0x1bmNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGx1bmNoLnB1c2goeyBmcm9tOiB0aW1lUG9pbnRzW2kgLSAxXSwgdG86IHRpbWVQb2ludHNbaV0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbHVuY2hNYXhMZW5ndGggPSBNYXRoLm1heCh0aW1lUG9pbnRzLmxlbmd0aCAvIDIsIGx1bmNoTWF4TGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5bal0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBmb3JtYXRUaW1lKHRpbWVQb2ludHNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IGZvcm1hdFRpbWUodGltZVBvaW50c1t0aW1lUG9pbnRzLmxlbmd0aCAtIDFdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGx1bmNoOiBsdW5jaFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkYXlLZXkgPT09IHRvZGF5S2V5KSB7IC8vINCh0LXQs9C+0LTQvdGP0YjQvdC40Lkg0LTQtdC90Ywg0L3QsNC00L4g0L/QvtC00YHQstC10YLQuNGC0YxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uW2pdLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29sdW1uW2pdLmtleSA9IHdlZWtLZXlzTG9jYWxbal07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vINCU0L7Qv9C+0LvQvdC10L3QuNC1INC/0YPRgdGC0YvQvNC4INC+0LHRitC10LrRgtCw0LzQuCDQvNCw0YHRgdC40LLQvtCyIGx1bmNoXG4gICAgICAgICAgICBjb2x1bW4uZm9yRWFjaCggZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICAgICAgICAgIGlmIChjb2wubHVuY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbERlZmF1bHRzKGNvbC5sdW5jaCwgcmFuZ2UoMSwgbHVuY2hNYXhMZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0YWJsZTogY29sdW1uLFxuICAgICAgICAgICAgICAgIGhhc0x1bmNoOiBoYXNMdW5jaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vINCh0LPQtdC90LXRgNC40YDQvtCy0LDRgtGMINGB0YLRgNC+0LrRgyDQtNC70Y8g0LLRgdC10YUg0LTQvdC10LkgbW9kZWwsINGB0L7QstC/0LDQtNCw0Y7RidC40YUg0YEgZGF5XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VTaW1wbGVTdHJpbmcoZGF5LCBtb2RlbCkge1xuICAgICAgICAgICAgdmFyIHBvaW50cyxcbiAgICAgICAgICAgICAgICBvdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRheUxpc3Q6IFtdLFxuICAgICAgICAgICAgICAgICAgICBsdW5jaDogW11cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGx1bmNoZXNUaW1lID0gW107XG5cbiAgICAgICAgICAgIGlmIChkYXkgJiYgZGF5LndvcmtpbmdfaG91cnMgJiYgZGF5LndvcmtpbmdfaG91cnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gcGx1Y2soZ2V0U29ydGVkVGltZVBvaW50cyhkYXkpLCAndGltZScpO1xuICAgICAgICAgICAgICAgIHBvaW50cy5mb3JFYWNoKCBmdW5jdGlvbiAocG9pbnQsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQuZnJvbSA9IGZvcm1hdFRpbWUocG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gcG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC50byA9IGZvcm1hdFRpbWUocG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbHVuY2hlc1RpbWUucHVzaChmb3JtYXRUaW1lKHBvaW50KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGx1bmNoZXNUaW1lLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5sdW5jaC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IGx1bmNoZXNUaW1lW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IGx1bmNoZXNUaW1lW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGx1bmNoU3RyOiBjYXBpdGFsaXNlRmlyc3RMZXR0ZXIodChsb2NhbExhbmcsICdsdW5jaCcpKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3V0LmZyb20gPT0gJzAwOjAwJyAmJiBvdXQudG8gPT0gJzAwOjAwJykge1xuICAgICAgICAgICAgICAgICAgICBvdXQudG8gPSAnMjQ6MDAnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkYXkucm91bmRfdGhlX2Nsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5hbGx0aW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb3V0LmFsbHRpbWVTdHIgPSB0KGxvY2FsTGFuZywgJ3dvcmtzQXJvdW5kVGhlQ2xvY2snKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyDQktGL0YXQvtC00L3QvtC5XG4gICAgICAgICAgICAgICAgb3V0LmhvbGlkYXkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDQpNC+0YDQvNC40YDRg9C10Lwg0YHQv9C40YHQvtC6INC00L3QtdC5INC90LAg0LvQvtC60LDQu9GM0L3QvtC8INGP0LfRi9C60LVcbiAgICAgICAgICAgIHZhciBncm91cFdvcmtpbmdEYXlzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDBdOyAvLyDQpNC70LDQs9C4INGA0LDQsdC+0YLRiyDRhNC40YDQvNGLINCyINC00L3QuCDRgtC10LrRg9GJ0LXQuSDQs9GA0YPQv9C/0YtcbiAgICAgICAgICAgIHZhciBmbG93ID0gMDtcblxuICAgICAgICAgICAgd2Vla0tleXMuZm9yRWFjaCggZnVuY3Rpb24gKGRheUtleSwgbnVtS2V5KSB7IC8vICdNb24nLCAwXG4gICAgICAgICAgICAgICAgaWYgKGlzRXF1YWwobW9kZWxbZGF5S2V5XSwgZGF5KSB8fCAoIW1vZGVsW2RheUtleV0gJiYgZGF5ID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXQuZGF5TGlzdC5wdXNoKHdlZWtGdWxsS2V5c0xvY2FsW251bUtleV0pO1xuICAgICAgICAgICAgICAgICAgICBncm91cFdvcmtpbmdEYXlzW2RheU51bShudW1LZXkgKyBmaXJzdGRheU9mZnNldCldID0gMTtcbiAgICAgICAgICAgICAgICAgICAgZmxvdysrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbG93ID4gMikgeyAvLyDQkdC+0LvQtdC1IDIg0LTQvdC10Lkg0L/QvtC00YDRj9C0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdERheSA9IG91dC5kYXlMaXN0LnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMSA7IGkgPCBmbG93IC0gMSA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dC5kYXlMaXN0LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQuZGF5TGlzdFtvdXQuZGF5TGlzdC5sZW5ndGggLSAxXSArPSAnIOKAlCAnICsgbGFzdERheTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZsb3cgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyDQodC/0LjRgdC+0Log0LTQvdC10Lkg0LIg0LTQsNC90L3QvtC5INCz0YDRg9C/0L/QtSDQuNC00LXQvdGC0LjRh9C10L0g0YHQv9C40YHQutGDINCx0YPQtNC90LjRhSDQtNC90LXQuSwg0LfQvdCw0YfQuNGCINC80L7QttC90L4g0LfQsNC80LXQvdC40YLRjCDRgdC70L7QstC+0LwgXCLQkdGD0LTQvdC4XCJcbiAgICAgICAgICAgIG91dC5idWRuaSA9IGlzRXF1YWwobG9jYWxXb3JraW5nRGF5cywgZ3JvdXBXb3JraW5nRGF5cyk7XG4gICAgICAgICAgICAvLyDQodC/0LjRgdC+0Log0YDQsNCx0L7Rh9C40YUg0LTQvdC10LkgLSDQstGB0LUg0LTQvdC4INC90LXQtNC10LvQuCwg0LfQvdCw0YfQuNGCINC90YPQttC90L4g0LLRi9Cy0L7QtNC40YLRjCDRhNGA0LDQt9GDIFwi0JXQttC10LTQvdC10LLQvdC+XCJcbiAgICAgICAgICAgIG91dC5ldmVyeWRheSA9ICggTWF0aC5taW4uYXBwbHkoTWF0aCwgZ3JvdXBXb3JraW5nRGF5cykgPT09IDEgKTtcblxuICAgICAgICAgICAgaWYgKCBvdXQuaG9saWRheSApIHsgb3V0LmhvbGlkYXlTdHIgPSB0KGxvY2FsTGFuZywgJ3Jlc3REYXknLCBvdXQuZGF5TGlzdC5sZW5ndGgpLnNsaWNlKDIpOyB9XG5cbiAgICAgICAgICAgIC8vINCU0LXQu9Cw0LXQvCDQuNC3INC80LDRgdGB0LjQstCwINGB0YLRgNC+0LrRgyDQuCDQv9C+0LTQvdC40LzQsNC10Lwg0L/QtdGA0LLRi9C5INGB0LjQvNCy0L7Qu1xuICAgICAgICAgICAgb3V0LmRheUxpc3QgPSBvdXQuZGF5TGlzdC5qb2luKCcsICcpO1xuICAgICAgICAgICAgb3V0LmRheUxpc3QgPSBvdXQuZGF5TGlzdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG91dC5kYXlMaXN0LnNsaWNlKDEpO1xuXG5cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQktC+0LfQstGA0LDRidCw0LXRgiDQvNCw0YHRgdC40LIgc2ltcGxlINGB0YLRgNC+0Log0L3QsCDQvtGB0L3QvtCy0LUg0LzQsNGB0YHQuNCy0LAg0LTQvdC10LkgZGF5c1xuICAgICAgICBmdW5jdGlvbiBtYWtlQWR2YW5jZWRTdHJpbmcoZGF5cywgbW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRheXMubGVuZ3RoIC0gMSA7IGkgPj0gMCA7IGktLSkge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKG1ha2VTaW1wbGVTdHJpbmcoZGF5c1tpXSwgbW9kZWwpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vINCX0LDQv9C+0LvQvdGP0LXQvCDQvdCw0LfQstCw0L3QuNGPINC00L3QtdC5INC90LXQtNC10LvQuCwgMSAtINC/0L7QvdC10LTQtdC70YzQvdC40LouINCSINC30LDQv9C+0LvQvdC10L3QvdGL0YUg0LzQsNGB0YHQuNCy0LDRhSDQv9C+0L3QtdC00LXQu9GM0L3QuNC6INGN0YLQviAwXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgNyA7IGkrKykge1xuICAgICAgICAgICAgd2Vla0tleXNbaV0gPSB3ZWVrS2V5c1Nob3J0W2ldO1xuICAgICAgICAgICAgd2Vla0tleXNMb2NhbFtpXSA9IHRoaXMuZGljdC50KGxvY2FsTGFuZywgd2Vla0tleXNTaG9ydFtpXS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIHdlZWtGdWxsS2V5c0xvY2FsW2ldID0gdGhpcy5kaWN0LnQobG9jYWxMYW5nLCB3ZWVrS2V5c0Z1bGxbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g0JLRi9GH0LjRgdC70Y/QtdC8INGB0LXQs9C+0LTQvdGP0YjQvdC40Lkg0LTQtdC90Ywg0L3QtdC00LXQu9C4ICjRgdGB0YvQu9C60YMg0L3QsCDQvtCx0YrQtdC60YIg0LTQvdGPINCyINC80L7QtNC10LvQuClcbiAgICAgICAgdG9kYXlLZXkgPSB3ZWVrS2V5c1Nob3J0W2RheU51bShuZXcgRGF0ZShub3cpLmdldERheSgpIC0gZmlyc3RkYXlPZmZzZXQpXTtcbiAgICAgICAgdG9kYXkgPSBtb2RlbFt0b2RheUtleV07IC8vINCe0LHRitC10LrRgiDRgNCw0YHQv9C40YHQsNC90LjRjyAtINGC0LXQutGD0YnQuNC5INC00LXQvdGMINC90LXQtNC10LvQuFxuICAgICAgICBzZXRUb2RheVN0cmluZyh0b2RheSk7IC8vINCh0LTQtdC70LDRgtGMINC+0LHRitC10LrRgiDQtNC70Y8g0YjQsNCx0LvQvtC90LAgLSDRgdGC0YDQvtC60LAsINC60L7RgtC+0YDQsNGPINC+0L/QuNGB0YvQstCw0LXRgiDQstGA0LXQvNGPINGA0LDQsdC+0YLRiyDRgdC10LPQvtC00L3Rj1xuXG4gICAgICAgIC8vINCd0LDRhdC+0LTQuNC8INC60L7Qu9C40YfQtdGB0YLQstC+INGA0LDQt9C90YvRhSDRgNCw0YHQv9C40YHQsNC90LjQuSDQuCDRgdC+0YXRgNCw0L3Rj9C10Lwg0LjRhSDQsiDQvNCw0YHRgdC40LJcbiAgICAgICAgdmFyIGFwaURpZmZlcmVudERheXMgPSBbXSwgLy8g0JzQsNGB0YHQuNCyINGA0LDQt9C70LjRh9Cw0Y7RidC40YXRgdGPINC00L3QtdC5INC40Lcg0LzQvtC00LXQu9C4XG4gICAgICAgICAgICBhcGlTY2hlZHVsZURheXNDb3VudCA9IDAsIC8vINCa0L7Qu9C40YfQtdGB0YLQstC+INC+0L/QuNGB0LDQvdC90YvRhSDQtNC90LXQuSDQsiDRgNCw0YHQv9C40YHQsNC90LjQuCDQvNC+0LTQtdC70LhcbiAgICAgICAgICAgIGFwaURpZmZlcmVudERheXNDb3VudCA9IDAsIC8vINCa0L7Qu9C40YfQtdGB0YLQstC+INGA0LDQt9C90YvRhSDQtNC90LXQuSDQsiDRgNCw0YHQv9C40YHQsNC90LjQuCDQvNC+0LTQtdC70LhcbiAgICAgICAgICAgIGRpZmZlcmVudFdvcmtpbmdIb3Vyc0NvdW50ID0gW107IC8vINCa0L7Qu9C40YfQtdGB0YLQstC+INGA0LDQsdC+0YfQuNGFINGH0LDRgdC+0LIg0LIg0YDQsNC30L3Ri9GFINC00L3Rj9GFXG5cbiAgICAgICAgT2JqZWN0LmtleXMobW9kZWwpLmZvckVhY2goIGZ1bmN0aW9uKGRheSkge1xuICAgICAgICAgICAgaWYgKG1vZGVsW2RheV0gJiYgbW9kZWxbZGF5XS53b3JraW5nX2hvdXJzKSB7IC8vINCf0YDQvtCy0LXRgNGP0LXQvCDRh9GC0L4g0Y3RgtC+INC00LXQvdGMLCDQsCDQvdC1INC60L7QvNC80LXQvdGC0LDRgNC40Lkg0LjQu9C4INGH0YLQvi3RgtC+INC10YnRkVxuICAgICAgICAgICAgICAgIGFwaVNjaGVkdWxlRGF5c0NvdW50Kys7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsKG1vZGVsW2RheV0sIGdldEFycmF5TGFzdChhcGlEaWZmZXJlbnREYXlzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpRGlmZmVyZW50RGF5cy5wdXNoKG1vZGVsW2RheV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXBpRGlmZmVyZW50RGF5c0NvdW50ID0gYXBpRGlmZmVyZW50RGF5cy5sZW5ndGg7XG4gICAgICAgIC8vINCV0YHQu9C4INC90LUg0LLRgdC1INC00L3QuCDQvtC/0LjRgdCw0L3RiyDQsiDQvNC+0LTQtdC70LgsINC30L3QsNGH0LjRgiDQtdGB0YLRjCDQtdGJ0ZEg0L7QtNC40L0g0YLQuNC/INC00L3QtdC5IC0g0LLRi9GF0L7QtNC90L7QuSAo0L7RgtGB0YPRgtGB0YLQstGD0YnQuNC5INCyINC80L7QtNC10LvQuClcbiAgICAgICAgaWYgKGFwaVNjaGVkdWxlRGF5c0NvdW50IDwgNykge1xuICAgICAgICAgICAgYXBpRGlmZmVyZW50RGF5c0NvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQldGB0LvQuCDRgNCw0LfQvdGL0YUg0LHQvtC70LXQtSAyLCDRgtC+INGD0L/RgNC+0YHRgtC40YLRjCDQvdC1INC/0L7Qu9GD0YfQuNGC0YHRjyAtINC00LXQu9Cw0LXQvCDRgtCw0LHQu9C40YbRg1xuICAgICAgICBpZiAoYXBpRGlmZmVyZW50RGF5c0NvdW50ID4gMikge1xuICAgICAgICAgICAgc2NoZWR1bGUud2VlayA9IG1ha2VUYWJsZShtb2RlbCk7XG4gICAgICAgIH0gZWxzZSB7IC8vINCY0L3QsNGH0LUsINGB0L7RgdGC0LDQstC70Y/QtdC8INC60L7QvNC80LXQvdGC0LDRgNC40Lkg0LjQtyDQtNCy0YPRhSDRgdGC0YDQvtC6XG5cbiAgICAgICAgICAgIC8vINCh0LvRg9GH0LDQuSwg0LrQvtCz0LTQsCDQstGB0LUg0L7QtNC40L3QsNC60L7QstGL0LVcbiAgICAgICAgICAgIGlmIChhcGlEaWZmZXJlbnREYXlzQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZS53ZWVrID0ge1xuICAgICAgICAgICAgICAgICAgICBldmVudGx5OiBbbWFrZVNpbXBsZVN0cmluZyhtb2RlbFt3ZWVrS2V5c1swXV0sIG1vZGVsKV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8g0J7RgdGC0LDRkdGC0YHRjyDRgdC70YPRh9Cw0LksINC60L7Qs9C00LAg0LXRgdGC0Ywg0LTQstCwINGC0LjQv9CwINC00L3QtdC5XG4gICAgICAgICAgICAgICAgLy8g0J7Qv9GA0LXQtNC10LvRj9C10Lwg0LTQtdC90Ywg0YEg0L3QsNC40LHQvtC70YzRiNC40Lwg0LrQvtC70LjRh9C10YHRgtCy0L7QvCDRgNCw0LHQvtGH0LjRhSDRh9Cw0YHQvtCyINC40Lcg0YfQuNGB0LvQsCDRgNCw0LfQvdGL0YUg0LTQvdC10LlcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwIDsgaSA8IGFwaURpZmZlcmVudERheXNDb3VudCA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkaWZmZXJlbnRXb3JraW5nSG91cnNDb3VudFtpXSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFwaURpZmZlcmVudERheXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBwbHVjayhnZXRTb3J0ZWRUaW1lUG9pbnRzKGFwaURpZmZlcmVudERheXNbaV0pLCAndGltZScpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCA7IGogPCBwb2ludHMubGVuZ3RoIDsgaiA9IGogKyAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhvdXJzID0gKGdldEhvdXJzKHBvaW50c1tqICsgMV0pICsgZ2V0TWludXRlcyhwb2ludHNbaiArIDFdKSAvIDYwKSAtIChnZXRIb3Vycyhwb2ludHNbal0pICsgZ2V0TWludXRlcyhwb2ludHNbal0pIC8gNjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZlcmVudFdvcmtpbmdIb3Vyc0NvdW50W2ldICs9IGhvdXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyDQktGL0YXQvtC00L3QvtC5XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGlEaWZmZXJlbnREYXlzW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBhcGlTb3J0ZWREaWZmZXJlbnREYXlzID0gc29ydEJ5KGFwaURpZmZlcmVudERheXMsIGZ1bmN0aW9uIChkYXksIGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlmZmVyZW50V29ya2luZ0hvdXJzQ291bnRba2V5XTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHNjaGVkdWxlLndlZWsgPSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50bHk6IG1ha2VBZHZhbmNlZFN0cmluZyhhcGlTb3J0ZWREaWZmZXJlbnREYXlzLCBtb2RlbClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2NoZWR1bGUuY29tbWVudCA9IG1vZGVsLmNvbW1lbnQ7XG4gICAgICAgIGlmIChzY2hlZHVsZS53ZWVrICYmIHNjaGVkdWxlLndlZWsuZXZlbnRseSAmJiBzY2hlZHVsZS53ZWVrLmV2ZW50bHkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBzY2hlZHVsZS5ldmVyeWRheSA9IHNjaGVkdWxlLndlZWsuZXZlbnRseVswXS5ldmVyeWRheTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZWR1bGU7XG4gICAgfSxcblxuICAgIGZvcmVjYXN0OiBmdW5jdGlvbiAoc2NoZWR1bGUsIHBhcmFtcykge1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSAnJyxcbiAgICAgICAgb3BlbixcbiAgICAgICAgdG9kYXkgPSB7fSxcbiAgICAgICAgbm93VGV4dCxcbiAgICAgICAgbWF4SG91cnMgPSBwYXJhbXMgJiYgcGFyYW1zLm1heEhvdXJzIHx8IDE7XG5cbiAgICAgICAgaWYgKCFzY2hlZHVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjaGVkdWxlLmFsd2F5cykgeyAvLyDQmtGA0YPQs9C70L7RgdGD0YLQvtGH0L3QviDQtdC20LXQtNC90LXQstC90L4gLSDQsdC+0LvQtdC1INC90LjRh9C10LPQviDQstGL0LLQvtC00LjRgtGMINC90LUg0L3Rg9C20L3QvlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b2RheToge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ2Fyb3VuZFRoZUNsb2NrJylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wZW46IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQpNC+0YDQvNC40YDRg9C10Lwg0YHRgtGA0L7QutGDIC0g0YfQtdGA0LXQtyDRgdC60L7Qu9GM0LrQviDQv9GA0L7QuNC30L7QudC00ZHRgiDRgdC70LXQtNGD0Y7RidCw0Y8g0LjQvdCy0LXRgNGB0LjRjyDQvtGC0LrRgNGL0YLQvtGB0YLQuFxuICAgICAgICBpZiAoc2NoZWR1bGUud2lsbCAmJiBzY2hlZHVsZS53aWxsLmggPCBtYXhIb3Vycykge1xuICAgICAgICAgICAgaWYgKHNjaGVkdWxlLndpbGwuaCkge1xuICAgICAgICAgICAgICAgIGludGVydmFsICs9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnbkhvdXJzJywgc2NoZWR1bGUud2lsbC5oKSArICcgJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVkdWxlLndpbGwubSkge1xuICAgICAgICAgICAgICAgIGludGVydmFsICs9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnbk1pbnMnLCBzY2hlZHVsZS53aWxsLm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g0JTQsNC90L3Ri9C1INC90LAg0YHQtdCz0L7QtNC90Y9cbiAgICAgICAgaWYgKHNjaGVkdWxlLnRvZGF5KSB7XG4gICAgICAgICAgICB0b2RheS50ZXh0ID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICd0b2RheScpO1xuICAgICAgICAgICAgaWYgKHNjaGVkdWxlLmV2ZXJ5ZGF5KSB7XG4gICAgICAgICAgICAgICAgdG9kYXkudGV4dCA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnZXZlcnlkYXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvZGF5LmZyb20gPSBzY2hlZHVsZS50b2RheS5mcm9tO1xuICAgICAgICAgICAgdG9kYXkudG8gPSBzY2hlZHVsZS50b2RheS50bztcbiAgICAgICAgICAgIHRvZGF5Lmx1bmNoID0gc2NoZWR1bGUubHVuY2g7XG4gICAgICAgICAgICBpZiAodG9kYXkubHVuY2gpIHtcbiAgICAgICAgICAgICAgICB0b2RheS5sdW5jaFN0ciA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnbHVuY2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvZGF5LnRleHQgPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ3RvZGF5SXNSZXN0RGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQotC10LrRg9GJ0LjQuSDRgdGC0LDRgtGD0YEg0Lgg0L/RgNC+0LPQvdC+0LdcbiAgICAgICAgaWYgKHNjaGVkdWxlLmFsd2F5cykgeyAvLyDQldGB0LvQuCDQutGA0YPQs9C70L7RgdGD0YLQvtGH0L3Qviwg0L3QuNGH0LXQs9C+INC60YDQvtC80LUgXCLQmtGA0YPQs9C70L7RgdGD0YLQvtGH0L3QvlwiINCy0YvQstC+0LTQuNGC0Ywg0L3QtSDQvdGD0LbQvdC+XG4gICAgICAgICAgICB0b2RheS50ZXh0ID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdhcm91bmRUaGVDbG9jaycpO1xuICAgICAgICAgICAgb3BlbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2NoZWR1bGUubm93KSB7XG4gICAgICAgICAgICBvcGVuID0gc2NoZWR1bGUubm93Lm9wZW47XG4gICAgICAgICAgICBpZiAob3BlbikgeyAvLyDQvtGC0LrRgNGL0YLQvlxuICAgICAgICAgICAgICAgIGlmIChzY2hlZHVsZS53aWxsICYmIHNjaGVkdWxlLndpbGwud2lsbFR5cGUgPT09ICdsdW5jaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g0LTQsNC70LXQtSAtINC30LDQutGA0YvRgtC40LUg0L3QsCDQvtCx0LXQtFxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZWR1bGUud2lsbCAmJiBzY2hlZHVsZS53aWxsLmggPCBtYXhIb3Vycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g0LzQtdC90LXQtSBtYXhIb3VycyDQtNC+INC30LDQutGA0YvRgtC40Y8gINC90LAg0L7QsdC10LRcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vd1RleHQgPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ19pbicpICsgJyAnICsgdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICduTWlucycsIGludGVydmFsKSArIHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnaXNDbG9zaW5nT25EaW5uZXInKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vINCx0L7Qu9GM0YjQtSBtYXhIb3VycyDQtNC+INC30LDQutGA0YvRgtC40Y8gINC90LAg0L7QsdC10LRcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vd1RleHQgPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ2lzT3BlbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyDQtNCw0LvQtdC1INC/0YDQvtGB0YLQviDQt9Cw0LrRgNGL0YLQuNC1XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlZHVsZS53aWxsLmggPCBtYXhIb3Vycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g0LzQtdC90LXQtSBtYXhIb3VycyDQtNC+INC30LDQutGA0YvRgtC40Y8g0L/RgNC+0YHRgtC+XG4gICAgICAgICAgICAgICAgICAgICAgICBub3dUZXh0ID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdjbG9zZUluJykgKyB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ25NaW5zJywgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g0LHQvtC70YzRiNC1IG1heEhvdXJzINC00L4g0LfQsNC60YDRi9GC0LjRjyDQv9GA0L7RgdGC0L5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vd1RleHQgPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ2lzT3BlbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHsgLy8g0LfQsNC60YDRi9GC0L5cbiAgICAgICAgICAgICAgICBpZiAoc2NoZWR1bGUud2lsbCAmJiBzY2hlZHVsZS53aWxsLndoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g0L7RgtC60YDQvtC10YLRgdGPINC90LUg0YHQtdCz0L7QtNC90Y9cbiAgICAgICAgICAgICAgICAgICAgbm93VGV4dCA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnb3BlbicpICsgc2NoZWR1bGUud2lsbC53aGVuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vINC+0YLQutGA0L7QtdGC0YHRjyDRgdC10LPQvtC00L3Rj1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZWR1bGUubm93ICYmIHNjaGVkdWxlLm5vdy5sdW5jaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g0YHQtdC50YfQsNGBINC+0LHQtdC0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZWR1bGUud2lsbC5oIDwgbWF4SG91cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDQvNC10L3QtdC1IG1heEhvdXJzINC00L4g0L7RgtC60YDRi9GC0LjRjyDRgSDQvtCx0LXQtNCwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93VGV4dCA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnTHVuY2gnKSArIHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnb3BlbkluJykgKyB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ25NaW5zJywgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDQsdC+0LvRjNGI0LUgbWF4SG91cnMg0LTQviDQvtGC0LrRgNGL0YLQuNGPINGBINC+0LHQtdC00LBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3dUZXh0ID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdMdW5jaCcpICsgdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdvcGVuQXQnKSArIHNjaGVkdWxlLndpbGwudGlsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vINC/0YDQvtGB0YLQviDQt9Cw0LrRgNGL0YLQvlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVkdWxlLndpbGwgJiYgc2NoZWR1bGUud2lsbC5oIDwgbWF4SG91cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDQvNC10L3QtdC1IG1heEhvdXJzINC00L4g0L7RgtC60YDRi9GC0LjRjyDQv9GA0L7RgdGC0L5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3dUZXh0ID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdvcGVuSW4nKSArIHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnbk1pbnMnLCBpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vINCx0L7Qu9GM0YjQtSBtYXhIb3VycyDQtNC+INC+0YLQutGA0YvRgtC40Y8g0L/RgNC+0YHRgtC+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93VGV4dCA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnb3BlbkF0JykgKyBzY2hlZHVsZS53aWxsLnRpbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9kYXk6IHRvZGF5LFxuICAgICAgICAgICAgbm93OiBub3dUZXh0LFxuICAgICAgICAgICAgb3Blbjogb3BlbixcbiAgICAgICAgICAgIHdlZWs6IHNjaGVkdWxlLndlZWssXG4gICAgICAgICAgICBjb21tZW50OiBzY2hlZHVsZS5jb21tZW50LFxuICAgICAgICAgICAgZXZlcnlkYXk6IHNjaGVkdWxlLmV2ZXJ5ZGF5XG4gICAgICAgIH07XG4gICAgfVxufTtcbiIsIi8qZ2xvYmFsXG4gICAgRmlybUNhcmQ6ZmFsc2VcbiovXG4vLyBGaXJtQ2FyZC5kaWN0aW9uYXJ5ID0ge307XG5cbkZpcm1DYXJkLnByb3RvdHlwZS5kaWN0ID0ge1xuXG4gICAgdDogZnVuY3Rpb24gKGxhbmcsIG1zZywgYXJndW1lbnQpIHsgLy8gKFN0cmluZywgTnVtYmVyKSAtPiBTdHJpbmdcbiAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgIG1zZ0lzc2V0ID0gZmFsc2UsXG4gICAgICAgICAgICBkaWN0aW9uYXJ5TXNnLFxuICAgICAgICAgICAgZXhwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1tsYW5nXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChsYW5nID09PSAnYXInKSB7XG4gICAgICAgICAgICAgICAgbGFuZyA9ICdlbic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhbmcgPSAncnUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRpY3Rpb25hcnlNc2cgPSB0aGlzW2xhbmddW21zZ107XG4gICAgICAgIG1zZ0lzc2V0ID0gdHlwZW9mIGRpY3Rpb25hcnlNc2cgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAoIW1zZ0lzc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IG1zZ0lzc2V0ID8gZGljdGlvbmFyeU1zZyA6IG1zZztcblxuICAgICAgICBpZiAoYXJndW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXJndW1lbnQgPSBwYXJzZUludChhcmd1bWVudCwgMTApO1xuICAgICAgICAgICAgYXJndW1lbnQgPSBpc05hTihhcmd1bWVudCkgPyAwIDogYXJndW1lbnQ7XG4gICAgICAgICAgICBleHAgPSB0aGlzW2xhbmddLnBsdXJhbFJ1bGVzKGFyZ3VtZW50KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGFyZ3VtZW50ICsgJyAnICsgZGljdGlvbmFyeU1zZ1tleHBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHJ1OiB7XG4gICAgICAgIHBsdXJhbFJ1bGVzOiBmdW5jdGlvbiAobikgeyAvLyAoTnVtYmVyKVxuICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gMSAmJiBuICUgMTAwICE9PSAxMSkgeyAvLyAxLCAyMVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChuICUgMTAgPj0gMiAmJiBuICUgMTAgPD0gNCAmJiAobiAlIDEwKSAlIDEgPT09IDApICYmIChuICUgMTAwIDwgMTIgfHwgbiAlIDEwMCA+IDE0KSkgeyAvLyAyLCAzXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgobiAlIDEwID09PSAwKSB8fCAobiAlIDEwID49IDUgJiYgbiAlIDEwIDw9IDkgJiYgKG4gJSAxMCkgJSAxID09PSAwKSB8fCAobiAlIDEwMCA+PSAxMSAmJiAobiAlIDEwMCkgPD0gMTQgJiYgKG4gJSAxMDApICUgMSA9PT0gMCkpIHsgLy8gMTMsIDE3XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnRuQmFjazogJ9Cd0LDQt9Cw0LQnLFxuICAgICAgICBidG5GaW5kV2F5OiAn0J/RgNC+0LXRhdCw0YLRjCDRgdGO0LTQsCcsXG4gICAgICAgIGJ0bkVudHJhbmNlOiAn0J3QsNC50YLQuCDQstGF0L7QtCcsXG4gICAgICAgIGxpbmtSZXZpZXdzOiBbJ9C+0YLQt9GL0LInLCAn0L7RgtC30YvQstCwJywgJ9C+0YLQt9GL0LLQvtCyJ10sXG4gICAgICAgIGxpbmtQaG90bzogWyfRhNC+0YLQvicsICfRhNC+0YLQvicsICfRhNC+0YLQviddLFxuICAgICAgICBsaW5rQm9va2xldDogJ9CR0YPQutC70LXRgicsXG4gICAgICAgIHRvbW1vcm93OiAn0LfQsNCy0YLRgNCwJyxcbiAgICAgICAgYWZ0ZXJUb21tb3JvdzogJ9C/0L7RgdC70LXQt9Cw0LLRgtGA0LAnLFxuICAgICAgICBhZnRlcldlZWs6ICfRh9C10YDQtdC3INC90LXQtNC10LvRjicsXG4gICAgICAgIG5leHRTdW46ICfQsiDQstC+0YHQutGA0LXRgdC10L3RjNC1JyxcbiAgICAgICAgbmV4dE1vbjogJ9CyINC/0L7QvdC10LTQtdC70YzQvdC40LonLFxuICAgICAgICBuZXh0VHVlOiAn0LLQviDQstGC0L7RgNC90LjQuicsXG4gICAgICAgIG5leHRXZWQ6ICfQsiDRgdGA0LXQtNGDJyxcbiAgICAgICAgbmV4dFRodTogJ9CyINGH0LXRgtCy0LXRgNCzJyxcbiAgICAgICAgbmV4dEZyaTogJ9CyINC/0Y/RgtC90LjRhtGDJyxcbiAgICAgICAgbmV4dFNhdDogJ9CyINGB0YPQsdCx0L7RgtGDJyxcbiAgICAgICAgd2lsbE9wZW46ICfQvtGC0LrRgNC+0LXRgtGB0Y8nLFxuICAgICAgICB3aWxsQ2xvc2U6ICfQt9Cw0LrRgNC+0LXRgtGB0Y8nLFxuICAgICAgICBpc09wZW46ICfQntGC0LrRgNGL0YLQvicsXG4gICAgICAgIG9wZW5UaWxsOiAn0J7RgtC60YDRi9GC0L4g0LTQviAnLFxuICAgICAgICBjbG9zZUluOiAn0JfQsNC60YDQvtC10YLRgdGPINGH0LXRgNC10LcgJyxcbiAgICAgICAgb3BlbkF0OiAn0J7RgtC60YDQvtC10YLRgdGPINCyICcsXG4gICAgICAgIG9wZW5JbjogJ9Ce0YLQutGA0L7QtdGC0YHRjyDRh9C10YDQtdC3ICcsXG4gICAgICAgIG9wZW46ICfQntGC0LrRgNC+0LXRgtGB0Y8gJyxcbiAgICAgICAgbkhvdXJzOiBbJ9GH0LDRgScsICfRh9Cw0YHQsCcsICfRh9Cw0YHQvtCyJ10sXG4gICAgICAgIG5NaW5zOiBbJ9C80LjQvdGD0YLRgycsICfQvNC40L3Rg9GC0YsnLCAn0LzQuNC90YPRgiddLFxuICAgICAgICBsdW5jaDogJ9C+0LHQtdC0JyxcbiAgICAgICAgTHVuY2g6ICfQntCx0LXQtC4gJyxcbiAgICAgICAgd29ya2luZ0RheXM6ICfQoNCw0LHQvtGH0LjQtSDQtNC90LgnLFxuICAgICAgICB3ZWVrZGF5czogJ9CR0YPQtNC90LjQtSDQtNC90LgnLFxuICAgICAgICByZXN0RGF5OiBbJ9Cy0YvRhdC+0LTQvdC+0LknLCAn0LLRi9GF0L7QtNC90YvQtScsJ9Cy0YvRhdC+0LTQvdGL0LUnXSxcbiAgICAgICAgcmV2aWV3c09uRmxhbXA6ICfQntGC0LfRi9Cy0Ysg0L3QsCDQpNC70LDQvNC/0LUnLFxuICAgICAgICB3cml0ZVJldmlld09uRmxhbXA6ICfQndCw0L/QuNGB0LDRgtGMINC+0YLQt9GL0LIg0L3QsCDQpNC70LDQvNC/0LUnLFxuICAgICAgICBwYXltZW50OiAn0L7Qv9C70LDRgtCwJyxcbiAgICAgICAgZXZlcnlkYXk6ICfQldC20LXQtNC90LXQstC90L4gYycsXG4gICAgICAgIHdvcmtzQXJvdW5kVGhlQ2xvY2s6ICfQoNCw0LHQvtGC0LDQtdGCINC60YDRg9Cz0LvQvtGB0YPRgtC+0YfQvdC+JyxcbiAgICAgICAgYXJvdW5kVGhlQ2xvY2s6ICfQmtGA0YPQs9C70L7RgdGD0YLQvtGH0L3QvicsXG4gICAgICAgIGtub3dNb3JlOiAn0YPQt9C90LDRgtGMINCx0L7Qu9GM0YjQtScsXG4gICAgICAgIHRvQ2xvc2U6ICfQtNC+INC30LDQutGA0YvRgtC40Y8nLFxuICAgICAgICBtb25kYXk6ICfQv9C+0L3QtdC00LXQu9GM0L3QuNC6JyxcbiAgICAgICAgdHVlc2RheTogJ9Cy0YLQvtGA0L3QuNC6JyxcbiAgICAgICAgd2VkbmVzZGF5OiAn0YHRgNC10LTQsCcsXG4gICAgICAgIHRodXJzZGF5OiAn0YfQtdGC0LLQtdGA0LMnLFxuICAgICAgICBmcmlkYXk6ICfQv9GP0YLQvdC40YbQsCcsXG4gICAgICAgIHNhdHVyZGF5OiAn0YHRg9Cx0LHQvtGC0LAnLFxuICAgICAgICBzdW5kYXk6ICfQstC+0YHQutGA0LXRgdC10L3RjNC1JyxcbiAgICAgICAgbW9uOiAn0L/QvtC9JyxcbiAgICAgICAgdHVlOiAn0LLRgtGAJyxcbiAgICAgICAgd2VkOiAn0YHRgNC0JyxcbiAgICAgICAgdGh1OiAn0YfRgtCyJyxcbiAgICAgICAgZnJpOiAn0L/RgtC9JyxcbiAgICAgICAgc2F0OiAn0YHQsdGCJyxcbiAgICAgICAgc3VuOiAn0LLRgdC6JyxcbiAgICAgICAgdG9MdW5jaDogJ9C00L4g0L7QsdC10LTQsCcsXG4gICAgICAgIHRvZGF5OiAn0KHQtdCz0L7QtNC90Y8nLFxuICAgICAgICBsZXNzVGhlbkhvdXI6ICfQvNC10L3QtdC1INGH0LDRgdCwJyxcbiAgICAgICAgeW91Q291bGRMYXRlOiAn0LLRiyDQvNC+0LbQtdGC0LUg0L3QtSDRg9GB0L/QtdGC0YwnLFxuICAgICAgICB3b3JraW5nVGltZTogJ9GA0LDQsdC+0YfQtdC1INCy0YDQtdC80Y8nLFxuICAgICAgICBzaG93QWxsT3JnSW5SdWJyaWM6ICfQn9C+0LrQsNC30LDRgtGMINCy0YHQtSDQvtGA0LPQsNC90LjQt9Cw0YbQuNC4INGA0YPQsdGA0LjQutC4JyxcbiAgICAgICAgdG9kYXlJc1Jlc3REYXk6ICfQodC10LPQvtC00L3RjyDQstGL0YXQvtC00L3QvtC5JyxcbiAgICAgICAgaW50ZXJuZXQ6ICfQntC/0LvQsNGC0LAg0YfQtdGA0LXQtyDQmNC90YLQtdGA0L3QtdGCJyxcbiAgICAgICAgbm9uY2FzaDogJ9CR0LXQt9C90LDQu9C40YfQvdGL0Lkg0YDQsNGB0YfQtdGCJyxcbiAgICAgICAgZ29sZGNyb3duOiAn0JfQvtC70L7RgtCw0Y8g0JrQvtGA0L7QvdCwJyxcbiAgICAgICAgZGluZXJzY2x1YjogJ0RpbmVycyBDbHViJyxcbiAgICAgICAgbWFzdGVyY2FyZDogJ01hc3RlcmNhcmQnLFxuICAgICAgICBtYWVzdHJvY2FyZDogJ01hZXN0cm9DYXJkJyxcbiAgICAgICAgdmlzYTogJ1Zpc2EnLFxuICAgICAgICBjYXNoOiAn0J3QsNC70LjRh9C90YvQuSDRgNCw0YHRh9C10YInLFxuICAgICAgICBhbWVyaWNhbmV4cHJlc3M6ICdBbWVyaWNhbiBFeHByZXNzJyxcbiAgICAgICAgaG91ciA6ICfRh9Cw0YEnLFxuICAgICAgICBsZXNzOiAn0LzQtdC90LXQtScsXG4gICAgICAgIF9pbiA6ICfQp9C10YDQtdC3JyxcbiAgICAgICAgaXNDbG9zaW5nT25EaW5uZXIgOiAnINC30LDQutGA0YvQstCw0LXRgtGB0Y8g0L3QsCDQvtCx0LXQtCdcbiAgICB9LFxuXG4gICAgaXQ6IHtcbiAgICAgICAgcGx1cmFsUnVsZXM6IGZ1bmN0aW9uIChuKSB7IC8vIChOdW1iZXIpXG4gICAgICAgICAgICBpZiAobiA9PT0gMSkgeyAvLyAxXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAxOyAvLzAsIDIsIDMsIDQgLi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBidG5CYWNrOiAnSW5kaWV0cm8nLFxuICAgICAgICBidG5GaW5kV2F5OiAnQ29tZSBhcnJpdmFyZSAnLFxuICAgICAgICBidG5FbnRyYW5jZTogJ1Ryb3ZhIGxcXCdpbmdyZXNzbycsXG4gICAgICAgIGxpbmtSZXZpZXdzOiBbJ3JlY2Vuc2lvbmUnLCAncmVjZW5zaW9uaSddLFxuICAgICAgICBsaW5rUGhvdG86IFsnZm90b2dyYWZpYScsICdmb3RvZ3JhZmllJ10sXG4gICAgICAgIGxpbmtCb29rbGV0OiAnU3VsbFxcJ2F6aWVuZGEnLFxuICAgICAgICB0b21tb3JvdzogJ2RvbWFuaScsXG4gICAgICAgIGFmdGVyVG9tbW9yb3c6ICdkb3BvZG9tYW5pJyxcbiAgICAgICAgYWZ0ZXJXZWVrOiAndHJhIHVuYSBzZXR0aW1hbmEnLFxuICAgICAgICBuZXh0U3VuOiAnbGEgZG9tZW5pY2EnLFxuICAgICAgICBuZXh0TW9uOiAnaWwgbHVuZWRpJyxcbiAgICAgICAgbmV4dFR1ZTogJ2lsIG1hcnRlZMOsJyxcbiAgICAgICAgbmV4dFdlZDogJ2lsIG1lcmNvbGVkw6wnLFxuICAgICAgICBuZXh0VGh1OiAnaWwgZ2lvdmVkaScsXG4gICAgICAgIG5leHRGcmk6ICdpbCB2ZW5lcmTDrCcsXG4gICAgICAgIG5leHRTYXQ6ICdpbCBzYWJhdG8nLFxuICAgICAgICB3aWxsT3BlbjogJ2FwcmUnLFxuICAgICAgICB3aWxsQ2xvc2U6ICdjaXVzbycsXG4gICAgICAgIGlzT3BlbjogJ0FwZXJ0bycsXG4gICAgICAgIG9wZW5UaWxsOiAnQXBlcnRvIGZpbm8gYWxsZSAnLFxuICAgICAgICBjbG9zZUluOiAnQ2hpdWRlIHRyYSAnLFxuICAgICAgICBvcGVuQXQ6ICdBcHJlIGFsbGUgJyxcbiAgICAgICAgb3BlbkluOiAnQXByZSB0cmEgJyxcbiAgICAgICAgb3BlbjogJ0FwcmUgJyxcbiAgICAgICAgbkhvdXJzOiBbJ29yYScsICdvcmUnXSxcbiAgICAgICAgbk1pbnM6IFsnbWludXRvJywgJ21pbnV0aSddLFxuICAgICAgICBsdW5jaDogJ3BhdXNhIHByYW56bycsXG4gICAgICAgIEx1bmNoOiAnUGF1c2EgcHJhbnpvLiAnLFxuICAgICAgICB3b3JraW5nRGF5czogJ0dpb3JuaSBmZXJpYWxpJyxcbiAgICAgICAgd2Vla2RheXM6ICdHaW9ybmkgZmVyaWFsaScsXG4gICAgICAgIHJlc3REYXk6IFsnY2hpdXN1cmEnLCdjaGl1c3VyYSddLFxuICAgICAgICByZXZpZXdzT25GbGFtcDogJ1JlY2Vuc2lvbmkgc3UgRmxhbXAnLFxuICAgICAgICB3cml0ZVJldmlld09uRmxhbXA6ICdTY3JpdmkgdW5hIHJlY2Vuc2lvbmUgc3UgRmxhbXAnLFxuICAgICAgICBwYXltZW50OiAncGFnYW1lbnRvJyxcbiAgICAgICAgZXZlcnlkYXk6ICdPZ25pIGdpb3JubyBkYWxvbGUnLFxuICAgICAgICB3b3Jrc0Fyb3VuZFRoZUNsb2NrOiAnT3BlcmF0aXZvIDI0IG9yZSBzdSAyNCcsXG4gICAgICAgIGFyb3VuZFRoZUNsb2NrOiAnMjQgb3JlIHN1IDI0JyxcbiAgICAgICAga25vd01vcmU6ICd1bHRlcmlvcmkgaW5mb3JtYXppb25pJyxcbiAgICAgICAgdG9DbG9zZTogJ2Zpbm8gYWxsYSBjaGl1c3VyYScsXG4gICAgICAgIG1vbmRheTogJ2x1bmVkaScsXG4gICAgICAgIHR1ZXNkYXk6ICdtYXJ0ZWTDrCcsXG4gICAgICAgIHdlZG5lc2RheTogJ21lcmNvbGVkw6wnLFxuICAgICAgICB0aHVyc2RheTogJ2dpb3ZlZGknLFxuICAgICAgICBmcmlkYXk6ICd2ZW5lcmTDrCcsXG4gICAgICAgIHNhdHVyZGF5OiAnc2FiYXRvJyxcbiAgICAgICAgc3VuZGF5OiAnZG9tZW5pY2EnLFxuICAgICAgICBtb246ICdsdW4nLFxuICAgICAgICB0dWU6ICdtYXInLFxuICAgICAgICB3ZWQ6ICdtZXInLFxuICAgICAgICB0aHU6ICdnaW8nLFxuICAgICAgICBmcmk6ICd2ZW4nLFxuICAgICAgICBzYXQ6ICdzYWInLFxuICAgICAgICBzdW46ICdkb20nLFxuICAgICAgICB0b0x1bmNoOiAnZmlubyBhbGxhIHBhdXNhIHByYW56bycsXG4gICAgICAgIHRvZGF5OiAnT2dnaScsXG4gICAgICAgIGxlc3NUaGVuSG91cjogJ21lbm8gZGkgdW5cXCdvcmEnLFxuICAgICAgICB5b3VDb3VsZExhdGU6ICdhZmZyZXR0YXJzaSwgY2hpdXN1cmEgaW1taW5lbnRlJyxcbiAgICAgICAgd29ya2luZ1RpbWU6ICdvcmFyaW8gZGkgbGF2b3JvJyxcbiAgICAgICAgc2hvd0FsbE9yZ0luUnVicmljOiAnVmlzdWFsaXp6YSB0dXR0ZSBsZSBhemllbmRlIGRlbGxhIGNhdGVnb3JpYScsXG4gICAgICAgIHRvZGF5SXNSZXN0RGF5OiAnb2dnaSBjaGl1c28nLFxuICAgICAgICBpbnRlcm5ldDogJ1BhZ2FtZW50byBvbi1saW5lJyxcbiAgICAgICAgbm9uY2FzaDogJ1BhZ2FtZW50byBub24gaW4gY29udGFudGknLFxuICAgICAgICBnb2xkY3Jvd246ICdab2xvdGFqYSBLb3JvbmEnLFxuICAgICAgICBkaW5lcnNjbHViOiAnRGluZXJzIENsdWInLFxuICAgICAgICBtYXN0ZXJjYXJkOiAnTWFzdGVyQ2FyZCcsXG4gICAgICAgIG1hZXN0cm9jYXJkOiAnTWFlc3Ryb0NhcmQnLFxuICAgICAgICB2aXNhOiAnVmlzYScsXG4gICAgICAgIGNhc2g6ICdQYWdhbWVudG8gaW4gY29udGFudGknLFxuICAgICAgICBhbWVyaWNhbmV4cHJlc3M6ICdBbWVyaWNhbiBFeHByZXNzJyxcbiAgICAgICAgaG91ciA6ICd1blxcJ29yYScsXG4gICAgICAgIGxlc3M6ICdtZW5vIGRpJyxcbiAgICAgICAgX2luIDogJ1RyYScsXG4gICAgICAgIGlzQ2xvc2luZ09uRGlubmVyIDogJ2NoaXVkZSBwZXIgcGF1c2EgcHJhbnpvJ1xuICAgIH0sXG5cbiAgICBlbjoge1xuICAgICAgICBwbHVyYWxSdWxlczogZnVuY3Rpb24gKG4pIHsgLy8gKE51bWJlcilcbiAgICAgICAgICAgIGlmIChuID09PSAxKSB7IC8vIDFcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7IC8vMCwgMiwgMywgNCAuLlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGJ0bkJhY2s6ICdCYWNrJyxcbiAgICAgICAgYnRuRmluZFdheTogJ0dldCBoZXJlJyxcbiAgICAgICAgYnRuRW50cmFuY2U6ICdGaW5kIGVudHJhbmNlJyxcbiAgICAgICAgbGlua1Jldmlld3M6IFsncmV2aWV3JywgJ3Jldmlld3MnXSxcbiAgICAgICAgbGlua1Bob3RvOiBbJ3Bob3RvJywgJ3Bob3RvcyddLFxuICAgICAgICBsaW5rQm9va2xldDogJ0Fib3V0IGNvbXBhbnknLFxuICAgICAgICB0b21tb3JvdzogJ3RvbW9ycm93JyxcbiAgICAgICAgYWZ0ZXJUb21tb3JvdzogJ3RoZSBkYXkgYWZ0ZXIgdG9tb3Jyb3cnLFxuICAgICAgICBhZnRlcldlZWs6ICdpbiBhIHdlZWsnLFxuICAgICAgICBuZXh0U3VuOiAnb24gU3VuZGF5JyxcbiAgICAgICAgbmV4dE1vbjogJ29uIE1vbmRheScsXG4gICAgICAgIG5leHRUdWU6ICdvbiBUdWVzZGF5JyxcbiAgICAgICAgbmV4dFdlZDogJ29uIFdlZG5lc2RheScsXG4gICAgICAgIG5leHRUaHU6ICdvbiBUaHVyc2RheScsXG4gICAgICAgIG5leHRGcmk6ICdvbiBGcmlkYXknLFxuICAgICAgICBuZXh0U2F0OiAnb24gU2F0dXJkYXknLFxuICAgICAgICB3aWxsT3BlbjogJ29wZW5zICcsXG4gICAgICAgIHdpbGxDbG9zZTogJ2Nsb3NlcycsXG4gICAgICAgIGlzT3BlbjogJ09wZW4nLFxuICAgICAgICBvcGVuVGlsbDogJ09wZW4gdGlsbCAnLFxuICAgICAgICBjbG9zZUluOiAnQ2xvc2VzIGluICcsXG4gICAgICAgIG9wZW5BdDogJ09wZW5zIGF0ICcsXG4gICAgICAgIG9wZW5JbjogJ09wZW5zIGluICcsXG4gICAgICAgIG9wZW46ICdPcGVucyAnLFxuICAgICAgICBuSG91cnM6IFsnaG91cicsICdob3VycyddLFxuICAgICAgICBuTWluczogWydtaW51dGUnLCAnbWludXRlcyddLFxuICAgICAgICBsdW5jaDogJ2x1bmNoIGJyZWFrJyxcbiAgICAgICAgTHVuY2g6ICdMdW5jaCBicmVhay4gJyxcbiAgICAgICAgd29ya2luZ0RheXM6ICdXb3JraW5nIGRheXMnLFxuICAgICAgICB3ZWVrZGF5czogJ1dlZWtkYXlzJyxcbiAgICAgICAgcmVzdERheTogWydkYXkgb2ZmJywnZGF5cyBvZmYnXSxcbiAgICAgICAgcmV2aWV3c09uRmxhbXA6ICdSZXZpZXdzIG9uIEZsYW1wJyxcbiAgICAgICAgd3JpdGVSZXZpZXdPbkZsYW1wOiAnV3JpdGUgYSByZXZpZXcgb24gRmxhbXAnLFxuICAgICAgICBwYXltZW50OiAncGF5bWVudCcsXG4gICAgICAgIGV2ZXJ5ZGF5OiAnRGFpbHkgZnJvbScsXG4gICAgICAgIHdvcmtzQXJvdW5kVGhlQ2xvY2s6ICdPcGVuIDI0IGhvdXJzJyxcbiAgICAgICAgYXJvdW5kVGhlQ2xvY2s6ICcyNGgnLFxuICAgICAgICBrbm93TW9yZTogJ3NlZSBhbHNvJyxcbiAgICAgICAgdG9DbG9zZTogJ3VudGlsIGNsb3NpbmcnLFxuICAgICAgICBtb25kYXk6ICdNb25kYXknLFxuICAgICAgICB0dWVzZGF5OiAnVHVlc2RheScsXG4gICAgICAgIHdlZG5lc2RheTogJ1dlZG5lc2RheScsXG4gICAgICAgIHRodXJzZGF5OiAnVGh1cnNkYXknLFxuICAgICAgICBmcmlkYXk6ICdGcmlkYXknLFxuICAgICAgICBzYXR1cmRheTogJ1NhdHVyZGF5JyxcbiAgICAgICAgc3VuZGF5OiAnU3VuZGF5JyxcbiAgICAgICAgbW9uOiAnTW9uJyxcbiAgICAgICAgdHVlOiAnVHVlJyxcbiAgICAgICAgd2VkOiAnV2VkJyxcbiAgICAgICAgdGh1OiAnVGh1JyxcbiAgICAgICAgZnJpOiAnRnJpJyxcbiAgICAgICAgc2F0OiAnU2F0JyxcbiAgICAgICAgc3VuOiAnU3VuJyxcbiAgICAgICAgdG9MdW5jaDogJ3VudGlsIGx1bmNoJyxcbiAgICAgICAgdG9kYXk6ICdUb2RheScsXG4gICAgICAgIGxlc3NUaGVuSG91cjogJ2xlc3MgdGhlbiBvbmUgaG91cicsXG4gICAgICAgIHlvdUNvdWxkTGF0ZTogJ3lvdSBtaWdodCBiZSBsYXRlJyxcbiAgICAgICAgd29ya2luZ1RpbWU6ICd3b3JraW5nIGhvdXJzJyxcbiAgICAgICAgc2hvd0FsbE9yZ0luUnVicmljOiAnU2hvdyBhbGwgb3JnYW5pemF0aW9ucyBpbiB0aGUgY2F0ZWdvcnknLFxuICAgICAgICB0b2RheUlzUmVzdERheTogJ2Nsb3NlZCB0b2RheScsXG4gICAgICAgIGludGVybmV0OiAnT25saW5lJyxcbiAgICAgICAgbm9uY2FzaDogJyBOby1jYXNoJyxcbiAgICAgICAgZ29sZGNyb3duOiAnR29sZGVuIENyb3duJyxcbiAgICAgICAgZGluZXJzY2x1YjogJ0RpbmVycyBDbHViJyxcbiAgICAgICAgbWFzdGVyY2FyZDogJ01hc3RlcmNhcmQnLFxuICAgICAgICBtYWVzdHJvY2FyZDogJ01hZXN0cm9DYXJkJyxcbiAgICAgICAgdmlzYTogJ1Zpc2EnLFxuICAgICAgICBjYXNoOiAnQ2FzaCcsXG4gICAgICAgIGFtZXJpY2FuZXhwcmVzczogJ0FtZXJpY2FuIEV4cHJlc3MnLFxuICAgICAgICBob3VyIDogJ2hvdXInLFxuICAgICAgICBsZXNzOiAnbGVzcycsXG4gICAgICAgIF9pbiA6ICdJbicsXG4gICAgICAgIGlzQ2xvc2luZ09uRGlubmVyIDogJ3dpbGwgYmUgY2xvc2luZyBmb3IgbHVuY2gnXG4gICAgfSxcblxuICAgIGNzOiB7XG4gICAgICAgIHBsdXJhbFJ1bGVzOiBmdW5jdGlvbiAobikgeyAvLyAoTnVtYmVyKVxuICAgICAgICAgICAgcmV0dXJuIChuID09PSAxKSA/IDAgOiAobiA+PSAyICYmIG4gPD0gNCkgPyAxIDogMjtcbiAgICAgICAgfSxcblxuICAgICAgICBidG5CYWNrOiAnWnDEm3QnLFxuICAgICAgICBidG5GaW5kV2F5OiAnSmV0IHNlbScsXG4gICAgICAgIGJ0bkVudHJhbmNlOiAnSGxlZGF0IHZzdHVwJyxcbiAgICAgICAgbGlua1Jldmlld3M6IFsncmVjZW56ZScsICdyZWNlbnplJywgJ3JlY2VuesOtJ10sXG4gICAgICAgIGxpbmtQaG90bzogWydmb3RvZ3JhZmllJywgJ2ZvdG9ncmFmaWUnLCAnZm90b2dyYWZpw60nXSxcbiAgICAgICAgbGlua0Jvb2tsZXQ6ICdMZXTDoWsnLFxuICAgICAgICB0b21tb3JvdzogJ3rDrXRyYScsXG4gICAgICAgIGFmdGVyVG9tbW9yb3c6ICdwb3rDrXTFmcOtJyxcbiAgICAgICAgYWZ0ZXJXZWVrOiAnemEgdMO9ZGVuJyxcbiAgICAgICAgbmV4dFN1bjogJ3YgbmVkxJtsaScsXG4gICAgICAgIG5leHRNb246ICd2IHBvbmTEm2zDrScsXG4gICAgICAgIG5leHRUdWU6ICd2IMO6dGVyw70nLFxuICAgICAgICBuZXh0V2VkOiAndmUgc3TFmWVkdScsXG4gICAgICAgIG5leHRUaHU6ICd2ZSDEjXR2cnRlaycsXG4gICAgICAgIG5leHRGcmk6ICd2IHDDoXRlaycsXG4gICAgICAgIG5leHRTYXQ6ICd2IHNvYm90dScsXG4gICAgICAgIHdpbGxPcGVuOiAnb3RldsWZZSBzZScsXG4gICAgICAgIHdpbGxDbG9zZTogJ3phdsWZZSBzZScsXG4gICAgICAgIGlzT3BlbjogJ090ZXbFmWVubycsXG4gICAgICAgIG9wZW5UaWxsOiAnT3RldsWZZW5vIGRvICcsXG4gICAgICAgIGNsb3NlSW46ICdaYXbFmWUgc2UgemEgJyxcbiAgICAgICAgb3BlbkF0OiAnT3RldsWZZSBzZSB2ICcsXG4gICAgICAgIG9wZW5JbjogJ090ZXbFmWUgc2UgemEgJyxcbiAgICAgICAgb3BlbjogJ090ZXbFmWUgc2UgJyxcbiAgICAgICAgbkhvdXJzOiBbICdob2RpbnUnICwgJ2hvZGlueScgLCAnaG9kaW4nIF0sXG4gICAgICAgIG5NaW5zOiBbICdtaW51dHUnICwgJ21pbnV0eScgLCAnbWludXQnIF0sXG4gICAgICAgIGx1bmNoOiAncG9sZWRuw60gcMWZZXN0w6F2a2EnLFxuICAgICAgICBMdW5jaDogJ1BvbGVkbsOtIHDFmWVzdMOhdmthLiAnLFxuICAgICAgICB3b3JraW5nRGF5czogJ1bFoWVkbsOtIGRueScsXG4gICAgICAgIHdlZWtkYXlzOiAnVsWhZWRuw60gZG55JyxcbiAgICAgICAgcmVzdERheTogWyd6YXbFmWVubycsICd6YXbFmWVubyddLFxuICAgICAgICByZXZpZXdzT25GbGFtcDogJ1JlY2VuemUgbmEgRmxhbXB1JyxcbiAgICAgICAgd3JpdGVSZXZpZXdPbkZsYW1wOiAnTmFwc2F0IHJlY2VuemkgbmEgRmxhbXB1JyxcbiAgICAgICAgcGF5bWVudDogJ3BsYXRiYScsXG4gICAgICAgIGV2ZXJ5ZGF5OiAnRGVubsSbIG9kICcsXG4gICAgICAgIHdvcmtzQXJvdW5kVGhlQ2xvY2s6ICdQcmFjdWplIG5vbnN0b3AnLFxuICAgICAgICBhcm91bmRUaGVDbG9jazogJ05vbnN0b3AnLFxuICAgICAgICBrbm93TW9yZTogJ2RvenbEm2TEm3Qgc2UgdsOtY2UnLFxuICAgICAgICB0b0Nsb3NlOiAnZG8gdXphdsWZZW7DrScsXG4gICAgICAgIG1vbmRheTogJ3BvbmTEm2zDrScsXG4gICAgICAgIHR1ZXNkYXk6ICfDunRlcsO9JyxcbiAgICAgICAgd2VkbmVzZGF5OiAnc3TFmWVkYScsXG4gICAgICAgIHRodXJzZGF5OiAnxI10dnJ0ZWsnLFxuICAgICAgICBmcmlkYXk6ICdww6F0ZWsnLFxuICAgICAgICBzYXR1cmRheTogJ3NvYm90YScsXG4gICAgICAgIHN1bmRheTogJ25lZMSbbGUnLFxuICAgICAgICBtb246ICdwbycsXG4gICAgICAgIHR1ZTogJ8O6dCcsXG4gICAgICAgIHdlZDogJ3N0JyxcbiAgICAgICAgdGh1OiAnxI10JyxcbiAgICAgICAgZnJpOiAncMOhJyxcbiAgICAgICAgc2F0OiAnc28nLFxuICAgICAgICBzdW46ICduZScsXG4gICAgICAgIHRvTHVuY2g6ICdkbyBwb2xlZG7DrSBwxZllc3TDoXZreScsXG4gICAgICAgIHRvZGF5OiAnRG5lcycsXG4gICAgICAgIGxlc3NUaGVuSG91cjogJ23DqW7EmyBuZcW+IGhvZGludScsXG4gICAgICAgIHlvdUNvdWxkTGF0ZTogJ25lbXVzw610ZSB0byBzdGlobm91dCcsXG4gICAgICAgIHdvcmtpbmdUaW1lOiAncHJhY292bsOtIGRvYmEnLFxuICAgICAgICBzaG93QWxsT3JnSW5SdWJyaWM6ICdab2JyYXppdCB2xaFlY2hueSBvcmdhbml6YWNlIHYgcnVicmljZScsXG4gICAgICAgIHRvZGF5SXNSZXN0RGF5OiAnRG5lcyBqZSB6YXbFmWVubycsXG4gICAgICAgIGludGVybmV0OiAnUGxhdGJhIHByb3N0xZllZG5pY3R2w61tIEludGVybmV0dScsXG4gICAgICAgIG5vbmNhc2g6ICdCZXpob3Rvdm9zdG7DrSBwbGF0YmEnLFxuICAgICAgICBnb2xkY3Jvd246ICdab2xvdGFqYSBLb3JvbmEnLFxuICAgICAgICBkaW5lcnNjbHViOiAnRGluZXJzIENsdWInLFxuICAgICAgICBtYXN0ZXJjYXJkOiAnTWFzdGVyY2FyZCcsXG4gICAgICAgIG1hZXN0cm9jYXJkOiAnTWFlc3Ryb0NhcmQnLFxuICAgICAgICB2aXNhOiAnVmlzYScsXG4gICAgICAgIGNhc2g6ICdQbGF0YmEgaG90b3bEmycsXG4gICAgICAgIGFtZXJpY2FuZXhwcmVzczogJ0FtZXJpY2FuIEV4cHJlc3MnLFxuICAgICAgICBob3VyIDogJ2hvZGludScsXG4gICAgICAgIGxlc3M6ICdtw6luxJsnLFxuICAgICAgICBfaW4gOiAnWmEnLFxuICAgICAgICBpc0Nsb3NpbmdPbkRpbm5lciA6ICd6YcSNw61uw6EgcG9sZWRuw60gcMWZZXN0w6F2a2EnXG4gICAgfSxcblxuICAgIGVzOiB7XG4gICAgICAgIHBsdXJhbFJ1bGVzOiBmdW5jdGlvbiAobikgeyAvLyAoTnVtYmVyKVxuICAgICAgICAgIHJldHVybiAobiA9PT0gMSkgPyAwIDogKG4gPj0gMiAmJiBuIDw9IDQpID8gMSA6IDI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnRuQmFjazogJ0F0csOhcycsXG4gICAgICAgIGJ0bkZpbmRXYXk6ICdJciBwYXJhIGFsbMOhJyxcbiAgICAgICAgYnRuRW50cmFuY2U6ICdCdXNjYXIgYWNjZXNvJyxcbiAgICAgICAgbGlua1Jldmlld3M6IFsnY29tZW50YXJpbycsICdjb21lbnRhcmlvcycsICdjb21lbnRhcmlvcyddLFxuICAgICAgICBsaW5rUGhvdG86IFsnZm90bycsICdmb3RvcycsICdmb3RvcyddLFxuICAgICAgICBsaW5rQm9va2xldDogJ0ZvbGxldG8nLFxuICAgICAgICB0b21tb3JvdzogJ21hw7FhbmEnLFxuICAgICAgICBhZnRlclRvbW1vcm93OiAncGFzYWRvIG1hw7FhbmEnLFxuICAgICAgICBhZnRlcldlZWs6ICdlbiB1bmEgc2VtYW5hIG3DoXMnLFxuICAgICAgICBuZXh0U3VuOiAnZWwgZG9taW5nbycsXG4gICAgICAgIG5leHRNb246ICdlbCBsdW5lcycsXG4gICAgICAgIG5leHRUdWU6ICdlbCBtYXJ0ZXMnLFxuICAgICAgICBuZXh0V2VkOiAnZWwgbWnDqXJjb2xlcycsXG4gICAgICAgIG5leHRUaHU6ICdlbCBqdWV2ZXMnLFxuICAgICAgICBuZXh0RnJpOiAnZWwgdmllcm5lcycsXG4gICAgICAgIG5leHRTYXQ6ICdlbCBzw6FiYWRvJyxcbiAgICAgICAgd2lsbE9wZW46ICdzZSBhYnJpcsOhJyxcbiAgICAgICAgd2lsbENsb3NlOiAnc2UgY2VycmFyw6EnLFxuICAgICAgICBpc09wZW46ICdBYmllcnRvJyxcbiAgICAgICAgb3BlblRpbGw6ICdBYmllcnRvIGhhc3RhICcsXG4gICAgICAgIGNsb3NlSW46ICdTZSBjZXJyYXLDoSBkZW50cm8gZGUgJyxcbiAgICAgICAgb3BlbkF0OiAnU2UgYWJyaXLDoSBlbCAnLFxuICAgICAgICBvcGVuSW46ICdTZSBhYnJpcsOhIGRlbnRybyBkZSAnLFxuICAgICAgICBvcGVuOiAnU2UgYWJyaXLDoSAnLFxuICAgICAgICBuSG91cnM6IFsnaG9yYScsICdob3JhcycsICdob3JhcyddLFxuICAgICAgICBuTWluczogWydtaW51dG8nLCAnbWludXRvcycsICdtaW51dG9zJ10sXG4gICAgICAgIGx1bmNoOiAnaG9yYSBkZSBjb2xhY2nDs24nLFxuICAgICAgICBMdW5jaDogJ0hvcmEgZGUgY29sYWNpw7NuLiAnLFxuICAgICAgICB3b3JraW5nRGF5czogJ0TDrWFzIGxhYm9yYWJsZXMnLFxuICAgICAgICB3ZWVrZGF5czogJ0TDrWFzIGxhYm9yYWJsZXMnLFxuICAgICAgICByZXN0RGF5OiBbJ2NlcnJhZG8nLCdjZXJyYWRvJ10sXG4gICAgICAgIHJldmlld3NPbkZsYW1wOiAnQ29tZW50YXJpb3MgZW4gRmxhbXAnLFxuICAgICAgICB3cml0ZVJldmlld09uRmxhbXA6ICdFc2NyaWJpciB1biBjb21lbnRhcmlvIGVuIEZsYW1wJyxcbiAgICAgICAgcGF5bWVudDogJ3BhZ28nLFxuICAgICAgICBldmVyeWRheTogJ0NhZGEgZMOtYSBkZXNkZScsXG4gICAgICAgIHdvcmtzQXJvdW5kVGhlQ2xvY2s6ICdBYmllcnRvIGxhcyAyNCBob3JhcycsXG4gICAgICAgIGFyb3VuZFRoZUNsb2NrOiAnMjQgaG9yYXMnLFxuICAgICAgICBrbm93TW9yZTogJ3BhcmEgc2FiZXIgbcOhcycsXG4gICAgICAgIHRvQ2xvc2U6ICdoYXN0YSBlbCBjaWVycmUnLFxuICAgICAgICBtb25kYXk6ICdsdW5lcycsXG4gICAgICAgIHR1ZXNkYXk6ICdtYXJ0ZXMnLFxuICAgICAgICB3ZWRuZXNkYXk6ICdtacOpcmNvbGVzJyxcbiAgICAgICAgdGh1cnNkYXk6ICdqdWV2ZXMnLFxuICAgICAgICBmcmlkYXk6ICd2aWVybmVzJyxcbiAgICAgICAgc2F0dXJkYXk6ICdzw6FiYWRvJyxcbiAgICAgICAgc3VuZGF5OiAnZG9taW5nbycsXG4gICAgICAgIG1vbjogJ2x1bicsXG4gICAgICAgIHR1ZTogJ21hcicsXG4gICAgICAgIHdlZDogJ21pw6knLFxuICAgICAgICB0aHU6ICdqdWUnLFxuICAgICAgICBmcmk6ICd2aWUnLFxuICAgICAgICBzYXQ6ICdzw6FiJyxcbiAgICAgICAgc3VuOiAnZG9tJyxcbiAgICAgICAgdG9MdW5jaDogJ2FudGVzIGRlIGxhIGhvcmEgZGUgY29sYWNpw7NuJyxcbiAgICAgICAgdG9kYXk6ICdIb3knLFxuICAgICAgICBsZXNzVGhlbkhvdXI6ICdtZW5vcyBkZSB1bmEgaG9yYScsXG4gICAgICAgIHlvdUNvdWxkTGF0ZTogJ3B1ZWRlIHNlciBxdWUgbm8gYWxjYW56YXMgYSBsbGVnYXInLFxuICAgICAgICB3b3JraW5nVGltZTogJ2hvcmFyaW8gZGUgdHJhYmFqbycsXG4gICAgICAgIHNob3dBbGxPcmdJblJ1YnJpYzogJ01vc3RyYXIgdG9kYXMgbGFzIGVtcHJlc2FzIGRlIGxhIGNhdGVnb3LDrWEnLFxuICAgICAgICB0b2RheUlzUmVzdERheTogJ0hveSBjZXJyYWRvJyxcbiAgICAgICAgaW50ZXJuZXQ6ICdQYWdvIHBvciBJbnRlcm5ldCcsXG4gICAgICAgIG5vbmNhc2g6ICdQYWdvIHNpbiBlZmVjdGl2bycsXG4gICAgICAgIGdvbGRjcm93bjogJ1pvbG90YXlhIEtvcm9uYScsXG4gICAgICAgIGRpbmVyc2NsdWI6ICdEaW5lcnMgQ2x1YicsXG4gICAgICAgIG1hc3RlcmNhcmQ6ICdNYXN0ZXJjYXJkJyxcbiAgICAgICAgbWFlc3Ryb2NhcmQ6ICdNYWVzdHJvQ2FyZCcsXG4gICAgICAgIHZpc2E6ICdWaXNhJyxcbiAgICAgICAgY2FzaDogJ1BhZ28gZW4gZWZlY3Rpdm8nLFxuICAgICAgICBhbWVyaWNhbmV4cHJlc3M6ICdBbWVyaWNhbiBFeHByZXNzJyxcbiAgICAgICAgaG91ciA6ICdob3JhJyxcbiAgICAgICAgbGVzczogJ21lbm9zIGRlJyxcbiAgICAgICAgX2luIDogJ0RlbnRybyBkZScsXG4gICAgICAgIGlzQ2xvc2luZ09uRGlubmVyIDogJ3NlIGNpZXJyYSBwb3IgaG9yYSBkZSBjb2xhY2nDs24nXG4gICAgfVxufTtcbiIsIkRHLlRyYWZmaWMgPSBERy5UaWxlTGF5ZXIuZXh0ZW5kKHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHBlcmlvZDogMCxcbiAgICAgICAgZGlzYWJsZUxhYmVsOiBmYWxzZVxuICAgIH0sXG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIERpY3Rpb25hcnk6IHt9XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fdGlsZVVybCA9IERHLmNvbmZpZy5wcm90b2NvbCArIChERy5Ccm93c2VyLnJldGluYSA/IERHLmNvbmZpZy5yZXRpbmFUcmFmZmljVGlsZVNlcnZlciA6IERHLmNvbmZpZy50cmFmZmljVGlsZVNlcnZlcik7XG4gICAgICAgIHRoaXMuX21ldGFVcmwgPSBERy5jb25maWcucHJvdG9jb2wgKyAoREcuQnJvd3Nlci5yZXRpbmEgPyBERy5jb25maWcucmV0aW5hVHJhZmZpY01ldGFTZXJ2ZXIgOiBERy5jb25maWcudHJhZmZpY01ldGFTZXJ2ZXIpO1xuICAgICAgICB0aGlzLl90aW1lVXJsID0gREcuY29uZmlnLnByb3RvY29sICsgREcuY29uZmlnLnRyYWZmaWNUaW1lc3RhbXBTZXJ2ZXI7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUludGVydmFsID0gREcuY29uZmlnLnRyYWZmaWNMYXllclVwZGF0ZUludGVydmFsO1xuXG4gICAgICAgIHRoaXMuX2xheWVyc09wdGlvbnMgPSB7XG4gICAgICAgICAgICBlcnJvclRpbGVVcmw6ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFBQUFBUC8vL3lINUJBRUFBQUFBTEFBQUFBQUJBQUVBQUFJQlJBQTcnLFxuICAgICAgICAgICAgc3ViZG9tYWluczogJzAxMjM0NTY3OScsXG4gICAgICAgICAgICBtYXhOYXRpdmVab29tOiAxOCxcbiAgICAgICAgICAgIGRldGVjdFJldGluYTogREcuY29uZmlnLmRldGVjdFJldGluYSxcbiAgICAgICAgICAgIG1pblpvb206IERHLmNvbmZpZy50cmFmZmljTGF5ZXJNaW5ab29tXG4gICAgICAgIH07XG5cbiAgICAgICAgb3B0aW9ucyA9IERHLnNldE9wdGlvbnModGhpcywgREcuZXh0ZW5kKG9wdGlvbnMgfHwge30sIHRoaXMuX2xheWVyc09wdGlvbnMpKTtcbiAgICAgICAgb3B0aW9ucy50aW1lc3RhbXBTdHJpbmcgPSBvcHRpb25zLnBlcmlvZCA/ICcnIDogKCc/JyArICAobmV3IERhdGUoKSkuZ2V0VGltZSgpKTtcbiAgICAgICAgdGhpcy5fbWV0YUxheWVyID0gREcuTWV0YS5sYXllcihudWxsLCB7XG4gICAgICAgICAgICBkZXRlY3RSZXRpbmE6IG9wdGlvbnMuZGV0ZWN0UmV0aW5hLFxuICAgICAgICAgICAgbWF4TmF0aXZlWm9vbTogb3B0aW9ucy5tYXhOYXRpdmVab29tLFxuICAgICAgICAgICAgZGF0YUZpbHRlcjogREcuYmluZCh0aGlzLl9wcm9jZXNzRGF0YSwgdGhpcyksXG4gICAgICAgICAgICBtaW5ab29tOiBvcHRpb25zLm1pblpvb21cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2lzRGcgPSB0cnVlO1xuICAgICAgICB0aGlzLl9vblRpbWVyID0gREcuYmluZCh0aGlzLl9vblRpbWVyLCB0aGlzKTtcbiAgICAgICAgREcuVGlsZUxheWVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgdGhpcy5fdGlsZVVybCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vICNzZXRUaW1lKGRheSBbMC02XSwgdGltZVswLTIzXSkgPz8/P1xuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB0aGlzLl91cGRhdGVMYXllclByb2plY3QoKTtcblxuICAgICAgICBtYXBcbiAgICAgICAgICAgIC5hZGRMYXllcih0aGlzLl9tZXRhTGF5ZXIpXG4gICAgICAgICAgICAub24oJ3Byb2plY3RjaGFuZ2UgcHJvamVjdGxlYXZlJywgdGhpcy5fb25NYXBQcm9qZWN0Q2hhbmdlLCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlTGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX21ldGFMYXllci5vbih0aGlzLl9sYXllckV2ZW50c0xpc3RlbmVycywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbEhlbHBlciA9IERHLmxhYmVsKCk7XG4gICAgICAgICAgICB0aGlzLl9tYXAub24oJ2xhbmdjaGFuZ2UnLCB0aGlzLl91cGRhdGVMYW5nLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl91cGRhdGVJbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLl9vblRpbWVyLCB0aGlzLl91cGRhdGVJbnRlcnZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICBERy5UaWxlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3VwZGF0ZVRpbWVyKTtcblxuICAgICAgICBtYXBcbiAgICAgICAgICAgIC5yZW1vdmVMYXllcih0aGlzLl9tZXRhTGF5ZXIpXG4gICAgICAgICAgICAub2ZmKCdwcm9qZWN0Y2hhbmdlIHByb2plY3RsZWF2ZScsIHRoaXMuX29uTWFwUHJvamVjdENoYW5nZSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZUxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXRhTGF5ZXIub2ZmKHRoaXMuX2xheWVyRXZlbnRzTGlzdGVuZXJzLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYWJlbEhlbHBlcik7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbEhlbHBlciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9tYXAub2ZmKCdsYW5nY2hhbmdlJywgdGhpcy5fdXBkYXRlTGFuZywgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBERy5UaWxlTGF5ZXIucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLl9nZXRUaW1lc3RhbXBTdHJpbmcoKS50aGVuKFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9wdGlvbnMudGltZXN0YW1wU3RyaW5nID0gJz8nICsgcmVzcG9uc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zLnRpbWVzdGFtcFN0cmluZyA9ICc/JyArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9KS50aGVuKFxuICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5maXJlKCd1cGRhdGUnLCB7dGltZXN0YW1wOiBzZWxmLm9wdGlvbnMudGltZXN0YW1wU3RyaW5nfSk7XG4gICAgICAgICAgICAgICAgc2VsZi5fbGF5ZXJFdmVudHNMaXN0ZW5lcnMubW91c2VvdXQuY2FsbChzZWxmKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9tZXRhTGF5ZXIuZ2V0T3JpZ2luKCkuc2V0VVJMKHNlbGYuX3ByZXBhcmVNZXRhVVJMKCksIHNlbGYpO1xuICAgICAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGdldFN1YmRvbWFpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllcnNPcHRpb25zLnN1YmRvbWFpbnNbXG4gICAgICAgICAgICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLl9sYXllcnNPcHRpb25zLnN1YmRvbWFpbnMubGVuZ3RoKVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlTGFuZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsYW5nID0gdGhpcy5fbWFwLmdldExhbmcoKTtcbiAgICAgICAgaWYgKGxhbmcgPT09ICdhcicpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsSGVscGVyLm9wdGlvbnMudGV4dERpcmVjdGlvbiA9ICdydGwnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWxIZWxwZXIub3B0aW9ucy50ZXh0RGlyZWN0aW9uID0gJ2F1dG8nO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9nZXRUaW1lc3RhbXBTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gREcuYWpheChcbiAgICAgICAgICAgIERHLlV0aWwudGVtcGxhdGUoXG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZVVybCxcbiAgICAgICAgICAgICAgICBERy5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICBzIDogdGhpcy5nZXRTdWJkb21haW4oKSxcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdENvZGU6IHRoaXMuX21hcC5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpLmNvZGVcbiAgICAgICAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMgfHwge30pKSxcbiAgICAgICAgICAgIHt0eXBlOiAnZ2V0J31cbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgX29uVGltZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlcmlvZCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcHJvY2Vzc0RhdGE6IGZ1bmN0aW9uKHRyYWZmaWNEYXRhLCBjb29yZCkge1xuICAgICAgICB2YXIgdGlsZU9yaWdpblBvaW50ID0gY29vcmQuc2NhbGVCeSh0aGlzLmdldFRpbGVTaXplKCkpO1xuICAgICAgICB2YXIgcG9seWdvbkxuZ0xhdFRvUG9pbnRzID0gREcuYmluZCh0aGlzLl9wb2x5Z29uTG5nTGF0VG9Qb2ludHMsIHRoaXMsIHRpbGVPcmlnaW5Qb2ludCk7XG4gICAgICAgIHZhciBoaW50cyA9IHt9O1xuXG4gICAgICAgIGlmICghREcuVXRpbC5pc0FycmF5KHRyYWZmaWNEYXRhKSkgeyAgICAvLyBUT0RPIHJlbW92ZVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhZmZpY0RhdGFbMV0uZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICB0aGlzW2l0ZW0uZ3JhcGhfaWRdID0gaXRlbS5zcGVlZF90ZXh0O1xuICAgICAgICB9LCBoaW50cyk7XG5cbiAgICAgICAgcmV0dXJuIHRyYWZmaWNEYXRhWzBdXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5ncmFwaF9pZCxcbiAgICAgICAgICAgICAgICAgICAgc3BlZWQ6IGhpbnRzW2l0ZW0uZ3JhcGhfaWRdLFxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeTogREcuV2t0LnRvR2VvSlNPTihpdGVtLmdlb21ldHJ5WzBdLm9iamVjdFswXSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmdlb21ldHJ5LnR5cGUgPT0gJ1BvbHlnb24nIHx8XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZ2VvbWV0cnkudHlwZSA9PSAnTXVsdGlQb2x5Z29uJztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2VvSnNvbiA9IGl0ZW0uZ2VvbWV0cnk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZ2VvSnNvbi50eXBlID09ICdQb2x5Z29uJykge1xuICAgICAgICAgICAgICAgICAgICBnZW9Kc29uLmNvb3JkaW5hdGVzID0gcG9seWdvbkxuZ0xhdFRvUG9pbnRzKGdlb0pzb24uY29vcmRpbmF0ZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvSnNvbi50eXBlID09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb0pzb24uY29vcmRpbmF0ZXMgPSBnZW9Kc29uLmNvb3JkaW5hdGVzLm1hcChwb2x5Z29uTG5nTGF0VG9Qb2ludHMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9wb2x5Z29uTG5nTGF0VG9Qb2ludHM6IGZ1bmN0aW9uKG9yaWdpblBvaW50LCBwb2x5Z29uKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgcmV0dXJuIHBvbHlnb24ubWFwKGZ1bmN0aW9uKGNvbnRvdXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250b3VyLm1hcChmdW5jdGlvbihsbmdMYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwXG4gICAgICAgICAgICAgICAgICAgIC5wcm9qZWN0KFtsbmdMYXRbMV0sIGxuZ0xhdFswXV0pLnJvdW5kKClcbiAgICAgICAgICAgICAgICAgICAgLnN1YnRyYWN0KG9yaWdpblBvaW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3ByZXBhcmVNZXRhVVJMOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIERHLlV0aWwudGVtcGxhdGUodGhpcy5fbWV0YVVybCwgREcuZXh0ZW5kKHtcbiAgICAgICAgICAgIHg6ICd7eH0nLFxuICAgICAgICAgICAgeTogJ3t5fScsXG4gICAgICAgICAgICB6OiAne3p9JyxcbiAgICAgICAgICAgIHM6ICd7c30nXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlTGF5ZXJQcm9qZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb2plY3QgPSB0aGlzLl9tYXAucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKTtcbiAgICAgICAgREcuc2V0T3B0aW9ucyh0aGlzLCBwcm9qZWN0ICYmIHByb2plY3QudHJhZmZpYyA/IHtcbiAgICAgICAgICAgIHByb2plY3RDb2RlOiBwcm9qZWN0LmNvZGUsXG4gICAgICAgICAgICBib3VuZHM6IHByb2plY3QubGF0TG5nQm91bmRzLFxuICAgICAgICAgICAgbWluWm9vbTogTWF0aC5tYXgocHJvamVjdC5taW5ab29tLCB0aGlzLl9sYXllcnNPcHRpb25zLm1pblpvb20pLFxuICAgICAgICAgICAgbWF4Wm9vbTogcHJvamVjdC5tYXhab29tXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgICBtYXhab29tOiAwLFxuICAgICAgICAgICAgbWluWm9vbTogMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbWV0YUxheWVyLmdldE9yaWdpbigpLnNldFVSTCh0aGlzLl9wcmVwYXJlTWV0YVVSTCgpKTtcbiAgICB9LFxuXG4gICAgX29uTWFwUHJvamVjdENoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyUHJvamVjdCgpO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH0sXG5cbiAgICBfbGF5ZXJFdmVudHNMaXN0ZW5lcnM6IHtcbiAgICAgICAgbW91c2VvdmVyOiBmdW5jdGlvbihlKSB7IC8vIChPYmplY3QpXG4gICAgICAgICAgICB0aGlzLl9zZXRDdXJzb3IoJ3BvaW50ZXInKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYWJlbEhlbHBlciAmJiBlLm1ldGEuc3BlZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbEhlbHBlclxuICAgICAgICAgICAgICAgICAgICAuc2V0UG9zaXRpb24oZS5sYXRsbmcpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRDb250ZW50KGUubWV0YS5zcGVlZCArICcgJyArIHRoaXMudCgnc3BlZWRfdW5pdF9rbV9oJykpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRUbyh0aGlzLl9tYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3VzZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRDdXJzb3IoJycpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xhYmVsSGVscGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xhYmVsSGVscGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWxIZWxwZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbEhlbHBlci5zZXRQb3NpdGlvbihlLmxhdGxuZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldEN1cnNvcjogZnVuY3Rpb24oY3Vyc29yKSB7IC8vIChTdHJpbmcpXG4gICAgICAgIHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gICAgfVxuXG59KTtcblxuREcuVHJhZmZpYy5pbmNsdWRlKERHLkxvY2FsZSk7XG5cbkRHLnRyYWZmaWMgPSBmdW5jdGlvbihvcHRpb25zKSB7IC8vIChPYmplY3QpXG4gICAgcmV0dXJuIG5ldyBERy5UcmFmZmljKG9wdGlvbnMpO1xufTtcbiIsIkRHLlRyYWZmaWMuRGljdGlvbmFyeS5ydSA9IHtcbiAgICBzcGVlZF91bml0X2ttX2g6ICfQutC8L9GHJ1xufTtcbiIsIkRHLlRyYWZmaWMuRGljdGlvbmFyeS5pdCA9IHtcbiAgICBzcGVlZF91bml0X2ttX2g6ICdrbS9oJ1xufTtcbiIsIkRHLlRyYWZmaWMuRGljdGlvbmFyeS5jcyA9IHtcbiAgICBzcGVlZF91bml0X2ttX2g6ICdrbS9oJ1xufTtcbiIsIkRHLlRyYWZmaWMuRGljdGlvbmFyeS5lcyA9IHtcbiAgICBzcGVlZF91bml0X2ttX2g6ICdrbS9oJ1xufTtcbiIsIkRHLlRyYWZmaWMuRGljdGlvbmFyeS5lbiA9IHtcbiAgICBzcGVlZF91bml0X2ttX2g6ICdrbS9oJ1xufTtcbiIsIkRHLlRyYWZmaWMuRGljdGlvbmFyeS5hciA9IHtcbiAgICBzcGVlZF91bml0X2ttX2g6ICfZg9mFL9iz2KfYudipJ1xufTtcbiIsIkRHLkNvbnRyb2wuVHJhZmZpYyA9IERHLlJvdW5kQ29udHJvbC5leHRlbmQoe1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcG9zaXRpb246ICd0b3ByaWdodCcsXG4gICAgICAgIGljb25DbGFzczogJ3RyYWZmaWMnXG4gICAgfSxcblxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgRGljdGlvbmFyeToge31cbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLl90cmFmZmljQ2xhc3MgPSAnZGctdHJhZmZpYy1jb250cm9sJztcbiAgICAgICAgdGhpcy5fY29udHJvbEhpZGVDbGFzcyA9ICdkZy1jb250cm9sLXJvdW5kX2lzLWhpZGRlbl90cnVlJztcblxuICAgICAgICBERy5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBERy5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgX2FjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBfdHJhZmZpY0xheWVyOiBudWxsXG4gICAgICAgIH0pLm9uKHRoaXMuX2NvbnRyb2xFdmVudHMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBfY29udHJvbEV2ZW50czoge1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fdHJhZmZpY0xheWVyID0gREcudHJhZmZpYygpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9uKCd6b29tZW5kIHByb2plY3RjaGFuZ2UgcHJvamVjdGxlYXZlJywgdGhpcy5fdXBkYXRlQ29udHJvbFZpc2liaWxpdHksIHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBjbGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSAhdGhpcy5fYWN0aXZlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvd1RyYWZmaWMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5faGlkZVRyYWZmaWMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMub2ZmKHRoaXMuX2NvbnRyb2xFdmVudHMsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9mZignem9vbWVuZCBwcm9qZWN0Y2hhbmdlIHByb2plY3RsZWF2ZScsIHRoaXMuX3VwZGF0ZUNvbnRyb2xWaXNpYmlsaXR5LCB0aGlzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fdHJhZmZpY0xheWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RyYWZmaWNMYXllciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3Nob3dUcmFmZmljOiBmdW5jdGlvbigpIHsgLy8gKClcbiAgICAgICAgdGhpcy5fdXBkYXRlVHJhZmZpY1Njb3JlKCk7XG4gICAgICAgIHRoaXMuX21hcC5hZGRMYXllcih0aGlzLl90cmFmZmljTGF5ZXIpO1xuICAgIH0sXG5cbiAgICBfaGlkZVRyYWZmaWM6IGZ1bmN0aW9uKCkgeyAvLyAoKVxuICAgICAgICB0aGlzLl9oYW5kbGVEb20oJ3JlbW92ZScpO1xuICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fdHJhZmZpY0xheWVyKTtcbiAgICB9LFxuXG4gICAgX2hhbmRsZURvbTogZnVuY3Rpb24obWV0aG9kLCBzY29yZSkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuX2xpbms7XG5cbiAgICAgICAgYS5pbm5lckhUTUwgPSBzY29yZSB8fCAnJztcbiAgICAgICAgREcuRG9tVXRpbFttZXRob2QgKyAnQ2xhc3MnXShhLCB0aGlzLl90cmFmZmljQ2xhc3MpO1xuICAgICAgICBERy5Eb21VdGlsW21ldGhvZCArICdDbGFzcyddKGEsIHRoaXMuX3RyYWZmaWNDbGFzcyArICdfY29sb3JfJyArIHRoaXMuX3Njb3JlUmF0ZSk7XG4gICAgfSxcblxuICAgIF9nZXRUcmFmZmljQ29sb3I6IGZ1bmN0aW9uKHNjb3JlKSB7IC8vIChOdW1iZXIpIC0+IFN0cmluZ1xuICAgICAgICB2YXIgcmVzdWx0ID0gJ2dyZWVuJztcblxuICAgICAgICBpZiAoc2NvcmUgPiA3KSB7XG4gICAgICAgICAgICByZXN1bHQgPSAncmVkJztcbiAgICAgICAgfSBlbHNlIGlmIChzY29yZSA+IDQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9ICd5ZWxsb3cnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUNvbnRyb2xWaXNpYmlsaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb2plY3QgPSB0aGlzLl9tYXAucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKSxcbiAgICAgICAgICAgIHByb2plY3RIYXNUcmFmZmljID0gcHJvamVjdCAmJiBwcm9qZWN0LnRyYWZmaWMsXG4gICAgICAgICAgICBtZXRob2QgPSAoKHRoaXMuX21hcC5nZXRab29tKCkgPCBERy5jb25maWcudHJhZmZpY0xheWVyTWluWm9vbSkgfHxcbiAgICAgICAgICAgICghcHJvamVjdEhhc1RyYWZmaWMpKSA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnO1xuXG4gICAgICAgIERHLkRvbVV0aWxbbWV0aG9kXSh0aGlzLl9jb250YWluZXIsIHRoaXMuX2NvbnRyb2xIaWRlQ2xhc3MpO1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlICYmIHByb2plY3RIYXNUcmFmZmljKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUcmFmZmljU2NvcmUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdXBkYXRlVHJhZmZpY1Njb3JlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX2dldFRyYWZmaWNTY29yZSgpLnRoZW4oZnVuY3Rpb24oc2NvcmUpIHtcbiAgICAgICAgICAgIHNjb3JlID0gcGFyc2VJbnQoc2NvcmUsIDEwKTsgLy8gc29tZXRpbWVzIHdlYmFwaSByZXR1cm5zIHNvbWV0aGluZyBsaWtlICc1LCsnXG5cbiAgICAgICAgICAgIHNlbGYuX3Njb3JlUmF0ZSA9IHNlbGYuX2dldFRyYWZmaWNDb2xvcihzY29yZSk7XG4gICAgICAgICAgICBzZWxmLl9oYW5kbGVEb20oJ2FkZCcsIHNjb3JlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9nZXRUcmFmZmljU2NvcmU6IGZ1bmN0aW9uKCkgeyAvLyAoKSAtPiBQcm9taXNlXG4gICAgICAgIHZhciB1cmwgPSBERy5VdGlsLnRlbXBsYXRlKFxuICAgICAgICAgICAgREcuY29uZmlnLnByb3RvY29sICsgREcuY29uZmlnLnRyYWZmaWNTY29yZVNlcnZlcixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzOiB0aGlzLl90cmFmZmljTGF5ZXIuZ2V0U3ViZG9tYWluKCksXG4gICAgICAgICAgICAgICAgcHJvamVjdENvZGU6IHRoaXMuX21hcC5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpLmNvZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gREcuYWpheCh1cmwsIHt0eXBlOiAnZ2V0J30pO1xuICAgIH0sXG5cbiAgICBfcmVuZGVyVHJhbnNsYXRpb246IGZ1bmN0aW9uKCkgeyAvLyAoKVxuICAgICAgICB0aGlzLl9saW5rLnRpdGxlID0gdGhpcy50KCdidXR0b25fdGl0bGUnKTtcbiAgICB9XG59KTtcblxuREcuY29udHJvbC50cmFmZmljID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuQ29udHJvbC5UcmFmZmljKG9wdGlvbnMpO1xufTtcblxuREcuTWFwLm1lcmdlT3B0aW9ucyh7XG4gICAgdHJhZmZpY0NvbnRyb2w6IGZhbHNlXG59KTtcblxuREcuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudHJhZmZpY0NvbnRyb2wpIHtcbiAgICAgICAgdGhpcy50cmFmZmljQ29udHJvbCA9IERHLmNvbnRyb2wudHJhZmZpYyh0aGlzLm9wdGlvbnMudHJhZmZpY0NvbnRyb2wpO1xuICAgICAgICB0aGlzLmFkZENvbnRyb2wodGhpcy50cmFmZmljQ29udHJvbCk7XG4gICAgfVxufSk7XG4iLCJERy5Db250cm9sLlRyYWZmaWMuRGljdGlvbmFyeS5ydSA9IHtcbiAgICBidXR0b25fdGl0bGU6ICfQn9GA0L7QsdC60LgnXG59O1xuIiwiREcuQ29udHJvbC5UcmFmZmljLkRpY3Rpb25hcnkuaXQgPSB7XG4gICAgYnV0dG9uX3RpdGxlOiAnQ29sb25uYSdcbn07XG4iLCJERy5Db250cm9sLlRyYWZmaWMuRGljdGlvbmFyeS5jcyA9IHtcbiAgICBidXR0b25fdGl0bGU6ICdaw6FjcHknXG59O1xuIiwiREcuQ29udHJvbC5UcmFmZmljLkRpY3Rpb25hcnkuZXMgPSB7XG4gICAgYnV0dG9uX3RpdGxlOiAnVGFjbydcbn07XG4iLCJERy5Db250cm9sLlRyYWZmaWMuRGljdGlvbmFyeS5lbiA9IHtcbiAgICBidXR0b25fdGl0bGU6ICdUcmFmZmljJ1xufTtcbiIsIkRHLkNvbnRyb2wuVHJhZmZpYy5EaWN0aW9uYXJ5LmFyID0ge1xuICAgIGJ1dHRvbl90aXRsZTogJ9it2LHZg9ipINin2YTYs9mK2LEnXG59O1xuIiwiREcuUnVsZXIgPSBERy5MYXllci5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBlZGl0YWJsZTogdHJ1ZVxuICAgIH0sXG5cbiAgICBpbmNsdWRlczogW0RHLkxvY2FsZV0sXG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIERpY3Rpb25hcnk6IHt9XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGxhdGxuZ3MsIG9wdGlvbnMpIHsgLy8gKEFycmF5LCBPYmplY3QpXG4gICAgICAgIERHLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLl9sYXllcnMgPSB7XG4gICAgICAgICAgICBiYWNrIDogbnVsbCxcbiAgICAgICAgICAgIG1pZGRsZSA6IG51bGwsXG4gICAgICAgICAgICBmcm9udCA6IG51bGwsXG4gICAgICAgICAgICBtb3VzZSA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcG9pbnRzID0gW107XG5cbiAgICAgICAgdGhpcy5fbGF5ZXJzQ29udGFpbmVyID0gREcuZmVhdHVyZUdyb3VwKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2xheWVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllcnNDb250YWluZXIuYWRkTGF5ZXIodGhpcy5fbGF5ZXJzW25hbWVdID0gREcuZmVhdHVyZUdyb3VwKCkpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB0aGlzLl9yZXNldCgpO1xuXG4gICAgICAgIGlmIChERy5Ccm93c2VyLm1vYmlsZSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpbmVNb3VzZUV2ZW50cy5tb3VzZW92ZXI7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbGluZU1vdXNlRXZlbnRzLm1vdXNlb3V0O1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpbmVNb3VzZUV2ZW50cy5tb3VzZW1vdmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbGluZU1vdXNlRXZlbnRzLmNsaWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhdGxuZ3MgJiYgbGF0bG5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TGF0TG5ncyhsYXRsbmdzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7IC8vIChNYXApXG4gICAgICAgIHRoaXMuX21hcCA9IG1hcC5vbignbGFuZ2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc3RhbmNlLCB0aGlzKTtcblxuICAgICAgICAvLyAgUGFuZSBmb3IgcnVsZXIgTWFya2Vyc1xuICAgICAgICBpZiAoIXRoaXMuX21hcC5nZXRQYW5lKCdydWxlck1hcmtlclBhbmUnKSkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLmNyZWF0ZVBhbmUoJ3J1bGVyTWFya2VyUGFuZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIE1haW4gcnVsZXIgcGFuZSAoc3ZnIG9iamVjdHMgYW5kIHJ1bm5lcilcbiAgICAgICAgaWYgKCF0aGlzLl9tYXAuZ2V0UGFuZSgncnVsZXJQYW5lJykpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5jcmVhdGVQYW5lKCdydWxlclBhbmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xheWVyc0NvbnRhaW5lci5hZGRUbyh0aGlzLl9tYXApO1xuXG4gICAgICAgIGlmICh0aGlzLl9wb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllcnMubW91c2UuZmlyZSgnbGF5ZXJhZGQnKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpc3RhbmNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sYXllcnMubW91c2Uub24odGhpcy5fbGluZU1vdXNlRXZlbnRzLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uKG1hcCkgeyAvLyAoTWFwKVxuICAgICAgICBtYXBcbiAgICAgICAgICAgIC5vZmYoJ2xhbmdjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXN0YW5jZSwgdGhpcylcbiAgICAgICAgICAgIC5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNDb250YWluZXIpO1xuXG4gICAgICAgIHRoaXMuX2xheWVycy5tb3VzZS5vZmYodGhpcy5fbGluZU1vdXNlRXZlbnRzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICB9LFxuXG4gICAgZ2V0VG90YWxEaXN0YW5jZTogZnVuY3Rpb24oKSB7IC8vICgpIC0+IE51bWJlclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY0Rpc3RhbmNlKCk7XG4gICAgfSxcblxuICAgIHNwbGljZUxhdExuZ3M6IGZ1bmN0aW9uKGluZGV4KSB7IC8vIChOdW1iZXIsIE51bWJlciwgYXJncyAuLi4pIC0+IEFycmF5XG4gICAgICAgIHZhciBvbGRMZW5ndGggPSB0aGlzLl9wb2ludHMubGVuZ3RoLFxuICAgICAgICAgICAgbXV0YXRpb25TdGFydCA9IGluZGV4ID49IDAgPyBNYXRoLm1pbihpbmRleCwgb2xkTGVuZ3RoKSA6IG9sZExlbmd0aCAtIGluZGV4LFxuICAgICAgICAgICAgcmVtb3ZlZCA9IEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkodGhpcy5fcG9pbnRzLCBhcmd1bWVudHMpLm1hcChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVycy5tb3VzZS5yZW1vdmVMYXllcihwb2ludCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50Lm9mZigpLmdldExhdExuZygpO1xuICAgICAgICAgICAgfSwgdGhpcyksXG4gICAgICAgICAgICBsZW5ndGggPSB0aGlzLl9wb2ludHMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBtdXRhdGlvblN0YXJ0OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzLl9wb2ludHNbaV0gaW5zdGFuY2VvZiBERy5SdWxlci5MYXllcmVkTWFya2VyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludHNbaV0gPSB0aGlzLl9jcmVhdGVQb2ludCh0aGlzLl9wb2ludHNbaV0sIHRoaXMub3B0aW9ucy5pY29uU3R5bGVzLmxhcmdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKHRoaXMuX3BvaW50RXZlbnRzLCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uY2UoJ2FkZCcsIHRoaXMuX2FkZENsb3NlSGFuZGxlciwgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRUbyh0aGlzLl9sYXllcnMubW91c2UsIHRoaXMuX2xheWVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpICYmICF0aGlzLl9wb2ludHNbaSAtIDFdLl9sZWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZExlZ3ModGhpcy5fcG9pbnRzW2kgLSAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50c1tpXS5zZXRQb2ludFN0eWxlKHRoaXMub3B0aW9ucy5pY29uU3R5bGVzW2kgJiYgaSA8IGxlbmd0aCAtIDEgPyAnc21hbGwnIDogJ2xhcmdlJ10pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50c1tpXS5fcG9zID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUxlZ3ModGhpcy5fcG9pbnRzW2xlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIGlmIChvbGRMZW5ndGggPiAwICYmIG9sZExlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50c1tvbGRMZW5ndGggLSAxXS5jb2xsYXBzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BvaW50c1ttdXRhdGlvblN0YXJ0XSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxlZ3ModGhpcy5fcG9pbnRzW211dGF0aW9uU3RhcnRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtdXRhdGlvblN0YXJ0ID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50c1ttdXRhdGlvblN0YXJ0IC0gMV0uc2V0UG9pbnRTdHlsZSh0aGlzLm9wdGlvbnMuaWNvblN0eWxlcy5zbWFsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEaXN0YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5fbm9ybWFsaXplUnVsZXJQb2ludHMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoREcuQnJvd3Nlci50b3VjaCAmJiB0aGlzLl9saW5lTWFya2VySGVscGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lTWFya2VySGVscGVyLmNvbGxhcHNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlyZUNoYW5nZUV2ZW50KCk7XG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0sXG5cbiAgICBhZGRMYXRMbmc6IGZ1bmN0aW9uKGxhdGxuZykgeyAvLyAoTGF0TG5nKSAtPiBSdWxlclxuICAgICAgICB2YXIgbGFzdFBvaW50ID0gdGhpcy5fcG9pbnRzW3RoaXMuX3BvaW50cy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgICAgICBsYXRsbmcgPSBERy5sYXRMbmcobGF0bG5nKTtcblxuICAgICAgICBpZiAobGFzdFBvaW50KSB7XG4gICAgICAgICAgICBsYXRsbmcgPSB0aGlzLl9ub3JtYWxpemVMYXRMbmcobGF0bG5nLCBsYXN0UG9pbnQuZ2V0TGF0TG5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zcGxpY2VMYXRMbmdzKHRoaXMuX3BvaW50cy5sZW5ndGgsIDAsIGxhdGxuZyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRMYXRMbmdzOiBmdW5jdGlvbigpIHsgLy8gKCkgLT4gQXJyYXlcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50cy5tYXAoZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwb2ludC5nZXRMYXRMbmcoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHNldExhdExuZ3M6IGZ1bmN0aW9uKGxhdGxuZ3MpIHsgLy8gKEFycmF5KSAtPiBSdWxlclxuICAgICAgICB2YXIgYXJncyA9IGxhdGxuZ3Muc2xpY2UoKTtcbiAgICAgICAgYXJncy51bnNoaWZ0KDAsIHRoaXMuX3BvaW50cy5sZW5ndGgpO1xuICAgICAgICB0aGlzLnNwbGljZUxhdExuZ3MuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcmVzZXQ6IGZ1bmN0aW9uKCkgeyAvLyAoKVxuICAgICAgICBERy5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgX2xpbmVNYXJrZXJIZWxwZXI6IG51bGwsXG4gICAgICAgICAgICBfbW9ycGhpbmdOb3c6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfbGluZU1vdXNlRXZlbnRzOiB7XG4gICAgICAgIGNsaWNrOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LmxheWVyO1xuICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIERHLk1hcmtlciAmJiB0YXJnZXQuX3BvcyAhPT0gdGhpcy5fcG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGluZU1hcmtlckhlbHBlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9saW5lTWFya2VySGVscGVyLmNvbGxhcHNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldC5zZXRUZXh0KHRoaXMuX2dldEZvcm1hdGVkRGlzdGFuY2UodGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZU1hcmtlckhlbHBlciA9IHRhcmdldDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgREcuUGF0aCAmJiB0aGlzLm9wdGlvbnMuZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF0bG5nID0gZXZlbnQubGF0bG5nLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRQb3MgPSB0YXJnZXQuX3BvaW50Ll9wb3MgKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMuc3BsaWNlTGF0TG5ncyhpbnNlcnRQb3MsIDAsIGxhdGxuZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlb3ZlcjogZnVuY3Rpb24oZXZlbnQpIHsgLy8gKE1vdXNlRXZlbnQpXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQubGF5ZXI7XG5cbiAgICAgICAgICAgIHRhcmdldC5faG92ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fbW9ycGhpbmdOb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgREcuTWFya2VyICYmIHRhcmdldC5fcG9zICE9PSB0aGlzLl9wb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5zZXRUZXh0KHRoaXMuX2dldEZvcm1hdGVkRGlzdGFuY2UodGFyZ2V0KSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIERHLlBhdGggJiYgIXRoaXMuX2xpbmVNYXJrZXJIZWxwZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSB0YXJnZXQuX3BvaW50O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZU1hcmtlckhlbHBlciA9IHRoaXMuX2FkZFJ1bm5pbmdMYWJlbChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmVhcmVzdFBvaW50KHBvaW50Ll9sZWdzLm1pZGRsZSwgZXZlbnQubGF0bG5nKSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3VzZW91dDogZnVuY3Rpb24oZXZlbnQpIHsgLy8gKE1vdXNlRXZlbnQpXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQubGF5ZXIsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdiA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG5cbiAgICAgICAgICAgIHRhcmdldC5faG92ZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX21vcnBoaW5nTm93IHx8IHRhcmdldC5fcG9zID09PSB0aGlzLl9wb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBERy5NYXJrZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBjb2xsYXBzZSBvbmx5IHdoZW4gd2UgbW92ZSBvdXQgZnJvbSBsYWJlbCBjb250YWluZXIgKGlmIGJyb3dzZXIgc3VwcG9ydCByZWxhdGVkVGFyZ2V0KVxuICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxFdi5yZWxhdGVkVGFyZ2V0IHx8XG4gICAgICAgICAgICAgICAgICAgIChvcmlnaW5hbEV2LnJlbGF0ZWRUYXJnZXQgIT09IHRhcmdldC5xdWVyeVNlbGVjdG9yKCdjb250YWluZXInKSAmJlxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2LnJlbGF0ZWRUYXJnZXQucGFyZW50Tm9kZSAhPT0gdGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJ2NvbnRhaW5lcicpKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuY29sbGFwc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVJ1bm5pbmdMYWJlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uKGV2ZW50KSB7IC8vIChNb3VzZUV2ZW50KVxuICAgICAgICAgICAgaWYgKHRoaXMuX21vcnBoaW5nTm93IHx8ICF0aGlzLl9saW5lTWFya2VySGVscGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBldmVudC5sYXllci5fcG9pbnQsXG4gICAgICAgICAgICAgICAgbGF0bG5nID0gdGhpcy5fbmVhcmVzdFBvaW50KHBvaW50Ll9sZWdzLm1pZGRsZSwgZXZlbnQubGF0bG5nKTtcblxuICAgICAgICAgICAgdGhpcy5fbGluZU1hcmtlckhlbHBlclxuICAgICAgICAgICAgICAgICAgICAuc2V0TGF0TG5nKGxhdGxuZylcbiAgICAgICAgICAgICAgICAgICAgLnNldFRleHQodGhpcy5fZ2V0Rm9ybWF0ZWREaXN0YW5jZShwb2ludCwgcG9pbnQuZ2V0TGF0TG5nKCkuZGlzdGFuY2VUbyhsYXRsbmcpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxheWVyYWRkOiBmdW5jdGlvbigpIHsgLy8gKClcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2xheWVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW25hbWVdLmJyaW5nVG9Gcm9udCgpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2ZpcmVDaGFuZ2VFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnY2hhbmdlZCcsIHtsYXRsbmdzIDogdGhpcy5nZXRMYXRMbmdzKCl9KTtcbiAgICB9LFxuXG4gICAgX2FkZFJ1bm5pbmdMYWJlbDogZnVuY3Rpb24obGF0bG5nLCBwcmV2aW91c1BvaW50KSB7IC8vIChMYXRMbmcsIFJ1bGVyLkxheWVyZWRNYXJrZXIpXG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMuX2NyZWF0ZVBvaW50KGxhdGxuZykuYWRkVG8odGhpcy5fbGF5ZXJzLm1vdXNlLCB0aGlzLl9sYXllcnMpO1xuICAgICAgICB2YXIgcGFuZSA9IHRoaXMuX21hcC5nZXRQYW5lKCdydWxlclBhbmUnKTtcbiAgICAgICAgcGFuZS5pbnNlcnRCZWZvcmUocG9pbnQuX2ljb24sIHBhbmUubGFzdEVsZW1lbnRDaGlsZCk7XG4gICAgICAgIHJldHVybiBwb2ludC5zZXRUZXh0KHRoaXMuX2dldEZvcm1hdGVkRGlzdGFuY2UocHJldmlvdXNQb2ludCwgcHJldmlvdXNQb2ludC5nZXRMYXRMbmcoKS5kaXN0YW5jZVRvKGxhdGxuZykpKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZVJ1bm5pbmdMYWJlbDogZnVuY3Rpb24oKSB7IC8vICgpXG4gICAgICAgIGlmICh0aGlzLl9saW5lTWFya2VySGVscGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllcnMubW91c2UucmVtb3ZlTGF5ZXIodGhpcy5fbGluZU1hcmtlckhlbHBlcik7XG4gICAgICAgICAgICB0aGlzLl9saW5lTWFya2VySGVscGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfaW5zZXJ0UG9pbnRJbkxpbmU6IGZ1bmN0aW9uKGV2ZW50KSB7IC8vIChNb3VzZUV2ZW50KVxuICAgICAgICB2YXIgbGF0bG5nID0gdGhpcy5fbGluZU1hcmtlckhlbHBlci5nZXRMYXRMbmcoKSxcbiAgICAgICAgICAgIGluc2VydFBvcyA9IGV2ZW50LnRhcmdldC5fcG9pbnQuX3BvcyArIDEsXG4gICAgICAgICAgICBwb2ludDtcblxuICAgICAgICBpZiAoTC5Ccm93c2VyLmllKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudGFyZ2V0IHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQuc3JjRWxlbWVudCxcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXRoLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQocGF0aCk7IC8vIElFIGNsaWNrIGV2ZW50IGxlYWtpbmcgcHJvYmxlbSBzb2x1dGlvbjogd2UgcmVhcHBlbmQgbW91c2Vkb3duIGV2ZW50IHRhcmdldCBlbGVtZW50XG4gICAgICAgIH1cblxuICAgICAgICBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihldmVudC5vcmlnaW5hbEV2ZW50KTtcblxuICAgICAgICB0aGlzLnNwbGljZUxhdExuZ3MoaW5zZXJ0UG9zLCAwLCBsYXRsbmcpO1xuICAgICAgICBwb2ludCA9IHRoaXMuX3BvaW50c1tpbnNlcnRQb3NdO1xuICAgICAgICBwb2ludC5zZXRUZXh0KHRoaXMuX2dldEZvcm1hdGVkRGlzdGFuY2UocG9pbnQpKTtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcbiAgICAgICAgICAgICAgICBlLmluaXRNb3VzZUV2ZW50KCdtb3VzZXVwJywgZmFsc2UsIGZhbHNlLCBkb2N1bWVudC5kZWZhdWx0VmlldywgMSwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDEsIHBvaW50Ll9pY29uKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGUpO1xuXG4gICAgICAgICAgICAgICAgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuICAgICAgICAgICAgICAgIGUuaW5pdE1vdXNlRXZlbnQoJ21vdXNlZG93bicsIGZhbHNlLCBmYWxzZSwgZG9jdW1lbnQuZGVmYXVsdFZpZXcsIDEsIDAsIDAsIDAsIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAxLCBwb2ludC5faWNvbik7XG4gICAgICAgICAgICAgICAgcG9pbnQuX2ljb24uZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9pbnQuX2ljb24uZmlyZUV2ZW50KCdvbk1vdXNlVXAnLCBERy5leHRlbmQoZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKSwge1xuICAgICAgICAgICAgICAgICAgICBidXR0b246IDEsXG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBwb2ludC5faWNvbi5maXJlRXZlbnQoJ29uTW91c2VEb3duJywgREcuZXh0ZW5kKGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCksIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uOiAxLFxuICAgICAgICAgICAgICAgICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIHRoaXMuX3JlbW92ZVJ1bm5pbmdMYWJlbCgpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxlZ3MocG9pbnQpO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIHRoZSBwb2ludCBvbiBnaXZlbiBwb2x5bGluZSB3aGljaCBpcyBjbG9zZXN0IHRvIGdpdmVuIGxhdGxuZ1xuICAgIF9uZWFyZXN0UG9pbnQ6IGZ1bmN0aW9uKHBvbHlsaW5lLCBsYXRsbmcpIHsgLy8gKFBvbHlsaW5lLCBMYXRMbmcpIC0+IExhdExuZ1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gQ29udmVydCBldmVyeXRoaW5nIHRvIHBpeGVsIGNvb3JkaW5hdGVzXG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMuX3Byb2plY3QobGF0bG5nKTtcbiAgICAgICAgdmFyIGxpbmVQb2ludHMgPSBwb2x5bGluZS5nZXRMYXRMbmdzKCkubWFwKGZ1bmN0aW9uKGxhdGxuZykge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3Byb2plY3QobGF0bG5nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRmlyc3QgbG9vayBmb3IgY2xvc2VzdCBwb2x5bGluZSBzZWdtZW50XG4gICAgICAgIHZhciBtaW5EaXN0YW5jZTtcbiAgICAgICAgdmFyIGNsb3Nlc3RTZWdtZW50SW5kZXg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IERHLkxpbmVVdGlsLnBvaW50VG9TZWdtZW50RGlzdGFuY2UoXG4gICAgICAgICAgICAgICAgcG9pbnQsXG4gICAgICAgICAgICAgICAgbGluZVBvaW50c1tpXSxcbiAgICAgICAgICAgICAgICBsaW5lUG9pbnRzW2kgKyAxXVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKG1pbkRpc3RhbmNlID09PSB1bmRlZmluZWQgfHwgZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFNlZ21lbnRJbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVuIGxvb2sgZm9yIGNsb3Nlc3QgcG9pbnQgb24gdGhhdCBzZWdtZW50XG4gICAgICAgIHZhciBjbG9zZXN0UG9pbnQgPSBERy5MaW5lVXRpbC5jbG9zZXN0UG9pbnRPblNlZ21lbnQoXG4gICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgIGxpbmVQb2ludHNbY2xvc2VzdFNlZ21lbnRJbmRleF0sXG4gICAgICAgICAgICBsaW5lUG9pbnRzW2Nsb3Nlc3RTZWdtZW50SW5kZXggKyAxXVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIENvbnZlcnQgYmFjayB0byBMYXRMbmdcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucHJvamVjdChjbG9zZXN0UG9pbnQpO1xuICAgIH0sXG5cbiAgICBfYWRkQ2xvc2VIYW5kbGVyOiBmdW5jdGlvbihldmVudCkgeyAvLyAoRXZlbnQpXG4gICAgICAgIGV2ZW50LnRhcmdldFxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCB0aGlzLl9kZWxldGVQb2ludCwgdGhpcylcbiAgICAgICAgICAgICAgICAucXVlcnlTZWxlY3RvcigncmVtb3ZlLWxpbmsnKS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgfSxcblxuICAgIF9jcmVhdGVQb2ludDogZnVuY3Rpb24obGF0bG5nLCBzdHlsZSkgeyAvLyAoTGF0TG5nLCBPYmplY3QpIC0+IFJ1bGVyLkxheWVyZWRNYXJrZXJcbiAgICAgICAgdmFyIHBvaW50U3R5bGUgPSBzdHlsZSA/IHN0eWxlIDogdGhpcy5vcHRpb25zLmljb25TdHlsZXMubGFyZ2UsXG4gICAgICAgICAgICBsYXllcnMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMocG9pbnRTdHlsZSkuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgbGF5ZXJzW2xheWVyXSA9IERHLmNpcmNsZU1hcmtlcihsYXRsbmcsIHBvaW50U3R5bGVbbGF5ZXJdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIERHLlJ1bGVyLmxheWVyZWRNYXJrZXIobGF0bG5nLCB7XG4gICAgICAgICAgICBsYXllcnMgOiBsYXllcnMsXG4gICAgICAgICAgICBkcmFnZ2FibGUgOiB0aGlzLm9wdGlvbnMuZWRpdGFibGUsXG4gICAgICAgICAgICB0ZXh0RGlyZWN0aW9uOiB0aGlzLl9tYXAuZ2V0TGFuZygpICE9PSAnYXInID8gJ2F1dG8nIDogJ3J0bCdcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIE1vdmVzIGN1cnIgTGF0TG5nIHRvIGNvcnJlY3Qgd29ybGQgaWYgbmVjZXNzYXJ5IHNvIHRoYXQgcnVsZXIgc2VjdGlvblxuICAgIC8vIGJldHdlZW4gY3VyciBhbmQgYmFzZSBjYW4gYmUgcGxvdHRlZCBjb3JyZWN0bHkuIFJldHVybnMgYSBuZXcgTGF0TG5nXG4gICAgLy8gb2JqZWN0LlxuICAgIF9ub3JtYWxpemVMYXRMbmc6IGZ1bmN0aW9uKGN1cnIsIGJhc2UpIHsgLy8gKExhdExuZywgTGF0TG5nKSAtPiBMYXRMbmdcbiAgICAgICAgdmFyIGRpZmYgPSAoY3Vyci5sbmcgPCBiYXNlLmxuZykgPyAzNjAgOiAtMzYwO1xuXG4gICAgICAgIHZhciBuZXdMbmcgPSBjdXJyLmxuZztcbiAgICAgICAgd2hpbGUgKE1hdGguYWJzKG5ld0xuZyAtIGJhc2UubG5nKSA+IDE4MCkge1xuICAgICAgICAgICAgbmV3TG5nICs9IGRpZmY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gREcubGF0TG5nKGN1cnIubGF0LCBuZXdMbmcpO1xuICAgIH0sXG5cbiAgICAvLyBSZWFycmFuZ2VzIHJ1bGVyIHBvaW50cyBiZXR3ZWVuIHdvcmxkcyBiYXNlZCBvbiBwb2ludCBwYXJhbSBzbyB0aGF0IGFsbFxuICAgIC8vIHJ1bGVyIHNlY3Rpb25zIGNhbiBiZSBwbG90dGVkIGNvcnJlY3RseS5cbiAgICBfbm9ybWFsaXplUnVsZXJQb2ludHM6IGZ1bmN0aW9uKHBvaW50KSB7IC8vIChSdWxlci5MYXllcmVkTWFya2VyKVxuICAgICAgICBwb2ludCA9IHBvaW50IHx8IHRoaXMuX3BvaW50c1swXTtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHBvaW50Ll9wb3M7XG4gICAgICAgIHZhciBjaGFuZ2VkUG9pbnRzID0gW107XG4gICAgICAgIHZhciBpLCBjdXJyUG9pbnQsIHByZXZQb2ludCwgbGF0bG5nLCBub3JtYWxpemVkO1xuXG4gICAgICAgIC8vIENoZWNrIHBvaW50cyB0byB0aGUgcmlnaHRcbiAgICAgICAgZm9yIChpID0gcG9zaXRpb24gKyAxOyBpIDwgdGhpcy5fcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyUG9pbnQgPSB0aGlzLl9wb2ludHNbaV07XG4gICAgICAgICAgICBwcmV2UG9pbnQgPSB0aGlzLl9wb2ludHNbaSAtIDFdO1xuXG4gICAgICAgICAgICBsYXRsbmcgPSBjdXJyUG9pbnQuZ2V0TGF0TG5nKCk7XG4gICAgICAgICAgICBub3JtYWxpemVkID0gdGhpcy5fbm9ybWFsaXplTGF0TG5nKGxhdGxuZywgcHJldlBvaW50LmdldExhdExuZygpKTtcblxuICAgICAgICAgICAgaWYgKCFub3JtYWxpemVkLmVxdWFscyhsYXRsbmcpKSB7XG4gICAgICAgICAgICAgICAgY3VyclBvaW50LnNldExhdExuZyhub3JtYWxpemVkKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkUG9pbnRzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBwb2ludHMgdG8gdGhlIGxlZnRcbiAgICAgICAgZm9yIChpID0gcG9zaXRpb24gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY3VyclBvaW50ID0gdGhpcy5fcG9pbnRzW2ldO1xuICAgICAgICAgICAgcHJldlBvaW50ID0gdGhpcy5fcG9pbnRzW2kgKyAxXTtcblxuICAgICAgICAgICAgbGF0bG5nID0gY3VyclBvaW50LmdldExhdExuZygpO1xuICAgICAgICAgICAgbm9ybWFsaXplZCA9IHRoaXMuX25vcm1hbGl6ZUxhdExuZyhsYXRsbmcsIHByZXZQb2ludC5nZXRMYXRMbmcoKSk7XG5cbiAgICAgICAgICAgIGlmICghbm9ybWFsaXplZC5lcXVhbHMobGF0bG5nKSkge1xuICAgICAgICAgICAgICAgIGN1cnJQb2ludC5zZXRMYXRMbmcobm9ybWFsaXplZCk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZFBvaW50cy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIGxlZ3Mgb2YgYWxsIHBvaW50cyB0aGF0IGNoYW5nZWQgcG9zaXRpb25cbiAgICAgICAgY2hhbmdlZFBvaW50cy5zb3J0KCkucmVkdWNlKGZ1bmN0aW9uKHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgc2tpcFByZXZpb3VzID0gcHJldmlvdXMgJiYgcHJldmlvdXMgPT09IGN1cnJlbnQgLSAxO1xuXG4gICAgICAgICAgICBzZWxmLl91cGRhdGVMZWdzKHNlbGYuX3BvaW50c1tjdXJyZW50XSwgc2tpcFByZXZpb3VzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgIH0sIG51bGwpO1xuICAgIH0sXG5cbiAgICBfcG9pbnRFdmVudHM6IHtcbiAgICAgICAgZHJhZzogZnVuY3Rpb24oZXZlbnQpIHsgLy8gKEV2ZW50KVxuICAgICAgICAgICAgdmFyIHBvaW50ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgICAgICAgICB0aGlzLl9ub3JtYWxpemVSdWxlclBvaW50cyhwb2ludCk7XG5cbiAgICAgICAgICAgIGlmICghREcuQnJvd3Nlci50b3VjaCAmJiBwb2ludCAhPT0gdGhpcy5fcG9pbnRzW3RoaXMuX3BvaW50cy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIHBvaW50LnNldFRleHQodGhpcy5fZ2V0Rm9ybWF0ZWREaXN0YW5jZShwb2ludCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMZWdzKHBvaW50KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpc3RhbmNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdlbmQ6IGZ1bmN0aW9uKGV2ZW50KSB7IC8vIChFdmVudClcbiAgICAgICAgICAgIHZhciBwb2ludCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuX21vcnBoaW5nTm93ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIXBvaW50Ll9ob3ZlcmVkICYmIHBvaW50ICE9PSB0aGlzLl9wb2ludHNbdGhpcy5fcG9pbnRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgcG9pbnQuY29sbGFwc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2ZpcmVDaGFuZ2VFdmVudCgpO1xuICAgICAgICB9LFxuICAgICAgICBkcmFnc3RhcnQ6IGZ1bmN0aW9uKCkgeyAvLyAoKVxuICAgICAgICAgICAgaWYgKERHLkJyb3dzZXIudG91Y2ggJiYgdGhpcy5fbGluZU1hcmtlckhlbHBlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVNYXJrZXJIZWxwZXIuY29sbGFwc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21vcnBoaW5nTm93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZGVsZXRlUG9pbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7IC8vIChNb3VzZUV2ZW50KVxuICAgICAgICB2YXIgb3JpZ2luYWxFdmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgICB0YXJnZXQgPSBvcmlnaW5hbEV2ZW50LnRhcmdldCAgfHwgb3JpZ2luYWxFdmVudC5zcmNFbGVtZW50O1xuXG4gICAgICAgIGlmICh0YXJnZXQuY2xhc3NOYW1lICE9PSAnZGctcnVsZXJfX2xhYmVsLXJlbW92ZS1saW5rJyAmJlxuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTmFtZSAhPT0gJ2RnLXJ1bGVyX19yZW1vdmUtbGluay1vdmVybGF5Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIERHLkRvbUV2ZW50LnN0b3AoZXZlbnQub3JpZ2luYWxFdmVudCk7XG4gICAgICAgIHRoaXMuc3BsaWNlTGF0TG5ncyhldmVudC50YXJnZXQuX3BvcywgMSk7XG4gICAgfSxcblxuICAgIF9kZWdUb1JhZDogZnVuY3Rpb24oZGVnKSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5QSSAvIDE4MCkgKiBkZWc7XG4gICAgfSxcblxuICAgIF9yYWRUb0RlZzogZnVuY3Rpb24ocmFkKSB7XG4gICAgICAgIHJldHVybiAoMTgwIC8gTWF0aC5QSSkgKiByYWQ7XG4gICAgfSxcblxuICAgIC8vIE1hcC1pbmRlcGVuZGVudCBwcm9qZWN0IG1ldGhvZFxuICAgIF9wcm9qZWN0OiBmdW5jdGlvbihsYXRsbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5wcm9qZWN0KGxhdGxuZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gREcuQ1JTLkVQU0czODU3LmxhdExuZ1RvUG9pbnQobGF0bG5nLCAxKTtcbiAgICB9LFxuXG4gICAgLy8gTWFwLWluZGVwZW5kZW50IHVucHJvamVjdCBtZXRob2RcbiAgICBfdW5wcm9qZWN0OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICBpZiAodGhpcy5fbWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnVucHJvamVjdChwb2ludCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gREcuQ1JTLkVQU0czODU3LnBvaW50VG9MYXRMbmcocG9pbnQsIDEpO1xuICAgIH0sXG5cbiAgICAvLyBDYWxjdWxhdGVzIHRoZSBzaXplIG9mIGFuZ2xlIHBvaW50MS1wb2ludC1wb2ludDJcbiAgICBfY2FsY0FuZ2xlOiBmdW5jdGlvbihwb2ludCwgcG9pbnQxLCBwb2ludDIpIHsgLy8gKExhdExuZywgTGF0TG5nLCBMYXRMbmcpIC0+IE51bWJlclxuICAgICAgICBwb2ludDEgPSB0aGlzLl9ub3JtYWxpemVMYXRMbmcocG9pbnQxLCBwb2ludCk7XG4gICAgICAgIHBvaW50MiA9IHRoaXMuX25vcm1hbGl6ZUxhdExuZyhwb2ludDIsIHBvaW50KTtcblxuICAgICAgICBwb2ludCA9IHRoaXMuX3Byb2plY3QocG9pbnQpO1xuICAgICAgICBwb2ludDEgPSB0aGlzLl9wcm9qZWN0KHBvaW50MSk7XG4gICAgICAgIHBvaW50MiA9IHRoaXMuX3Byb2plY3QocG9pbnQyKTtcblxuICAgICAgICB2YXIgeDEgPSBwb2ludDEueCAtIHBvaW50Lng7XG4gICAgICAgIHZhciB4MiA9IHBvaW50Mi54IC0gcG9pbnQueDtcbiAgICAgICAgdmFyIHkxID0gcG9pbnQxLnkgLSBwb2ludC55O1xuICAgICAgICB2YXIgeTIgPSBwb2ludDIueSAtIHBvaW50Lnk7XG5cbiAgICAgICAgdmFyIGRvdFByb2R1Y3QgPSB4MSAqIHgyICsgeTEgKiB5MjtcbiAgICAgICAgdmFyIG1hZzEgPSBNYXRoLnNxcnQoeDEgKiB4MSArIHkxICogeTEpO1xuICAgICAgICB2YXIgbWFnMiA9IE1hdGguc3FydCh4MiAqIHgyICsgeTIgKiB5Mik7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWNvcyhkb3RQcm9kdWN0IC8gKG1hZzEgKiBtYWcyKSk7XG4gICAgfSxcblxuICAgIC8vIENhbGN1bGF0ZXMgdGhlIG1pZHBvaW50IG9uIHRoZSBncmVhdCBjaXJjbGUgYmV0d2VlbiB0d28gTGF0TG5nc1xuICAgIF9jYWxjTWlkUG9pbnQ6IGZ1bmN0aW9uKGxhdGxuZzEsIGxhdGxuZzIpIHsgLy8gKExhdExuZywgTGF0TG5nKSAtPiBMYXRMbmdcbiAgICAgICAgdmFyIGxvbjEgPSB0aGlzLl9kZWdUb1JhZChsYXRsbmcxLmxuZyk7XG4gICAgICAgIHZhciBsYXQxID0gdGhpcy5fZGVnVG9SYWQobGF0bG5nMS5sYXQpO1xuXG4gICAgICAgIHZhciBsb24yID0gdGhpcy5fZGVnVG9SYWQobGF0bG5nMi5sbmcpO1xuICAgICAgICB2YXIgbGF0MiA9IHRoaXMuX2RlZ1RvUmFkKGxhdGxuZzIubGF0KTtcblxuICAgICAgICAvLyBCYXNlZCBvbiBmb3JtdWxhZSBmcm9tXG4gICAgICAgIC8vIGh0dHA6Ly93aWxsaWFtcy5iZXN0LnZ3aC5uZXQvYXZmb3JtLmh0bSNJbnRlcm1lZGlhdGVcbiAgICAgICAgdmFyIGQgPSBNYXRoLmFjb3MoTWF0aC5zaW4obGF0MSkgKiBNYXRoLnNpbihsYXQyKSArXG4gICAgICAgICAgICBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogTWF0aC5jb3MobG9uMSAtIGxvbjIpKTtcblxuICAgICAgICAvLyBTcGxpdCB0aGUgYXJjIGluIGhhbGZcbiAgICAgICAgdmFyIGYgPSAwLjU7XG5cbiAgICAgICAgdmFyIEEgPSBNYXRoLnNpbigoMSAtIGYpICogZCkgLyBNYXRoLnNpbihkKTtcbiAgICAgICAgdmFyIEIgPSBNYXRoLnNpbihmICogZCkgLyBNYXRoLnNpbihkKTtcblxuICAgICAgICB2YXIgeCA9IEEgKiBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxvbjEpICtcbiAgICAgICAgICAgIEIgKiBNYXRoLmNvcyhsYXQyKSAqIE1hdGguY29zKGxvbjIpO1xuXG4gICAgICAgIHZhciB5ID0gQSAqIE1hdGguY29zKGxhdDEpICogTWF0aC5zaW4obG9uMSkgK1xuICAgICAgICAgICAgQiAqIE1hdGguY29zKGxhdDIpICogTWF0aC5zaW4obG9uMik7XG5cbiAgICAgICAgdmFyIHogPSBBICogTWF0aC5zaW4obGF0MSkgKyBCICogTWF0aC5zaW4obGF0Mik7XG5cbiAgICAgICAgdmFyIGxhdCA9IE1hdGguYXRhbjIoeiwgTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpKTtcbiAgICAgICAgdmFyIGxvbiA9IE1hdGguYXRhbjIoeSwgeCk7XG5cbiAgICAgICAgcmV0dXJuIERHLmxhdExuZyh0aGlzLl9yYWRUb0RlZyhsYXQpLCB0aGlzLl9yYWRUb0RlZyhsb24pKTtcbiAgICB9LFxuXG4gICAgLy8gQWRhcHRpdmUgc2FtcGxpbmcgYWxnb3JpdGhtIGJhc2VkIG9uXG4gICAgLy8gaHR0cDovL2FyaWVsLmNocm9ub3RleHQub3JnL2RkL2RlZmlndWVpcmVkbzkzYWRhcHRpdmUucGRmXG4gICAgX2FkYXB0aXZlU2FtcGxlOiBmdW5jdGlvbihsZWZ0LCByaWdodCwgZGVwdGgsIG1pZGRsZSkgeyAvLyAoTGF0TG5nLCBMYXRMbmcsIE51bWJlclssIExhdExuZ10pIC0+IExhdExuZ1tdXG4gICAgICAgIGlmIChkZXB0aCA+IDkpIHtcbiAgICAgICAgICAgIC8vIE1heCByZWN1cnNpb24gZGVwdGggcmVhY2hlZFxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgbWlkZGxlID0gbWlkZGxlIHx8IHRoaXMuX2NhbGNNaWRQb2ludChsZWZ0LCByaWdodCk7XG5cbiAgICAgICAgdmFyIGxlZnRNaWRkbGUgPSB0aGlzLl9jYWxjTWlkUG9pbnQobGVmdCwgbWlkZGxlKTtcbiAgICAgICAgdmFyIHJpZ2h0TWlkZGxlID0gdGhpcy5fY2FsY01pZFBvaW50KG1pZGRsZSwgcmlnaHQpO1xuXG4gICAgICAgIHZhciBhbmdsZTEgPSB0aGlzLl9jYWxjQW5nbGUobGVmdE1pZGRsZSwgbWlkZGxlLCBsZWZ0KTtcbiAgICAgICAgdmFyIGFuZ2xlMiA9IHRoaXMuX2NhbGNBbmdsZShtaWRkbGUsIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdmFyIGFuZ2xlMyA9IHRoaXMuX2NhbGNBbmdsZShyaWdodE1pZGRsZSwgbWlkZGxlLCByaWdodCk7XG5cbiAgICAgICAgLy8gbGVmdCAtLS0gbGVmdE1pZGRsZSAtLS0gbWlkZGxlIC0tLSByaWdodE1pZGRsZSAtLS0gcmlnaHRcbiAgICAgICAgLy8gICAgICAgICAgICBhbmdsZTEgICAgICAgYW5nbGUyICAgICAgIGFuZ2xlM1xuXG4gICAgICAgIHZhciBtaW5BbmdsZSA9IDMuMTtcbiAgICAgICAgaWYgKGFuZ2xlMSA+IG1pbkFuZ2xlICYmIGFuZ2xlMiA+IG1pbkFuZ2xlICYmIGFuZ2xlMyA+IG1pbkFuZ2xlKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNlY3Rpb24gaXMgc3RyYWlnaHQgZW5vdWdoLCBubyBpbnRlcm1lZGlhdGUgcG9pbnRzIG5lZWRlZC5cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFuZ2xlcyBhcmUgdG9vIHNtYWxsLiBSZWN1cnNpdmVseSBzYW1wbGUgaGFsdmVzIG9mIHRoaXMgc2VjdGlvbi5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5fYWRhcHRpdmVTYW1wbGUobGVmdCwgbWlkZGxlLCBkZXB0aCArIDEsIGxlZnRNaWRkbGUpKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1pZGRsZSk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuX2FkYXB0aXZlU2FtcGxlKG1pZGRsZSwgcmlnaHQsIGRlcHRoICsgMSwgcmlnaHRNaWRkbGUpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBDYWxjdWxhdGVzIHRoZSBncmVhdCBjaXJjbGUgYXJjIGJldHdlZW4gdHdvIExhdExuZ3MuXG4gICAgX2NhbGNHcmVhdENpcmNsZTogZnVuY3Rpb24obGF0bG5nMSwgbGF0bG5nMikgeyAvLyAoTGF0TG5nLCBMYXRMbmcpIC0+IExhdExuZ1tdXG4gICAgICAgIGxhdGxuZzIgPSB0aGlzLl9ub3JtYWxpemVMYXRMbmcobGF0bG5nMiwgbGF0bG5nMSk7XG5cbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBwb2ludHMgYXJlIGNsb3NlIHRvIGVhY2ggb3RoZXIgKHdpdGhpbiAxIGRlZ3JlZSlcbiAgICAgICAgaWYgKGxhdGxuZzEuZXF1YWxzKGxhdGxuZzIsIDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2xhdGxuZzEsIGxhdGxuZzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiB0aGUgZ3JlYXQgY2lyY2xlIGNyb3NzZXMgYSBwb2xlXG4gICAgICAgIGlmIChNYXRoLmFicyhsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nKSA9PSAxODApIHtcbiAgICAgICAgICAgIC8vIE5vcnRoIG9yIHNvdXRoIHBvbGU/XG4gICAgICAgICAgICB2YXIgbGF0aXR1ZGUgPSAobGF0bG5nMS5sYXQgKyBsYXRsbmcyLmxhdCA+IDApID8gOTAgOiAtOTA7XG5cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbGF0bG5nMSxcbiAgICAgICAgICAgICAgICBERy5sYXRMbmcobGF0aXR1ZGUsIGxhdGxuZzEubG5nKSxcbiAgICAgICAgICAgICAgICBERy5sYXRMbmcobGF0aXR1ZGUsIGxhdGxuZzIubG5nKSxcbiAgICAgICAgICAgICAgICBsYXRsbmcyXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIHJlc3VsdC5wdXNoKGxhdGxuZzEpO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuX2FkYXB0aXZlU2FtcGxlKGxhdGxuZzEsIGxhdGxuZzIsIDApKTtcbiAgICAgICAgcmVzdWx0LnB1c2gobGF0bG5nMik7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBhcmMgZG9lc24ndCBqdW1wIGJldHdlZW4gd29ybGRzXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSB0aGlzLl9ub3JtYWxpemVMYXRMbmcocmVzdWx0W2ldLCByZXN1bHRbaSAtIDFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIF9hZGRMZWdzOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICB2YXIgcGF0aFN0eWxlcyA9IHRoaXMub3B0aW9ucy5wYXRoU3R5bGVzO1xuXG4gICAgICAgIHZhciBncmVhdENpcmNsZVBvaW50cyA9IHRoaXMuX2NhbGNHcmVhdENpcmNsZShcbiAgICAgICAgICAgIHBvaW50LmdldExhdExuZygpLFxuICAgICAgICAgICAgdGhpcy5fcG9pbnRzW3BvaW50Ll9wb3MgKyAxXS5nZXRMYXRMbmcoKVxuICAgICAgICApO1xuXG4gICAgICAgIHBvaW50Ll9sZWdzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHBhdGhTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgIHBvaW50Ll9sZWdzW2xheWVyXSA9IERHLnBvbHlsaW5lKGdyZWF0Q2lyY2xlUG9pbnRzLCBwYXRoU3R5bGVzW2xheWVyXSkuYWRkVG8odGhpcy5fbGF5ZXJzW2xheWVyXSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHBvaW50Ll9sZWdzLm1vdXNlLl9wb2ludCA9IHBvaW50Lm9uY2UoJ3JlbW92ZScsIHRoaXMuX2NsZWFyUmVtb3ZpbmdQb2ludExlZ3MsIHRoaXMpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWRpdGFibGUgJiYgIURHLkJyb3dzZXIubW9iaWxlKSB7XG4gICAgICAgICAgICBwb2ludC5fbGVncy5tb3VzZS5vbignbW91c2Vkb3duJywgdGhpcy5faW5zZXJ0UG9pbnRJbkxpbmUsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzLm1vdXNlLmFkZExheWVyKHBvaW50Ll9sZWdzLm1vdXNlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2xlYXJSZW1vdmluZ1BvaW50TGVnczogZnVuY3Rpb24oZXZlbnQpIHsgLy8gKEV2ZW50KVxuICAgICAgICB0aGlzLl9yZW1vdmVMZWdzKGV2ZW50LnRhcmdldCk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVMZWdzOiBmdW5jdGlvbihwb2ludCkgeyAvLyAoUnVsZXIuTGF5ZXJlZE1hcmtlcilcbiAgICAgICAgaWYgKHBvaW50Ll9sZWdzKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwb2ludC5fbGVncykuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyc1tsYXllcl0ucmVtb3ZlTGF5ZXIocG9pbnQuX2xlZ3NbbGF5ZXJdKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgcG9pbnQuX2xlZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF91cGRhdGVMZWdzOiBmdW5jdGlvbihwb2ludCwgc2tpcFByZXZpb3VzKSB7IC8vIChSdWxlci5MYXllcmVkTWFya2VyLCBCb29sZWFuKVxuICAgICAgICB2YXIgbGF0bG5nID0gcG9pbnQuZ2V0TGF0TG5nKCksXG4gICAgICAgICAgICBwcmV2aW91c1BvaW50ID0gdGhpcy5fcG9pbnRzW3BvaW50Ll9wb3MgLSAxXSxcbiAgICAgICAgICAgIG5leHRQb2ludCA9IHRoaXMuX3BvaW50c1twb2ludC5fcG9zICsgMV0sXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIG5ld1BvaW50cztcblxuICAgICAgICBpZiAocHJldmlvdXNQb2ludCAmJiAhc2tpcFByZXZpb3VzKSB7XG4gICAgICAgICAgICBuZXdQb2ludHMgPSBzZWxmLl9jYWxjR3JlYXRDaXJjbGUocHJldmlvdXNQb2ludC5nZXRMYXRMbmcoKSwgbGF0bG5nKTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMocHJldmlvdXNQb2ludC5fbGVncykuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUG9pbnQuX2xlZ3NbbGF5ZXJdLnNldExhdExuZ3MobmV3UG9pbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQb2ludCkge1xuICAgICAgICAgICAgbmV3UG9pbnRzID0gc2VsZi5fY2FsY0dyZWF0Q2lyY2xlKGxhdGxuZywgbmV4dFBvaW50LmdldExhdExuZygpKTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMocG9pbnQuX2xlZ3MpLmZvckVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBwb2ludC5fbGVnc1tsYXllcl0uc2V0TGF0TG5ncyhuZXdQb2ludHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NhbGNEaXN0YW5jZTogZnVuY3Rpb24oZmluaXNoUG9pbnQsIHRhaWwpIHsgLy8gKFJ1bGVyLkxheWVyZWRNYXJrZXIsIE51bWJlcikgLT4gTnVtYmVyXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHRhaWwgPyB0YWlsIDogMCxcbiAgICAgICAgICAgIGNhbGNUbyA9IGZpbmlzaFBvaW50ID8gZmluaXNoUG9pbnQuX3BvcyA6IHRoaXMuX3BvaW50cy5sZW5ndGggLSAxO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsY1RvOyBpKyspIHtcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IHRoaXMuX3BvaW50c1tpXS5nZXRMYXRMbmcoKS5kaXN0YW5jZVRvKHRoaXMuX3BvaW50c1tpICsgMV0uZ2V0TGF0TG5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xuICAgIH0sXG5cbiAgICBfZ2V0Rm9ybWF0ZWREaXN0YW5jZTogZnVuY3Rpb24oKSB7IC8vICgpIC0+IFN0cmluZ1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLl9jYWxjRGlzdGFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICAgIHVuaXRzID0gJ20nO1xuXG4gICAgICAgIGlmIChkaXN0YW5jZSA+IDEwMDApIHtcbiAgICAgICAgICAgIGRpc3RhbmNlIC89IDEwMDA7XG4gICAgICAgICAgICB1bml0cyA9ICdrbSc7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAxMDAwKSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBkaXN0YW5jZS50b0ZpeGVkKCk7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBkaXN0YW5jZS5zbGljZSgwLCAtMykgKyAnICcgKyBkaXN0YW5jZS5zbGljZSgtMyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gZGlzdGFuY2UudG9GaXhlZCgyKS5zcGxpdCgnLicpLmpvaW4odGhpcy50KCdkZWxpbWl0ZXInKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGgucm91bmQoZGlzdGFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtkaXN0YW5jZSB8fCAwLCAnICcsIHRoaXMudCh1bml0cyldLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlRGlzdGFuY2U6IGZ1bmN0aW9uKCkgeyAvLyAoKVxuICAgICAgICBpZiAodGhpcy5fbWFwICYmIHRoaXMuX3BvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50c1t0aGlzLl9wb2ludHMubGVuZ3RoIC0gMV0uc2V0VGV4dCh0aGlzLl9nZXRGb3JtYXRlZERpc3RhbmNlKCkpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkRHLnJ1bGVyID0gZnVuY3Rpb24obGF0bG5ncywgb3B0aW9ucykgeyAvLyAoQXJyYXksIE9iamVjdClcbiAgICByZXR1cm4gbmV3IERHLlJ1bGVyKGxhdGxuZ3MsIG9wdGlvbnMpO1xufTtcbiIsIkRHLlJ1bGVyLkxheWVyZWRNYXJrZXIgPSBERy5NYXJrZXIuZXh0ZW5kKHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgICAgIGtleWJvYXJkOiBmYWxzZSxcbiAgICAgICAgcmlzZU9uSG92ZXI6IHRydWUsXG4gICAgICAgIHBhbmU6ICdydWxlck1hcmtlclBhbmUnLFxuICAgICAgICB0ZXh0RGlyZWN0aW9uOiAnYXV0bycsIC8vICdhdXRvJyB8ICdsdHInIHwgJ3J0bCdcbiAgICAgICAgaWNvbkhUTUw6IFtcbiAgICAgICAgICAgICc8aW1nIGNsYXNzPVwiZGctcnVsZXJfX2xhYmVsLXNwYWNlclwiIHNyYz1cImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBN1wiIHdpZHRoPVwiMjZcIiBoZWlnaHQ9XCIyNlwiIC8+JyxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZGctcnVsZXJfX2xhYmVsLWNvbnRhaW5lclwiPicsXG4gICAgICAgICAgICAnICAgIDxkaXYgY2xhc3M9XCJkZy1ydWxlcl9fcG9pbnRcIj48L2Rpdj4nLFxuICAgICAgICAgICAgJyAgICA8c3BhbiBjbGFzcz1cImRnLXJ1bGVyX19sYWJlbC1kaXN0YW5jZVwiPjAg0LrQvDwvc3Bhbj4nLFxuICAgICAgICAgICAgJyAgICA8c3BhbiBjbGFzcz1cImRnLXJ1bGVyX19sYWJlbC1yZW1vdmUtbGlua1wiPjwvc3Bhbj4nLFxuICAgICAgICAgICAgJyAgICA8ZGl2IGNsYXNzPVwiZGctcnVsZXJfX3JlbW92ZS1saW5rLW92ZXJsYXlcIj48L2Rpdj4nLFxuICAgICAgICAgICAgJzwvZGl2PidcbiAgICAgICAgXS5qb2luKCdcXG4nKVxuICAgIH0sXG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIGRvbUNsYXNzIDogJ2RnLXJ1bGVyX19sYWJlbCdcbiAgICB9LFxuXG4gICAgYWRkVG8gOiBmdW5jdGlvbihtYXAsIGxheWVycykge1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9sYXllcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgbGF5ZXJzW25hbWVdLmFkZExheWVyKHRoaXMuX2xheWVyc1tuYW1lXSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0ID0gbGF5ZXJzO1xuICAgICAgICByZXR1cm4gREcuTWFya2VyLnByb3RvdHlwZS5hZGRUby5jYWxsKHRoaXMub24oJ21vdmUnLCB0aGlzLl9vbk1vdmUpLCBtYXApO1xuICAgIH0sXG5cbiAgICBvblJlbW92ZSA6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9sYXllcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fdmlld3BvcnRbbmFtZV0ucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW25hbWVdKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMub2ZmKCdtb3ZlJywgdGhpcy5fb25Nb3ZlKTtcbiAgICAgICAgdGhpcy5fdmlld3BvcnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdHlsZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBERy5NYXJrZXIucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcbiAgICB9LFxuXG4gICAgc2V0VGV4dCA6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ljb25Db2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faWNvbk5vZGVzLmxhYmVsLmlubmVySFRNTCA9IHRleHQ7XG4gICAgICAgIHRoaXMuX2ljb25Ob2Rlcy5sYWJlbC5zZXRBdHRyaWJ1dGUoJ2RpcicsIHRoaXMub3B0aW9ucy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFBvaW50U3R5bGUgOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICBpZiAodGhpcy5fc3R5bGUgIT09IHN0eWxlKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9zdHlsZSA9IHN0eWxlKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllcnNbbmFtZV0uc2V0U3R5bGUoc3R5bGVbbmFtZV0pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGV4cGFuZCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9pY29uQ29sbGFwc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ljb25Ob2Rlcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMuX2ljb25Ob2Rlcy5zcGFjZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNvbGxhcHNlIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2ljb25Db2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pY29uTm9kZXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2ljb25Ob2Rlcy5zcGFjZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBxdWVyeVNlbGVjdG9yIDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ljb24ucXVlcnlTZWxlY3RvcignLicgKyBERy5SdWxlci5MYXllcmVkTWFya2VyLmRvbUNsYXNzICsgJy0nICsgc2VsZWN0b3IpO1xuICAgIH0sXG5cbiAgICBfb25Nb3ZlIDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGxhdGxuZyA9IGV2ZW50LmxhdGxuZztcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fbGF5ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyc1tuYW1lXS5zZXRMYXRMbmcobGF0bG5nKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIF9pbml0SWNvbiA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBERy5NYXJrZXIucHJvdG90eXBlLl9pbml0SWNvbi5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9pY29uQ29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faWNvbi5zdHlsZS53aWR0aCA9ICcnO1xuICAgICAgICB0aGlzLl9pY29uTm9kZXMgPSB7XG4gICAgICAgICAgICBsYWJlbCA6IHRoaXMucXVlcnlTZWxlY3RvcignZGlzdGFuY2UnKSxcbiAgICAgICAgICAgIHNwYWNlciA6IHRoaXMucXVlcnlTZWxlY3Rvcignc3BhY2VyJyksXG4gICAgICAgICAgICBjb250YWluZXIgOiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2NvbnRhaW5lcicpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIGRvbid0IGNoYW5nZSBpY29uIHpJbmRleFxuICAgIF9zZXRQb3M6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICBMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5faWNvbiwgcG9zKTtcblxuICAgICAgICBpZiAodGhpcy5fc2hhZG93KSB7XG4gICAgICAgICAgICBMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fc2hhZG93LCBwb3MpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9hZnRlckluaXQgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbGF5ZXJzID0gdGhpcy5vcHRpb25zLmxheWVycyB8fCBudWxsO1xuICAgICAgICB0aGlzLm9wdGlvbnMuaWNvbiA9IERHLmRpdkljb24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBERy5SdWxlci5MYXllcmVkTWFya2VyLmRvbUNsYXNzLFxuICAgICAgICAgICAgaWNvblNpemU6IFsyNiwgMjZdLFxuICAgICAgICAgICAgaWNvbkFuY2hvcjogWzEzLCAxM10sXG4gICAgICAgICAgICBodG1sOiB0aGlzLm9wdGlvbnMuaWNvbkhUTUxcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuREcuUnVsZXIuTGF5ZXJlZE1hcmtlci5hZGRJbml0SG9vaygnX2FmdGVySW5pdCcpO1xuXG5ERy5SdWxlci5sYXllcmVkTWFya2VyID0gZnVuY3Rpb24obGF0bG5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBERy5SdWxlci5MYXllcmVkTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XG59O1xuIiwidmFyIHJ1bGVyUmVuZGVyZXIgPSBERy5zdmcoe3BhbmU6ICdydWxlclBhbmUnfSk7XG52YXIgaG92ZXJSZW5kZXJlciA9IERHLnN2Zyh7cGFuZTogJ3J1bGVyUGFuZSd9KTtcblxuREcuUnVsZXIubWVyZ2VPcHRpb25zKHtcbiAgICBwYXRoU3R5bGVzOiB7XG4gICAgICAgIGJhY2s6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgd2VpZ2h0OiAxMixcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgICAgIG5vQ2xpcDogdHJ1ZSxcbiAgICAgICAgICAgIHJlbmRlcmVyOiBydWxlclJlbmRlcmVyLFxuICAgICAgICAgICAgc21vb3RoRmFjdG9yOiAwXG4gICAgICAgIH0sXG4gICAgICAgIG1pZGRsZToge1xuICAgICAgICAgICAgY29sb3I6ICcjMGRhNWQ1JyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICB3ZWlnaHQ6IDQsXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgICBub0NsaXA6IHRydWUsXG4gICAgICAgICAgICByZW5kZXJlcjogcnVsZXJSZW5kZXJlcixcbiAgICAgICAgICAgIHNtb290aEZhY3RvcjogMFxuICAgICAgICB9LFxuICAgICAgICBtb3VzZToge1xuICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IERHLkJyb3dzZXIudm1sID8gMC4xIDogMCxcbiAgICAgICAgICAgIHdlaWdodDogREcuQnJvd3Nlci50b3VjaCA/IDQwIDogMjAsXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAncGFpbnRlZCcsXG4gICAgICAgICAgICBub0NsaXA6IHRydWUsXG4gICAgICAgICAgICByZW5kZXJlcjogaG92ZXJSZW5kZXJlcixcbiAgICAgICAgICAgIHNtb290aEZhY3RvcjogMFxuICAgICAgICB9XG4gICAgfSxcbiAgICBpY29uU3R5bGVzOiB7XG4gICAgICAgIGxhcmdlOiB7XG4gICAgICAgICAgICBiYWNrOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHdlaWdodDogMSxcbiAgICAgICAgICAgICAgICByYWRpdXM6IDEzLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBydWxlclJlbmRlcmVyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWlkZGxlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMGRhNWQ1JyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyMwZGE1ZDUnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHdlaWdodDogMSxcbiAgICAgICAgICAgICAgICByYWRpdXM6IDksXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IHJ1bGVyUmVuZGVyZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9udDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICcjMGRhNWQ1JyxcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6IDQsXG4gICAgICAgICAgICAgICAgcmFkaXVzOiA1LFxuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBydWxlclJlbmRlcmVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNtYWxsOiB7XG4gICAgICAgICAgICBiYWNrOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHdlaWdodDogMSxcbiAgICAgICAgICAgICAgICByYWRpdXM6IDksXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IHJ1bGVyUmVuZGVyZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtaWRkbGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMwZGE1ZDUnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnIzBkYTVkNScsXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgd2VpZ2h0OiAxLFxuICAgICAgICAgICAgICAgIHJhZGl1czogNSxcbiAgICAgICAgICAgICAgICByZW5kZXJlcjogcnVsZXJSZW5kZXJlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb250OiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyMwZGE1ZDUnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHdlaWdodDogNCxcbiAgICAgICAgICAgICAgICByYWRpdXM6IDIsXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IHJ1bGVyUmVuZGVyZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiREcuUnVsZXIuRGljdGlvbmFyeS5ydSA9IHtcbiAgICBrbSA6ICfQutC8JyxcbiAgICBtIDogJ9C8JyxcbiAgICBkZWxpbWl0ZXIgOiAnLCdcbn07XG4iLCJERy5SdWxlci5EaWN0aW9uYXJ5Lml0ID0ge1xuICAgIGttIDogJ2ttJyxcbiAgICBtIDogJ20nLFxuICAgIGRlbGltaXRlciA6ICcsJ1xufTtcbiIsIkRHLlJ1bGVyLkRpY3Rpb25hcnkuY3MgPSB7XG4gICAga206ICdrbScsXG4gICAgbTogJ20nLFxuICAgIGRlbGltaXRlcjogJywnXG59O1xuIiwiREcuUnVsZXIuRGljdGlvbmFyeS5lcyA9IHtcbiAgICBrbSA6ICdrbScsXG4gICAgbSA6ICdtJyxcbiAgICBkZWxpbWl0ZXIgOiAnLCdcbn07XG4iLCJERy5SdWxlci5EaWN0aW9uYXJ5LmVuID0ge1xuICAgIGttIDogJ2ttJyxcbiAgICBtIDogJ20nLFxuICAgIGRlbGltaXRlciA6ICcuJ1xufTtcbiIsIkRHLlJ1bGVyLkRpY3Rpb25hcnkuYXIgPSB7XG4gICAga20gOiAn2YPZhScsXG4gICAgbSA6ICfZhScsXG4gICAgZGVsaW1pdGVyIDogJy4nXG59O1xuIiwiREcuQ29udHJvbC5SdWxlciA9IERHLlJvdW5kQ29udHJvbC5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBwb3NpdGlvbjogJ3RvcHJpZ2h0JyxcbiAgICAgICAgaWNvbkNsYXNzOiAncnVsZXInXG4gICAgfSxcblxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgRGljdGlvbmFyeToge31cbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBERy5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBERy5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgX2FjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBfZHJhd2luZ0hlbHBlcjogbnVsbCxcbiAgICAgICAgICAgIF9nZW9jbGlja2VyTmVlZFJlc3RvcmU6IGZhbHNlXG4gICAgICAgIH0pLm9uKHRoaXMuX2NvbnRyb2xFdmVudHMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBfY29udHJvbEV2ZW50czoge1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fZHJhd2luZ0hlbHBlciA9IERHLnJ1bGVyKFtdKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gIXRoaXMuX2FjdGl2ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0RHJhd2luZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKCcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9maW5pc2hEcmF3aW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLm9mZih0aGlzLl9jb250cm9sRXZlbnRzLCB0aGlzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fZHJhd2luZ0hlbHBlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kcmF3aW5nSGVscGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfc3RhcnREcmF3aW5nOiBmdW5jdGlvbigpIHsgLy8gKClcbiAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAuYWRkTGF5ZXIodGhpcy5fZHJhd2luZ0hlbHBlcilcbiAgICAgICAgICAgIC5vbignY2xpY2snLCB0aGlzLl9oYW5kbGVNYXBDbGljaywgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5fbWFwLmZpcmUoJ3J1bGVyc3RhcnQnKTtcbiAgICB9LFxuXG4gICAgX2ZpbmlzaERyYXdpbmc6IGZ1bmN0aW9uKCkgeyAvLyAoKVxuICAgICAgICB0aGlzLl9tYXBcbiAgICAgICAgICAgIC5vZmYoJ2NsaWNrJywgdGhpcy5faGFuZGxlTWFwQ2xpY2ssIHRoaXMpXG4gICAgICAgICAgICAucmVtb3ZlTGF5ZXIodGhpcy5fZHJhd2luZ0hlbHBlcik7XG5cbiAgICAgICAgdGhpcy5fZHJhd2luZ0hlbHBlci5zZXRMYXRMbmdzKFtdKTtcblxuICAgICAgICB0aGlzLl9tYXAuZmlyZSgncnVsZXJlbmQnKTtcbiAgICB9LFxuXG4gICAgX2hhbmRsZU1hcENsaWNrOiBmdW5jdGlvbihldmVudCkgeyAvLyAoTW91c2VFdmVudHMpXG4gICAgICAgIHRoaXMuX2RyYXdpbmdIZWxwZXIuYWRkTGF0TG5nKGV2ZW50LmxhdGxuZyk7XG4gICAgfSxcblxuICAgIF9yZW5kZXJUcmFuc2xhdGlvbjogZnVuY3Rpb24oKSB7IC8vICgpXG4gICAgICAgIHRoaXMuX2xpbmsudGl0bGUgPSB0aGlzLnQoJ2J1dHRvbl90aXRsZScpO1xuICAgIH1cbn0pO1xuXG5ERy5jb250cm9sLnJ1bGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuQ29udHJvbC5SdWxlcihvcHRpb25zKTtcbn07XG5cbkRHLk1hcC5tZXJnZU9wdGlvbnMoe1xuICAgIHJ1bGVyQ29udHJvbDogZmFsc2Vcbn0pO1xuXG5ERy5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydWxlckNvbnRyb2wpIHtcbiAgICAgICAgdGhpcy5ydWxlckNvbnRyb2wgPSBERy5jb250cm9sLnJ1bGVyKHRoaXMub3B0aW9ucy5ydWxlckNvbnRyb2wpO1xuICAgICAgICB0aGlzLmFkZENvbnRyb2wodGhpcy5ydWxlckNvbnRyb2wpO1xuICAgIH1cbn0pO1xuIiwiREcuQ29udHJvbC5SdWxlci5EaWN0aW9uYXJ5LnJ1ID0ge1xuICAgIGJ1dHRvbl90aXRsZTogJ9Cb0LjQvdC10LnQutCwJ1xufTtcbiIsIkRHLkNvbnRyb2wuUnVsZXIuRGljdGlvbmFyeS5pdCA9IHtcbiAgICBidXR0b25fdGl0bGUgOiAnUmlnaGVsbG8nXG59O1xuIiwiREcuQ29udHJvbC5SdWxlci5EaWN0aW9uYXJ5LmNzID0ge1xuICAgIGJ1dHRvbl90aXRsZTogJ1ByYXbDrXRrbydcbn07XG4iLCJERy5Db250cm9sLlJ1bGVyLkRpY3Rpb25hcnkuZXMgPSB7XG4gICAgYnV0dG9uX3RpdGxlIDogJ1JlZ2xhJ1xufTtcbiIsIkRHLkNvbnRyb2wuUnVsZXIuRGljdGlvbmFyeS5lbiA9IHtcbiAgICBidXR0b25fdGl0bGUgOiAnUnVsZXInXG59O1xuIiwiREcuQ29udHJvbC5SdWxlci5EaWN0aW9uYXJ5LmFyID0ge1xuICAgIGJ1dHRvbl90aXRsZTogJ9mF2LPYt9ix2KknXG59O1xuIiwiKGZ1bmN0aW9uKGR1c3Qpe2R1c3QucmVnaXN0ZXIoXCJER0F0dHJpYnV0aW9uXFwvY29weXJpZ2h0XCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctYXR0cmlidXRpb25fX2NvcHlyaWdodFxcXCI+PHVsIGNsYXNzPVxcXCJkZy1hdHRyaWJ1dGlvbl9fbGlua3NcXFwiPjxsaSBjbGFzcz1cXFwiZGctYXR0cmlidXRpb25fX2xpbmstaXRlbVxcXCI+XCIpLngoY3R4LmdldChbXCJvc21cIl0sIGZhbHNlKSxjdHgse1wiZWxzZVwiOmJvZHlfMSxcImJsb2NrXCI6Ym9keV8yfSx7fSkudyhcIjwvbGk+PGxpIGNsYXNzPVxcXCJkZy1hdHRyaWJ1dGlvbl9fbGluay1pdGVtXFxcIj48YSBocmVmPVxcXCJcIikuZihjdHguZ2V0KFtcImNvcHlyaWdodF9saWNlbnNlXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgY2xhc3M9XFxcImRnLWF0dHJpYnV0aW9uX19saW5rXFxcIj5cIikuZihjdHguZ2V0KFtcImxpY2Vuc2VfYWdyZWVtZW50XCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiPC9hPjwvbGk+PC91bD48YSBocmVmPVxcXCJcIikuZihjdHguZ2V0KFtcImNvcHlyaWdodF9sb2dvXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgY2xhc3M9XFxcImRnLWF0dHJpYnV0aW9uX19sb2dvLXVybFxcXCI+PC9hPjwvZGl2PlwiKTt9Ym9keV8wLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxhIGhyZWY9XFxcIlwiKS5mKGN0eC5nZXQoW1wiY29weXJpZ2h0X2FwaWxpbmtcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCJcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIiBjbGFzcz1cXFwiZGctYXR0cmlidXRpb25fX2xpbmtcXFwiIGRpcj1cXFwiXCIpLmYoY3R4LmdldChbXCJkaXJcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCJcXFwiPlwiKS5mKGN0eC5nZXQoW1wid29ya19vblwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIjwvYT5cIik7fWJvZHlfMS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMihjaGssY3R4KXtyZXR1cm4gY2hrLncoXCLCqSA8YSBocmVmPVxcXCJodHRwOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL2NvcHlyaWdodFxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiIGNsYXNzPVxcXCJkZy1hdHRyaWJ1dGlvbl9fbGlua1xcXCI+T3BlblN0cmVldE1hcCBjb250cmlidXRvcnM8L2E+LCA8YSBocmVmPVxcXCJcIikuZihjdHguZ2V0KFtcImNvcHlyaWdodF9hcGlsaW5rXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgY2xhc3M9XFxcImRnLWF0dHJpYnV0aW9uX19saW5rXFxcIiBkaXI9XFxcIlwiKS5mKGN0eC5nZXQoW1wiZGlyXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiXFxcIj5cIikuZihjdHguZ2V0KFtcIndvcmtfb25fd2l0aF9vc21cIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCI8L2E+XCIpO31ib2R5XzIuX19kdXN0Qm9keT0hMDtyZXR1cm4gYm9keV8wfShkdXN0KSk7IiwiKGZ1bmN0aW9uKGR1c3Qpe2R1c3QucmVnaXN0ZXIoXCJER0dlb2NsaWNrZXJcXC9jaXR5YXJlYVwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLW1hcC1nZW9jbGlja2VyX19wdXJwb3NlIGRnLW1hcC1nZW9jbGlja2VyX19wdXJwb3NlX3R5cGVfXCIpLmYoY3R4LmdldChbXCJ0eXBlXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiXFxcIj5cIikuZihjdHguZ2V0KFtcInB1cnBvc2VcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCI8L2Rpdj5cIikucyhjdHguZ2V0KFtcImRyaWxsZG93blwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMX0se30pO31ib2R5XzAuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzEoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctbWFwLWdlb2NsaWNrZXJfX2RyaWxsZG93blxcXCI+XCIpLmYoY3R4LmdldChbXCJkcmlsbGRvd25cIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCI8L2Rpdj5cIik7fWJvZHlfMS5fX2R1c3RCb2R5PSEwO3JldHVybiBib2R5XzB9KGR1c3QpKTsiLCIoZnVuY3Rpb24oZHVzdCl7ZHVzdC5yZWdpc3RlcihcIkRHR2VvY2xpY2tlclxcL2Zpcm1DYXJkQWRkclwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxhZGRyZXNzIGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX2FkZHJlc3MgZGctZmlybS1jYXJkX19pY29uXFxcIj5cIikuZihjdHguZ2V0KFtcImFkZHJlc3NcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLnMoY3R4LmdldChbXCJjb21tZW50XCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8xfSx7fSkudyhcIjwvYWRkcmVzcz5cIik7fWJvZHlfMC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8c3BhbiBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19jb21tZW50XFxcIj4mbWRhc2g7IFwiKS5mKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXCJoXCIpLncoXCI8L3NwYW4+XCIpO31ib2R5XzEuX19kdXN0Qm9keT0hMDtyZXR1cm4gYm9keV8wfShkdXN0KSk7IiwiKGZ1bmN0aW9uKGR1c3Qpe2R1c3QucmVnaXN0ZXIoXCJER0dlb2NsaWNrZXJcXC9maXJtQ2FyZENvbnRhY3RzXCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay5zKGN0eC5nZXQoW1wiZ3JvdXBzXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8xfSx7fSk7fWJvZHlfMC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLnMoY3R4LmdldChbXCJjb250YWN0c1wiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMn0se30pO31ib2R5XzEuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzIoY2hrLGN0eCl7cmV0dXJuIGNoay5oKFwic2VsZWN0XCIsY3R4LHtcImJsb2NrXCI6Ym9keV8zfSx7XCJrZXlcIjpjdHguZ2V0KFtcInR5cGVcIl0sIGZhbHNlKSxcInR5cGVcIjpcInN0cmluZ1wifSxcImhcIik7fWJvZHlfMi5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMyhjaGssY3R4KXtyZXR1cm4gY2hrLmgoXCJlcVwiLGN0eCx7XCJibG9ja1wiOmJvZHlfNH0se1widmFsdWVcIjpcInBob25lXCIsXCJ0eXBlXCI6XCJzdHJpbmdcIn0sXCJoXCIpLmgoXCJlcVwiLGN0eCx7XCJibG9ja1wiOmJvZHlfNn0se1widmFsdWVcIjpcImZheFwiLFwidHlwZVwiOlwic3RyaW5nXCJ9LFwiaFwiKS5oKFwiZXFcIixjdHgse1wiYmxvY2tcIjpib2R5Xzh9LHtcInZhbHVlXCI6XCJ3ZWJzaXRlXCIsXCJ0eXBlXCI6XCJzdHJpbmdcIn0sXCJoXCIpLmgoXCJlcVwiLGN0eCx7XCJibG9ja1wiOmJvZHlfOX0se1widmFsdWVcIjpcImVtYWlsXCIsXCJ0eXBlXCI6XCJzdHJpbmdcIn0sXCJoXCIpO31ib2R5XzMuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzQoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19waG9uZSBkZy1maXJtLWNhcmRfX2ljb25cXFwiPjxzcGFuIGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX3Bob25lLW51bVxcXCI+XCIpLmYoY3R4LmdldChbXCJ0ZXh0XCJdLCBmYWxzZSksY3R4LFwiaFwiKS5zKGN0eC5nZXQoW1wiY29tbWVudFwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfNX0se30pLncoXCI8L3NwYW4+PC9kaXY+XCIpO31ib2R5XzQuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzUoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPHNwYW4gY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fY29tbWVudFxcXCIgdGl0bGU9XFxcIlwiKS5mKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXCJoXCIpLncoXCJcXFwiPiZtZGFzaDsmbmJzcDsmbmJzcDtcIikuZihjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFwiaFwiKS53KFwiPC9zcGFuPlwiKTt9Ym9keV81Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV82KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fcGhvbmUgZGctZmlybS1jYXJkX19pY29uXFxcIj48c3BhbiBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19waG9uZS1udW1cXFwiPlwiKS5mKGN0eC5nZXQoW1widGV4dFwiXSwgZmFsc2UpLGN0eCxcImhcIikucyhjdHguZ2V0KFtcImNvbW1lbnRcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5Xzd9LHt9KS53KFwiPC9zcGFuPjwvZGl2PlwiKTt9Ym9keV82Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV83KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxzcGFuIGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX2NvbW1lbnRcXFwiIHRpdGxlPVxcXCJcIikuZihjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFwiaFwiKS53KFwiXFxcIj4mbWRhc2g7Jm5ic3A7Jm5ic3A7XCIpLmYoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcImhcIikudyhcIjwvc3Bhbj5cIik7fWJvZHlfNy5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfOChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX2xpbmsgZGctZmlybS1jYXJkX19zaXRlIGRnLWZpcm0tY2FyZF9faWNvblxcXCI+PGEgaHJlZj1cXFwiXCIpLmYoY3R4LmdldChbXCJ1cmxcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCJcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIiBjbGFzcz1cXFwiZGctbGlua19zY2hlbWVfZGFyayBkZy1maXJtLWNhcmRfX3NpdGVsaW5rXFxcIj5cIikuZihjdHguZ2V0KFtcInRleHRcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCI8L2E+PC9kaXY+XCIpO31ib2R5XzguX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzkoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19saW5rIGRnLWZpcm0tY2FyZF9fZW1haWwgZGctZmlybS1jYXJkX19pY29uXFxcIj48YSBocmVmPVxcXCJtYWlsdG86XCIpLmYoY3R4LmdldChbXCJ2YWx1ZVwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIlxcXCI+XCIpLmYoY3R4LmdldChbXCJ2YWx1ZVwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIjwvYT48L2Rpdj5cIik7fWJvZHlfOS5fX2R1c3RCb2R5PSEwO3JldHVybiBib2R5XzB9KGR1c3QpKTsiLCIoZnVuY3Rpb24oZHVzdCl7ZHVzdC5yZWdpc3RlcihcIkRHR2VvY2xpY2tlclxcL2Zpcm1DYXJkSGVhZGVyXCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctcG9wdXBfX2hlYWRlci10aXRsZSBkZy1wb3B1cF9faGVhZGVyLXRpdGxlX2Zvcl9maXJtY2FyZFxcXCIgdGl0bGU9XFxcIlwiKS5mKGN0eC5nZXQoW1wiZmlybU5hbWVcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCJcXFwiPlwiKS5mKGN0eC5nZXQoW1wiZmlybU5hbWVcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCI8L2Rpdj5cIikueChjdHguZ2V0KFtcImxpbmtzXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8xfSx7fSk7fWJvZHlfMC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1wb3B1cF9faGVhZGVyLWxpbmtzXFxcIj5cIikucyhjdHguZ2V0KFtcImxpbmtzXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8yfSx7fSkudyhcIjwvZGl2PlwiKTt9Ym9keV8xLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yKGNoayxjdHgpe3JldHVybiBjaGsuaChcImVxXCIsY3R4LHtcImVsc2VcIjpib2R5XzMsXCJibG9ja1wiOmJvZHlfNn0se1wia2V5XCI6Ym9keV83LFwidmFsdWVcIjpcImZsYW1wX3N0YXJzXCIsXCJ0eXBlXCI6XCJzdHJpbmdcIn0sXCJoXCIpO31ib2R5XzIuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzMoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGEgY2xhc3M9XFxcImRnLXBvcHVwX19oZWFkZXItbGluayBkZy1wb3B1cF9fbGluayBkZy1wb3B1cF9fbGlua190eXBlX1wiKS5mKGN0eC5nZXQoW1wibmFtZVwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIlxcXCJcIikueChjdHguZ2V0KFtcImhyZWZcIl0sIGZhbHNlKSxjdHgse1wiZWxzZVwiOmJvZHlfNCxcImJsb2NrXCI6Ym9keV81fSx7fSkudyhcIj5cIikuZihjdHguZ2V0KFtcImxhYmVsXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiPC9hPlwiKTt9Ym9keV8zLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV80KGNoayxjdHgpe3JldHVybiBjaGsudyhcImhyZWY9XFxcImphdmFzY3JpcHQ6dm9pZCgwKVxcXCJcIik7fWJvZHlfNC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCJocmVmPVwiKS5mKGN0eC5nZXQoW1wiaHJlZlwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCJcIik7fWJvZHlfNS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNihjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1wb3B1cF9fcmF0aW5nXFxcIj48ZGl2IGNsYXNzPVxcXCJkZy1wb3B1cF9fcmF0aW5nLXN0YXJzXFxcIiBzdHlsZT1cXFwid2lkdGg6IFwiKS5mKGN0eC5nZXQoW1wid2lkdGhcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCIlXFxcIj48L2Rpdj48L2Rpdj5cIik7fWJvZHlfNi5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNyhjaGssY3R4KXtyZXR1cm4gY2hrLmYoY3R4LmdldChbXCJuYW1lXCJdLCBmYWxzZSksY3R4LFwiaFwiKTt9Ym9keV83Ll9fZHVzdEJvZHk9ITA7cmV0dXJuIGJvZHlfMH0oZHVzdCkpOyIsIihmdW5jdGlvbihkdXN0KXtkdXN0LnJlZ2lzdGVyKFwiREdHZW9jbGlja2VyXFwvZmlybUNhcmRSdWJyaWNcIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLnMoY3R4LmdldChbXCJydWJyaWNzXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8xfSx7fSk7fWJvZHlfMC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8c2VjdGlvbiBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19ydWJyaWNzXFxcIj5cIikueChjdHguZ2V0KFtcInByaW1hcnlcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzJ9LHt9KS54KGN0eC5nZXQoW1wiYWRkaXRpb25hbFwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfNH0se30pLncoXCI8L3NlY3Rpb24+XCIpO31ib2R5XzEuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzIoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPHVsIGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX3J1YnJpY3MtbGlzdCBkZy1maXJtLWNhcmRfX3J1YnJpY3MtbGlzdF90eXBlX3ByaW1hcnlcXFwiPlwiKS5zKGN0eC5nZXQoW1wicHJpbWFyeVwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfM30se30pLncoXCI8L3VsPlwiKTt9Ym9keV8yLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8zKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxsaSBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19ydWJyaWNzLWxpc3QtaXRlbVxcXCI+XCIpLmYoY3R4LmdldChbXCJuYW1lXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiPC9saT5cIik7fWJvZHlfMy5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8dWwgY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fcnVicmljcy1saXN0IGRnLWZpcm0tY2FyZF9fcnVicmljcy1saXN0X3R5cGVfYWRkaXRpb25hbFxcXCI+XCIpLnMoY3R4LmdldChbXCJhZGRpdGlvbmFsXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV81fSx7fSkudyhcIjwvdWw+XCIpO31ib2R5XzQuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzUoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGxpIGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX3J1YnJpY3MtbGlzdC1pdGVtXFxcIj5cIikuZihjdHguZ2V0KFtcIm5hbWVcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCI8L2xpPlwiKTt9Ym9keV81Ll9fZHVzdEJvZHk9ITA7cmV0dXJuIGJvZHlfMH0oZHVzdCkpOyIsIihmdW5jdGlvbihkdXN0KXtkdXN0LnJlZ2lzdGVyKFwiREdHZW9jbGlja2VyXFwvZmlybUNhcmRTY2hlZHVsZVwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fc2NoZWR1bGUgZGctc2NoZWR1bGUgZGctc2NoZWR1bGVfb3Blbl9cIikueChjdHguZ2V0UGF0aChmYWxzZSwgW1wiZm9yZWNhc3RcIixcIm9wZW5cIl0pLGN0eCx7XCJlbHNlXCI6Ym9keV8xLFwiYmxvY2tcIjpib2R5XzJ9LHt9KS53KFwiIGRnLXNjaGVkdWxlX3dvcmtzLWV2ZXJ5ZGF5X1wiKS54KGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJzY2hlZHVsZVwiLFwiZXZlcnlkYXlcIl0pLGN0eCx7XCJlbHNlXCI6Ym9keV8zLFwiYmxvY2tcIjpib2R5XzR9LHt9KS53KFwiXFxcIj5cIikueChjdHguZ2V0KFtcInNjaGVkdWxlXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV81fSx7fSkudyhcIjwvZGl2PlwiKTt9Ym9keV8wLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xKGNoayxjdHgpe3JldHVybiBjaGsudyhcImZhbHNlXCIpO31ib2R5XzEuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzIoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwidHJ1ZVwiKTt9Ym9keV8yLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8zKGNoayxjdHgpe3JldHVybiBjaGsudyhcImZhbHNlXCIpO31ib2R5XzMuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzQoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwidHJ1ZVwiKTt9Ym9keV80Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV81KGNoayxjdHgpe3JldHVybiBjaGsueChjdHguZ2V0UGF0aChmYWxzZSwgW1wiZm9yZWNhc3RcIixcInRvZGF5XCJdKSxjdHgse1wiYmxvY2tcIjpib2R5XzZ9LHt9KS5zKGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJmb3JlY2FzdFwiLFwibm93XCJdKSxjdHgse1wiYmxvY2tcIjpib2R5XzEwfSx7fSkubngoY3R4LmdldFBhdGgoZmFsc2UsIFtcInNjaGVkdWxlXCIsXCJldmVyeWRheVwiXSksY3R4LHtcImJsb2NrXCI6Ym9keV8xMn0se30pO31ib2R5XzUuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzYoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctc2NoZWR1bGVfX3RvZGF5XFxcIj48ZGl2IGNsYXNzPVxcXCJkZy1zY2hlZHVsZV9fdG9kYXktaW5uZXJcXFwiPlwiKS5mKGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJmb3JlY2FzdFwiLFwidG9kYXlcIixcInRleHRcIl0pLGN0eCxcImhcIikudyhcIiZuYnNwO1wiKS54KGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJmb3JlY2FzdFwiLFwidG9kYXlcIixcImZyb21cIl0pLGN0eCx7XCJibG9ja1wiOmJvZHlfN30se30pLngoY3R4LmdldFBhdGgoZmFsc2UsIFtcInNjaGVkdWxlXCIsXCJsdW5jaFwiXSksY3R4LHtcImJsb2NrXCI6Ym9keV84fSx7fSkudyhcIjwvZGl2PjwvZGl2PlwiKTt9Ym9keV82Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV83KGNoayxjdHgpe3JldHVybiBjaGsuZihjdHguZ2V0UGF0aChmYWxzZSwgW1wiZm9yZWNhc3RcIixcInRvZGF5XCIsXCJmcm9tXCJdKSxjdHgsXCJoXCIpLncoXCImbmRhc2g7XCIpLmYoY3R4LmdldFBhdGgoZmFsc2UsIFtcImZvcmVjYXN0XCIsXCJ0b2RheVwiLFwidG9cIl0pLGN0eCxcImhcIik7fWJvZHlfNy5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfOChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCIsJm5ic3A7XCIpLmYoY3R4LmdldFBhdGgoZmFsc2UsIFtcImZvcmVjYXN0XCIsXCJ0b2RheVwiLFwibHVuY2hTdHJcIl0pLGN0eCxcImhcIikudyhcIiZuYnNwO1wiKS5zKGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJzY2hlZHVsZVwiLFwibHVuY2hcIl0pLGN0eCx7XCJibG9ja1wiOmJvZHlfOX0se30pO31ib2R5XzguX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzkoY2hrLGN0eCl7cmV0dXJuIGNoay5mKGN0eC5nZXQoW1wiZnJvbVwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIiZuZGFzaDtcIikuZihjdHguZ2V0KFtcInRvXCJdLCBmYWxzZSksY3R4LFwiaFwiKTt9Ym9keV85Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xMChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1zY2hlZHVsZV9fbm93XFxcIj48c3BhbiBjbGFzcz1cXFwiZGctc2NoZWR1bGVfX25vdy10ZXh0XFxcIj5cIikuZihjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFwiaFwiKS5zKGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJzY2hlZHVsZVwiLFwiY29tbWVudFwiXSksY3R4LHtcImJsb2NrXCI6Ym9keV8xMX0se30pLncoXCI8L3NwYW4+PC9kaXY+XCIpO31ib2R5XzEwLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xMShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCIsIFwiKS5mKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXCJoXCIpO31ib2R5XzExLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xMihjaGssY3R4KXtyZXR1cm4gY2hrLngoY3R4LmdldFBhdGgoZmFsc2UsIFtcInNjaGVkdWxlXCIsXCJ3ZWVrXCJdKSxjdHgse1wiYmxvY2tcIjpib2R5XzEzfSx7fSk7fWJvZHlfMTIuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzEzKGNoayxjdHgpe3JldHVybiBjaGsueChjdHguZ2V0UGF0aChmYWxzZSwgW1wic2NoZWR1bGVcIixcIndlZWtcIixcImV2ZW50bHlcIl0pLGN0eCx7XCJibG9ja1wiOmJvZHlfMTR9LHt9KS54KGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJzY2hlZHVsZVwiLFwid2Vla1wiLFwidGFibGVcIl0pLGN0eCx7XCJibG9ja1wiOmJvZHlfMjJ9LHt9KTt9Ym9keV8xMy5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMTQoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctc2NoZWR1bGVfX3RhYmxlXFxcIj5cIikucyhjdHguZ2V0UGF0aChmYWxzZSwgW1wic2NoZWR1bGVcIixcIndlZWtcIixcImV2ZW50bHlcIl0pLGN0eCx7XCJibG9ja1wiOmJvZHlfMTV9LHt9KS53KFwiPC9kaXY+XCIpO31ib2R5XzE0Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xNShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1zY2hlZHVsZV9fc3RyaW5nXFxcIj5cIikueChjdHguZ2V0KFtcImFsbHRpbWVcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzE2fSx7fSkueChjdHguZ2V0KFtcImV2ZXJ5ZGF5XCJdLCBmYWxzZSksY3R4LHtcImVsc2VcIjpib2R5XzE3LFwiYmxvY2tcIjpib2R5XzE4fSx7fSkueChjdHguZ2V0KFtcImhvbGlkYXlcIl0sIGZhbHNlKSxjdHgse1wiZWxzZVwiOmJvZHlfMTksXCJibG9ja1wiOmJvZHlfMjF9LHt9KS53KFwiPC9kaXY+XCIpO31ib2R5XzE1Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xNihjaGssY3R4KXtyZXR1cm4gY2hrLmYoY3R4LmdldChbXCJhbGx0aW1lU3RyXCJdLCBmYWxzZSksY3R4LFwiaFwiKTt9Ym9keV8xNi5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMTcoY2hrLGN0eCl7cmV0dXJuIGNoay5mKGN0eC5nZXQoW1wiZGF5TGlzdFwiXSwgZmFsc2UpLGN0eCxcImhcIik7fWJvZHlfMTcuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzE4KGNoayxjdHgpe3JldHVybiBjaGsuZihjdHguZ2V0UGF0aChmYWxzZSwgW1wiZm9yZWNhc3RcIixcInRvZGF5XCIsXCJ0ZXh0XCJdKSxjdHgsXCJoXCIpO31ib2R5XzE4Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xOShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8c3BhbiBjbGFzcz1cXFwic2NoZWR1bGVfX3N0cmluZy10aW1lXFxcIj4mbmJzcDtcIikuZihjdHguZ2V0KFtcImZyb21cIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCImbmRhc2g7XCIpLmYoY3R4LmdldChbXCJ0b1wiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIjwvc3Bhbj5cIikucyhjdHguZ2V0KFtcImx1bmNoXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8yMH0se30pO31ib2R5XzE5Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yMChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8cD5cIikuZihjdHguZ2V0KFtcImx1bmNoU3RyXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiJm1kYXNoOzxzcGFuIGNsYXNzPVxcXCJzY2hlZHVsZV9fc3RyaW5nLXRpbWVcXFwiPlwiKS5mKGN0eC5nZXQoW1wiZnJvbVwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIiZuZGFzaDtcIikuZihjdHguZ2V0KFtcInRvXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiPC9zcGFuPjwvcD5cIik7fWJvZHlfMjAuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzIxKGNoayxjdHgpe3JldHVybiBjaGsudyhcIiZuYnNwOyZtZGFzaDs8c3BhbiBjbGFzcz1cXFwic2NoZWR1bGVfX3N0cmluZy10aW1lXFxcIj4mbmJzcDtcIikuZihjdHguZ2V0KFtcImhvbGlkYXlTdHJcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCI8L3NwYW4+XCIpO31ib2R5XzIxLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yMihjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2PjxkaXYgY2xhc3M9XFxcImRnLXNjaGVkdWxlX190YWJsZVxcXCI+PGRpdiBjbGFzcz1cXFwiZGctc2NoZWR1bGVfX3RjIGRnLXNjaGVkdWxlX190Y19wcmVcXFwiPjxkaXYgY2xhc3M9XFxcImRnLXNjaGVkdWxlX19kYXktbmFtZVxcXCI+Jm5ic3A7PC9kaXY+PGRpdiBjbGFzcz1cXFwiZGctc2NoZWR1bGVfX3RhYmxlLWNsb2NrIGRnLXNjaGVkdWxlX190ZFxcXCI+PC9kaXY+XCIpLngoY3R4LmdldFBhdGgoZmFsc2UsIFtcInNjaGVkdWxlXCIsXCJ3ZWVrXCIsXCJoYXNMdW5jaFwiXSksY3R4LHtcImJsb2NrXCI6Ym9keV8yM30se30pLncoXCI8L2Rpdj5cIikucyhjdHguZ2V0UGF0aChmYWxzZSwgW1wic2NoZWR1bGVcIixcIndlZWtcIixcInRhYmxlXCJdKSxjdHgse1wiYmxvY2tcIjpib2R5XzI0fSx7fSkudyhcIjwvZGl2PiAgPC9kaXY+XCIpO31ib2R5XzIyLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yMyhjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1zY2hlZHVsZV9fdGFibGUtbHVuY2ggZGctc2NoZWR1bGVfX3RkXFxcIj48L2Rpdj5cIik7fWJvZHlfMjMuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzI0KGNoayxjdHgpe3JldHVybiBjaGsuaChcImlmXCIsY3R4LHtcImJsb2NrXCI6Ym9keV8yNX0se1wiY29uZFwiOmJvZHlfMjZ9LFwiaFwiKS53KFwiPGRpdiBjbGFzcz1cXFwiZGctc2NoZWR1bGVfX3RjXCIpLngoY3R4LmdldChbXCJhY3RpdmVcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzI3fSx7fSkudyhcIlxcXCI+PGRpdiBjbGFzcz1cXFwiZGctc2NoZWR1bGVfX2RheS1uYW1lXFxcIj5cIikuZihjdHguZ2V0KFtcImtleVwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIjwvZGl2PjxkaXYgY2xhc3M9XFxcImRnLXNjaGVkdWxlX190ZFxcXCI+XCIpLngoY3R4LmdldChbXCJmcm9tXCJdLCBmYWxzZSksY3R4LHtcImVsc2VcIjpib2R5XzI4LFwiYmxvY2tcIjpib2R5XzI5fSx7fSkudyhcIjwvZGl2PlwiKS5zKGN0eC5nZXQoW1wibHVuY2hcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzMwfSx7fSkudyhcIjwvZGl2PiBcIikuaChcImlmXCIsY3R4LHtcImJsb2NrXCI6Ym9keV8zM30se1wiY29uZFwiOmJvZHlfMzR9LFwiaFwiKTt9Ym9keV8yNC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMjUoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPHNwYW4gY2xhc3M9XFxcImRnLXNjaGVkdWxlX190YWJsZS1jZWxsLWdyb3VwXFxcIj5cIik7fWJvZHlfMjUuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzI2KGNoayxjdHgpe3JldHVybiBjaGsudyhcIihcIikuZihjdHguZ2V0KFtcIiRpZHhcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCIgPT0gXCIpLmYoY3R4LmdldChbXCIkbGVuXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiIC0gMilcIik7fWJvZHlfMjYuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzI3KGNoayxjdHgpe3JldHVybiBjaGsudyhcIiBkZy1zY2hlZHVsZV9fdGNfYWN0aXZlX3RydWVcIik7fWJvZHlfMjcuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzI4KGNoayxjdHgpe3JldHVybiBjaGsudyhcIiZuZGFzaDtcIik7fWJvZHlfMjguX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzI5KGNoayxjdHgpe3JldHVybiBjaGsuZihjdHguZ2V0KFtcImZyb21cIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCIgXCIpLmYoY3R4LmdldChbXCJ0b1wiXSwgZmFsc2UpLGN0eCxcImhcIik7fWJvZHlfMjkuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzMwKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLXNjaGVkdWxlX190ZFxcXCI+XCIpLngoY3R4LmdldChbXCJmcm9tXCJdLCBmYWxzZSksY3R4LHtcImVsc2VcIjpib2R5XzMxLFwiYmxvY2tcIjpib2R5XzMyfSx7fSkudyhcIjwvZGl2PlwiKTt9Ym9keV8zMC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMzEoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiJm5kYXNoO1wiKTt9Ym9keV8zMS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMzIoY2hrLGN0eCl7cmV0dXJuIGNoay5mKGN0eC5nZXQoW1wiZnJvbVwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIiBcIikuZihjdHguZ2V0KFtcInRvXCJdLCBmYWxzZSksY3R4LFwiaFwiKTt9Ym9keV8zMi5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMzMoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPC9zcGFuPlwiKTt9Ym9keV8zMy5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMzQoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiKFwiKS5mKGN0eC5nZXQoW1wiJGlkeFwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIiA9PSBcIikuZihjdHguZ2V0KFtcIiRsZW5cIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCIpXCIpO31ib2R5XzM0Ll9fZHVzdEJvZHk9ITA7cmV0dXJuIGJvZHlfMH0oZHVzdCkpOyIsIihmdW5jdGlvbihkdXN0KXtkdXN0LnJlZ2lzdGVyKFwiREdHZW9jbGlja2VyXFwvZmlybWxpc3RJdGVtXCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGEgaWQ9XFxcIlwiKS5mKGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJmaXJtXCIsXCJpZFwiXSksY3R4LFwiaFwiKS53KFwiXFxcIiBjbGFzcz1cXFwiZGctcG9wdXBfX2xpbmtcXFwiIGhyZWY9XFxcIiNcXFwiPlwiKS5mKGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJmaXJtXCIsXCJuYW1lXCJdKSxjdHgsXCJoXCIpLncoXCI8L2E+XCIpO31ib2R5XzAuX19kdXN0Qm9keT0hMDtyZXR1cm4gYm9keV8wfShkdXN0KSk7IiwiKGZ1bmN0aW9uKGR1c3Qpe2R1c3QucmVnaXN0ZXIoXCJER0dlb2NsaWNrZXJcXC9mcmltQ2FyZFBheW1lbnRzXCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay54KGN0eC5nZXQoW1wicGF5bWVudHNcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzF9LHt9KTt9Ym9keV8wLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxzZWN0aW9uIGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX2FhXFxcIj48dWwgY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fYWEtbGlzdFxcXCI+XCIpLnMoY3R4LmdldChbXCJwYXltZW50c1wiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMn0se30pLncoXCI8L3VsPjwvc2VjdGlvbj5cIik7fWJvZHlfMS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMihjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8bGkgY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fYWEtbGlzdC1pdGVtXFxcIj5cIikuZihjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFwiaFwiKS53KFwiPC9saT5cIik7fWJvZHlfMi5fX2R1c3RCb2R5PSEwO3JldHVybiBib2R5XzB9KGR1c3QpKTsiLCIoZnVuY3Rpb24oZHVzdCl7ZHVzdC5yZWdpc3RlcihcIkRHR2VvY2xpY2tlclxcL2hvdXNlXCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay5zKGN0eC5nZXQoW1wiYWRkcmVzc1wiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMX0se30pLnMoY3R4LmdldChbXCJwdXJwb3NlXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV80fSx7fSkucyhjdHguZ2V0KFtcImF0dHJhY3Rpb25zXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV81fSx7fSk7fWJvZHlfMC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8YWRkcmVzcyBjbGFzcz1cXFwiZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3NcXFwiPlwiKS5zKGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJhZGRyZXNzXCIsXCJoZWFkZXJcIl0pLGN0eCx7XCJibG9ja1wiOmJvZHlfMn0se30pLnMoY3R4LmdldFBhdGgoZmFsc2UsIFtcImFkZHJlc3NcIixcImRyaWxsZG93blwiXSksY3R4LHtcImJsb2NrXCI6Ym9keV8zfSx7fSkudyhcIjwvYWRkcmVzcz5cIik7fWJvZHlfMS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMihjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzcy1oZWFkZXJcXFwiPlwiKS5mKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXCJoXCIpLncoXCI8L2Rpdj5cIik7fWJvZHlfMi5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMyhjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzcy1kcmlsbGRvd25cXFwiPlwiKS5mKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXCJoXCIpLncoXCI8L2Rpdj5cIik7fWJvZHlfMy5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1tYXAtZ2VvY2xpY2tlcl9fcHVycG9zZVxcXCI+XCIpLmYoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcImhcIikudyhcIjwvZGl2PlwiKTt9Ym9keV80Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV81KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLW1hcC1nZW9jbGlja2VyX19wdXJwb3NlIGRnLW1hcC1nZW9jbGlja2VyX19wdXJwb3NlX3R5cGVfc2lnaHRcXFwiPlwiKS5mKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXCJoXCIpLncoXCI8L2Rpdj5cIik7fWJvZHlfNS5fX2R1c3RCb2R5PSEwO3JldHVybiBib2R5XzB9KGR1c3QpKTsiLCIoZnVuY3Rpb24oZHVzdCl7ZHVzdC5yZWdpc3RlcihcIkRHR2VvY2xpY2tlclxcL2xvYWRlclwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLXByZWxvYWRlciBkZy1wcmVsb2FkZXJfc2NoZW1lX3JlZ3VsYXIgZGctcHJlbG9hZGVyX2FuaW1hdGlvbl9cIikueChjdHguZ2V0KFtcImFuaW1cIl0sIGZhbHNlKSxjdHgse1wiZWxzZVwiOmJvZHlfMSxcImJsb2NrXCI6Ym9keV8yfSx7fSkueChjdHguZ2V0KFtcInNtYWxsXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8zfSx7fSkudyhcIlxcXCI+PC9kaXY+XCIpO31ib2R5XzAuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzEoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiZmFsc2VcIik7fWJvZHlfMS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMihjaGssY3R4KXtyZXR1cm4gY2hrLncoXCJ0cnVlXCIpO31ib2R5XzIuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzMoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiIGRnLXByZWxvYWRlcl9zaXplX3NtYWxsXCIpO31ib2R5XzMuX19kdXN0Qm9keT0hMDtyZXR1cm4gYm9keV8wfShkdXN0KSk7IiwiKGZ1bmN0aW9uKGR1c3Qpe2R1c3QucmVnaXN0ZXIoXCJER0dlb2NsaWNrZXJcXC9wb3B1cEZvb3RlclwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLXBvcHVwX19mb290ZXItdGl0bGVcXFwiPjxhIGNsYXNzPVxcXCJkZy1wb3B1cF9fc2hvdy1sZXNzLWhvdXNlLWxpbmtcXFwiIGhyZWY9XFxcImphdmFzY3JpcHQ6dm9pZCgwKVxcXCI+XCIpLmYoY3R4LmdldChbXCJoaWRlRmlybXNUZXh0XCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiPC9hPjwvZGl2PlwiKTt9Ym9keV8wLl9fZHVzdEJvZHk9ITA7cmV0dXJuIGJvZHlfMH0oZHVzdCkpOyIsIihmdW5jdGlvbihkdXN0KXtkdXN0LnJlZ2lzdGVyKFwiREdHZW9jbGlja2VyXFwvcG9wdXBGb290ZXJCdG5zXCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay54KGN0eC5nZXQoW1wiYnRuc1wiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMX0se30pO31ib2R5XzAuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzEoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGZvb3RlciBjbGFzcz1cXFwiZGctcG9wdXBfX2Zvb3Rlci1idXR0b25zXFxcIj5cIikucyhjdHguZ2V0KFtcImJ0bnNcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzJ9LHt9KS53KFwiPC9mb290ZXI+XCIpO31ib2R5XzEuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzIoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctcG9wdXBfX2Zvb3Rlci1idXR0b24td3JhcHBlclxcXCI+PGEgY2xhc3M9XFxcImRnLXBvcHVwX19idXR0b25fbmFtZV9cIikuZihjdHguZ2V0KFtcIm5hbWVcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCIgZGctcG9wdXBfX2Zvb3Rlci1idXR0b25cIikueChjdHguZ2V0KFtcImljb25cIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzN9LHt9KS53KFwiXFxcIlwiKS54KGN0eC5nZXQoW1wiaHJlZlwiXSwgZmFsc2UpLGN0eCx7XCJlbHNlXCI6Ym9keV80LFwiYmxvY2tcIjpib2R5XzV9LHt9KS53KFwiPlwiKS5mKGN0eC5nZXQoW1wibGFiZWxcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCI8L2E+PC9kaXY+XCIpO31ib2R5XzIuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzMoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiIGRnLXBvcHVwX19mb290ZXItaWNvbi1idXR0b25cIik7fWJvZHlfMy5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCJocmVmPVxcXCJqYXZhc2NyaXB0OnZvaWQoMClcXFwiXCIpO31ib2R5XzQuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzUoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiaHJlZj1cIikuZihjdHguZ2V0KFtcImhyZWZcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiXCIpO31ib2R5XzUuX19kdXN0Qm9keT0hMDtyZXR1cm4gYm9keV8wfShkdXN0KSk7IiwiKGZ1bmN0aW9uKGR1c3Qpe2R1c3QucmVnaXN0ZXIoXCJER0dlb2NsaWNrZXJcXC9wb3B1cEhlYWRlclwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsucyhjdHguZ2V0KFtcInRpdGxlXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8xfSx7fSk7fWJvZHlfMC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1wb3B1cF9faGVhZGVyLXRpdGxlXFxcIj5cIikuZihjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFwiaFwiKS53KFwiPC9kaXY+XCIpO31ib2R5XzEuX19kdXN0Qm9keT0hMDtyZXR1cm4gYm9keV8wfShkdXN0KSk7IiwiKGZ1bmN0aW9uKGR1c3Qpe2R1c3QucmVnaXN0ZXIoXCJER0dlb2NsaWNrZXJcXC9zaWdodFwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsucyhjdHguZ2V0KFtcInB1cnBvc2VcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzF9LHt9KS5zKGN0eC5nZXQoW1wiYWRkcmVzc1wiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMn0se30pLnMoY3R4LmdldChbXCJkZXNjcmlwdGlvblwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfNX0se30pO31ib2R5XzAuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzEoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2UgZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2VfdHlwZV9zaWdodFxcXCI+XCIpLmYoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcImhcIikudyhcIjwvZGl2PlwiKTt9Ym9keV8xLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxhZGRyZXNzIGNsYXNzPVxcXCJkZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzc1xcXCI+XCIpLnMoY3R4LmdldFBhdGgoZmFsc2UsIFtcImFkZHJlc3NcIixcImhlYWRlclwiXSksY3R4LHtcImJsb2NrXCI6Ym9keV8zfSx7fSkucyhjdHguZ2V0UGF0aChmYWxzZSwgW1wiYWRkcmVzc1wiLFwiZHJpbGxkb3duXCJdKSxjdHgse1wiYmxvY2tcIjpib2R5XzR9LHt9KS53KFwiPC9hZGRyZXNzPlwiKTt9Ym9keV8yLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8zKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLW1hcC1nZW9jbGlja2VyX19hZGRyZXNzLWhlYWRlclxcXCI+XCIpLmYoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcImhcIikudyhcIjwvZGl2PlwiKTt9Ym9keV8zLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV80KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLW1hcC1nZW9jbGlja2VyX19hZGRyZXNzLWRyaWxsZG93blxcXCI+XCIpLmYoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcImhcIikudyhcIjwvZGl2PlwiKTt9Ym9keV80Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV81KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLW1hcC1nZW9jbGlja2VyX19zaWdodC1kZXNjcmlwdGlvblxcXCI+XCIpLmYoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcImhcIikudyhcIjwvZGl2PlwiKS5zKGN0eC5nZXQoW1wic2hvd01vcmVUZXh0XCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV82fSx7fSk7fWJvZHlfNS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNihjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8YSBjbGFzcz1cXFwiZGctbWFwLWdlb2NsaWNrZXJfX3Nob3ctbW9yZS1zaWdodHMtbGlua1xcXCIgaHJlZj1cXFwiamF2YXNjcmlwdDp2b2lkKDApXFxcIj5cIikuZihjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFwiaFwiKS53KFwiPC9hPlwiKTt9Ym9keV82Ll9fZHVzdEJvZHk9ITA7cmV0dXJuIGJvZHlfMH0oZHVzdCkpOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGJyb3dzZXIgZmllbGQsIGNoZWNrIG91dCB0aGUgYnJvd3NlciBmaWVsZCBhdCBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJvd3NlcmlmeS1oYW5kYm9vayNicm93c2VyLWZpZWxkLlxuXG52YXIgc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyIGluc2VydFN0eWxlRWxlbWVudCA9IGZ1bmN0aW9uKHN0eWxlRWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgIHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5pbnNlcnRBdCA9IG9wdGlvbnMuaW5zZXJ0QXQgfHwgJ2JvdHRvbSc7XG5cbiAgICBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgaWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuICAgICAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSAnYm90dG9tJykge1xuICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXFwnaW5zZXJ0QXRcXCcuIE11c3QgYmUgXFwndG9wXFwnIG9yIFxcJ2JvdHRvbVxcJy4nKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvLyBDcmVhdGUgYSA8bGluaz4gdGFnIHdpdGggb3B0aW9uYWwgZGF0YSBhdHRyaWJ1dGVzXG4gICAgY3JlYXRlTGluazogZnVuY3Rpb24oaHJlZiwgYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG5cbiAgICAgICAgbGluay5ocmVmID0gaHJlZjtcbiAgICAgICAgbGluay5yZWwgPSAnc3R5bGVzaGVldCc7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmICggISBhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdkYXRhLScgKyBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgfSxcbiAgICAvLyBDcmVhdGUgYSA8c3R5bGU+IHRhZyB3aXRoIG9wdGlvbmFsIGRhdGEgYXR0cmlidXRlc1xuICAgIGNyZWF0ZVN0eWxlOiBmdW5jdGlvbihjc3NUZXh0LCBhdHRyaWJ1dGVzLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgZXh0cmFPcHRpb25zID0gZXh0cmFPcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoICEgYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0eWxlLnNoZWV0KSB7IC8vIGZvciBqc2RvbSBhbmQgSUU5K1xuICAgICAgICAgICAgc3R5bGUuaW5uZXJIVE1MID0gY3NzVGV4dDtcbiAgICAgICAgICAgIHN0eWxlLnNoZWV0LmNzc1RleHQgPSBjc3NUZXh0O1xuICAgICAgICAgICAgaW5zZXJ0U3R5bGVFbGVtZW50KHN0eWxlLCB7IGluc2VydEF0OiBleHRyYU9wdGlvbnMuaW5zZXJ0QXQgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGUuc3R5bGVTaGVldCkgeyAvLyBmb3IgSUU4IGFuZCBiZWxvd1xuICAgICAgICAgICAgaW5zZXJ0U3R5bGVFbGVtZW50KHN0eWxlLCB7IGluc2VydEF0OiBleHRyYU9wdGlvbnMuaW5zZXJ0QXQgfSk7XG4gICAgICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3NUZXh0O1xuICAgICAgICB9IGVsc2UgeyAvLyBmb3IgQ2hyb21lLCBGaXJlZm94LCBhbmQgU2FmYXJpXG4gICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3NUZXh0KSk7XG4gICAgICAgICAgICBpbnNlcnRTdHlsZUVsZW1lbnQoc3R5bGUsIHsgaW5zZXJ0QXQ6IGV4dHJhT3B0aW9ucy5pbnNlcnRBdCB9KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICYmIGRlZmluZS5hbWQuZHVzdCA9PT0gdHJ1ZSkge1xuICAgIGRlZmluZShbJ2R1c3QuY29yZSddLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnZHVzdGpzLWxpbmtlZGluJykpO1xuICB9IGVsc2Uge1xuICAgIGZhY3Rvcnkocm9vdC5kdXN0KTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbihkdXN0KSB7XG5cbmZ1bmN0aW9uIGxvZyhoZWxwZXIsIG1zZywgbGV2ZWwpIHtcbiAgbGV2ZWwgPSBsZXZlbCB8fCBcIklORk9cIjtcbiAgaGVscGVyID0gaGVscGVyID8gJ3tAJyArIGhlbHBlciArICd9OiAnIDogJyc7XG4gIGR1c3QubG9nKGhlbHBlciArIG1zZywgbGV2ZWwpO1xufVxuXG52YXIgX2RlcHJlY2F0ZWRDYWNoZSA9IHt9O1xuZnVuY3Rpb24gX2RlcHJlY2F0ZWQodGFyZ2V0KSB7XG4gIGlmKF9kZXByZWNhdGVkQ2FjaGVbdGFyZ2V0XSkgeyByZXR1cm47IH1cbiAgbG9nKHRhcmdldCwgXCJEZXByZWNhdGlvbiB3YXJuaW5nOiBcIiArIHRhcmdldCArIFwiIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIGR1c3Rqcy1oZWxwZXJzXCIsIFwiV0FSTlwiKTtcbiAgbG9nKG51bGwsIFwiRm9yIGhlbHAgYW5kIGEgZGVwcmVjYXRpb24gdGltZWxpbmUsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbGlua2VkaW4vZHVzdGpzLWhlbHBlcnMvd2lraS9EZXByZWNhdGVkLUZlYXR1cmVzI1wiICsgdGFyZ2V0LnJlcGxhY2UoL1xcVysvZywgXCJcIiksIFwiV0FSTlwiKTtcbiAgX2RlcHJlY2F0ZWRDYWNoZVt0YXJnZXRdID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNTZWxlY3QoY29udGV4dCkge1xuICByZXR1cm4gY29udGV4dC5zdGFjay50YWlsICYmXG4gICAgICAgICBjb250ZXh0LnN0YWNrLnRhaWwuaGVhZCAmJlxuICAgICAgICAgdHlwZW9mIGNvbnRleHQuc3RhY2sudGFpbC5oZWFkLl9fc2VsZWN0X18gIT09IFwidW5kZWZpbmVkXCI7XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdFN0YXRlKGNvbnRleHQpIHtcbiAgcmV0dXJuIGlzU2VsZWN0KGNvbnRleHQpICYmIGNvbnRleHQuZ2V0KCdfX3NlbGVjdF9fJyk7XG59XG5cbi8qKlxuICogQWRkcyBhIHNwZWNpYWwgX19zZWxlY3RfXyBrZXkgYmVoaW5kIHRoZSBoZWFkIG9mIHRoZSBjb250ZXh0IHN0YWNrLiBVc2VkIHRvIG1haW50YWluIHRoZSBzdGF0ZVxuICogb2Yge0BzZWxlY3R9IGJsb2Nrc1xuICogQHBhcmFtIGNvbnRleHQge0NvbnRleHR9IGFkZCBzdGF0ZSB0byB0aGlzIENvbnRleHRcbiAqIEBwYXJhbSBvcHRzIHtPYmplY3R9IGFkZCB0aGVzZSBwcm9wZXJ0aWVzIHRvIHRoZSBzdGF0ZSAoYGtleWAgYW5kIGB0eXBlYClcbiAqL1xuZnVuY3Rpb24gYWRkU2VsZWN0U3RhdGUoY29udGV4dCwgb3B0cykge1xuICB2YXIgaGVhZCA9IGNvbnRleHQuc3RhY2suaGVhZCxcbiAgICAgIG5ld0NvbnRleHQgPSBjb250ZXh0LnJlYmFzZSgpLFxuICAgICAga2V5O1xuXG4gIGlmKGNvbnRleHQuc3RhY2sgJiYgY29udGV4dC5zdGFjay50YWlsKSB7XG4gICAgbmV3Q29udGV4dC5zdGFjayA9IGNvbnRleHQuc3RhY2sudGFpbDtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IHtcbiAgICBpc1BlbmRpbmc6IGZhbHNlLFxuICAgIGlzUmVzb2x2ZWQ6IGZhbHNlLFxuICAgIGlzRGVmZXJyZWRDb21wbGV0ZTogZmFsc2UsXG4gICAgZGVmZXJyZWRzOiBbXVxuICB9O1xuXG4gIGZvcihrZXkgaW4gb3B0cykge1xuICAgIHN0YXRlW2tleV0gPSBvcHRzW2tleV07XG4gIH1cblxuICByZXR1cm4gbmV3Q29udGV4dFxuICAucHVzaCh7IFwiX19zZWxlY3RfX1wiOiBzdGF0ZSB9KVxuICAucHVzaChoZWFkLCBjb250ZXh0LnN0YWNrLmluZGV4LCBjb250ZXh0LnN0YWNrLm9mKTtcbn1cblxuLyoqXG4gKiBBZnRlciBhIHtAc2VsZWN0fSBvciB7QG1hdGh9IGJsb2NrIGlzIGNvbXBsZXRlLCB0aGV5IGludm9rZSB0aGlzIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTZWxlY3REZWZlcnJlZHMoc3RhdGUpIHtcbiAgdmFyIHgsIGxlbjtcbiAgc3RhdGUuaXNEZWZlcnJlZFBlbmRpbmcgPSB0cnVlO1xuICBpZihzdGF0ZS5kZWZlcnJlZHMubGVuZ3RoKSB7XG4gICAgc3RhdGUuaXNEZWZlcnJlZENvbXBsZXRlID0gdHJ1ZTtcbiAgICBmb3IoeD0wLCBsZW49c3RhdGUuZGVmZXJyZWRzLmxlbmd0aDsgeDxsZW47IHgrKykge1xuICAgICAgc3RhdGUuZGVmZXJyZWRzW3hdKCk7XG4gICAgfVxuICB9XG4gIHN0YXRlLmlzRGVmZXJyZWRQZW5kaW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogVXNlZCBieSB7QGNvbnRleHREdW1wfVxuICovXG5mdW5jdGlvbiBqc29uRmlsdGVyKGtleSwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKClcbiAgICAgIC5yZXBsYWNlKC8oXlxccyt8XFxzKyQpL21nLCAnJylcbiAgICAgIC5yZXBsYWNlKC9cXG4vbWcsICcnKVxuICAgICAgLnJlcGxhY2UoLyxcXHMqL21nLCAnLCAnKVxuICAgICAgLnJlcGxhY2UoL1xcKVxcey9tZywgJykgeycpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHRydXRoIHRlc3QgaGVscGVyXG4gKi9cbmZ1bmN0aW9uIHRydXRoVGVzdChuYW1lLCB0ZXN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gZmlsdGVyKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcywgbmFtZSwgdGVzdCk7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBpbnZva2VkIGJ5IHRydXRoIHRlc3QgaGVscGVyc1xuICovXG5mdW5jdGlvbiBmaWx0ZXIoY2h1bmssIGNvbnRleHQsIGJvZGllcywgcGFyYW1zLCBoZWxwZXJOYW1lLCB0ZXN0KSB7XG4gIHZhciBib2R5ID0gYm9kaWVzLmJsb2NrLFxuICAgICAgc2tpcCA9IGJvZGllc1snZWxzZSddLFxuICAgICAgc2VsZWN0U3RhdGUgPSBnZXRTZWxlY3RTdGF0ZShjb250ZXh0KSB8fCB7fSxcbiAgICAgIHdpbGxSZXNvbHZlLCBrZXksIHZhbHVlLCB0eXBlO1xuXG4gIC8vIE9uY2Ugb25lIHRydXRoIHRlc3QgaW4gYSBzZWxlY3QgcGFzc2VzLCBzaG9ydC1jaXJjdWl0IHRoZSByZXN0IG9mIHRoZSB0ZXN0c1xuICBpZiAoc2VsZWN0U3RhdGUuaXNSZXNvbHZlZCAmJiAhc2VsZWN0U3RhdGUuaXNEZWZlcnJlZFBlbmRpbmcpIHtcbiAgICByZXR1cm4gY2h1bms7XG4gIH1cblxuICAvLyBGaXJzdCBjaGVjayBmb3IgYSBrZXkgb24gdGhlIGhlbHBlciBpdHNlbGYsIHRoZW4gbG9vayBmb3IgYSBrZXkgb24gdGhlIHtAc2VsZWN0fVxuICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KCdrZXknKSkge1xuICAgIGtleSA9IHBhcmFtcy5rZXk7XG4gIH0gZWxzZSBpZiAoc2VsZWN0U3RhdGUuaGFzT3duUHJvcGVydHkoJ2tleScpKSB7XG4gICAga2V5ID0gc2VsZWN0U3RhdGUua2V5O1xuICB9IGVsc2Uge1xuICAgIGxvZyhoZWxwZXJOYW1lLCBcIk5vIGtleSBzcGVjaWZpZWRcIiwgXCJXQVJOXCIpO1xuICAgIHJldHVybiBjaHVuaztcbiAgfVxuXG4gIHR5cGUgPSBwYXJhbXMudHlwZSB8fCBzZWxlY3RTdGF0ZS50eXBlO1xuXG4gIGtleSA9IGNvZXJjZShjb250ZXh0LnJlc29sdmUoa2V5KSwgdHlwZSk7XG4gIHZhbHVlID0gY29lcmNlKGNvbnRleHQucmVzb2x2ZShwYXJhbXMudmFsdWUpLCB0eXBlKTtcblxuICBpZiAodGVzdChrZXksIHZhbHVlKSkge1xuICAgIC8vIE9uY2UgYSB0cnV0aCB0ZXN0IHBhc3NlcywgcHV0IHRoZSBzZWxlY3QgaW50byBcInBlbmRpbmdcIiBzdGF0ZS4gTm93IHdlIGNhbiByZW5kZXIgdGhlIGJvZHkgb2ZcbiAgICAvLyB0aGUgdHJ1dGggdGVzdCAod2hpY2ggbWF5IGNvbnRhaW4gdHJ1dGggdGVzdHMpIHdpdGhvdXQgYWx0ZXJpbmcgdGhlIHN0YXRlIG9mIHRoZSBzZWxlY3QuXG4gICAgaWYgKCFzZWxlY3RTdGF0ZS5pc1BlbmRpbmcpIHtcbiAgICAgIHdpbGxSZXNvbHZlID0gdHJ1ZTtcbiAgICAgIHNlbGVjdFN0YXRlLmlzUGVuZGluZyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChib2R5KSB7XG4gICAgICBjaHVuayA9IGNodW5rLnJlbmRlcihib2R5LCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKHdpbGxSZXNvbHZlKSB7XG4gICAgICBzZWxlY3RTdGF0ZS5pc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2tpcCkge1xuICAgIGNodW5rID0gY2h1bmsucmVuZGVyKHNraXAsIGNvbnRleHQpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuZnVuY3Rpb24gY29lcmNlKHZhbHVlLCB0eXBlKSB7XG4gIGlmICh0eXBlKSB7XG4gICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgfVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdudW1iZXInOiByZXR1cm4gK3ZhbHVlO1xuICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgdmFsdWUgPSAodmFsdWUgPT09ICdmYWxzZScgPyBmYWxzZSA6IHZhbHVlKTtcbiAgICAgIHJldHVybiBCb29sZWFuKHZhbHVlKTtcbiAgICBjYXNlICdkYXRlJzogcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIGhlbHBlcnMgPSB7XG5cbiAgLy8gVXRpbGl0eSBoZWxwaW5nIHRvIHJlc29sdmUgZHVzdCByZWZlcmVuY2VzIGluIHRoZSBnaXZlbiBjaHVua1xuICAvLyB1c2VzIG5hdGl2ZSBEdXN0IENvbnRleHQjcmVzb2x2ZSAoYXZhaWxhYmxlIHNpbmNlIER1c3QgMi42LjIpXG4gIFwidGFwXCI6IGZ1bmN0aW9uKGlucHV0LCBjaHVuaywgY29udGV4dCkge1xuICAgIC8vIGRlcHJlY2F0ZWQgZm9yIHJlbW92YWwgaW4gMS44XG4gICAgX2RlcHJlY2F0ZWQoXCJ0YXBcIik7XG4gICAgcmV0dXJuIGNvbnRleHQucmVzb2x2ZShpbnB1dCk7XG4gIH0sXG5cbiAgXCJzZXBcIjogZnVuY3Rpb24oY2h1bmssIGNvbnRleHQsIGJvZGllcykge1xuICAgIHZhciBib2R5ID0gYm9kaWVzLmJsb2NrO1xuICAgIGlmIChjb250ZXh0LnN0YWNrLmluZGV4ID09PSBjb250ZXh0LnN0YWNrLm9mIC0gMSkge1xuICAgICAgcmV0dXJuIGNodW5rO1xuICAgIH1cbiAgICBpZiAoYm9keSkge1xuICAgICAgcmV0dXJuIGJvZHkoY2h1bmssIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICB9LFxuXG4gIFwiZmlyc3RcIjogZnVuY3Rpb24oY2h1bmssIGNvbnRleHQsIGJvZGllcykge1xuICAgIGlmIChjb250ZXh0LnN0YWNrLmluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm4gYm9kaWVzLmJsb2NrKGNodW5rLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rO1xuICB9LFxuXG4gIFwibGFzdFwiOiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhY2suaW5kZXggPT09IGNvbnRleHQuc3RhY2sub2YgLSAxKSB7XG4gICAgICByZXR1cm4gYm9kaWVzLmJsb2NrKGNodW5rLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rO1xuICB9LFxuXG4gIC8qKlxuICAgKiB7QGNvbnRleHREdW1wfVxuICAgKiBAcGFyYW0ga2V5IHtTdHJpbmd9IHNldCB0byBcImZ1bGxcIiB0byB0aGUgZnVsbCBjb250ZXh0IHN0YWNrLCBvdGhlcndpc2UgdGhlIGN1cnJlbnQgY29udGV4dCBpcyBkdW1wZWRcbiAgICogQHBhcmFtIHRvIHtTdHJpbmd9IHNldCB0byBcImNvbnNvbGVcIiB0byBsb2cgdG8gY29uc29sZSwgb3RoZXJ3aXNlIG91dHB1dHMgdG8gdGhlIGNodW5rXG4gICAqL1xuICBcImNvbnRleHREdW1wXCI6IGZ1bmN0aW9uKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcykge1xuICAgIHZhciB0byA9IGNvbnRleHQucmVzb2x2ZShwYXJhbXMudG8pLFxuICAgICAgICBrZXkgPSBjb250ZXh0LnJlc29sdmUocGFyYW1zLmtleSksXG4gICAgICAgIHRhcmdldCwgb3V0cHV0O1xuICAgIHN3aXRjaChrZXkpIHtcbiAgICAgIGNhc2UgJ2Z1bGwnOlxuICAgICAgICB0YXJnZXQgPSBjb250ZXh0LnN0YWNrO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRhcmdldCA9IGNvbnRleHQuc3RhY2suaGVhZDtcbiAgICB9XG4gICAgb3V0cHV0ID0gSlNPTi5zdHJpbmdpZnkodGFyZ2V0LCBqc29uRmlsdGVyLCAyKTtcbiAgICBzd2l0Y2godG8pIHtcbiAgICAgIGNhc2UgJ2NvbnNvbGUnOlxuICAgICAgICBsb2coJ2NvbnRleHREdW1wJywgb3V0cHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSgvPC9nLCAnXFxcXHUwMDNjJyk7XG4gICAgICAgIGNodW5rID0gY2h1bmsud3JpdGUob3V0cHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rO1xuICB9LFxuXG4gIC8qKlxuICAgKiB7QG1hdGh9XG4gICAqIEBwYXJhbSBrZXkgZmlyc3QgdmFsdWVcbiAgICogQHBhcmFtIG1ldGhvZCB7U3RyaW5nfSBvcGVyYXRpb24gdG8gcGVyZm9ybVxuICAgKiBAcGFyYW0gb3BlcmFuZCBzZWNvbmQgdmFsdWUgKG5vdCByZXF1aXJlZCBmb3Igb3BlcmF0aW9ucyBsaWtlIGBhYnNgKVxuICAgKiBAcGFyYW0gcm91bmQgaWYgdHJ1dGh5LCByb3VuZCgpIHRoZSByZXN1bHRcbiAgICovXG4gIFwibWF0aFwiOiBmdW5jdGlvbiAoY2h1bmssIGNvbnRleHQsIGJvZGllcywgcGFyYW1zKSB7XG4gICAgdmFyIGtleSA9IHBhcmFtcy5rZXksXG4gICAgICAgIG1ldGhvZCA9IHBhcmFtcy5tZXRob2QsXG4gICAgICAgIG9wZXJhbmQgPSBwYXJhbXMub3BlcmFuZCxcbiAgICAgICAgcm91bmQgPSBwYXJhbXMucm91bmQsXG4gICAgICAgIG91dHB1dCwgc3RhdGUsIHgsIGxlbjtcblxuICAgIGlmKCFwYXJhbXMuaGFzT3duUHJvcGVydHkoJ2tleScpIHx8ICFwYXJhbXMubWV0aG9kKSB7XG4gICAgICBsb2coXCJtYXRoXCIsIFwiYGtleWAgb3IgYG1ldGhvZGAgd2FzIG5vdCBwcm92aWRlZFwiLCBcIkVSUk9SXCIpO1xuICAgICAgcmV0dXJuIGNodW5rO1xuICAgIH1cblxuICAgIGtleSA9IHBhcnNlRmxvYXQoY29udGV4dC5yZXNvbHZlKGtleSkpO1xuICAgIG9wZXJhbmQgPSBwYXJzZUZsb2F0KGNvbnRleHQucmVzb2x2ZShvcGVyYW5kKSk7XG5cbiAgICBzd2l0Y2gobWV0aG9kKSB7XG4gICAgICBjYXNlIFwibW9kXCI6XG4gICAgICAgIGlmKG9wZXJhbmQgPT09IDApIHtcbiAgICAgICAgICBsb2coXCJtYXRoXCIsIFwiRGl2aXNpb24gYnkgMFwiLCBcIkVSUk9SXCIpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dCA9IGtleSAlIG9wZXJhbmQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICBvdXRwdXQgPSBrZXkgKyBvcGVyYW5kO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzdWJ0cmFjdFwiOlxuICAgICAgICBvdXRwdXQgPSBrZXkgLSBvcGVyYW5kO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtdWx0aXBseVwiOlxuICAgICAgICBvdXRwdXQgPSBrZXkgKiBvcGVyYW5kO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXZpZGVcIjpcbiAgICAgICAgaWYob3BlcmFuZCA9PT0gMCkge1xuICAgICAgICAgIGxvZyhcIm1hdGhcIiwgXCJEaXZpc2lvbiBieSAwXCIsIFwiRVJST1JcIik7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ID0ga2V5IC8gb3BlcmFuZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY2VpbFwiOlxuICAgICAgY2FzZSBcImZsb29yXCI6XG4gICAgICBjYXNlIFwicm91bmRcIjpcbiAgICAgIGNhc2UgXCJhYnNcIjpcbiAgICAgICAgb3V0cHV0ID0gTWF0aFttZXRob2RdKGtleSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvaW50XCI6XG4gICAgICAgIG91dHB1dCA9IHBhcnNlSW50KGtleSwgMTApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxvZyhcIm1hdGhcIiwgXCJNZXRob2QgYFwiICsgbWV0aG9kICsgXCJgIGlzIG5vdCBzdXBwb3J0ZWRcIiwgXCJFUlJPUlwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG91dHB1dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChyb3VuZCkge1xuICAgICAgICBvdXRwdXQgPSBNYXRoLnJvdW5kKG91dHB1dCk7XG4gICAgICB9XG4gICAgICBpZiAoYm9kaWVzICYmIGJvZGllcy5ibG9jaykge1xuICAgICAgICBjb250ZXh0ID0gYWRkU2VsZWN0U3RhdGUoY29udGV4dCwgeyBrZXk6IG91dHB1dCB9KTtcbiAgICAgICAgY2h1bmsgPSBjaHVuay5yZW5kZXIoYm9kaWVzLmJsb2NrLCBjb250ZXh0KTtcbiAgICAgICAgcmVzb2x2ZVNlbGVjdERlZmVycmVkcyhnZXRTZWxlY3RTdGF0ZShjb250ZXh0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaHVuayA9IGNodW5rLndyaXRlKG91dHB1dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNodW5rO1xuICB9LFxuXG4gIC8qKlxuICAgKiB7QHNlbGVjdH1cbiAgICogR3JvdXBzIGEgc2V0IG9mIHRydXRoIHRlc3RzIGFuZCBvdXRwdXRzIHRoZSBmaXJzdCBvbmUgdGhhdCBwYXNzZXMuXG4gICAqIEFsc28gY29udGFpbnMge0Bhbnl9IGFuZCB7QG5vbmV9IGJsb2Nrcy5cbiAgICogQHBhcmFtIGtleSBhIHZhbHVlIG9yIHJlZmVyZW5jZSB0byB1c2UgYXMgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIGNvbXBhcmlzb25zXG4gICAqIEBwYXJhbSB0eXBlIGNvZXJjZSBhbGwgdHJ1dGggdGVzdCBrZXlzIHdpdGhvdXQgYW4gZXhwbGljaXQgdHlwZSB0byB0aGlzIHR5cGVcbiAgICovXG4gIFwic2VsZWN0XCI6IGZ1bmN0aW9uKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcykge1xuICAgIHZhciBib2R5ID0gYm9kaWVzLmJsb2NrLFxuICAgICAgICBzdGF0ZSA9IHt9O1xuXG4gICAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eSgna2V5JykpIHtcbiAgICAgIHN0YXRlLmtleSA9IGNvbnRleHQucmVzb2x2ZShwYXJhbXMua2V5KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eSgndHlwZScpKSB7XG4gICAgICBzdGF0ZS50eXBlID0gcGFyYW1zLnR5cGU7XG4gICAgfVxuXG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIGNvbnRleHQgPSBhZGRTZWxlY3RTdGF0ZShjb250ZXh0LCBzdGF0ZSk7XG4gICAgICBjaHVuayA9IGNodW5rLnJlbmRlcihib2R5LCBjb250ZXh0KTtcbiAgICAgIHJlc29sdmVTZWxlY3REZWZlcnJlZHMoZ2V0U2VsZWN0U3RhdGUoY29udGV4dCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2coXCJzZWxlY3RcIiwgXCJNaXNzaW5nIGJvZHkgYmxvY2tcIiwgXCJXQVJOXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY2h1bms7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRydXRoIHRlc3QgaGVscGVyc1xuICAgKiBAcGFyYW0ga2V5IGEgdmFsdWUgb3IgcmVmZXJlbmNlIHRvIHVzZSBhcyB0aGUgbGVmdC1oYW5kIHNpZGUgb2YgY29tcGFyaXNvbnNcbiAgICogQHBhcmFtIHZhbHVlIGEgdmFsdWUgb3IgcmVmZXJlbmNlIHRvIHVzZSBhcyB0aGUgcmlnaHQtaGFuZCBzaWRlIG9mIGNvbXBhcmlzb25zXG4gICAqIEBwYXJhbSB0eXBlIGlmIHNwZWNpZmllZCwgYGtleWAgYW5kIGB2YWx1ZWAgd2lsbCBiZSBmb3JjaWJseSBjYXN0IHRvIHRoaXMgdHlwZVxuICAgKi9cbiAgXCJlcVwiOiB0cnV0aFRlc3QoJ2VxJywgZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gIH0pLFxuICBcIm5lXCI6IHRydXRoVGVzdCgnbmUnLCBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBsZWZ0ICE9PSByaWdodDtcbiAgfSksXG4gIFwibHRcIjogdHJ1dGhUZXN0KCdsdCcsIGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGxlZnQgPCByaWdodDtcbiAgfSksXG4gIFwibHRlXCI6IHRydXRoVGVzdCgnbHRlJywgZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdCA8PSByaWdodDtcbiAgfSksXG4gIFwiZ3RcIjogdHJ1dGhUZXN0KCdndCcsIGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGxlZnQgPiByaWdodDtcbiAgfSksXG4gIFwiZ3RlXCI6IHRydXRoVGVzdCgnZ3RlJywgZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdCA+PSByaWdodDtcbiAgfSksXG5cbiAgLyoqXG4gICAqIHtAYW55fVxuICAgKiBPdXRwdXRzIGFzIGxvbmcgYXMgYXQgbGVhc3Qgb25lIHRydXRoIHRlc3QgaW5zaWRlIGEge0BzZWxlY3R9IGhhcyBwYXNzZWQuXG4gICAqIE11c3QgYmUgY29udGFpbmVkIGluc2lkZSBhIHtAc2VsZWN0fSBibG9jay5cbiAgICogVGhlIHBhc3NpbmcgdHJ1dGggdGVzdCBjYW4gYmUgYmVmb3JlIG9yIGFmdGVyIHRoZSB7QGFueX0gYmxvY2suXG4gICAqL1xuICBcImFueVwiOiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpIHtcbiAgICB2YXIgc2VsZWN0U3RhdGUgPSBnZXRTZWxlY3RTdGF0ZShjb250ZXh0KTtcblxuICAgIGlmKCFzZWxlY3RTdGF0ZSkge1xuICAgICAgbG9nKFwiYW55XCIsIFwiTXVzdCBiZSB1c2VkIGluc2lkZSBhIHtAc2VsZWN0fSBibG9ja1wiLCBcIkVSUk9SXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihzZWxlY3RTdGF0ZS5pc0RlZmVycmVkQ29tcGxldGUpIHtcbiAgICAgICAgbG9nKFwiYW55XCIsIFwiTXVzdCBub3QgYmUgbmVzdGVkIGluc2lkZSB7QGFueX0gb3Ige0Bub25lfSBibG9ja1wiLCBcIkVSUk9SXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2h1bmsgPSBjaHVuay5tYXAoZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICBzZWxlY3RTdGF0ZS5kZWZlcnJlZHMucHVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKHNlbGVjdFN0YXRlLmlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5yZW5kZXIoYm9kaWVzLmJsb2NrLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rLmVuZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNodW5rO1xuICB9LFxuXG4gIC8qKlxuICAgKiB7QG5vbmV9XG4gICAqIE91dHB1dHMgaWYgbm8gdHJ1dGggdGVzdHMgaW5zaWRlIGEge0BzZWxlY3R9IHBhc3MuXG4gICAqIE11c3QgYmUgY29udGFpbmVkIGluc2lkZSBhIHtAc2VsZWN0fSBibG9jay5cbiAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBoZWxwZXIgZG9lcyBub3QgbWF0dGVyLlxuICAgKi9cbiAgXCJub25lXCI6IGZ1bmN0aW9uKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcykge1xuICAgIHZhciBzZWxlY3RTdGF0ZSA9IGdldFNlbGVjdFN0YXRlKGNvbnRleHQpO1xuXG4gICAgaWYoIXNlbGVjdFN0YXRlKSB7XG4gICAgICBsb2coXCJub25lXCIsIFwiTXVzdCBiZSB1c2VkIGluc2lkZSBhIHtAc2VsZWN0fSBibG9ja1wiLCBcIkVSUk9SXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihzZWxlY3RTdGF0ZS5pc0RlZmVycmVkQ29tcGxldGUpIHtcbiAgICAgICAgbG9nKFwibm9uZVwiLCBcIk11c3Qgbm90IGJlIG5lc3RlZCBpbnNpZGUge0Bhbnl9IG9yIHtAbm9uZX0gYmxvY2tcIiwgXCJFUlJPUlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNodW5rID0gY2h1bmsubWFwKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgc2VsZWN0U3RhdGUuZGVmZXJyZWRzLnB1c2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZighc2VsZWN0U3RhdGUuaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgICBjaHVuayA9IGNodW5rLnJlbmRlcihib2RpZXMuYmxvY2ssIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2h1bmsuZW5kKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2h1bms7XG4gIH0sXG5cbiAgLyoqXG4gICoge0BzaXplfVxuICAqIFdyaXRlIHRoZSBzaXplIG9mIHRoZSB0YXJnZXQgdG8gdGhlIGNodW5rXG4gICogRmFsc3kgdmFsdWVzIGFuZCB0cnVlIGhhdmUgc2l6ZSAwXG4gICogTnVtYmVycyBhcmUgcmV0dXJuZWQgYXMtaXNcbiAgKiBBcnJheXMgYW5kIFN0cmluZ3MgaGF2ZSBzaXplIGVxdWFsIHRvIHRoZWlyIGxlbmd0aFxuICAqIE9iamVjdHMgaGF2ZSBzaXplIGVxdWFsIHRvIHRoZSBudW1iZXIgb2Yga2V5cyB0aGV5IGNvbnRhaW5cbiAgKiBEdXN0IGJvZGllcyBhcmUgZXZhbHVhdGVkIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgaXMgcmV0dXJuZWRcbiAgKiBGdW5jdGlvbnMgYXJlIGV2YWx1YXRlZCBhbmQgdGhlIGxlbmd0aCBvZiB0aGVpciByZXR1cm4gdmFsdWUgaXMgZXZhbHVhdGVkXG4gICogQHBhcmFtIGtleSBmaW5kIHRoZSBzaXplIG9mIHRoaXMgdmFsdWUgb3IgcmVmZXJlbmNlXG4gICovXG4gIFwic2l6ZVwiOiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpIHtcbiAgICB2YXIga2V5ID0gcGFyYW1zLmtleSxcbiAgICAgICAgdmFsdWUsIGs7XG5cbiAgICBrZXkgPSBjb250ZXh0LnJlc29sdmUocGFyYW1zLmtleSk7XG4gICAgaWYgKCFrZXkgfHwga2V5ID09PSB0cnVlKSB7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgfSBlbHNlIGlmKGR1c3QuaXNBcnJheShrZXkpKSB7XG4gICAgICB2YWx1ZSA9IGtleS5sZW5ndGg7XG4gICAgfSBlbHNlIGlmICghaXNOYU4ocGFyc2VGbG9hdChrZXkpKSAmJiBpc0Zpbml0ZShrZXkpKSB7XG4gICAgICB2YWx1ZSA9IGtleTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHZhbHVlID0gMDtcbiAgICAgIGZvcihrIGluIGtleSl7XG4gICAgICAgIGlmKGtleS5oYXNPd25Qcm9wZXJ0eShrKSl7XG4gICAgICAgICAgdmFsdWUrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IChrZXkgKyAnJykubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gY2h1bmsud3JpdGUodmFsdWUpO1xuICB9XG5cbn07XG5cbmZvcih2YXIga2V5IGluIGhlbHBlcnMpIHtcbiAgZHVzdC5oZWxwZXJzW2tleV0gPSBoZWxwZXJzW2tleV07XG59XG5cbnJldHVybiBkdXN0O1xuXG59KSk7XG4iLCIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCAmJiBkZWZpbmUuYW1kLmR1c3QgPT09IHRydWUpIHtcbiAgICBkZWZpbmUoJ2R1c3QuY29yZScsIFtdLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICByb290LmR1c3QgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG4gIHZhciBkdXN0ID0ge1xuICAgICAgICBcInZlcnNpb25cIjogXCIyLjcuNVwiXG4gICAgICB9LFxuICAgICAgTk9ORSA9ICdOT05FJywgRVJST1IgPSAnRVJST1InLCBXQVJOID0gJ1dBUk4nLCBJTkZPID0gJ0lORk8nLCBERUJVRyA9ICdERUJVRycsXG4gICAgICBFTVBUWV9GVU5DID0gZnVuY3Rpb24oKSB7fTtcblxuICBkdXN0LmNvbmZpZyA9IHtcbiAgICB3aGl0ZXNwYWNlOiBmYWxzZSxcbiAgICBhbWQ6IGZhbHNlLFxuICAgIGNqczogZmFsc2UsXG4gICAgY2FjaGU6IHRydWVcbiAgfTtcblxuICAvLyBEaXJlY3RpdmUgYWxpYXNlcyB0byBtaW5pZnkgY29kZVxuICBkdXN0Ll9hbGlhc2VzID0ge1xuICAgIFwid3JpdGVcIjogXCJ3XCIsXG4gICAgXCJlbmRcIjogXCJlXCIsXG4gICAgXCJtYXBcIjogXCJtXCIsXG4gICAgXCJyZW5kZXJcIjogXCJyXCIsXG4gICAgXCJyZWZlcmVuY2VcIjogXCJmXCIsXG4gICAgXCJzZWN0aW9uXCI6IFwic1wiLFxuICAgIFwiZXhpc3RzXCI6IFwieFwiLFxuICAgIFwibm90ZXhpc3RzXCI6IFwibnhcIixcbiAgICBcImJsb2NrXCI6IFwiYlwiLFxuICAgIFwicGFydGlhbFwiOiBcInBcIixcbiAgICBcImhlbHBlclwiOiBcImhcIlxuICB9O1xuXG4gIChmdW5jdGlvbiBpbml0TG9nZ2luZygpIHtcbiAgICAvKmdsb2JhbCBwcm9jZXNzLCBjb25zb2xlKi9cbiAgICB2YXIgbG9nZ2luZ0xldmVscyA9IHsgREVCVUc6IDAsIElORk86IDEsIFdBUk46IDIsIEVSUk9SOiAzLCBOT05FOiA0IH0sXG4gICAgICAgIGNvbnNvbGVMb2csXG4gICAgICAgIGxvZztcblxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS5sb2cpIHtcbiAgICAgIGNvbnNvbGVMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIGlmKHR5cGVvZiBjb25zb2xlTG9nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxvZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbnNvbGVMb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbnNvbGVMb2coQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykuam9pbignICcpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nID0gRU1QVFlfRlVOQztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXJzIG1lc3NhZ2VzIGJhc2VkIG9uIGBkdXN0LmRlYnVnTGV2ZWxgLlxuICAgICAqIFRoaXMgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aWxsIHByaW50IHRvIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xFcnJvcn0gbWVzc2FnZSB0aGUgbWVzc2FnZSB0byBwcmludC90aHJvd1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBzZXZlcml0eSBvZiB0aGUgbWVzc2FnZShFUlJPUiwgV0FSTiwgSU5GTywgb3IgREVCVUcpXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGR1c3QubG9nID0gZnVuY3Rpb24obWVzc2FnZSwgdHlwZSkge1xuICAgICAgdHlwZSA9IHR5cGUgfHwgSU5GTztcbiAgICAgIGlmIChsb2dnaW5nTGV2ZWxzW3R5cGVdID49IGxvZ2dpbmdMZXZlbHNbZHVzdC5kZWJ1Z0xldmVsXSkge1xuICAgICAgICBsb2coJ1tEVVNUOicgKyB0eXBlICsgJ10nLCBtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZHVzdC5kZWJ1Z0xldmVsID0gTk9ORTtcbiAgICBpZih0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgL1xcYmR1c3RcXGIvLnRlc3QocHJvY2Vzcy5lbnYuREVCVUcpKSB7XG4gICAgICBkdXN0LmRlYnVnTGV2ZWwgPSBERUJVRztcbiAgICB9XG5cbiAgfSgpKTtcblxuICBkdXN0LmhlbHBlcnMgPSB7fTtcblxuICBkdXN0LmNhY2hlID0ge307XG5cbiAgZHVzdC5yZWdpc3RlciA9IGZ1bmN0aW9uKG5hbWUsIHRtcGwpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdG1wbC50ZW1wbGF0ZU5hbWUgPSBuYW1lO1xuICAgIGlmIChkdXN0LmNvbmZpZy5jYWNoZSAhPT0gZmFsc2UpIHtcbiAgICAgIGR1c3QuY2FjaGVbbmFtZV0gPSB0bXBsO1xuICAgIH1cbiAgfTtcblxuICBkdXN0LnJlbmRlciA9IGZ1bmN0aW9uKG5hbWVPclRlbXBsYXRlLCBjb250ZXh0LCBjYWxsYmFjaykge1xuICAgIHZhciBjaHVuayA9IG5ldyBTdHViKGNhbGxiYWNrKS5oZWFkO1xuICAgIHRyeSB7XG4gICAgICBsb2FkKG5hbWVPclRlbXBsYXRlLCBjaHVuaywgY29udGV4dCkuZW5kKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjaHVuay5zZXRFcnJvcihlcnIpO1xuICAgIH1cbiAgfTtcblxuICBkdXN0LnN0cmVhbSA9IGZ1bmN0aW9uKG5hbWVPclRlbXBsYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJlYW0oKSxcbiAgICAgICAgY2h1bmsgPSBzdHJlYW0uaGVhZDtcbiAgICBkdXN0Lm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9hZChuYW1lT3JUZW1wbGF0ZSwgY2h1bmssIGNvbnRleHQpLmVuZCgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNodW5rLnNldEVycm9yKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfTtcblxuICAvKipcbiAgICogRXh0cmFjdHMgYSB0ZW1wbGF0ZSBmdW5jdGlvbiAoYm9keV8wKSBmcm9tIHdoYXRldmVyIGlzIHBhc3NlZC5cbiAgICogQHBhcmFtIG5hbWVPclRlbXBsYXRlIHsqfSBDb3VsZCBiZTpcbiAgICogICAtIHRoZSBuYW1lIG9mIGEgdGVtcGxhdGUgdG8gbG9hZCBmcm9tIGNhY2hlXG4gICAqICAgLSBhIENvbW1vbkpTLWNvbXBpbGVkIHRlbXBsYXRlIChhIGZ1bmN0aW9uIHdpdGggYSBgdGVtcGxhdGVgIHByb3BlcnR5KVxuICAgKiAgIC0gYSB0ZW1wbGF0ZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gbG9hZEZyb21DYWNoZSB7Qm9vbGVhbn0gaWYgZmFsc2UsIGRvbid0IGxvb2sgaW4gdGhlIGNhY2hlXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBhIHRlbXBsYXRlIGZ1bmN0aW9uLCBpZiBmb3VuZFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VGVtcGxhdGUobmFtZU9yVGVtcGxhdGUsIGxvYWRGcm9tQ2FjaGUvKj10cnVlKi8pIHtcbiAgICBpZighbmFtZU9yVGVtcGxhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYodHlwZW9mIG5hbWVPclRlbXBsYXRlID09PSAnZnVuY3Rpb24nICYmIG5hbWVPclRlbXBsYXRlLnRlbXBsYXRlKSB7XG4gICAgICAvLyBTdWdhciBhd2F5IENvbW1vbkpTIG1vZHVsZSB0ZW1wbGF0ZXNcbiAgICAgIHJldHVybiBuYW1lT3JUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICB9XG4gICAgaWYoZHVzdC5pc1RlbXBsYXRlRm4obmFtZU9yVGVtcGxhdGUpKSB7XG4gICAgICAvLyBUZW1wbGF0ZSBmdW5jdGlvbnMgcGFzc2VkIGRpcmVjdGx5XG4gICAgICByZXR1cm4gbmFtZU9yVGVtcGxhdGU7XG4gICAgfVxuICAgIGlmKGxvYWRGcm9tQ2FjaGUgIT09IGZhbHNlKSB7XG4gICAgICAvLyBUcnkgbG9hZGluZyBhIHRlbXBsYXRlIHdpdGggdGhpcyBuYW1lIGZyb20gY2FjaGVcbiAgICAgIHJldHVybiBkdXN0LmNhY2hlW25hbWVPclRlbXBsYXRlXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsb2FkKG5hbWVPclRlbXBsYXRlLCBjaHVuaywgY29udGV4dCkge1xuICAgIGlmKCFuYW1lT3JUZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuIGNodW5rLnNldEVycm9yKG5ldyBFcnJvcignTm8gdGVtcGxhdGUgb3IgdGVtcGxhdGUgbmFtZSBwcm92aWRlZCB0byByZW5kZXInKSk7XG4gICAgfVxuXG4gICAgdmFyIHRlbXBsYXRlID0gZ2V0VGVtcGxhdGUobmFtZU9yVGVtcGxhdGUsIGR1c3QuY29uZmlnLmNhY2hlKTtcblxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuIHRlbXBsYXRlKGNodW5rLCBDb250ZXh0LndyYXAoY29udGV4dCwgdGVtcGxhdGUudGVtcGxhdGVOYW1lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkdXN0Lm9uTG9hZCkge1xuICAgICAgICByZXR1cm4gY2h1bmsubWFwKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgLy8gQWxpYXMganVzdCBzbyBpdCdzIGVhc2llciB0byByZWFkIHRoYXQgdGhpcyB3b3VsZCBhbHdheXMgYmUgYSBuYW1lXG4gICAgICAgICAgdmFyIG5hbWUgPSBuYW1lT3JUZW1wbGF0ZTtcbiAgICAgICAgICAvLyBUaHJlZSBwb3NzaWJsZSBzY2VuYXJpb3MgZm9yIGEgc3VjY2Vzc2Z1bCBjYWxsYmFjazpcbiAgICAgICAgICAvLyAgIC0gYHJlcXVpcmUobmFtZU9yVGVtcGxhdGUpKGR1c3QpOyBjYigpYFxuICAgICAgICAgIC8vICAgLSBgc3JjID0gcmVhZEZpbGUoJ3NyYy5kdXN0Jyk7IGNiKG51bGwsIHNyYylgXG4gICAgICAgICAgLy8gICAtIGBjb21waWxlZFRlbXBsYXRlID0gcmVxdWlyZShuYW1lT3JUZW1wbGF0ZSkoZHVzdCk7IGNiKG51bGwsIGNvbXBpbGVkVGVtcGxhdGUpYFxuICAgICAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyLCBzcmNPclRlbXBsYXRlKSB7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGU7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjaHVuay5zZXRFcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJlZmVyIGEgdGVtcGxhdGUgdGhhdCBpcyBwYXNzZWQgdmlhIGNhbGxiYWNrIG92ZXIgdGhlIGNhY2hlZCB2ZXJzaW9uLlxuICAgICAgICAgICAgdGVtcGxhdGUgPSBnZXRUZW1wbGF0ZShzcmNPclRlbXBsYXRlLCBmYWxzZSkgfHwgZ2V0VGVtcGxhdGUobmFtZSwgZHVzdC5jb25maWcuY2FjaGUpO1xuICAgICAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAvLyBJdCdzIGEgdGVtcGxhdGUgc3RyaW5nLCBjb21waWxlIGl0IGFuZCByZWdpc3RlciB1bmRlciBgbmFtZWBcbiAgICAgICAgICAgICAgaWYoZHVzdC5jb21waWxlKSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUgPSBkdXN0LmxvYWRTb3VyY2UoZHVzdC5jb21waWxlKHNyY09yVGVtcGxhdGUsIG5hbWUpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2h1bmsuc2V0RXJyb3IobmV3IEVycm9yKCdEdXN0IGNvbXBpbGVyIG5vdCBhdmFpbGFibGUnKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBsYXRlKGNodW5rLCBDb250ZXh0LndyYXAoY29udGV4dCwgdGVtcGxhdGUudGVtcGxhdGVOYW1lKSkuZW5kKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoZHVzdC5vbkxvYWQubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICBkdXN0Lm9uTG9hZChuYW1lLCBjb250ZXh0Lm9wdGlvbnMsIGRvbmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkdXN0Lm9uTG9hZChuYW1lLCBkb25lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNodW5rLnNldEVycm9yKG5ldyBFcnJvcignVGVtcGxhdGUgTm90IEZvdW5kOiAnICsgbmFtZU9yVGVtcGxhdGUpKTtcbiAgICB9XG4gIH1cblxuICBkdXN0LmxvYWRTb3VyY2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAvKmpzaGludCBldmlsOnRydWUqL1xuICAgIHJldHVybiBldmFsKHNvdXJjZSk7XG4gIH07XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICBkdXN0LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICB9IGVsc2Uge1xuICAgIGR1c3QuaXNBcnJheSA9IGZ1bmN0aW9uKGFycikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG4gIH1cblxuICBkdXN0Lm5leHRUaWNrID0gKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogRHVzdCBoYXMgaXRzIG93biBydWxlcyBmb3Igd2hhdCBpcyBcImVtcHR5XCItLSB3aGljaCBpcyBub3QgdGhlIHNhbWUgYXMgZmFsc3kuXG4gICAqIEVtcHR5IGFycmF5cywgbnVsbCwgYW5kIHVuZGVmaW5lZCBhcmUgZW1wdHlcbiAgICovXG4gIGR1c3QuaXNFbXB0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkdXN0LmlzQXJyYXkodmFsdWUpICYmICF2YWx1ZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gIXZhbHVlO1xuICB9O1xuXG4gIGR1c3QuaXNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXk7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9iai5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBkdXN0LmlzVGVtcGxhdGVGbiA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICByZXR1cm4gdHlwZW9mIGVsZW0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgZWxlbS5fX2R1c3RCb2R5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNpZGUgc29tZXdoYXQtbmFpdmVseSBpZiBzb21ldGhpbmcgaXMgYSBUaGVuYWJsZS5cbiAgICogQHBhcmFtIGVsZW0geyp9IG9iamVjdCB0byBpbnNwZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzIGBlbGVtYCBhIFRoZW5hYmxlP1xuICAgKi9cbiAgZHVzdC5pc1RoZW5hYmxlID0gZnVuY3Rpb24oZWxlbSkge1xuICAgIHJldHVybiBlbGVtICYmXG4gICAgICAgICAgIHR5cGVvZiBlbGVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICB0eXBlb2YgZWxlbS50aGVuID09PSAnZnVuY3Rpb24nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNpZGUgdmVyeSBuYWl2ZWx5IGlmIHNvbWV0aGluZyBpcyBhIFN0cmVhbS5cbiAgICogQHBhcmFtIGVsZW0geyp9IG9iamVjdCB0byBpbnNwZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzIGBlbGVtYCBhIFN0cmVhbT9cbiAgICovXG4gIGR1c3QuaXNTdHJlYW1hYmxlID0gZnVuY3Rpb24oZWxlbSkge1xuICAgIHJldHVybiBlbGVtICYmXG4gICAgICAgICAgIHR5cGVvZiBlbGVtLm9uID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgIHR5cGVvZiBlbGVtLnBpcGUgPT09ICdmdW5jdGlvbic7XG4gIH07XG5cbiAgLy8gYXBwbHkgdGhlIGZpbHRlciBjaGFpbiBhbmQgcmV0dXJuIHRoZSBvdXRwdXQgc3RyaW5nXG4gIGR1c3QuZmlsdGVyID0gZnVuY3Rpb24oc3RyaW5nLCBhdXRvLCBmaWx0ZXJzLCBjb250ZXh0KSB7XG4gICAgdmFyIGksIGxlbiwgbmFtZSwgZmlsdGVyO1xuICAgIGlmIChmaWx0ZXJzKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBmaWx0ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBmaWx0ZXJzW2ldO1xuICAgICAgICBpZiAoIW5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZmlsdGVyID0gZHVzdC5maWx0ZXJzW25hbWVdO1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3MnKSB7XG4gICAgICAgICAgYXV0byA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHN0cmluZyA9IGZpbHRlcihzdHJpbmcsIGNvbnRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGR1c3QubG9nKCdJbnZhbGlkIGZpbHRlciBgJyArIG5hbWUgKyAnYCcsIFdBUk4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGJ5IGRlZmF1bHQgYWx3YXlzIGFwcGx5IHRoZSBoIGZpbHRlciwgdW5sZXNzIGFza2VkIHRvIHVuZXNjYXBlIHdpdGggfHNcbiAgICBpZiAoYXV0bykge1xuICAgICAgc3RyaW5nID0gZHVzdC5maWx0ZXJzW2F1dG9dKHN0cmluZywgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmc7XG4gIH07XG5cbiAgZHVzdC5maWx0ZXJzID0ge1xuICAgIGg6IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBkdXN0LmVzY2FwZUh0bWwodmFsdWUpOyB9LFxuICAgIGo6IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBkdXN0LmVzY2FwZUpzKHZhbHVlKTsgfSxcbiAgICB1OiBlbmNvZGVVUkksXG4gICAgdWM6IGVuY29kZVVSSUNvbXBvbmVudCxcbiAgICBqczogZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIGR1c3QuZXNjYXBlSlNPTih2YWx1ZSk7IH0sXG4gICAganA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoIUpTT04pIHtkdXN0LmxvZygnSlNPTiBpcyB1bmRlZmluZWQ7IGNvdWxkIG5vdCBwYXJzZSBgJyArIHZhbHVlICsgJ2AnLCBXQVJOKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBDb250ZXh0KHN0YWNrLCBnbG9iYWwsIG9wdGlvbnMsIGJsb2NrcywgdGVtcGxhdGVOYW1lKSB7XG4gICAgaWYoc3RhY2sgIT09IHVuZGVmaW5lZCAmJiAhKHN0YWNrIGluc3RhbmNlb2YgU3RhY2spKSB7XG4gICAgICBzdGFjayA9IG5ldyBTdGFjayhzdGFjayk7XG4gICAgfVxuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLmdsb2JhbCA9IGdsb2JhbDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuYmxvY2tzID0gYmxvY2tzO1xuICAgIHRoaXMudGVtcGxhdGVOYW1lID0gdGVtcGxhdGVOYW1lO1xuICAgIHRoaXMuX2lzQ29udGV4dCA9IHRydWU7XG4gIH1cblxuICBkdXN0Lm1ha2VCYXNlID0gZHVzdC5jb250ZXh0ID0gZnVuY3Rpb24oZ2xvYmFsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZXh0KHVuZGVmaW5lZCwgZ2xvYmFsLCBvcHRpb25zKTtcbiAgfTtcblxuICBkdXN0LmlzQ29udGV4dCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIG9iai5faXNDb250ZXh0ID09PSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGYWN0b3J5IGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIGNsb3N1cmUgc2NvcGUgYXJvdW5kIGEgVGhlbmFibGUtY2FsbGJhY2suXG4gICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gYSBUaGVuYWJsZSB0aGF0IHdpbGwgcmVzdW1lIGFcbiAgICogQ29udGV4dCBsb29rdXAgb25jZSB0aGUgVGhlbmFibGUgcmVzb2x2ZXMgd2l0aCBuZXcgZGF0YSwgYWRkaW5nIHRoYXQgbmV3XG4gICAqIGRhdGEgdG8gdGhlIGxvb2t1cCBzdGFjay5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFdpdGhSZXNvbHZlZERhdGEoY3R4LCBjdXIsIGRvd24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGN0eC5wdXNoKGRhdGEpLl9nZXQoY3VyLCBkb3duKTtcbiAgICB9O1xuICB9XG5cbiAgQ29udGV4dC53cmFwID0gZnVuY3Rpb24oY29udGV4dCwgbmFtZSkge1xuICAgIGlmIChkdXN0LmlzQ29udGV4dChjb250ZXh0KSkge1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29udGV4dChjb250ZXh0LCB7fSwge30sIG51bGwsIG5hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdWJsaWMgQVBJIGZvciBnZXR0aW5nIGEgdmFsdWUgZnJvbSB0aGUgY29udGV4dC5cbiAgICogQG1ldGhvZCBnZXRcbiAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHBhdGggVGhlIHBhdGggdG8gdGhlIHZhbHVlLiBTdXBwb3J0ZWQgZm9ybWF0cyBhcmU6XG4gICAqICdrZXknXG4gICAqICdwYXRoLnRvLmtleSdcbiAgICogJy5wYXRoLnRvLmtleSdcbiAgICogWydwYXRoJywgJ3RvJywgJ2tleSddXG4gICAqIFsna2V5J11cbiAgICogQHBhcmFtIHtib29sZWFufSBbY3VyPWZhbHNlXSBCb29sZWFuIHdoaWNoIGRldGVybWluZXMgaWYgdGhlIHNlYXJjaCBzaG91bGQgYmUgbGltaXRlZCB0byB0aGVcbiAgICogY3VycmVudCBjb250ZXh0ICh0cnVlKSwgb3IgaWYgZ2V0IHNob3VsZCBzZWFyY2ggaW4gcGFyZW50IGNvbnRleHRzIGFzIHdlbGwgKGZhbHNlKS5cbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfG9iamVjdH1cbiAgICovXG4gIENvbnRleHQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHBhdGgsIGN1cikge1xuICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChwYXRoWzBdID09PSAnLicpIHtcbiAgICAgICAgY3VyID0gdHJ1ZTtcbiAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDEpO1xuICAgICAgfVxuICAgICAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dldChjdXIsIHBhdGgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSB2YWx1ZSBmcm9tIHRoZSBjb250ZXh0XG4gICAqIEBtZXRob2QgX2dldFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGN1ciBHZXQgb25seSBmcm9tIHRoZSBjdXJyZW50IGNvbnRleHRcbiAgICogQHBhcmFtIHthcnJheX0gZG93biBBbiBhcnJheSBvZiBlYWNoIHN0ZXAgaW4gdGhlIHBhdGhcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7c3RyaW5nIHwgb2JqZWN0fVxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUuX2dldCA9IGZ1bmN0aW9uKGN1ciwgZG93bikge1xuICAgIHZhciBjdHggPSB0aGlzLnN0YWNrIHx8IHt9LFxuICAgICAgICBpID0gMSxcbiAgICAgICAgdmFsdWUsIGZpcnN0LCBsZW4sIGN0eFRoaXMsIGZuO1xuXG4gICAgZmlyc3QgPSBkb3duWzBdO1xuICAgIGxlbiA9IGRvd24ubGVuZ3RoO1xuXG4gICAgaWYgKGN1ciAmJiBsZW4gPT09IDApIHtcbiAgICAgIGN0eFRoaXMgPSBjdHg7XG4gICAgICBjdHggPSBjdHguaGVhZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjdXIpIHtcbiAgICAgICAgLy8gU2VhcmNoIHVwIHRoZSBzdGFjayBmb3IgdGhlIGZpcnN0IHZhbHVlXG4gICAgICAgIHdoaWxlIChjdHgpIHtcbiAgICAgICAgICBpZiAoY3R4LmlzT2JqZWN0KSB7XG4gICAgICAgICAgICBjdHhUaGlzID0gY3R4LmhlYWQ7XG4gICAgICAgICAgICB2YWx1ZSA9IGN0eC5oZWFkW2ZpcnN0XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdHggPSBjdHgudGFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyeSBsb29raW5nIGluIHRoZSBnbG9iYWwgY29udGV4dCBpZiB3ZSBoYXZlbid0IGZvdW5kIGFueXRoaW5nIHlldFxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGN0eCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eCA9IHRoaXMuZ2xvYmFsICYmIHRoaXMuZ2xvYmFsW2ZpcnN0XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdHgpIHtcbiAgICAgICAgLy8gaWYgc2NvcGUgaXMgbGltaXRlZCBieSBhIGxlYWRpbmcgZG90LCBkb24ndCBzZWFyY2ggdXAgdGhlIHRyZWVcbiAgICAgICAgaWYoY3R4LmhlYWQpIHtcbiAgICAgICAgICBjdHggPSBjdHguaGVhZFtmaXJzdF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29udGV4dCdzIGhlYWQgaXMgZW1wdHksIHZhbHVlIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGlzIG5vdCBkZWZpbmVkXG4gICAgICAgICAgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjdHggJiYgaSA8IGxlbikge1xuICAgICAgICBpZiAoZHVzdC5pc1RoZW5hYmxlKGN0eCkpIHtcbiAgICAgICAgICAvLyBCYWlsIGVhcmx5IGJ5IHJldHVybmluZyBhIFRoZW5hYmxlIGZvciB0aGUgcmVtYWluZGVyIG9mIHRoZSBzZWFyY2ggdHJlZVxuICAgICAgICAgIHJldHVybiBjdHgudGhlbihnZXRXaXRoUmVzb2x2ZWREYXRhKHRoaXMsIGN1ciwgZG93bi5zbGljZShpKSkpO1xuICAgICAgICB9XG4gICAgICAgIGN0eFRoaXMgPSBjdHg7XG4gICAgICAgIGN0eCA9IGN0eFtkb3duW2ldXTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY3R4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBjdHguYXBwbHkoY3R4VGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZHVzdC5sb2coZXJyLCBFUlJPUik7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZm4uX19kdXN0Qm9keSA9ICEhY3R4Ll9fZHVzdEJvZHk7XG4gICAgICByZXR1cm4gZm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkdXN0LmxvZygnQ2Fubm90IGZpbmQgcmVmZXJlbmNlIGB7JyArIGRvd24uam9pbignLicpICsgJ31gIGluIHRlbXBsYXRlIGAnICsgdGhpcy5nZXRUZW1wbGF0ZU5hbWUoKSArICdgJywgSU5GTyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4O1xuICAgIH1cbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24oY3VyLCBkb3duKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChjdXIsIGRvd24pO1xuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihoZWFkLCBpZHgsIGxlbikge1xuICAgIGlmKGhlYWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZHVzdC5sb2coXCJOb3QgcHVzaGluZyBhbiB1bmRlZmluZWQgdmFyaWFibGUgb250byB0aGUgY29udGV4dFwiLCBJTkZPKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZWJhc2UobmV3IFN0YWNrKGhlYWQsIHRoaXMuc3RhY2ssIGlkeCwgbGVuKSk7XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLmN1cnJlbnQoKTtcbiAgICB0aGlzLnN0YWNrID0gdGhpcy5zdGFjayAmJiB0aGlzLnN0YWNrLnRhaWw7XG4gICAgcmV0dXJuIGhlYWQ7XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUucmViYXNlID0gZnVuY3Rpb24oaGVhZCkge1xuICAgIHJldHVybiBuZXcgQ29udGV4dChoZWFkLCB0aGlzLmdsb2JhbCwgdGhpcy5vcHRpb25zLCB0aGlzLmJsb2NrcywgdGhpcy5nZXRUZW1wbGF0ZU5hbWUoKSk7XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMucmViYXNlKCk7XG4gICAgY29udGV4dC5zdGFjayA9IHRoaXMuc3RhY2s7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0YWNrICYmIHRoaXMuc3RhY2suaGVhZDtcbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5nZXRCbG9jayA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBibG9ja3MsIGxlbiwgZm47XG5cbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAga2V5ID0ga2V5KG5ldyBDaHVuaygpLCB0aGlzKS5kYXRhLmpvaW4oJycpO1xuICAgIH1cblxuICAgIGJsb2NrcyA9IHRoaXMuYmxvY2tzO1xuXG4gICAgaWYgKCFibG9ja3MpIHtcbiAgICAgIGR1c3QubG9nKCdObyBibG9ja3MgZm9yIGNvbnRleHQgYCcgKyBrZXkgKyAnYCBpbiB0ZW1wbGF0ZSBgJyArIHRoaXMuZ2V0VGVtcGxhdGVOYW1lKCkgKyAnYCcsIERFQlVHKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZW4gPSBibG9ja3MubGVuZ3RoO1xuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgZm4gPSBibG9ja3NbbGVuXVtrZXldO1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkdXN0LmxvZygnTWFsZm9ybWVkIHRlbXBsYXRlIGAnICsgdGhpcy5nZXRUZW1wbGF0ZU5hbWUoKSArICdgIHdhcyBtaXNzaW5nIG9uZSBvciBtb3JlIGJsb2Nrcy4nKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUuc2hpZnRCbG9ja3MgPSBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsXG4gICAgICAgIG5ld0Jsb2NrcztcblxuICAgIGlmIChsb2NhbHMpIHtcbiAgICAgIGlmICghYmxvY2tzKSB7XG4gICAgICAgIG5ld0Jsb2NrcyA9IFtsb2NhbHNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3QmxvY2tzID0gYmxvY2tzLmNvbmNhdChbbG9jYWxzXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENvbnRleHQodGhpcy5zdGFjaywgdGhpcy5nbG9iYWwsIHRoaXMub3B0aW9ucywgbmV3QmxvY2tzLCB0aGlzLmdldFRlbXBsYXRlTmFtZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICB2YXIgY2h1bms7XG5cbiAgICBpZih0eXBlb2YgYm9keSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfVxuICAgIGNodW5rID0gbmV3IENodW5rKCkucmVuZGVyKGJvZHksIHRoaXMpO1xuICAgIGlmKGNodW5rIGluc3RhbmNlb2YgQ2h1bmspIHtcbiAgICAgIHJldHVybiBjaHVuay5kYXRhLmpvaW4oJycpOyAvLyBpZTcgcGVyZlxuICAgIH1cbiAgICByZXR1cm4gY2h1bms7XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUuZ2V0VGVtcGxhdGVOYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGVtcGxhdGVOYW1lO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFN0YWNrKGhlYWQsIHRhaWwsIGlkeCwgbGVuKSB7XG4gICAgdGhpcy50YWlsID0gdGFpbDtcbiAgICB0aGlzLmlzT2JqZWN0ID0gaGVhZCAmJiB0eXBlb2YgaGVhZCA9PT0gJ29iamVjdCc7XG4gICAgdGhpcy5oZWFkID0gaGVhZDtcbiAgICB0aGlzLmluZGV4ID0gaWR4O1xuICAgIHRoaXMub2YgPSBsZW47XG4gIH1cblxuICBmdW5jdGlvbiBTdHViKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5oZWFkID0gbmV3IENodW5rKHRoaXMpO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLm91dCA9ICcnO1xuICB9XG5cbiAgU3R1Yi5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2h1bmsgPSB0aGlzLmhlYWQ7XG5cbiAgICB3aGlsZSAoY2h1bmspIHtcbiAgICAgIGlmIChjaHVuay5mbHVzaGFibGUpIHtcbiAgICAgICAgdGhpcy5vdXQgKz0gY2h1bmsuZGF0YS5qb2luKCcnKTsgLy9pZTcgcGVyZlxuICAgICAgfSBlbHNlIGlmIChjaHVuay5lcnJvcikge1xuICAgICAgICB0aGlzLmNhbGxiYWNrKGNodW5rLmVycm9yKTtcbiAgICAgICAgZHVzdC5sb2coJ1JlbmRlcmluZyBmYWlsZWQgd2l0aCBlcnJvciBgJyArIGNodW5rLmVycm9yICsgJ2AnLCBFUlJPUik7XG4gICAgICAgIHRoaXMuZmx1c2ggPSBFTVBUWV9GVU5DO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjaHVuayA9IGNodW5rLm5leHQ7XG4gICAgICB0aGlzLmhlYWQgPSBjaHVuaztcbiAgICB9XG4gICAgdGhpcy5jYWxsYmFjayhudWxsLCB0aGlzLm91dCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW50ZXJmYWNlIHNvcnQgb2YgbGlrZSBhIFN0cmVhbXMyIFJlYWRhYmxlU3RyZWFtLlxuICAgKi9cbiAgZnVuY3Rpb24gU3RyZWFtKCkge1xuICAgIHRoaXMuaGVhZCA9IG5ldyBDaHVuayh0aGlzKTtcbiAgfVxuXG4gIFN0cmVhbS5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2h1bmsgPSB0aGlzLmhlYWQ7XG5cbiAgICB3aGlsZShjaHVuaykge1xuICAgICAgaWYgKGNodW5rLmZsdXNoYWJsZSkge1xuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBjaHVuay5kYXRhLmpvaW4oJycpKTsgLy9pZTcgcGVyZlxuICAgICAgfSBlbHNlIGlmIChjaHVuay5lcnJvcikge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgY2h1bmsuZXJyb3IpO1xuICAgICAgICB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgICAgICBkdXN0LmxvZygnU3RyZWFtaW5nIGZhaWxlZCB3aXRoIGVycm9yIGAnICsgY2h1bmsuZXJyb3IgKyAnYCcsIEVSUk9SKTtcbiAgICAgICAgdGhpcy5mbHVzaCA9IEVNUFRZX0ZVTkM7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNodW5rID0gY2h1bmsubmV4dDtcbiAgICAgIHRoaXMuaGVhZCA9IGNodW5rO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2VuZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBsaXN0ZW5lcnMgZm9yIGB0eXBlYCBieSBwYXNzaW5nIGRhdGEuIE5vdGUgdGhhdCB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIGFcbiAgICogTm9kZSBzdHJlYW0sIHdoaWNoIGNhbiBwYXNzIGFuIGFyYml0cmFyeSBudW1iZXIgb2YgYXJndW1lbnRzXG4gICAqIEByZXR1cm4gYHRydWVgIGlmIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gICAqL1xuICBTdHJlYW0ucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzIHx8IHt9LFxuICAgICAgICBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSB8fCBbXSxcbiAgICAgICAgaSwgbDtcblxuICAgIGlmICghaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICBkdXN0LmxvZygnU3RyZWFtIGJyb2FkY2FzdGluZywgYnV0IG5vIGxpc3RlbmVycyBmb3IgYCcgKyB0eXBlICsgJ2AnLCBERUJVRyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaGFuZGxlcnMgPSBoYW5kbGVycy5zbGljZSgwKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBoYW5kbGVyc1tpXShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgU3RyZWFtLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzID0gdGhpcy5ldmVudHMgfHwge30sXG4gICAgICAgIGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdID0gZXZlbnRzW3R5cGVdIHx8IFtdO1xuXG4gICAgaWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkdXN0LmxvZygnTm8gY2FsbGJhY2sgZnVuY3Rpb24gcHJvdmlkZWQgZm9yIGAnICsgdHlwZSArICdgIGV2ZW50IGxpc3RlbmVyJywgV0FSTik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXJzLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUGlwZXMgdG8gYSBXcml0YWJsZVN0cmVhbS4gTm90ZSB0aGF0IGJhY2twcmVzc3VyZSBpc24ndCBpbXBsZW1lbnRlZCxcbiAgICogc28gd2UganVzdCB3cml0ZSBhcyBmYXN0IGFzIHdlIGNhbi5cbiAgICogQHBhcmFtIHN0cmVhbSB7V3JpdGFibGVTdHJlYW19XG4gICAqIEByZXR1cm4gc2VsZlxuICAgKi9cbiAgU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgaWYodHlwZW9mIHN0cmVhbS53cml0ZSAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgIHR5cGVvZiBzdHJlYW0uZW5kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkdXN0LmxvZygnSW5jb21wYXRpYmxlIHN0cmVhbSBwYXNzZWQgdG8gYHBpcGVgJywgV0FSTik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgZGVzdEVuZGVkID0gZmFsc2U7XG5cbiAgICBpZih0eXBlb2Ygc3RyZWFtLmVtaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdwaXBlJywgdGhpcyk7XG4gICAgfVxuXG4gICAgaWYodHlwZW9mIHN0cmVhbS5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkZXN0RW5kZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgICAub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBpZihkZXN0RW5kZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgc3RyZWFtLndyaXRlKGRhdGEsICd1dGY4Jyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZHVzdC5sb2coZXJyLCBFUlJPUik7XG4gICAgICB9XG4gICAgfSlcbiAgICAub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYoZGVzdEVuZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHN0cmVhbS5lbmQoKTtcbiAgICAgICAgZGVzdEVuZGVkID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBkdXN0LmxvZyhlcnIsIEVSUk9SKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBDaHVuayhyb290LCBuZXh0LCB0YXBzKSB7XG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIHRoaXMuZGF0YSA9IFtdOyAvL2llNyBwZXJmXG4gICAgdGhpcy5mbHVzaGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLnRhcHMgPSB0YXBzO1xuICB9XG5cbiAgQ2h1bmsucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciB0YXBzID0gdGhpcy50YXBzO1xuXG4gICAgaWYgKHRhcHMpIHtcbiAgICAgIGRhdGEgPSB0YXBzLmdvKGRhdGEpO1xuICAgIH1cbiAgICB0aGlzLmRhdGEucHVzaChkYXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBDaHVuay5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLndyaXRlKGRhdGEpO1xuICAgIH1cbiAgICB0aGlzLmZsdXNoYWJsZSA9IHRydWU7XG4gICAgdGhpcy5yb290LmZsdXNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIGN1cnNvciA9IG5ldyBDaHVuayh0aGlzLnJvb3QsIHRoaXMubmV4dCwgdGhpcy50YXBzKSxcbiAgICAgICAgYnJhbmNoID0gbmV3IENodW5rKHRoaXMucm9vdCwgY3Vyc29yLCB0aGlzLnRhcHMpO1xuXG4gICAgdGhpcy5uZXh0ID0gYnJhbmNoO1xuICAgIHRoaXMuZmx1c2hhYmxlID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2soYnJhbmNoKTtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgZHVzdC5sb2coZXJyLCBFUlJPUik7XG4gICAgICBicmFuY2guc2V0RXJyb3IoZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnNvcjtcbiAgfTtcblxuICBDaHVuay5wcm90b3R5cGUudGFwID0gZnVuY3Rpb24odGFwKSB7XG4gICAgdmFyIHRhcHMgPSB0aGlzLnRhcHM7XG5cbiAgICBpZiAodGFwcykge1xuICAgICAgdGhpcy50YXBzID0gdGFwcy5wdXNoKHRhcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFwcyA9IG5ldyBUYXAodGFwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLnVudGFwID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50YXBzID0gdGhpcy50YXBzLnRhaWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKGJvZHksIGNvbnRleHQpIHtcbiAgICByZXR1cm4gYm9keSh0aGlzLCBjb250ZXh0KTtcbiAgfTtcblxuICBDaHVuay5wcm90b3R5cGUucmVmZXJlbmNlID0gZnVuY3Rpb24oZWxlbSwgY29udGV4dCwgYXV0bywgZmlsdGVycykge1xuICAgIGlmICh0eXBlb2YgZWxlbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZWxlbSA9IGVsZW0uYXBwbHkoY29udGV4dC5jdXJyZW50KCksIFt0aGlzLCBjb250ZXh0LCBudWxsLCB7YXV0bzogYXV0bywgZmlsdGVyczogZmlsdGVyc31dKTtcbiAgICAgIGlmIChlbGVtIGluc3RhbmNlb2YgQ2h1bmspIHtcbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2UoZWxlbSwgY29udGV4dCwgYXV0bywgZmlsdGVycyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkdXN0LmlzVGhlbmFibGUoZWxlbSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmF3YWl0KGVsZW0sIGNvbnRleHQsIG51bGwsIGF1dG8sIGZpbHRlcnMpO1xuICAgIH0gZWxzZSBpZiAoZHVzdC5pc1N0cmVhbWFibGUoZWxlbSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbShlbGVtLCBjb250ZXh0LCBudWxsLCBhdXRvLCBmaWx0ZXJzKTtcbiAgICB9IGVsc2UgaWYgKCFkdXN0LmlzRW1wdHkoZWxlbSkpIHtcbiAgICAgIHJldHVybiB0aGlzLndyaXRlKGR1c3QuZmlsdGVyKGVsZW0sIGF1dG8sIGZpbHRlcnMsIGNvbnRleHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS5zZWN0aW9uID0gZnVuY3Rpb24oZWxlbSwgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpIHtcbiAgICB2YXIgYm9keSA9IGJvZGllcy5ibG9jayxcbiAgICAgICAgc2tpcCA9IGJvZGllc1snZWxzZSddLFxuICAgICAgICBjaHVuayA9IHRoaXMsXG4gICAgICAgIGksIGxlbiwgaGVhZDtcblxuICAgIGlmICh0eXBlb2YgZWxlbSA9PT0gJ2Z1bmN0aW9uJyAmJiAhZHVzdC5pc1RlbXBsYXRlRm4oZWxlbSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVsZW0gPSBlbGVtLmFwcGx5KGNvbnRleHQuY3VycmVudCgpLCBbdGhpcywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXNdKTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGR1c3QubG9nKGVyciwgRVJST1IpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRFcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgLy8gRnVuY3Rpb25zIHRoYXQgcmV0dXJuIGNodW5rcyBhcmUgYXNzdW1lZCB0byBoYXZlIGhhbmRsZWQgdGhlIGNodW5rIG1hbnVhbGx5LlxuICAgICAgLy8gTWFrZSB0aGF0IGNodW5rIHRoZSBjdXJyZW50IG9uZSBhbmQgZ28gdG8gdGhlIG5leHQgbWV0aG9kIGluIHRoZSBjaGFpbi5cbiAgICAgIGlmIChlbGVtIGluc3RhbmNlb2YgQ2h1bmspIHtcbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGR1c3QuaXNFbXB0eU9iamVjdChib2RpZXMpKSB7XG4gICAgICAvLyBObyBib2RpZXMgdG8gcmVuZGVyLCBhbmQgd2UndmUgYWxyZWFkeSBpbnZva2VkIGFueSBmdW5jdGlvbiB0aGF0IHdhcyBhdmFpbGFibGUgaW5cbiAgICAgIC8vIGhvcGVzIG9mIHJldHVybmluZyBhIENodW5rLlxuICAgICAgcmV0dXJuIGNodW5rO1xuICAgIH1cblxuICAgIGlmICghZHVzdC5pc0VtcHR5T2JqZWN0KHBhcmFtcykpIHtcbiAgICAgIGNvbnRleHQgPSBjb250ZXh0LnB1c2gocGFyYW1zKTtcbiAgICB9XG5cbiAgICAvKlxuICAgIER1c3QncyBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGVudW1lcmF0ZSBvdmVyIHRoZSBhcnJheSBlbGVtLCBwYXNzaW5nIGVhY2ggb2JqZWN0IGluIHRoZSBhcnJheSB0byB0aGUgYmxvY2suXG4gICAgV2hlbiBlbGVtIHJlc29sdmVzIHRvIGEgdmFsdWUgb3Igb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXksIER1c3Qgc2V0cyB0aGUgY3VycmVudCBjb250ZXh0IHRvIHRoZSB2YWx1ZVxuICAgIGFuZCByZW5kZXJzIHRoZSBibG9jayBvbmUgdGltZS5cbiAgICAqL1xuICAgIGlmIChkdXN0LmlzQXJyYXkoZWxlbSkpIHtcbiAgICAgIGlmIChib2R5KSB7XG4gICAgICAgIGxlbiA9IGVsZW0ubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgIGhlYWQgPSBjb250ZXh0LnN0YWNrICYmIGNvbnRleHQuc3RhY2suaGVhZCB8fCB7fTtcbiAgICAgICAgICBoZWFkLiRsZW4gPSBsZW47XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBoZWFkLiRpZHggPSBpO1xuICAgICAgICAgICAgY2h1bmsgPSBib2R5KGNodW5rLCBjb250ZXh0LnB1c2goZWxlbVtpXSwgaSwgbGVuKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhlYWQuJGlkeCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBoZWFkLiRsZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmV0dXJuIGNodW5rO1xuICAgICAgICB9IGVsc2UgaWYgKHNraXApIHtcbiAgICAgICAgICByZXR1cm4gc2tpcCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZHVzdC5pc1RoZW5hYmxlKGVsZW0pKSB7XG4gICAgICByZXR1cm4gdGhpcy5hd2FpdChlbGVtLCBjb250ZXh0LCBib2RpZXMpO1xuICAgIH0gZWxzZSBpZiAoZHVzdC5pc1N0cmVhbWFibGUoZWxlbSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbShlbGVtLCBjb250ZXh0LCBib2RpZXMpO1xuICAgIH0gZWxzZSBpZiAoZWxlbSA9PT0gdHJ1ZSkge1xuICAgICAvLyB0cnVlIGlzIHRydXRoeSBidXQgZG9lcyBub3QgY2hhbmdlIGNvbnRleHRcbiAgICAgIGlmIChib2R5KSB7XG4gICAgICAgIHJldHVybiBib2R5KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxlbSB8fCBlbGVtID09PSAwKSB7XG4gICAgICAgLy8gZXZlcnl0aGluZyB0aGF0IGV2YWx1YXRlcyB0byB0cnVlIGFyZSB0cnV0aHkgKCBlLmcuIE5vbi1lbXB0eSBzdHJpbmdzIGFuZCBFbXB0eSBvYmplY3RzIGFyZSB0cnV0aHkuIClcbiAgICAgICAvLyB6ZXJvIGlzIHRydXRoeVxuICAgICAgIC8vIGZvciBhbm9ueW1vdXMgZnVuY3Rpb25zIHRoYXQgZGlkIG5vdCByZXR1cm5zIGEgY2h1bmssIHRydXRoaW5lc3MgaXMgZXZhbHVhdGVkIGJhc2VkIG9uIHRoZSByZXR1cm4gdmFsdWVcbiAgICAgIGlmIChib2R5KSB7XG4gICAgICAgIHJldHVybiBib2R5KHRoaXMsIGNvbnRleHQucHVzaChlbGVtKSk7XG4gICAgICB9XG4gICAgIC8vIG5vbmV4aXN0ZW50LCBzY2FsYXIgZmFsc2UgdmFsdWUsIHNjYWxhciBlbXB0eSBzdHJpbmcsIG51bGwsXG4gICAgIC8vIHVuZGVmaW5lZCBhcmUgYWxsIGZhbHN5XG4gICAgfSBlbHNlIGlmIChza2lwKSB7XG4gICAgICByZXR1cm4gc2tpcCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZHVzdC5sb2coJ1NlY3Rpb24gd2l0aG91dCBjb3JyZXNwb25kaW5nIGtleSBpbiB0ZW1wbGF0ZSBgJyArIGNvbnRleHQuZ2V0VGVtcGxhdGVOYW1lKCkgKyAnYCcsIERFQlVHKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBDaHVuay5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24oZWxlbSwgY29udGV4dCwgYm9kaWVzKSB7XG4gICAgdmFyIGJvZHkgPSBib2RpZXMuYmxvY2ssXG4gICAgICAgIHNraXAgPSBib2RpZXNbJ2Vsc2UnXTtcblxuICAgIGlmICghZHVzdC5pc0VtcHR5KGVsZW0pKSB7XG4gICAgICBpZiAoYm9keSkge1xuICAgICAgICByZXR1cm4gYm9keSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGR1c3QubG9nKCdObyBibG9jayBmb3IgZXhpc3RzIGNoZWNrIGluIHRlbXBsYXRlIGAnICsgY29udGV4dC5nZXRUZW1wbGF0ZU5hbWUoKSArICdgJywgREVCVUcpO1xuICAgIH0gZWxzZSBpZiAoc2tpcCkge1xuICAgICAgcmV0dXJuIHNraXAodGhpcywgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS5ub3RleGlzdHMgPSBmdW5jdGlvbihlbGVtLCBjb250ZXh0LCBib2RpZXMpIHtcbiAgICB2YXIgYm9keSA9IGJvZGllcy5ibG9jayxcbiAgICAgICAgc2tpcCA9IGJvZGllc1snZWxzZSddO1xuXG4gICAgaWYgKGR1c3QuaXNFbXB0eShlbGVtKSkge1xuICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgcmV0dXJuIGJvZHkodGhpcywgY29udGV4dCk7XG4gICAgICB9XG4gICAgICBkdXN0LmxvZygnTm8gYmxvY2sgZm9yIG5vdC1leGlzdHMgY2hlY2sgaW4gdGVtcGxhdGUgYCcgKyBjb250ZXh0LmdldFRlbXBsYXRlTmFtZSgpICsgJ2AnLCBERUJVRyk7XG4gICAgfSBlbHNlIGlmIChza2lwKSB7XG4gICAgICByZXR1cm4gc2tpcCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLmJsb2NrID0gZnVuY3Rpb24oZWxlbSwgY29udGV4dCwgYm9kaWVzKSB7XG4gICAgdmFyIGJvZHkgPSBlbGVtIHx8IGJvZGllcy5ibG9jaztcblxuICAgIGlmIChib2R5KSB7XG4gICAgICByZXR1cm4gYm9keSh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLnBhcnRpYWwgPSBmdW5jdGlvbihlbGVtLCBjb250ZXh0LCBwYXJ0aWFsQ29udGV4dCwgcGFyYW1zKSB7XG4gICAgdmFyIGhlYWQ7XG5cbiAgICBpZihwYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQ29tcGF0aWJpbGl0eSBmb3IgPCAyLjcuMCB3aGVyZSBgcGFydGlhbENvbnRleHRgIGRpZCBub3QgZXhpc3RcbiAgICAgIHBhcmFtcyA9IHBhcnRpYWxDb250ZXh0O1xuICAgICAgcGFydGlhbENvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cblxuICAgIGlmICghZHVzdC5pc0VtcHR5T2JqZWN0KHBhcmFtcykpIHtcbiAgICAgIHBhcnRpYWxDb250ZXh0ID0gcGFydGlhbENvbnRleHQuY2xvbmUoKTtcbiAgICAgIGhlYWQgPSBwYXJ0aWFsQ29udGV4dC5wb3AoKTtcbiAgICAgIHBhcnRpYWxDb250ZXh0ID0gcGFydGlhbENvbnRleHQucHVzaChwYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnB1c2goaGVhZCk7XG4gICAgfVxuXG4gICAgaWYgKGR1c3QuaXNUZW1wbGF0ZUZuKGVsZW0pKSB7XG4gICAgICAvLyBUaGUgZXZlbnR1YWwgcmVzdWx0IG9mIGV2YWx1YXRpbmcgYGVsZW1gIGlzIGEgcGFydGlhbCBuYW1lXG4gICAgICAvLyBMb2FkIHRoZSBwYXJ0aWFsIGFmdGVyIGdldHRpbmcgaXRzIG5hbWUgYW5kIGVuZCB0aGUgYXN5bmMgY2h1bmtcbiAgICAgIHJldHVybiB0aGlzLmNhcHR1cmUoZWxlbSwgY29udGV4dCwgZnVuY3Rpb24obmFtZSwgY2h1bmspIHtcbiAgICAgICAgcGFydGlhbENvbnRleHQudGVtcGxhdGVOYW1lID0gbmFtZTtcbiAgICAgICAgbG9hZChuYW1lLCBjaHVuaywgcGFydGlhbENvbnRleHQpLmVuZCgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRpYWxDb250ZXh0LnRlbXBsYXRlTmFtZSA9IGVsZW07XG4gICAgICByZXR1cm4gbG9hZChlbGVtLCB0aGlzLCBwYXJ0aWFsQ29udGV4dCk7XG4gICAgfVxuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS5oZWxwZXIgPSBmdW5jdGlvbihuYW1lLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcywgYXV0bykge1xuICAgIHZhciBjaHVuayA9IHRoaXMsXG4gICAgICAgIGZpbHRlcnMgPSBwYXJhbXMuZmlsdGVycyxcbiAgICAgICAgcmV0O1xuXG4gICAgLy8gUHJlLTIuNy4xIGNvbXBhdDogaWYgYXV0byBpcyB1bmRlZmluZWQsIGl0J3MgYW4gb2xkIHRlbXBsYXRlLiBBdXRvbWF0aWNhbGx5IGVzY2FwZVxuICAgIGlmIChhdXRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGF1dG8gPSAnaCc7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIGludmFsaWQgaGVscGVycywgc2ltaWxhciB0byBpbnZhbGlkIGZpbHRlcnNcbiAgICBpZihkdXN0LmhlbHBlcnNbbmFtZV0pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldCA9IGR1c3QuaGVscGVyc1tuYW1lXShjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpO1xuICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgQ2h1bmspIHtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGlmKHR5cGVvZiBmaWx0ZXJzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGZpbHRlcnMgPSBmaWx0ZXJzLnNwbGl0KCd8Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkdXN0LmlzRW1wdHlPYmplY3QoYm9kaWVzKSkge1xuICAgICAgICAgIHJldHVybiBjaHVuay5zZWN0aW9uKHJldCwgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhlbHBlcnMgYWN0IHNsaWdodGx5IGRpZmZlcmVudGx5IGZyb20gZnVuY3Rpb25zIGluIGNvbnRleHQgaW4gdGhhdCB0aGV5IHdpbGwgYWN0IGFzXG4gICAgICAgIC8vIGEgcmVmZXJlbmNlIGlmIHRoZXkgYXJlIHNlbGYtY2xvc2luZyAoZHVlIHRvIGdyYW1tYXIgbGltaXRhdGlvbnMpXG4gICAgICAgIC8vIEluIHRoZSBDaHVuay5hd2FpdCBmdW5jdGlvbiB3ZSBjaGVjayB0byBtYWtlIHN1cmUgYm9kaWVzIGlzIG51bGwgYmVmb3JlIGFjdGluZyBhcyBhIHJlZmVyZW5jZVxuICAgICAgICByZXR1cm4gY2h1bmsucmVmZXJlbmNlKHJldCwgY29udGV4dCwgYXV0bywgZmlsdGVycyk7XG4gICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBkdXN0LmxvZygnRXJyb3IgaW4gaGVscGVyIGAnICsgbmFtZSArICdgOiAnICsgZXJyLm1lc3NhZ2UsIEVSUk9SKTtcbiAgICAgICAgcmV0dXJuIGNodW5rLnNldEVycm9yKGVycik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1c3QubG9nKCdIZWxwZXIgYCcgKyBuYW1lICsgJ2AgZG9lcyBub3QgZXhpc3QnLCBXQVJOKTtcbiAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2VydmUgYSBjaHVuayB0byBiZSBldmFsdWF0ZWQgb25jZSBhIHRoZW5hYmxlIGlzIHJlc29sdmVkIG9yIHJlamVjdGVkXG4gICAqIEBwYXJhbSB0aGVuYWJsZSB7VGhlbmFibGV9IHRoZSB0YXJnZXQgdGhlbmFibGUgdG8gYXdhaXRcbiAgICogQHBhcmFtIGNvbnRleHQge0NvbnRleHR9IGNvbnRleHQgdG8gdXNlIHRvIHJlbmRlciB0aGUgZGVmZXJyZWQgY2h1bmtcbiAgICogQHBhcmFtIGJvZGllcyB7T2JqZWN0fSBtdXN0IGNvbnRhaW4gYSBcImJvZHlcIiwgbWF5IGNvbnRhaW4gYW4gXCJlcnJvclwiXG4gICAqIEBwYXJhbSBhdXRvIHtTdHJpbmd9IGF1dG9tYXRpY2FsbHkgYXBwbHkgdGhpcyBmaWx0ZXIgaWYgdGhlIFRoZW5hYmxlIGlzIGEgcmVmZXJlbmNlXG4gICAqIEBwYXJhbSBmaWx0ZXJzIHtBcnJheX0gYXBwbHkgdGhlc2UgZmlsdGVycyBpZiB0aGUgVGhlbmFibGUgaXMgYSByZWZlcmVuY2VcbiAgICogQHJldHVybiB7Q2h1bmt9XG4gICAqL1xuICBDaHVuay5wcm90b3R5cGUuYXdhaXQgPSBmdW5jdGlvbih0aGVuYWJsZSwgY29udGV4dCwgYm9kaWVzLCBhdXRvLCBmaWx0ZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKGJvZGllcykge1xuICAgICAgICAgIGNodW5rID0gY2h1bmsuc2VjdGlvbihkYXRhLCBjb250ZXh0LCBib2RpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFjdHVhbGx5IGEgcmVmZXJlbmNlLiBTZWxmLWNsb3Npbmcgc2VjdGlvbnMgZG9uJ3QgcmVuZGVyXG4gICAgICAgICAgY2h1bmsgPSBjaHVuay5yZWZlcmVuY2UoZGF0YSwgY29udGV4dCwgYXV0bywgZmlsdGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmsuZW5kKCk7XG4gICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgdmFyIGVycm9yQm9keSA9IGJvZGllcyAmJiBib2RpZXMuZXJyb3I7XG4gICAgICAgIGlmKGVycm9yQm9keSkge1xuICAgICAgICAgIGNodW5rLnJlbmRlcihlcnJvckJvZHksIGNvbnRleHQucHVzaChlcnIpKS5lbmQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkdXN0LmxvZygnVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uIGluIGAnICsgY29udGV4dC5nZXRUZW1wbGF0ZU5hbWUoKSArICdgJywgSU5GTyk7XG4gICAgICAgICAgY2h1bmsuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNlcnZlIGEgY2h1bmsgdG8gYmUgZXZhbHVhdGVkIHdpdGggdGhlIGNvbnRlbnRzIG9mIGEgc3RyZWFtYWJsZS5cbiAgICogQ3VycmVudGx5IGFuIGVycm9yIGV2ZW50IHdpbGwgYm9tYiBvdXQgdGhlIHN0cmVhbS4gT25jZSBhbiBlcnJvclxuICAgKiBpcyByZWNlaXZlZCwgd2UgcHVzaCBpdCB0byBhbiB7OmVycm9yfSBibG9jayBpZiBvbmUgZXhpc3RzLCBhbmQgbG9nIG90aGVyd2lzZSxcbiAgICogdGhlbiBzdG9wIGxpc3RlbmluZyB0byB0aGUgc3RyZWFtLlxuICAgKiBAcGFyYW0gc3RyZWFtYWJsZSB7U3RyZWFtYWJsZX0gdGhlIHRhcmdldCBzdHJlYW1hYmxlIHRoYXQgd2lsbCBlbWl0IGV2ZW50c1xuICAgKiBAcGFyYW0gY29udGV4dCB7Q29udGV4dH0gY29udGV4dCB0byB1c2UgdG8gcmVuZGVyIGVhY2ggdGh1bmtcbiAgICogQHBhcmFtIGJvZGllcyB7T2JqZWN0fSBtdXN0IGNvbnRhaW4gYSBcImJvZHlcIiwgbWF5IGNvbnRhaW4gYW4gXCJlcnJvclwiXG4gICAqIEByZXR1cm4ge0NodW5rfVxuICAgKi9cbiAgQ2h1bmsucHJvdG90eXBlLnN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSwgY29udGV4dCwgYm9kaWVzLCBhdXRvLCBmaWx0ZXJzKSB7XG4gICAgdmFyIGJvZHkgPSBib2RpZXMgJiYgYm9kaWVzLmJsb2NrLFxuICAgICAgICBlcnJvckJvZHkgPSBib2RpZXMgJiYgYm9kaWVzLmVycm9yO1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihjaHVuaykge1xuICAgICAgdmFyIGVuZGVkID0gZmFsc2U7XG4gICAgICBzdHJlYW1cbiAgICAgICAgLm9uKCdkYXRhJywgZnVuY3Rpb24gZGF0YSh0aHVuaykge1xuICAgICAgICAgIGlmKGVuZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGJvZHkpIHtcbiAgICAgICAgICAgIC8vIEZvcmsgYSBuZXcgY2h1bmsgb3V0IG9mIHRoZSBibG9ja3N0cmVhbSBzbyB0aGF0IHdlIGNhbiBmbHVzaCBpdCBpbmRlcGVuZGVudGx5XG4gICAgICAgICAgICBjaHVuayA9IGNodW5rLm1hcChmdW5jdGlvbihjaHVuaykge1xuICAgICAgICAgICAgICBjaHVuay5yZW5kZXIoYm9keSwgY29udGV4dC5wdXNoKHRodW5rKSkuZW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYoIWJvZGllcykge1xuICAgICAgICAgICAgLy8gV2hlbiBhY3R1YWxseSBhIHJlZmVyZW5jZSwgZG9uJ3QgZm9yaywganVzdCB3cml0ZSBpbnRvIHRoZSBtYXN0ZXIgYXN5bmMgY2h1bmtcbiAgICAgICAgICAgIGNodW5rID0gY2h1bmsucmVmZXJlbmNlKHRodW5rLCBjb250ZXh0LCBhdXRvLCBmaWx0ZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICAgICAgICBpZihlbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihlcnJvckJvZHkpIHtcbiAgICAgICAgICAgIGNodW5rLnJlbmRlcihlcnJvckJvZHksIGNvbnRleHQucHVzaChlcnIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHVzdC5sb2coJ1VuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gYCcgKyBjb250ZXh0LmdldFRlbXBsYXRlTmFtZSgpICsgJ2AnLCBJTkZPKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoIWVuZGVkKSB7XG4gICAgICAgICAgICBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICBjaHVuay5lbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZW5kJywgZnVuY3Rpb24gZW5kKCkge1xuICAgICAgICAgIGlmKCFlbmRlZCkge1xuICAgICAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2h1bmsuZW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBDaHVuay5wcm90b3R5cGUuY2FwdHVyZSA9IGZ1bmN0aW9uKGJvZHksIGNvbnRleHQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICB2YXIgc3R1YiA9IG5ldyBTdHViKGZ1bmN0aW9uKGVyciwgb3V0KSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjaHVuay5zZXRFcnJvcihlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKG91dCwgY2h1bmspO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGJvZHkoc3R1Yi5oZWFkLCBjb250ZXh0KS5lbmQoKTtcbiAgICB9KTtcbiAgfTtcblxuICBDaHVuay5wcm90b3R5cGUuc2V0RXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICB0aGlzLmVycm9yID0gZXJyO1xuICAgIHRoaXMucm9vdC5mbHVzaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIENodW5rIGFsaWFzZXNcbiAgZm9yKHZhciBmIGluIENodW5rLnByb3RvdHlwZSkge1xuICAgIGlmKGR1c3QuX2FsaWFzZXNbZl0pIHtcbiAgICAgIENodW5rLnByb3RvdHlwZVtkdXN0Ll9hbGlhc2VzW2ZdXSA9IENodW5rLnByb3RvdHlwZVtmXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBUYXAoaGVhZCwgdGFpbCkge1xuICAgIHRoaXMuaGVhZCA9IGhlYWQ7XG4gICAgdGhpcy50YWlsID0gdGFpbDtcbiAgfVxuXG4gIFRhcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHRhcCkge1xuICAgIHJldHVybiBuZXcgVGFwKHRhcCwgdGhpcyk7XG4gIH07XG5cbiAgVGFwLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHRhcCA9IHRoaXM7XG5cbiAgICB3aGlsZSh0YXApIHtcbiAgICAgIHZhbHVlID0gdGFwLmhlYWQodmFsdWUpO1xuICAgICAgdGFwID0gdGFwLnRhaWw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICB2YXIgSENIQVJTID0gL1smPD5cIiddLyxcbiAgICAgIEFNUCAgICA9IC8mL2csXG4gICAgICBMVCAgICAgPSAvPC9nLFxuICAgICAgR1QgICAgID0gLz4vZyxcbiAgICAgIFFVT1QgICA9IC9cXFwiL2csXG4gICAgICBTUVVPVCAgPSAvXFwnL2c7XG5cbiAgZHVzdC5lc2NhcGVIdG1sID0gZnVuY3Rpb24ocykge1xuICAgIGlmICh0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIiB8fCAocyAmJiB0eXBlb2Ygcy50b1N0cmluZyA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgaWYgKHR5cGVvZiBzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHMgPSBzLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAoIUhDSEFSUy50ZXN0KHMpKSB7XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHMucmVwbGFjZShBTVAsJyZhbXA7JykucmVwbGFjZShMVCwnJmx0OycpLnJlcGxhY2UoR1QsJyZndDsnKS5yZXBsYWNlKFFVT1QsJyZxdW90OycpLnJlcGxhY2UoU1FVT1QsICcmIzM5OycpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfTtcblxuICB2YXIgQlMgPSAvXFxcXC9nLFxuICAgICAgRlMgPSAvXFwvL2csXG4gICAgICBDUiA9IC9cXHIvZyxcbiAgICAgIExTID0gL1xcdTIwMjgvZyxcbiAgICAgIFBTID0gL1xcdTIwMjkvZyxcbiAgICAgIE5MID0gL1xcbi9nLFxuICAgICAgTEYgPSAvXFxmL2csXG4gICAgICBTUSA9IC8nL2csXG4gICAgICBEUSA9IC9cIi9nLFxuICAgICAgVEIgPSAvXFx0L2c7XG5cbiAgZHVzdC5lc2NhcGVKcyA9IGZ1bmN0aW9uKHMpIHtcbiAgICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gc1xuICAgICAgICAucmVwbGFjZShCUywgJ1xcXFxcXFxcJylcbiAgICAgICAgLnJlcGxhY2UoRlMsICdcXFxcLycpXG4gICAgICAgIC5yZXBsYWNlKERRLCAnXFxcXFwiJylcbiAgICAgICAgLnJlcGxhY2UoU1EsICdcXFxcXFwnJylcbiAgICAgICAgLnJlcGxhY2UoQ1IsICdcXFxccicpXG4gICAgICAgIC5yZXBsYWNlKExTLCAnXFxcXHUyMDI4JylcbiAgICAgICAgLnJlcGxhY2UoUFMsICdcXFxcdTIwMjknKVxuICAgICAgICAucmVwbGFjZShOTCwgJ1xcXFxuJylcbiAgICAgICAgLnJlcGxhY2UoTEYsICdcXFxcZicpXG4gICAgICAgIC5yZXBsYWNlKFRCLCAnXFxcXHQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH07XG5cbiAgZHVzdC5lc2NhcGVKU09OID0gZnVuY3Rpb24obykge1xuICAgIGlmICghSlNPTikge1xuICAgICAgZHVzdC5sb2coJ0pTT04gaXMgdW5kZWZpbmVkOyBjb3VsZCBub3QgZXNjYXBlIGAnICsgbyArICdgJywgV0FSTik7XG4gICAgICByZXR1cm4gbztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG8pXG4gICAgICAgIC5yZXBsYWNlKExTLCAnXFxcXHUyMDI4JylcbiAgICAgICAgLnJlcGxhY2UoUFMsICdcXFxcdTIwMjknKVxuICAgICAgICAucmVwbGFjZShMVCwgJ1xcXFx1MDAzYycpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZHVzdDtcblxufSkpO1xuIiwiLyoqXG4qIEBwcmVzZXJ2ZSBIVE1MNSBTaGl2IDMuNy4zIHwgQGFmYXJrYXMgQGpkYWx0b24gQGpvbl9uZWFsIEByZW0gfCBNSVQvR1BMMiBMaWNlbnNlZFxuKi9cbjsoZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCkge1xuLypqc2hpbnQgZXZpbDp0cnVlICovXG4gIC8qKiB2ZXJzaW9uICovXG4gIHZhciB2ZXJzaW9uID0gJzMuNy4zLXByZSc7XG5cbiAgLyoqIFByZXNldCBvcHRpb25zICovXG4gIHZhciBvcHRpb25zID0gd2luZG93Lmh0bWw1IHx8IHt9O1xuXG4gIC8qKiBVc2VkIHRvIHNraXAgcHJvYmxlbSBlbGVtZW50cyAqL1xuICB2YXIgcmVTa2lwID0gL148fF4oPzpidXR0b258bWFwfHNlbGVjdHx0ZXh0YXJlYXxvYmplY3R8aWZyYW1lfG9wdGlvbnxvcHRncm91cCkkL2k7XG5cbiAgLyoqIE5vdCBhbGwgZWxlbWVudHMgY2FuIGJlIGNsb25lZCBpbiBJRSAqKi9cbiAgdmFyIHNhdmVDbG9uZXMgPSAvXig/OmF8Ynxjb2RlfGRpdnxmaWVsZHNldHxoMXxoMnxoM3xoNHxoNXxoNnxpfGxhYmVsfGxpfG9sfHB8cXxzcGFufHN0cm9uZ3xzdHlsZXx0YWJsZXx0Ym9keXx0ZHx0aHx0cnx1bCkkL2k7XG5cbiAgLyoqIERldGVjdCB3aGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIGRlZmF1bHQgaHRtbDUgc3R5bGVzICovXG4gIHZhciBzdXBwb3J0c0h0bWw1U3R5bGVzO1xuXG4gIC8qKiBOYW1lIG9mIHRoZSBleHBhbmRvLCB0byB3b3JrIHdpdGggbXVsdGlwbGUgZG9jdW1lbnRzIG9yIHRvIHJlLXNoaXYgb25lIGRvY3VtZW50ICovXG4gIHZhciBleHBhbmRvID0gJ19odG1sNXNoaXYnO1xuXG4gIC8qKiBUaGUgaWQgZm9yIHRoZSB0aGUgZG9jdW1lbnRzIGV4cGFuZG8gKi9cbiAgdmFyIGV4cGFuSUQgPSAwO1xuXG4gIC8qKiBDYWNoZWQgZGF0YSBmb3IgZWFjaCBkb2N1bWVudCAqL1xuICB2YXIgZXhwYW5kb0RhdGEgPSB7fTtcblxuICAvKiogRGV0ZWN0IHdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdW5rbm93biBlbGVtZW50cyAqL1xuICB2YXIgc3VwcG9ydHNVbmtub3duRWxlbWVudHM7XG5cbiAgKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICBhLmlubmVySFRNTCA9ICc8eHl6PjwveHl6Pic7XG4gICAgICAgIC8vaWYgdGhlIGhpZGRlbiBwcm9wZXJ0eSBpcyBpbXBsZW1lbnRlZCB3ZSBjYW4gYXNzdW1lLCB0aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzIGJhc2ljIEhUTUw1IFN0eWxlc1xuICAgICAgICBzdXBwb3J0c0h0bWw1U3R5bGVzID0gKCdoaWRkZW4nIGluIGEpO1xuXG4gICAgICAgIHN1cHBvcnRzVW5rbm93bkVsZW1lbnRzID0gYS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxIHx8IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBhc3NpZ24gYSBmYWxzZSBwb3NpdGl2ZSBpZiB1bmFibGUgdG8gc2hpdlxuICAgICAgICAgIChkb2N1bWVudC5jcmVhdGVFbGVtZW50KSgnYScpO1xuICAgICAgICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0eXBlb2YgZnJhZy5jbG9uZU5vZGUgPT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBmcmFnLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBmcmFnLmNyZWF0ZUVsZW1lbnQgPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICApO1xuICAgICAgICB9KCkpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgLy8gYXNzaWduIGEgZmFsc2UgcG9zaXRpdmUgaWYgZGV0ZWN0aW9uIGZhaWxzID0+IHVuYWJsZSB0byBzaGl2XG4gICAgICBzdXBwb3J0c0h0bWw1U3R5bGVzID0gdHJ1ZTtcbiAgICAgIHN1cHBvcnRzVW5rbm93bkVsZW1lbnRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgfSgpKTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHN0eWxlIHNoZWV0IHdpdGggdGhlIGdpdmVuIENTUyB0ZXh0IGFuZCBhZGRzIGl0IHRvIHRoZSBkb2N1bWVudC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gb3duZXJEb2N1bWVudCBUaGUgZG9jdW1lbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjc3NUZXh0IFRoZSBDU1MgdGV4dC5cbiAgICogQHJldHVybnMge1N0eWxlU2hlZXR9IFRoZSBzdHlsZSBlbGVtZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gYWRkU3R5bGVTaGVldChvd25lckRvY3VtZW50LCBjc3NUZXh0KSB7XG4gICAgdmFyIHAgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKSxcbiAgICAgICAgcGFyZW50ID0gb3duZXJEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdIHx8IG93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgcC5pbm5lckhUTUwgPSAneDxzdHlsZT4nICsgY3NzVGV4dCArICc8L3N0eWxlPic7XG4gICAgcmV0dXJuIHBhcmVudC5pbnNlcnRCZWZvcmUocC5sYXN0Q2hpbGQsIHBhcmVudC5maXJzdENoaWxkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBgaHRtbDUuZWxlbWVudHNgIGFzIGFuIGFycmF5LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIHNoaXZlZCBlbGVtZW50IG5vZGUgbmFtZXMuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRFbGVtZW50cygpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBodG1sNS5lbGVtZW50cztcbiAgICByZXR1cm4gdHlwZW9mIGVsZW1lbnRzID09ICdzdHJpbmcnID8gZWxlbWVudHMuc3BsaXQoJyAnKSA6IGVsZW1lbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dGVuZHMgdGhlIGJ1aWx0LWluIGxpc3Qgb2YgaHRtbDUgZWxlbWVudHNcbiAgICogQG1lbWJlck9mIGh0bWw1XG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBuZXdFbGVtZW50cyB3aGl0ZXNwYWNlIHNlcGFyYXRlZCBsaXN0IG9yIGFycmF5IG9mIG5ldyBlbGVtZW50IG5hbWVzIHRvIHNoaXZcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gb3duZXJEb2N1bWVudCBUaGUgY29udGV4dCBkb2N1bWVudC5cbiAgICovXG4gIGZ1bmN0aW9uIGFkZEVsZW1lbnRzKG5ld0VsZW1lbnRzLCBvd25lckRvY3VtZW50KSB7XG4gICAgdmFyIGVsZW1lbnRzID0gaHRtbDUuZWxlbWVudHM7XG4gICAgaWYodHlwZW9mIGVsZW1lbnRzICE9ICdzdHJpbmcnKXtcbiAgICAgIGVsZW1lbnRzID0gZWxlbWVudHMuam9pbignICcpO1xuICAgIH1cbiAgICBpZih0eXBlb2YgbmV3RWxlbWVudHMgIT0gJ3N0cmluZycpe1xuICAgICAgbmV3RWxlbWVudHMgPSBuZXdFbGVtZW50cy5qb2luKCcgJyk7XG4gICAgfVxuICAgIGh0bWw1LmVsZW1lbnRzID0gZWxlbWVudHMgKycgJysgbmV3RWxlbWVudHM7XG4gICAgc2hpdkRvY3VtZW50KG93bmVyRG9jdW1lbnQpO1xuICB9XG5cbiAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRhIGFzc29jaWF0ZWQgdG8gdGhlIGdpdmVuIGRvY3VtZW50XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGRvY3VtZW50LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgb2YgZGF0YS5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEV4cGFuZG9EYXRhKG93bmVyRG9jdW1lbnQpIHtcbiAgICB2YXIgZGF0YSA9IGV4cGFuZG9EYXRhW293bmVyRG9jdW1lbnRbZXhwYW5kb11dO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgICBkYXRhID0ge307XG4gICAgICAgIGV4cGFuSUQrKztcbiAgICAgICAgb3duZXJEb2N1bWVudFtleHBhbmRvXSA9IGV4cGFuSUQ7XG4gICAgICAgIGV4cGFuZG9EYXRhW2V4cGFuSURdID0gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyBhIHNoaXZlZCBlbGVtZW50IGZvciB0aGUgZ2l2ZW4gbm9kZU5hbWUgYW5kIGRvY3VtZW50XG4gICAqIEBtZW1iZXJPZiBodG1sNVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWUgbmFtZSBvZiB0aGUgZWxlbWVudFxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBvd25lckRvY3VtZW50IFRoZSBjb250ZXh0IGRvY3VtZW50LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2hpdmVkIGVsZW1lbnQuXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KG5vZGVOYW1lLCBvd25lckRvY3VtZW50LCBkYXRhKXtcbiAgICBpZiAoIW93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgb3duZXJEb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIH1cbiAgICBpZihzdXBwb3J0c1Vua25vd25FbGVtZW50cyl7XG4gICAgICAgIHJldHVybiBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgIH1cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IGdldEV4cGFuZG9EYXRhKG93bmVyRG9jdW1lbnQpO1xuICAgIH1cbiAgICB2YXIgbm9kZTtcblxuICAgIGlmIChkYXRhLmNhY2hlW25vZGVOYW1lXSkge1xuICAgICAgICBub2RlID0gZGF0YS5jYWNoZVtub2RlTmFtZV0uY2xvbmVOb2RlKCk7XG4gICAgfSBlbHNlIGlmIChzYXZlQ2xvbmVzLnRlc3Qobm9kZU5hbWUpKSB7XG4gICAgICAgIG5vZGUgPSAoZGF0YS5jYWNoZVtub2RlTmFtZV0gPSBkYXRhLmNyZWF0ZUVsZW0obm9kZU5hbWUpKS5jbG9uZU5vZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gZGF0YS5jcmVhdGVFbGVtKG5vZGVOYW1lKTtcbiAgICB9XG5cbiAgICAvLyBBdm9pZCBhZGRpbmcgc29tZSBlbGVtZW50cyB0byBmcmFnbWVudHMgaW4gSUUgPCA5IGJlY2F1c2VcbiAgICAvLyAqIEF0dHJpYnV0ZXMgbGlrZSBgbmFtZWAgb3IgYHR5cGVgIGNhbm5vdCBiZSBzZXQvY2hhbmdlZCBvbmNlIGFuIGVsZW1lbnRcbiAgICAvLyAgIGlzIGluc2VydGVkIGludG8gYSBkb2N1bWVudC9mcmFnbWVudFxuICAgIC8vICogTGluayBlbGVtZW50cyB3aXRoIGBzcmNgIGF0dHJpYnV0ZXMgdGhhdCBhcmUgaW5hY2Nlc3NpYmxlLCBhcyB3aXRoXG4gICAgLy8gICBhIDQwMyByZXNwb25zZSwgd2lsbCBjYXVzZSB0aGUgdGFiL3dpbmRvdyB0byBjcmFzaFxuICAgIC8vICogU2NyaXB0IGVsZW1lbnRzIGFwcGVuZGVkIHRvIGZyYWdtZW50cyB3aWxsIGV4ZWN1dGUgd2hlbiB0aGVpciBgc3JjYFxuICAgIC8vICAgb3IgYHRleHRgIHByb3BlcnR5IGlzIHNldFxuICAgIHJldHVybiBub2RlLmNhbkhhdmVDaGlsZHJlbiAmJiAhcmVTa2lwLnRlc3Qobm9kZU5hbWUpICYmICFub2RlLnRhZ1VybiA/IGRhdGEuZnJhZy5hcHBlbmRDaGlsZChub2RlKSA6IG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyBhIHNoaXZlZCBEb2N1bWVudEZyYWdtZW50IGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnRcbiAgICogQG1lbWJlck9mIGh0bWw1XG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGNvbnRleHQgZG9jdW1lbnQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzaGl2ZWQgRG9jdW1lbnRGcmFnbWVudC5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQob3duZXJEb2N1bWVudCwgZGF0YSl7XG4gICAgaWYgKCFvd25lckRvY3VtZW50KSB7XG4gICAgICAgIG93bmVyRG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB9XG4gICAgaWYoc3VwcG9ydHNVbmtub3duRWxlbWVudHMpe1xuICAgICAgICByZXR1cm4gb3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgfVxuICAgIGRhdGEgPSBkYXRhIHx8IGdldEV4cGFuZG9EYXRhKG93bmVyRG9jdW1lbnQpO1xuICAgIHZhciBjbG9uZSA9IGRhdGEuZnJhZy5jbG9uZU5vZGUoKSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGVsZW1zID0gZ2V0RWxlbWVudHMoKSxcbiAgICAgICAgbCA9IGVsZW1zLmxlbmd0aDtcbiAgICBmb3IoO2k8bDtpKyspe1xuICAgICAgICBjbG9uZS5jcmVhdGVFbGVtZW50KGVsZW1zW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoaXZzIHRoZSBgY3JlYXRlRWxlbWVudGAgYW5kIGBjcmVhdGVEb2N1bWVudEZyYWdtZW50YCBtZXRob2RzIG9mIHRoZSBkb2N1bWVudC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtEb2N1bWVudHxEb2N1bWVudEZyYWdtZW50fSBvd25lckRvY3VtZW50IFRoZSBkb2N1bWVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgb2YgdGhlIGRvY3VtZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gc2hpdk1ldGhvZHMob3duZXJEb2N1bWVudCwgZGF0YSkge1xuICAgIGlmICghZGF0YS5jYWNoZSkge1xuICAgICAgICBkYXRhLmNhY2hlID0ge307XG4gICAgICAgIGRhdGEuY3JlYXRlRWxlbSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudDtcbiAgICAgICAgZGF0YS5jcmVhdGVGcmFnID0gb3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50O1xuICAgICAgICBkYXRhLmZyYWcgPSBkYXRhLmNyZWF0ZUZyYWcoKTtcbiAgICB9XG5cblxuICAgIG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKG5vZGVOYW1lKSB7XG4gICAgICAvL2Fib3J0IHNoaXZcbiAgICAgIGlmICghaHRtbDUuc2hpdk1ldGhvZHMpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5jcmVhdGVFbGVtKG5vZGVOYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KG5vZGVOYW1lLCBvd25lckRvY3VtZW50LCBkYXRhKTtcbiAgICB9O1xuXG4gICAgb3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50ID0gRnVuY3Rpb24oJ2gsZicsICdyZXR1cm4gZnVuY3Rpb24oKXsnICtcbiAgICAgICd2YXIgbj1mLmNsb25lTm9kZSgpLGM9bi5jcmVhdGVFbGVtZW50OycgK1xuICAgICAgJ2guc2hpdk1ldGhvZHMmJignICtcbiAgICAgICAgLy8gdW5yb2xsIHRoZSBgY3JlYXRlRWxlbWVudGAgY2FsbHNcbiAgICAgICAgZ2V0RWxlbWVudHMoKS5qb2luKCkucmVwbGFjZSgvW1xcd1xcLTpdKy9nLCBmdW5jdGlvbihub2RlTmFtZSkge1xuICAgICAgICAgIGRhdGEuY3JlYXRlRWxlbShub2RlTmFtZSk7XG4gICAgICAgICAgZGF0YS5mcmFnLmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgICAgICAgIHJldHVybiAnYyhcIicgKyBub2RlTmFtZSArICdcIiknO1xuICAgICAgICB9KSArXG4gICAgICAnKTtyZXR1cm4gbn0nXG4gICAgKShodG1sNSwgZGF0YS5mcmFnKTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBTaGl2cyB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG4gICAqIEBtZW1iZXJPZiBodG1sNVxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBvd25lckRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBzaGl2LlxuICAgKiBAcmV0dXJucyB7RG9jdW1lbnR9IFRoZSBzaGl2ZWQgZG9jdW1lbnQuXG4gICAqL1xuICBmdW5jdGlvbiBzaGl2RG9jdW1lbnQob3duZXJEb2N1bWVudCkge1xuICAgIGlmICghb3duZXJEb2N1bWVudCkge1xuICAgICAgICBvd25lckRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgfVxuICAgIHZhciBkYXRhID0gZ2V0RXhwYW5kb0RhdGEob3duZXJEb2N1bWVudCk7XG5cbiAgICBpZiAoaHRtbDUuc2hpdkNTUyAmJiAhc3VwcG9ydHNIdG1sNVN0eWxlcyAmJiAhZGF0YS5oYXNDU1MpIHtcbiAgICAgIGRhdGEuaGFzQ1NTID0gISFhZGRTdHlsZVNoZWV0KG93bmVyRG9jdW1lbnQsXG4gICAgICAgIC8vIGNvcnJlY3RzIGJsb2NrIGRpc3BsYXkgbm90IGRlZmluZWQgaW4gSUU2LzcvOC85XG4gICAgICAgICdhcnRpY2xlLGFzaWRlLGRpYWxvZyxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsaGVhZGVyLGhncm91cCxtYWluLG5hdixzZWN0aW9ue2Rpc3BsYXk6YmxvY2t9JyArXG4gICAgICAgIC8vIGFkZHMgc3R5bGluZyBub3QgcHJlc2VudCBpbiBJRTYvNy84LzlcbiAgICAgICAgJ21hcmt7YmFja2dyb3VuZDojRkYwO2NvbG9yOiMwMDB9JyArXG4gICAgICAgIC8vIGhpZGVzIG5vbi1yZW5kZXJlZCBlbGVtZW50c1xuICAgICAgICAndGVtcGxhdGV7ZGlzcGxheTpub25lfSdcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghc3VwcG9ydHNVbmtub3duRWxlbWVudHMpIHtcbiAgICAgIHNoaXZNZXRob2RzKG93bmVyRG9jdW1lbnQsIGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gb3duZXJEb2N1bWVudDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBUaGUgYGh0bWw1YCBvYmplY3QgaXMgZXhwb3NlZCBzbyB0aGF0IG1vcmUgZWxlbWVudHMgY2FuIGJlIHNoaXZlZCBhbmRcbiAgICogZXhpc3Rpbmcgc2hpdmluZyBjYW4gYmUgZGV0ZWN0ZWQgb24gaWZyYW1lcy5cbiAgICogQHR5cGUgT2JqZWN0XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIC8vIG9wdGlvbnMgY2FuIGJlIGNoYW5nZWQgYmVmb3JlIHRoZSBzY3JpcHQgaXMgaW5jbHVkZWRcbiAgICogaHRtbDUgPSB7ICdlbGVtZW50cyc6ICdtYXJrIHNlY3Rpb24nLCAnc2hpdkNTUyc6IGZhbHNlLCAnc2hpdk1ldGhvZHMnOiBmYWxzZSB9O1xuICAgKi9cbiAgdmFyIGh0bWw1ID0ge1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBub2RlIG5hbWVzIG9mIHRoZSBlbGVtZW50cyB0byBzaGl2LlxuICAgICAqIEBtZW1iZXJPZiBodG1sNVxuICAgICAqIEB0eXBlIEFycmF5fFN0cmluZ1xuICAgICAqL1xuICAgICdlbGVtZW50cyc6IG9wdGlvbnMuZWxlbWVudHMgfHwgJ2FiYnIgYXJ0aWNsZSBhc2lkZSBhdWRpbyBiZGkgY2FudmFzIGRhdGEgZGF0YWxpc3QgZGV0YWlscyBkaWFsb2cgZmlnY2FwdGlvbiBmaWd1cmUgZm9vdGVyIGhlYWRlciBoZ3JvdXAgbWFpbiBtYXJrIG1ldGVyIG5hdiBvdXRwdXQgcGljdHVyZSBwcm9ncmVzcyBzZWN0aW9uIHN1bW1hcnkgdGVtcGxhdGUgdGltZSB2aWRlbycsXG5cbiAgICAvKipcbiAgICAgKiBjdXJyZW50IHZlcnNpb24gb2YgaHRtbDVzaGl2XG4gICAgICovXG4gICAgJ3ZlcnNpb24nOiB2ZXJzaW9uLFxuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIEhUTUw1IHN0eWxlIHNoZWV0IHNob3VsZCBiZSBpbnNlcnRlZC5cbiAgICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgJ3NoaXZDU1MnOiAob3B0aW9ucy5zaGl2Q1NTICE9PSBmYWxzZSksXG5cbiAgICAvKipcbiAgICAgKiBJcyBlcXVhbCB0byB0cnVlIGlmIGEgYnJvd3NlciBzdXBwb3J0cyBjcmVhdGluZyB1bmtub3duL0hUTUw1IGVsZW1lbnRzXG4gICAgICogQG1lbWJlck9mIGh0bWw1XG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgICdzdXBwb3J0c1Vua25vd25FbGVtZW50cyc6IHN1cHBvcnRzVW5rbm93bkVsZW1lbnRzLFxuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIGRvY3VtZW50J3MgYGNyZWF0ZUVsZW1lbnRgIGFuZCBgY3JlYXRlRG9jdW1lbnRGcmFnbWVudGBcbiAgICAgKiBtZXRob2RzIHNob3VsZCBiZSBvdmVyd3JpdHRlbi5cbiAgICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgJ3NoaXZNZXRob2RzJzogKG9wdGlvbnMuc2hpdk1ldGhvZHMgIT09IGZhbHNlKSxcblxuICAgIC8qKlxuICAgICAqIEEgc3RyaW5nIHRvIGRlc2NyaWJlIHRoZSB0eXBlIG9mIGBodG1sNWAgb2JqZWN0IChcImRlZmF1bHRcIiBvciBcImRlZmF1bHQgcHJpbnRcIikuXG4gICAgICogQG1lbWJlck9mIGh0bWw1XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgJ3R5cGUnOiAnZGVmYXVsdCcsXG5cbiAgICAvLyBzaGl2cyB0aGUgZG9jdW1lbnQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgYGh0bWw1YCBvYmplY3Qgb3B0aW9uc1xuICAgICdzaGl2RG9jdW1lbnQnOiBzaGl2RG9jdW1lbnQsXG5cbiAgICAvL2NyZWF0ZXMgYSBzaGl2ZWQgZWxlbWVudFxuICAgIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG5cbiAgICAvL2NyZWF0ZXMgYSBzaGl2ZWQgZG9jdW1lbnRGcmFnbWVudFxuICAgIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQ6IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQsXG5cbiAgICAvL2V4dGVuZHMgbGlzdCBvZiBlbGVtZW50c1xuICAgIGFkZEVsZW1lbnRzOiBhZGRFbGVtZW50c1xuICB9O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIGV4cG9zZSBodG1sNVxuICB3aW5kb3cuaHRtbDUgPSBodG1sNTtcblxuICAvLyBzaGl2IHRoZSBkb2N1bWVudFxuICBzaGl2RG9jdW1lbnQoZG9jdW1lbnQpO1xuXG4gIGlmKHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpe1xuICAgIG1vZHVsZS5leHBvcnRzID0gaHRtbDU7XG4gIH1cblxufSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZG9jdW1lbnQpKTtcbiIsIlxyXG52YXIgTCA9IHtcclxuXHR2ZXJzaW9uOiAnMS4wLjEnXHJcbn07XHJcblxyXG5mdW5jdGlvbiBleHBvc2UoKSB7XHJcblx0dmFyIG9sZEwgPSB3aW5kb3cuTDtcclxuXHJcblx0TC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0d2luZG93LkwgPSBvbGRMO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHJcblx0d2luZG93LkwgPSBMO1xyXG59XHJcblxyXG4vLyBkZWZpbmUgTGVhZmxldCBmb3IgTm9kZSBtb2R1bGUgcGF0dGVybiBsb2FkZXJzLCBpbmNsdWRpbmcgQnJvd3NlcmlmeVxyXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG5cdG1vZHVsZS5leHBvcnRzID0gTDtcclxuXHJcbi8vIGRlZmluZSBMZWFmbGV0IGFzIGFuIEFNRCBtb2R1bGVcclxufSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuXHRkZWZpbmUoTCk7XHJcbn1cclxuXHJcbi8vIGRlZmluZSBMZWFmbGV0IGFzIGEgZ2xvYmFsIEwgdmFyaWFibGUsIHNhdmluZyB0aGUgb3JpZ2luYWwgTCB0byByZXN0b3JlIGxhdGVyIGlmIG5lZWRlZFxyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRleHBvc2UoKTtcclxufVxyXG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICovXHJcblxyXG5MLlV0aWwgPSB7XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBleHRlbmQoZGVzdDogT2JqZWN0LCBzcmM/OiBPYmplY3QpOiBPYmplY3RcclxuXHQvLyBNZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGBzcmNgIG9iamVjdCAob3IgbXVsdGlwbGUgb2JqZWN0cykgaW50byBgZGVzdGAgb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBsYXR0ZXIuIEhhcyBhbiBgTC5leHRlbmRgIHNob3J0Y3V0LlxyXG5cdGV4dGVuZDogZnVuY3Rpb24gKGRlc3QpIHtcclxuXHRcdHZhciBpLCBqLCBsZW4sIHNyYztcclxuXHJcblx0XHRmb3IgKGogPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuXHRcdFx0c3JjID0gYXJndW1lbnRzW2pdO1xyXG5cdFx0XHRmb3IgKGkgaW4gc3JjKSB7XHJcblx0XHRcdFx0ZGVzdFtpXSA9IHNyY1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGRlc3Q7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGNyZWF0ZShwcm90bzogT2JqZWN0LCBwcm9wZXJ0aWVzPzogT2JqZWN0KTogT2JqZWN0XHJcblx0Ly8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW09iamVjdC5jcmVhdGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGUpXHJcblx0Y3JlYXRlOiBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XHJcblx0XHRmdW5jdGlvbiBGKCkge31cclxuXHRcdHJldHVybiBmdW5jdGlvbiAocHJvdG8pIHtcclxuXHRcdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcclxuXHRcdFx0cmV0dXJuIG5ldyBGKCk7XHJcblx0XHR9O1xyXG5cdH0pKCksXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBiaW5kKGZuOiBGdW5jdGlvbiwg4oCmKTogRnVuY3Rpb25cclxuXHQvLyBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBhcmd1bWVudHMgcGFzc2VkLCBsaWtlIFtGdW5jdGlvbi5wcm90b3R5cGUuYmluZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCkuXHJcblx0Ly8gSGFzIGEgYEwuYmluZCgpYCBzaG9ydGN1dC5cclxuXHRiaW5kOiBmdW5jdGlvbiAoZm4sIG9iaikge1xyXG5cdFx0dmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuXHRcdGlmIChmbi5iaW5kKSB7XHJcblx0XHRcdHJldHVybiBmbi5iaW5kLmFwcGx5KGZuLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MubGVuZ3RoID8gYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IGFyZ3VtZW50cyk7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBzdGFtcChvYmo6IE9iamVjdCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHVuaXF1ZSBJRCBvZiBhbiBvYmplY3QsIGFzc2lnaW5nIGl0IG9uZSBpZiBpdCBkb2Vzbid0IGhhdmUgaXQuXHJcblx0c3RhbXA6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRcdG9iai5fbGVhZmxldF9pZCA9IG9iai5fbGVhZmxldF9pZCB8fCArK0wuVXRpbC5sYXN0SWQ7XHJcblx0XHRyZXR1cm4gb2JqLl9sZWFmbGV0X2lkO1xyXG5cdFx0Lyplc2xpbnQtZW5hYmxlICovXHJcblx0fSxcclxuXHJcblx0Ly8gQHByb3BlcnR5IGxhc3RJZDogTnVtYmVyXHJcblx0Ly8gTGFzdCB1bmlxdWUgSUQgdXNlZCBieSBbYHN0YW1wKClgXSgjdXRpbC1zdGFtcClcclxuXHRsYXN0SWQ6IDAsXHJcblxyXG5cdC8vIEBmdW5jdGlvbiB0aHJvdHRsZShmbjogRnVuY3Rpb24sIHRpbWU6IE51bWJlciwgY29udGV4dDogT2JqZWN0KTogRnVuY3Rpb25cclxuXHQvLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZXhlY3V0ZXMgZnVuY3Rpb24gYGZuYCB3aXRoIHRoZSBnaXZlbiBzY29wZSBgY29udGV4dGBcclxuXHQvLyAoc28gdGhhdCB0aGUgYHRoaXNgIGtleXdvcmQgcmVmZXJzIHRvIGBjb250ZXh0YCBpbnNpZGUgYGZuYCdzIGNvZGUpLiBUaGUgZnVuY3Rpb25cclxuXHQvLyBgZm5gIHdpbGwgYmUgY2FsbGVkIG5vIG1vcmUgdGhhbiBvbmUgdGltZSBwZXIgZ2l2ZW4gYW1vdW50IG9mIGB0aW1lYC4gVGhlIGFyZ3VtZW50c1xyXG5cdC8vIHJlY2VpdmVkIGJ5IHRoZSBib3VuZCBmdW5jdGlvbiB3aWxsIGJlIGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gYmluZGluZyB0aGVcclxuXHQvLyBmdW5jdGlvbiwgZm9sbG93ZWQgYnkgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBpbnZva2luZyB0aGUgYm91bmQgZnVuY3Rpb24uXHJcblx0Ly8gSGFzIGFuIGBMLmJpbmRgIHNob3J0Y3V0LlxyXG5cdHRocm90dGxlOiBmdW5jdGlvbiAoZm4sIHRpbWUsIGNvbnRleHQpIHtcclxuXHRcdHZhciBsb2NrLCBhcmdzLCB3cmFwcGVyRm4sIGxhdGVyO1xyXG5cclxuXHRcdGxhdGVyID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHQvLyByZXNldCBsb2NrIGFuZCBjYWxsIGlmIHF1ZXVlZFxyXG5cdFx0XHRsb2NrID0gZmFsc2U7XHJcblx0XHRcdGlmIChhcmdzKSB7XHJcblx0XHRcdFx0d3JhcHBlckZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG5cdFx0XHRcdGFyZ3MgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHR3cmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmIChsb2NrKSB7XHJcblx0XHRcdFx0Ly8gY2FsbGVkIHRvbyBzb29uLCBxdWV1ZSB0byBjYWxsIGxhdGVyXHJcblx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cztcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gY2FsbCBhbmQgbG9jayB1bnRpbCBsYXRlclxyXG5cdFx0XHRcdGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcblx0XHRcdFx0c2V0VGltZW91dChsYXRlciwgdGltZSk7XHJcblx0XHRcdFx0bG9jayA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0cmV0dXJuIHdyYXBwZXJGbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gd3JhcE51bShudW06IE51bWJlciwgcmFuZ2U6IE51bWJlcltdLCBpbmNsdWRlTWF4PzogQm9vbGVhbik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCBtb2R1bG8gYHJhbmdlYCBpbiBzdWNoIGEgd2F5IHNvIGl0IGxpZXMgd2l0aGluXHJcblx0Ly8gYHJhbmdlWzBdYCBhbmQgYHJhbmdlWzFdYC4gVGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgYWx3YXlzIHNtYWxsZXIgdGhhblxyXG5cdC8vIGByYW5nZVsxXWAgdW5sZXNzIGBpbmNsdWRlTWF4YCBpcyBzZXQgdG8gYHRydWVgLlxyXG5cdHdyYXBOdW06IGZ1bmN0aW9uICh4LCByYW5nZSwgaW5jbHVkZU1heCkge1xyXG5cdFx0dmFyIG1heCA9IHJhbmdlWzFdLFxyXG5cdFx0ICAgIG1pbiA9IHJhbmdlWzBdLFxyXG5cdFx0ICAgIGQgPSBtYXggLSBtaW47XHJcblx0XHRyZXR1cm4geCA9PT0gbWF4ICYmIGluY2x1ZGVNYXggPyB4IDogKCh4IC0gbWluKSAlIGQgKyBkKSAlIGQgKyBtaW47XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGZhbHNlRm4oKTogRnVuY3Rpb25cclxuXHQvLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cclxuXHRmYWxzZUZuOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGZvcm1hdE51bShudW06IE51bWJlciwgZGlnaXRzPzogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIHJvdW5kZWQgdG8gYGRpZ2l0c2AgZGVjaW1hbHMsIG9yIHRvIDUgZGVjaW1hbHMgYnkgZGVmYXVsdC5cclxuXHRmb3JtYXROdW06IGZ1bmN0aW9uIChudW0sIGRpZ2l0cykge1xyXG5cdFx0dmFyIHBvdyA9IE1hdGgucG93KDEwLCBkaWdpdHMgfHwgNSk7XHJcblx0XHRyZXR1cm4gTWF0aC5yb3VuZChudW0gKiBwb3cpIC8gcG93O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiB0cmltKHN0cjogU3RyaW5nKTogU3RyaW5nXHJcblx0Ly8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW1N0cmluZy5wcm90b3R5cGUudHJpbV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0pXHJcblx0dHJpbTogZnVuY3Rpb24gKHN0cikge1xyXG5cdFx0cmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyOiBTdHJpbmcpOiBTdHJpbmdbXVxyXG5cdC8vIFRyaW1zIGFuZCBzcGxpdHMgdGhlIHN0cmluZyBvbiB3aGl0ZXNwYWNlIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiBwYXJ0cy5cclxuXHRzcGxpdFdvcmRzOiBmdW5jdGlvbiAoc3RyKSB7XHJcblx0XHRyZXR1cm4gTC5VdGlsLnRyaW0oc3RyKS5zcGxpdCgvXFxzKy8pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBzZXRPcHRpb25zKG9iajogT2JqZWN0LCBvcHRpb25zOiBPYmplY3QpOiBPYmplY3RcclxuXHQvLyBNZXJnZXMgdGhlIGdpdmVuIHByb3BlcnRpZXMgdG8gdGhlIGBvcHRpb25zYCBvZiB0aGUgYG9iamAgb2JqZWN0LCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyBvcHRpb25zLiBTZWUgYENsYXNzIG9wdGlvbnNgLiBIYXMgYW4gYEwuc2V0T3B0aW9uc2Agc2hvcnRjdXQuXHJcblx0c2V0T3B0aW9uczogZnVuY3Rpb24gKG9iaiwgb3B0aW9ucykge1xyXG5cdFx0aWYgKCFvYmouaGFzT3duUHJvcGVydHkoJ29wdGlvbnMnKSkge1xyXG5cdFx0XHRvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gTC5VdGlsLmNyZWF0ZShvYmoub3B0aW9ucykgOiB7fTtcclxuXHRcdH1cclxuXHRcdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG5cdFx0XHRvYmoub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gb2JqLm9wdGlvbnM7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iajogT2JqZWN0LCBleGlzdGluZ1VybD86IFN0cmluZywgdXBwZXJjYXNlPzogQm9vbGVhbik6IFN0cmluZ1xyXG5cdC8vIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgcGFyYW1ldGVyIFVSTCBzdHJpbmcsIGUuZy4gYHthOiBcImZvb1wiLCBiOiBcImJhclwifWBcclxuXHQvLyB0cmFuc2xhdGVzIHRvIGAnP2E9Zm9vJmI9YmFyJ2AuIElmIGBleGlzdGluZ1VybGAgaXMgc2V0LCB0aGUgcGFyYW1ldGVycyB3aWxsXHJcblx0Ly8gYmUgYXBwZW5kZWQgYXQgdGhlIGVuZC4gSWYgYHVwcGVyY2FzZWAgaXMgYHRydWVgLCB0aGUgcGFyYW1ldGVyIG5hbWVzIHdpbGxcclxuXHQvLyBiZSB1cHBlcmNhc2VkIChlLmcuIGAnP0E9Zm9vJkI9YmFyJ2ApXHJcblx0Z2V0UGFyYW1TdHJpbmc6IGZ1bmN0aW9uIChvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcclxuXHRcdHZhciBwYXJhbXMgPSBbXTtcclxuXHRcdGZvciAodmFyIGkgaW4gb2JqKSB7XHJcblx0XHRcdHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAoKCFleGlzdGluZ1VybCB8fCBleGlzdGluZ1VybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgKyBwYXJhbXMuam9pbignJicpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiB0ZW1wbGF0ZShzdHI6IFN0cmluZywgZGF0YTogT2JqZWN0KTogU3RyaW5nXHJcblx0Ly8gU2ltcGxlIHRlbXBsYXRpbmcgZmFjaWxpdHksIGFjY2VwdHMgYSB0ZW1wbGF0ZSBzdHJpbmcgb2YgdGhlIGZvcm0gYCdIZWxsbyB7YX0sIHtifSdgXHJcblx0Ly8gYW5kIGEgZGF0YSBvYmplY3QgbGlrZSBge2E6ICdmb28nLCBiOiAnYmFyJ31gLCByZXR1cm5zIGV2YWx1YXRlZCBzdHJpbmdcclxuXHQvLyBgKCdIZWxsbyBmb28sIGJhcicpYC4gWW91IGNhbiBhbHNvIHNwZWNpZnkgZnVuY3Rpb25zIGluc3RlYWQgb2Ygc3RyaW5ncyBmb3JcclxuXHQvLyBkYXRhIHZhbHVlcyDigJQgdGhleSB3aWxsIGJlIGV2YWx1YXRlZCBwYXNzaW5nIGBkYXRhYCBhcyBhbiBhcmd1bWVudC5cclxuXHR0ZW1wbGF0ZTogZnVuY3Rpb24gKHN0ciwgZGF0YSkge1xyXG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKEwuVXRpbC50ZW1wbGF0ZVJlLCBmdW5jdGlvbiAoc3RyLCBrZXkpIHtcclxuXHRcdFx0dmFyIHZhbHVlID0gZGF0YVtrZXldO1xyXG5cclxuXHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbHVlIHByb3ZpZGVkIGZvciB2YXJpYWJsZSAnICsgc3RyKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZShkYXRhKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdmFsdWU7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHR0ZW1wbGF0ZVJlOiAvXFx7ICooW1xcd19cXC1dKykgKlxcfS9nLFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gaXNBcnJheShvYmopOiBCb29sZWFuXHJcblx0Ly8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LmlzQXJyYXldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXkpXHJcblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gaW5kZXhPZihhcnJheTogQXJyYXksIGVsOiBPYmplY3QpOiBOdW1iZXJcclxuXHQvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkucHJvdG90eXBlLmluZGV4T2ZdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2YpXHJcblx0aW5kZXhPZjogZnVuY3Rpb24gKGFycmF5LCBlbCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAoYXJyYXlbaV0gPT09IGVsKSB7IHJldHVybiBpOyB9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fSxcclxuXHJcblx0Ly8gQHByb3BlcnR5IGVtcHR5SW1hZ2VVcmw6IFN0cmluZ1xyXG5cdC8vIERhdGEgVVJJIHN0cmluZyBjb250YWluaW5nIGEgYmFzZTY0LWVuY29kZWQgZW1wdHkgR0lGIGltYWdlLlxyXG5cdC8vIFVzZWQgYXMgYSBoYWNrIHRvIGZyZWUgbWVtb3J5IGZyb20gdW51c2VkIGltYWdlcyBvbiBXZWJLaXQtcG93ZXJlZFxyXG5cdC8vIG1vYmlsZSBkZXZpY2VzIChieSBzZXR0aW5nIGltYWdlIGBzcmNgIHRvIHRoaXMgc3RyaW5nKS5cclxuXHRlbXB0eUltYWdlVXJsOiAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBRC9BQ3dBQUFBQUFRQUJBQUFDQURzPSdcclxufTtcclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcblx0Ly8gaW5zcGlyZWQgYnkgaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuXHJcblx0ZnVuY3Rpb24gZ2V0UHJlZml4ZWQobmFtZSkge1xyXG5cdFx0cmV0dXJuIHdpbmRvd1snd2Via2l0JyArIG5hbWVdIHx8IHdpbmRvd1snbW96JyArIG5hbWVdIHx8IHdpbmRvd1snbXMnICsgbmFtZV07XHJcblx0fVxyXG5cclxuXHR2YXIgbGFzdFRpbWUgPSAwO1xyXG5cclxuXHQvLyBmYWxsYmFjayBmb3IgSUUgNy04XHJcblx0ZnVuY3Rpb24gdGltZW91dERlZmVyKGZuKSB7XHJcblx0XHR2YXIgdGltZSA9ICtuZXcgRGF0ZSgpLFxyXG5cdFx0ICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtICh0aW1lIC0gbGFzdFRpbWUpKTtcclxuXHJcblx0XHRsYXN0VGltZSA9IHRpbWUgKyB0aW1lVG9DYWxsO1xyXG5cdFx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lVG9DYWxsKTtcclxuXHR9XHJcblxyXG5cdHZhciByZXF1ZXN0Rm4gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCB0aW1lb3V0RGVmZXIsXHJcblx0ICAgIGNhbmNlbEZuID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdDYW5jZWxBbmltYXRpb25GcmFtZScpIHx8XHJcblx0ICAgICAgICAgICAgICAgZ2V0UHJlZml4ZWQoJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IGZ1bmN0aW9uIChpZCkgeyB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTsgfTtcclxuXHJcblxyXG5cdC8vIEBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCwgaW1tZWRpYXRlPzogQm9vbGVhbik6IE51bWJlclxyXG5cdC8vIFNjaGVkdWxlcyBgZm5gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGJyb3dzZXIgcmVwYWludHMuIGBmbmAgaXMgYm91bmQgdG9cclxuXHQvLyBgY29udGV4dGAgaWYgZ2l2ZW4uIFdoZW4gYGltbWVkaWF0ZWAgaXMgc2V0LCBgZm5gIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBpZlxyXG5cdC8vIHRoZSBicm93c2VyIGRvZXNuJ3QgaGF2ZSBuYXRpdmUgc3VwcG9ydCBmb3JcclxuXHQvLyBbYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZSksXHJcblx0Ly8gb3RoZXJ3aXNlIGl0J3MgZGVsYXllZC4gUmV0dXJucyBhIHJlcXVlc3QgSUQgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXHJcblx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUgPSBmdW5jdGlvbiAoZm4sIGNvbnRleHQsIGltbWVkaWF0ZSkge1xyXG5cdFx0aWYgKGltbWVkaWF0ZSAmJiByZXF1ZXN0Rm4gPT09IHRpbWVvdXREZWZlcikge1xyXG5cdFx0XHRmbi5jYWxsKGNvbnRleHQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHJlcXVlc3RGbi5jYWxsKHdpbmRvdywgTC5iaW5kKGZuLCBjb250ZXh0KSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZDogTnVtYmVyKTogdW5kZWZpbmVkXHJcblx0Ly8gQ2FuY2VscyBhIHByZXZpb3VzIGByZXF1ZXN0QW5pbUZyYW1lYC4gU2VlIGFsc28gW3dpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9jYW5jZWxBbmltYXRpb25GcmFtZSkuXHJcblx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0aWYgKGlkKSB7XHJcblx0XHRcdGNhbmNlbEZuLmNhbGwod2luZG93LCBpZCk7XHJcblx0XHR9XHJcblx0fTtcclxufSkoKTtcclxuXHJcbi8vIHNob3J0Y3V0cyBmb3IgbW9zdCB1c2VkIHV0aWxpdHkgZnVuY3Rpb25zXHJcbkwuZXh0ZW5kID0gTC5VdGlsLmV4dGVuZDtcclxuTC5iaW5kID0gTC5VdGlsLmJpbmQ7XHJcbkwuc3RhbXAgPSBMLlV0aWwuc3RhbXA7XHJcbkwuc2V0T3B0aW9ucyA9IEwuVXRpbC5zZXRPcHRpb25zO1xyXG5cblxyXG4vLyBAY2xhc3MgQ2xhc3NcclxuLy8gQGFrYSBMLkNsYXNzXHJcblxyXG4vLyBAc2VjdGlvblxyXG4vLyBAdW5pbmhlcml0YWJsZVxyXG5cclxuLy8gVGhhbmtzIHRvIEpvaG4gUmVzaWcgYW5kIERlYW4gRWR3YXJkcyBmb3IgaW5zcGlyYXRpb24hXHJcblxyXG5MLkNsYXNzID0gZnVuY3Rpb24gKCkge307XHJcblxyXG5MLkNsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gZXh0ZW5kKHByb3BzOiBPYmplY3QpOiBGdW5jdGlvblxyXG5cdC8vIFtFeHRlbmRzIHRoZSBjdXJyZW50IGNsYXNzXSgjY2xhc3MtaW5oZXJpdGFuY2UpIGdpdmVuIHRoZSBwcm9wZXJ0aWVzIHRvIGJlIGluY2x1ZGVkLlxyXG5cdC8vIFJldHVybnMgYSBKYXZhc2NyaXB0IGZ1bmN0aW9uIHRoYXQgaXMgYSBjbGFzcyBjb25zdHJ1Y3RvciAodG8gYmUgY2FsbGVkIHdpdGggYG5ld2ApLlxyXG5cdHZhciBOZXdDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBjYWxsIHRoZSBjb25zdHJ1Y3RvclxyXG5cdFx0aWYgKHRoaXMuaW5pdGlhbGl6ZSkge1xyXG5cdFx0XHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjYWxsIGFsbCBjb25zdHJ1Y3RvciBob29rc1xyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblx0fTtcclxuXHJcblx0dmFyIHBhcmVudFByb3RvID0gTmV3Q2xhc3MuX19zdXBlcl9fID0gdGhpcy5wcm90b3R5cGU7XHJcblxyXG5cdHZhciBwcm90byA9IEwuVXRpbC5jcmVhdGUocGFyZW50UHJvdG8pO1xyXG5cdHByb3RvLmNvbnN0cnVjdG9yID0gTmV3Q2xhc3M7XHJcblxyXG5cdE5ld0NsYXNzLnByb3RvdHlwZSA9IHByb3RvO1xyXG5cclxuXHQvLyBpbmhlcml0IHBhcmVudCdzIHN0YXRpY3NcclxuXHRmb3IgKHZhciBpIGluIHRoaXMpIHtcclxuXHRcdGlmICh0aGlzLmhhc093blByb3BlcnR5KGkpICYmIGkgIT09ICdwcm90b3R5cGUnKSB7XHJcblx0XHRcdE5ld0NsYXNzW2ldID0gdGhpc1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIG1peCBzdGF0aWMgcHJvcGVydGllcyBpbnRvIHRoZSBjbGFzc1xyXG5cdGlmIChwcm9wcy5zdGF0aWNzKSB7XHJcblx0XHRMLmV4dGVuZChOZXdDbGFzcywgcHJvcHMuc3RhdGljcyk7XHJcblx0XHRkZWxldGUgcHJvcHMuc3RhdGljcztcclxuXHR9XHJcblxyXG5cdC8vIG1peCBpbmNsdWRlcyBpbnRvIHRoZSBwcm90b3R5cGVcclxuXHRpZiAocHJvcHMuaW5jbHVkZXMpIHtcclxuXHRcdEwuVXRpbC5leHRlbmQuYXBwbHkobnVsbCwgW3Byb3RvXS5jb25jYXQocHJvcHMuaW5jbHVkZXMpKTtcclxuXHRcdGRlbGV0ZSBwcm9wcy5pbmNsdWRlcztcclxuXHR9XHJcblxyXG5cdC8vIG1lcmdlIG9wdGlvbnNcclxuXHRpZiAocHJvdG8ub3B0aW9ucykge1xyXG5cdFx0cHJvcHMub3B0aW9ucyA9IEwuVXRpbC5leHRlbmQoTC5VdGlsLmNyZWF0ZShwcm90by5vcHRpb25zKSwgcHJvcHMub3B0aW9ucyk7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggZ2l2ZW4gcHJvcGVydGllcyBpbnRvIHRoZSBwcm90b3R5cGVcclxuXHRMLmV4dGVuZChwcm90bywgcHJvcHMpO1xyXG5cclxuXHRwcm90by5faW5pdEhvb2tzID0gW107XHJcblxyXG5cdC8vIGFkZCBtZXRob2QgZm9yIGNhbGxpbmcgYWxsIGhvb2tzXHJcblx0cHJvdG8uY2FsbEluaXRIb29rcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdEhvb2tzQ2FsbGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzKSB7XHJcblx0XHRcdHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MuY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SG9va3NDYWxsZWQgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm90by5faW5pdEhvb2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHByb3RvLl9pbml0SG9va3NbaV0uY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gTmV3Q2xhc3M7XHJcbn07XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGluY2x1ZGUocHJvcGVydGllczogT2JqZWN0KTogdGhpc1xyXG4vLyBbSW5jbHVkZXMgYSBtaXhpbl0oI2NsYXNzLWluY2x1ZGVzKSBpbnRvIHRoZSBjdXJyZW50IGNsYXNzLlxyXG5MLkNsYXNzLmluY2x1ZGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHRMLmV4dGVuZCh0aGlzLnByb3RvdHlwZSwgcHJvcHMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtNZXJnZXMgYG9wdGlvbnNgXSgjY2xhc3Mtb3B0aW9ucykgaW50byB0aGUgZGVmYXVsdHMgb2YgdGhlIGNsYXNzLlxyXG5MLkNsYXNzLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0TC5leHRlbmQodGhpcy5wcm90b3R5cGUub3B0aW9ucywgb3B0aW9ucyk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkSW5pdEhvb2soZm46IEZ1bmN0aW9uKTogdGhpc1xyXG4vLyBBZGRzIGEgW2NvbnN0cnVjdG9yIGhvb2tdKCNjbGFzcy1jb25zdHJ1Y3Rvci1ob29rcykgdG8gdGhlIGNsYXNzLlxyXG5MLkNsYXNzLmFkZEluaXRIb29rID0gZnVuY3Rpb24gKGZuKSB7IC8vIChGdW5jdGlvbikgfHwgKFN0cmluZywgYXJncy4uLilcclxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblxyXG5cdHZhciBpbml0ID0gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nID8gZm4gOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzW2ZuXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHR9O1xyXG5cclxuXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzID0gdGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyB8fCBbXTtcclxuXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzLnB1c2goaW5pdCk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxuLypcclxuICogQGNsYXNzIEV2ZW50ZWRcclxuICogQGFrYSBMLkV2ZW50ZWRcclxuICogQGluaGVyaXRzIENsYXNzXHJcbiAqXHJcbiAqIEEgc2V0IG9mIG1ldGhvZHMgc2hhcmVkIGJldHdlZW4gZXZlbnQtcG93ZXJlZCBjbGFzc2VzIChsaWtlIGBNYXBgIGFuZCBgTWFya2VyYCkuIEdlbmVyYWxseSwgZXZlbnRzIGFsbG93IHlvdSB0byBleGVjdXRlIHNvbWUgZnVuY3Rpb24gd2hlbiBzb21ldGhpbmcgaGFwcGVucyB3aXRoIGFuIG9iamVjdCAoZS5nLiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIG1hcCwgY2F1c2luZyB0aGUgbWFwIHRvIGZpcmUgYCdjbGljaydgIGV2ZW50KS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogbWFwLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICogXHRhbGVydChlLmxhdGxuZyk7XHJcbiAqIH0gKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIExlYWZsZXQgZGVhbHMgd2l0aCBldmVudCBsaXN0ZW5lcnMgYnkgcmVmZXJlbmNlLCBzbyBpZiB5b3Ugd2FudCB0byBhZGQgYSBsaXN0ZW5lciBhbmQgdGhlbiByZW1vdmUgaXQsIGRlZmluZSBpdCBhcyBhIGZ1bmN0aW9uOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBmdW5jdGlvbiBvbkNsaWNrKGUpIHsgLi4uIH1cclxuICpcclxuICogbWFwLm9uKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gKiBtYXAub2ZmKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuTC5FdmVudGVkID0gTC5DbGFzcy5leHRlbmQoe1xyXG5cclxuXHQvKiBAbWV0aG9kIG9uKHR5cGU6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdCAqIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIGV2ZW50IHR5cGUgb2YgdGhlIG9iamVjdC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyIChvYmplY3QgdGhlIHRoaXMga2V5d29yZCB3aWxsIHBvaW50IHRvKS4gWW91IGNhbiBhbHNvIHBhc3Mgc2V2ZXJhbCBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb24oZXZlbnRNYXA6IE9iamVjdCk6IHRoaXNcclxuXHQgKiBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcblx0ICovXHJcblx0b246IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHQvLyB0eXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHQvLyB3ZSBkb24ndCBwcm9jZXNzIHNwYWNlLXNlcGFyYXRlZCBldmVudHMgaGVyZSBmb3IgcGVyZm9ybWFuY2U7XHJcblx0XHRcdFx0Ly8gaXQncyBhIGhvdCBwYXRoIHNpbmNlIExheWVyIHVzZXMgdGhlIG9uKG9iaikgc3ludGF4XHJcblx0XHRcdFx0dGhpcy5fb24odHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIHR5cGVzIGNhbiBiZSBhIHN0cmluZyBvZiBzcGFjZS1zZXBhcmF0ZWQgd29yZHNcclxuXHRcdFx0dHlwZXMgPSBMLlV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0LyogQG1ldGhvZCBvZmYodHlwZTogU3RyaW5nLCBmbj86IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLiBJZiBubyBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoYXQgcGFydGljdWxhciBldmVudCBmcm9tIHRoZSBvYmplY3QuIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gYG9uYCwgeW91IG11c3QgcGFzcyB0aGUgc2FtZSBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9mZihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycy5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIHRvIGFsbCBldmVudHMgb24gdGhlIG9iamVjdC5cclxuXHQgKi9cclxuXHRvZmY6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAoIXR5cGVzKSB7XHJcblx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgaWYgY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzXHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHR5cGVzID0gTC5VdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBhdHRhY2ggbGlzdGVuZXIgKHdpdGhvdXQgc3ludGFjdGljIHN1Z2FyIG5vdylcclxuXHRfb246IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xyXG5cclxuXHRcdC8qIGdldC9pbml0IGxpc3RlbmVycyBmb3IgdHlwZSAqL1xyXG5cdFx0dmFyIHR5cGVMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRpZiAoIXR5cGVMaXN0ZW5lcnMpIHtcclxuXHRcdFx0dHlwZUxpc3RlbmVycyA9IFtdO1xyXG5cdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSB0eXBlTGlzdGVuZXJzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcblx0XHRcdC8vIExlc3MgbWVtb3J5IGZvb3RwcmludC5cclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHRcdHZhciBuZXdMaXN0ZW5lciA9IHtmbjogZm4sIGN0eDogY29udGV4dH0sXHJcblx0XHQgICAgbGlzdGVuZXJzID0gdHlwZUxpc3RlbmVycztcclxuXHJcblx0XHQvLyBjaGVjayBpZiBmbiBhbHJlYWR5IHRoZXJlXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuICYmIGxpc3RlbmVyc1tpXS5jdHggPT09IGNvbnRleHQpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsaXN0ZW5lcnMucHVzaChuZXdMaXN0ZW5lcik7XHJcblx0XHR0eXBlTGlzdGVuZXJzLmNvdW50Kys7XHJcblx0fSxcclxuXHJcblx0X29mZjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzLFxyXG5cdFx0ICAgIGksXHJcblx0XHQgICAgbGVuO1xyXG5cclxuXHRcdGlmICghdGhpcy5fZXZlbnRzKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHJcblx0XHRpZiAoIWxpc3RlbmVycykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFmbikge1xyXG5cdFx0XHQvLyBTZXQgYWxsIHJlbW92ZWQgbGlzdGVuZXJzIHRvIG5vb3Agc28gdGhleSBhcmUgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGxpc3RlbmVyc1tpXS5mbiA9IEwuVXRpbC5mYWxzZUZuO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgZm9yIGEgdHlwZSBpZiBmdW5jdGlvbiBpc24ndCBzcGVjaWZpZWRcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcblx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxpc3RlbmVycykge1xyXG5cclxuXHRcdFx0Ly8gZmluZCBmbiBhbmQgcmVtb3ZlIGl0XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHZhciBsID0gbGlzdGVuZXJzW2ldO1xyXG5cdFx0XHRcdGlmIChsLmN0eCAhPT0gY29udGV4dCkgeyBjb250aW51ZTsgfVxyXG5cdFx0XHRcdGlmIChsLmZuID09PSBmbikge1xyXG5cclxuXHRcdFx0XHRcdC8vIHNldCB0aGUgcmVtb3ZlZCBsaXN0ZW5lciB0byBub29wIHNvIHRoYXQncyBub3QgY2FsbGVkIGlmIHJlbW92ZSBoYXBwZW5zIGluIGZpcmVcclxuXHRcdFx0XHRcdGwuZm4gPSBMLlV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuXHRcdFx0XHRcdFx0LyogY29weSBhcnJheSBpbiBjYXNlIGV2ZW50cyBhcmUgYmVpbmcgZmlyZWQgKi9cclxuXHRcdFx0XHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpcmUodHlwZTogU3RyaW5nLCBkYXRhPzogT2JqZWN0LCBwcm9wYWdhdGU/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIEZpcmVzIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS4gWW91IGNhbiBvcHRpb25hbGx5IHByb3ZpZGUgYW4gZGF0YVxyXG5cdC8vIG9iamVjdCDigJQgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBsaXN0ZW5lciBmdW5jdGlvbiB3aWxsIGNvbnRhaW4gaXRzXHJcblx0Ly8gcHJvcGVydGllcy4gVGhlIGV2ZW50IG1pZ2h0IGNhbiBvcHRpb25hbGx5IGJlIHByb3BhZ2F0ZWQgdG8gZXZlbnQgcGFyZW50cy5cclxuXHRmaXJlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSwgcHJvcGFnYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMubGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGV2ZW50ID0gTC5VdGlsLmV4dGVuZCh7fSwgZGF0YSwge3R5cGU6IHR5cGUsIHRhcmdldDogdGhpc30pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9ldmVudHMpIHtcclxuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHJcblx0XHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudCA9ICh0aGlzLl9maXJpbmdDb3VudCArIDEpIHx8IDE7XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcblx0XHRcdFx0XHRsLmZuLmNhbGwobC5jdHggfHwgdGhpcywgZXZlbnQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQtLTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuXHRcdFx0Ly8gcHJvcGFnYXRlIHRoZSBldmVudCB0byBwYXJlbnRzIChzZXQgd2l0aCBhZGRFdmVudFBhcmVudClcclxuXHRcdFx0dGhpcy5fcHJvcGFnYXRlRXZlbnQoZXZlbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGlzdGVucyh0eXBlOiBTdHJpbmcpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYSBwYXJ0aWN1bGFyIGV2ZW50IHR5cGUgaGFzIGFueSBsaXN0ZW5lcnMgYXR0YWNoZWQgdG8gaXQuXHJcblx0bGlzdGVuczogZnVuY3Rpb24gKHR5cGUsIHByb3BhZ2F0ZSkge1xyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRpZiAobGlzdGVuZXJzICYmIGxpc3RlbmVycy5sZW5ndGgpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0XHRpZiAocHJvcGFnYXRlKSB7XHJcblx0XHRcdC8vIGFsc28gY2hlY2sgcGFyZW50cyBmb3IgbGlzdGVuZXJzIGlmIGV2ZW50IHByb3BhZ2F0ZXNcclxuXHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50c1tpZF0ubGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG9uY2Uo4oCmKTogdGhpc1xyXG5cdC8vIEJlaGF2ZXMgYXMgW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pLCBleGNlcHQgdGhlIGxpc3RlbmVyIHdpbGwgb25seSBnZXQgZmlyZWQgb25jZSBhbmQgdGhlbiByZW1vdmVkLlxyXG5cdG9uY2U6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0dGhpcy5vbmNlKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSBMLmJpbmQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAub2ZmKHR5cGVzLCBmbiwgY29udGV4dClcclxuXHRcdFx0ICAgIC5vZmYodHlwZXMsIGhhbmRsZXIsIGNvbnRleHQpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0Ly8gYWRkIGEgbGlzdGVuZXIgdGhhdCdzIGV4ZWN1dGVkIG9uY2UgYW5kIHJlbW92ZWQgYWZ0ZXIgdGhhdFxyXG5cdFx0cmV0dXJuIHRoaXNcclxuXHRcdCAgICAub24odHlwZXMsIGZuLCBjb250ZXh0KVxyXG5cdFx0ICAgIC5vbih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBldmVudCBwYXJlbnQgLSBhbiBgRXZlbnRlZGAgdGhhdCB3aWxsIHJlY2VpdmUgcHJvcGFnYXRlZCBldmVudHNcclxuXHRhZGRFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dGhpcy5fZXZlbnRQYXJlbnRzID0gdGhpcy5fZXZlbnRQYXJlbnRzIHx8IHt9O1xyXG5cdFx0dGhpcy5fZXZlbnRQYXJlbnRzW0wuc3RhbXAob2JqKV0gPSBvYmo7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFuIGV2ZW50IHBhcmVudCwgc28gaXQgd2lsbCBzdG9wIHJlY2VpdmluZyBwcm9wYWdhdGVkIGV2ZW50c1xyXG5cdHJlbW92ZUV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudFBhcmVudHNbTC5zdGFtcChvYmopXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9wcm9wYWdhdGVFdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHR0aGlzLl9ldmVudFBhcmVudHNbaWRdLmZpcmUoZS50eXBlLCBMLmV4dGVuZCh7bGF5ZXI6IGUudGFyZ2V0fSwgZSksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG52YXIgcHJvdG8gPSBMLkV2ZW50ZWQucHJvdG90eXBlO1xyXG5cclxuLy8gYWxpYXNlczsgd2Ugc2hvdWxkIGRpdGNoIHRob3NlIGV2ZW50dWFsbHlcclxuXHJcbi8vIEBtZXRob2QgYWRkRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKVxyXG5wcm90by5hZGRFdmVudExpc3RlbmVyID0gcHJvdG8ub247XHJcblxyXG4vLyBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9mZijigKYpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5cclxuLy8gQG1ldGhvZCBjbGVhckFsbEV2ZW50TGlzdGVuZXJzKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvZmYoKWBdKCNldmVudGVkLW9mZilcclxucHJvdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHByb3RvLmNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMgPSBwcm90by5vZmY7XHJcblxyXG4vLyBAbWV0aG9kIGFkZE9uZVRpbWVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbmNlKOKApilgXSgjZXZlbnRlZC1vbmNlKVxyXG5wcm90by5hZGRPbmVUaW1lRXZlbnRMaXN0ZW5lciA9IHByb3RvLm9uY2U7XHJcblxyXG4vLyBAbWV0aG9kIGZpcmVFdmVudCjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgZmlyZSjigKYpYF0oI2V2ZW50ZWQtZmlyZSlcclxucHJvdG8uZmlyZUV2ZW50ID0gcHJvdG8uZmlyZTtcclxuXHJcbi8vIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lcnMo4oCmKTogQm9vbGVhblxyXG4vLyBBbGlhcyB0byBbYGxpc3RlbnMo4oCmKWBdKCNldmVudGVkLWxpc3RlbnMpXHJcbnByb3RvLmhhc0V2ZW50TGlzdGVuZXJzID0gcHJvdG8ubGlzdGVucztcclxuXHJcbkwuTWl4aW4gPSB7RXZlbnRzOiBwcm90b307XHJcblxuLypcclxuICogQG5hbWVzcGFjZSBCcm93c2VyXHJcbiAqIEBha2EgTC5Ccm93c2VyXHJcbiAqXHJcbiAqIEEgbmFtZXNwYWNlIHdpdGggc3RhdGljIHByb3BlcnRpZXMgZm9yIGJyb3dzZXIvZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGlmIChMLkJyb3dzZXIuaWVsdDkpIHtcclxuICogICBhbGVydCgnVXBncmFkZSB5b3VyIGJyb3dzZXIsIGR1ZGUhJyk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLFxyXG5cdCAgICBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXHJcblxyXG5cdCAgICBpZSA9ICdBY3RpdmVYT2JqZWN0JyBpbiB3aW5kb3csXHJcblxyXG5cdCAgICB3ZWJraXQgICAgPSB1YS5pbmRleE9mKCd3ZWJraXQnKSAhPT0gLTEsXHJcblx0ICAgIHBoYW50b21qcyA9IHVhLmluZGV4T2YoJ3BoYW50b20nKSAhPT0gLTEsXHJcblx0ICAgIGFuZHJvaWQyMyA9IHVhLnNlYXJjaCgnYW5kcm9pZCBbMjNdJykgIT09IC0xLFxyXG5cdCAgICBjaHJvbWUgICAgPSB1YS5pbmRleE9mKCdjaHJvbWUnKSAhPT0gLTEsXHJcblx0ICAgIGdlY2tvICAgICA9IHVhLmluZGV4T2YoJ2dlY2tvJykgIT09IC0xICAmJiAhd2Via2l0ICYmICF3aW5kb3cub3BlcmEgJiYgIWllLFxyXG5cclxuXHQgICAgd2luID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ1dpbicpID09PSAwLFxyXG5cclxuXHQgICAgbW9iaWxlID0gdHlwZW9mIG9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJyB8fCB1YS5pbmRleE9mKCdtb2JpbGUnKSAhPT0gLTEsXHJcblx0ICAgIG1zUG9pbnRlciA9ICF3aW5kb3cuUG9pbnRlckV2ZW50ICYmIHdpbmRvdy5NU1BvaW50ZXJFdmVudCxcclxuXHQgICAgcG9pbnRlciA9IHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgbXNQb2ludGVyLFxyXG5cclxuXHQgICAgaWUzZCA9IGllICYmICgndHJhbnNpdGlvbicgaW4gZG9jLnN0eWxlKSxcclxuXHQgICAgd2Via2l0M2QgPSAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93KSAmJiAoJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSkgJiYgIWFuZHJvaWQyMyxcclxuXHQgICAgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gZG9jLnN0eWxlLFxyXG5cdCAgICBvcGVyYTEyID0gJ09UcmFuc2l0aW9uJyBpbiBkb2Muc3R5bGU7XHJcblxyXG5cclxuXHR2YXIgdG91Y2ggPSAhd2luZG93LkxfTk9fVE9VQ0ggJiYgKHBvaW50ZXIgfHwgJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8XHJcblx0XHRcdCh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSk7XHJcblxyXG5cdEwuQnJvd3NlciA9IHtcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgaWU6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIChub3QgRWRnZSkuXHJcblx0XHRpZTogaWUsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IGllbHQ5OiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIGxlc3MgdGhhbiA5LlxyXG5cdFx0aWVsdDk6IGllICYmICFkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBlZGdlOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIHRoZSBFZGdlIHdlYiBicm93c2VyLlxyXG5cdFx0ZWRnZTogJ21zTGF1bmNoVXJpJyBpbiBuYXZpZ2F0b3IgJiYgISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCksXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IHdlYmtpdDogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgbGlrZSBDaHJvbWUgYW5kIFNhZmFyaSAoaW5jbHVkaW5nIG1vYmlsZSB2ZXJzaW9ucykuXHJcblx0XHR3ZWJraXQ6IHdlYmtpdCxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgZ2Vja286IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgbGlrZSBGaXJlZm94LlxyXG5cdFx0Z2Vja286IGdlY2tvLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBhbmRyb2lkOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFueSBicm93c2VyIHJ1bm5pbmcgb24gYW4gQW5kcm9pZCBwbGF0Zm9ybS5cclxuXHRcdGFuZHJvaWQ6IHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IGFuZHJvaWQyMzogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBicm93c2VycyBydW5uaW5nIG9uIEFuZHJvaWQgMiBvciBBbmRyb2lkIDMuXHJcblx0XHRhbmRyb2lkMjM6IGFuZHJvaWQyMyxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgY2hyb21lOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIHRoZSBDaHJvbWUgYnJvd3Nlci5cclxuXHRcdGNocm9tZTogY2hyb21lLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBzYWZhcmk6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgdGhlIFNhZmFyaSBicm93c2VyLlxyXG5cdFx0c2FmYXJpOiAhY2hyb21lICYmIHVhLmluZGV4T2YoJ3NhZmFyaScpICE9PSAtMSxcclxuXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IHdpbjogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIFdpbmRvd3MgcGxhdGZvcm1cclxuXHRcdHdpbjogd2luLFxyXG5cclxuXHJcblx0XHQvLyBAcHJvcGVydHkgaWUzZDogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuXHRcdGllM2Q6IGllM2QsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IHdlYmtpdDNkOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5cdFx0d2Via2l0M2Q6IHdlYmtpdDNkLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBnZWNrbzNkOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcblx0XHRnZWNrbzNkOiBnZWNrbzNkLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBvcGVyYTEyOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMgKHZlcnNpb24gMTIgb3IgbGF0ZXIpLlxyXG5cdFx0b3BlcmExMjogb3BlcmExMixcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgYW55M2Q6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcblx0XHRhbnkzZDogIXdpbmRvdy5MX0RJU0FCTEVfM0QgJiYgKGllM2QgfHwgd2Via2l0M2QgfHwgZ2Vja28zZCkgJiYgIW9wZXJhMTIgJiYgIXBoYW50b21qcyxcclxuXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1vYmlsZTogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcblx0XHRtb2JpbGU6IG1vYmlsZSxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0OiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5cdFx0bW9iaWxlV2Via2l0OiBtb2JpbGUgJiYgd2Via2l0LFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtb2JpbGVXZWJraXQzZDogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZSBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5cdFx0bW9iaWxlV2Via2l0M2Q6IG1vYmlsZSAmJiB3ZWJraXQzZCxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbW9iaWxlT3BlcmE6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5cdFx0bW9iaWxlT3BlcmE6IG1vYmlsZSAmJiB3aW5kb3cub3BlcmEsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1vYmlsZUdlY2tvOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5cdFx0bW9iaWxlR2Vja286IG1vYmlsZSAmJiBnZWNrbyxcclxuXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IHRvdWNoOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFt0b3VjaCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Ub3VjaF9ldmVudHMpLlxyXG5cdFx0dG91Y2g6ICEhdG91Y2gsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1zUG9pbnRlcjogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBicm93c2VycyBpbXBsZW1lbnRpbmcgdGhlIE1pY3Jvc29mdCB0b3VjaCBldmVudHMgbW9kZWwgKG5vdGFibHkgSUUxMCkuXHJcblx0XHRtc1BvaW50ZXI6ICEhbXNQb2ludGVyLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBwb2ludGVyOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFtwb2ludGVyIGV2ZW50c10oaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kbjQzMzI0NCUyOHY9dnMuODUlMjkuYXNweCkuXHJcblx0XHRwb2ludGVyOiAhIXBvaW50ZXIsXHJcblxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSByZXRpbmE6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgb24gYSBoaWdoLXJlc29sdXRpb24gXCJyZXRpbmFcIiBzY3JlZW4uXHJcblx0XHRyZXRpbmE6ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAod2luZG93LnNjcmVlbi5kZXZpY2VYRFBJIC8gd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSkpID4gMVxyXG5cdH07XHJcblxyXG59KCkpO1xyXG5cbi8qXHJcbiAqIEBjbGFzcyBQb2ludFxyXG4gKiBAYWthIEwuUG9pbnRcclxuICpcclxuICogUmVwcmVzZW50cyBhIHBvaW50IHdpdGggYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgaW4gcGl4ZWxzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcG9pbnQgPSBMLnBvaW50KDIwMCwgMzAwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgYW5kIG9wdGlvbnMgdGhhdCBhY2NlcHQgYFBvaW50YCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAucGFuQnkoWzIwMCwgMzAwXSk7XHJcbiAqIG1hcC5wYW5CeShMLnBvaW50KDIwMCwgMzAwKSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuUG9pbnQgPSBmdW5jdGlvbiAoeCwgeSwgcm91bmQpIHtcclxuXHR0aGlzLnggPSAocm91bmQgPyBNYXRoLnJvdW5kKHgpIDogeCk7XHJcblx0dGhpcy55ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh5KSA6IHkpO1xyXG59O1xyXG5cclxuTC5Qb2ludC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdC8vIEBtZXRob2QgY2xvbmUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludC5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFkZGl0aW9uIG9mIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGFkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBub24tZGVzdHJ1Y3RpdmUsIHJldHVybnMgYSBuZXcgcG9pbnRcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2FkZChMLnBvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0X2FkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBkZXN0cnVjdGl2ZSwgdXNlZCBkaXJlY3RseSBmb3IgcGVyZm9ybWFuY2UgaW4gc2l0dWF0aW9ucyB3aGVyZSBpdCdzIHNhZmUgdG8gbW9kaWZ5IGV4aXN0aW5nIHBvaW50XHJcblx0XHR0aGlzLnggKz0gcG9pbnQueDtcclxuXHRcdHRoaXMueSArPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzdWJ0cmFjdChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCBmcm9tIHRoZSBjdXJyZW50LlxyXG5cdHN1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3N1YnRyYWN0KEwucG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfc3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dGhpcy54IC09IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgLT0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGl2aWRlQnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG5cdGRpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZpZGVCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9kaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54IC89IG51bTtcclxuXHRcdHRoaXMueSAvPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG11bHRpcGx5QnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG5cdG11bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX211bHRpcGx5QnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfbXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54ICo9IG51bTtcclxuXHRcdHRoaXMueSAqPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBNdWx0aXBseSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgZWFjaCBjb29yZGluYXRlIG9mXHJcblx0Ly8gYHNjYWxlYC4gSW4gbGluZWFyIGFsZ2VicmEgdGVybXMsIG11bHRpcGx5IHRoZSBwb2ludCBieSB0aGVcclxuXHQvLyBbc2NhbGluZyBtYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NjYWxpbmdfJTI4Z2VvbWV0cnklMjkjTWF0cml4X3JlcHJlc2VudGF0aW9uKVxyXG5cdC8vIGRlZmluZWQgYnkgYHNjYWxlYC5cclxuXHRzY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh0aGlzLnggKiBwb2ludC54LCB0aGlzLnkgKiBwb2ludC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEludmVyc2Ugb2YgYHNjYWxlQnlgLiBEaXZpZGUgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5XHJcblx0Ly8gZWFjaCBjb29yZGluYXRlIG9mIGBzY2FsZWAuXHJcblx0dW5zY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh0aGlzLnggLyBwb2ludC54LCB0aGlzLnkgLyBwb2ludC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJvdW5kKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCByb3VuZGVkIGNvb3JkaW5hdGVzLlxyXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9yb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbG9vcigpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggZmxvb3JlZCBjb29yZGluYXRlcyAocm91bmRlZCBkb3duKS5cclxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZmxvb3IoKTtcclxuXHR9LFxyXG5cclxuXHRfZmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2VpbCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggY2VpbGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHVwKS5cclxuXHRjZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9jZWlsKCk7XHJcblx0fSxcclxuXHJcblx0X2NlaWw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJQb2ludDogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjYXJ0ZXNpYW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gTC5wb2ludChwb2ludCk7XHJcblxyXG5cdFx0dmFyIHggPSBwb2ludC54IC0gdGhpcy54LFxyXG5cdFx0ICAgIHkgPSBwb2ludC55IC0gdGhpcy55O1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBvaW50IGhhcyB0aGUgc2FtZSBjb29yZGluYXRlcy5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSBMLnBvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQueCA9PT0gdGhpcy54ICYmXHJcblx0XHQgICAgICAgcG9pbnQueSA9PT0gdGhpcy55O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBjb29yZGluYXRlcyBvZiB0aGUgZ2l2ZW4gcG9pbnQgYXJlIGxlc3MgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBjdXJyZW50IHBvaW50IGNvb3JkaW5hdGVzIChpbiBhYnNvbHV0ZSB2YWx1ZXMpLlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gTC5wb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKHBvaW50LngpIDw9IE1hdGguYWJzKHRoaXMueCkgJiZcclxuXHRcdCAgICAgICBNYXRoLmFicyhwb2ludC55KSA8PSBNYXRoLmFicyh0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICdQb2ludCgnICtcclxuXHRcdCAgICAgICAgTC5VdGlsLmZvcm1hdE51bSh0aGlzLngpICsgJywgJyArXHJcblx0XHQgICAgICAgIEwuVXRpbC5mb3JtYXROdW0odGhpcy55KSArICcpJztcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KHg6IE51bWJlciwgeTogTnVtYmVyLCByb3VuZD86IEJvb2xlYW4pXHJcbi8vIENyZWF0ZXMgYSBQb2ludCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMuIElmIG9wdGlvbmFsIGByb3VuZGAgaXMgc2V0IHRvIHRydWUsIHJvdW5kcyB0aGUgYHhgIGFuZCBgeWAgdmFsdWVzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBOdW1iZXJbXSlcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW3gsIHldYCBpbnN0ZWFkLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBPYmplY3QpXHJcbi8vIEV4cGVjdHMgYSBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHt4OiBOdW1iZXIsIHk6IE51bWJlcn1gIGluc3RlYWQuXHJcbkwucG9pbnQgPSBmdW5jdGlvbiAoeCwgeSwgcm91bmQpIHtcclxuXHRpZiAoeCBpbnN0YW5jZW9mIEwuUG9pbnQpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAoTC5VdGlsLmlzQXJyYXkoeCkpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh4WzBdLCB4WzFdKTtcclxuXHR9XHJcblx0aWYgKHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiAneCcgaW4geCAmJiAneScgaW4geCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHgueCwgeC55KTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMLlBvaW50KHgsIHksIHJvdW5kKTtcclxufTtcclxuXG4vKlxyXG4gKiBAY2xhc3MgQm91bmRzXHJcbiAqIEBha2EgTC5Cb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgaW4gcGl4ZWwgY29vcmRpbmF0ZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwMSA9IEwucG9pbnQoMTAsIDEwKSxcclxuICogcDIgPSBMLnBvaW50KDQwLCA2MCksXHJcbiAqIGJvdW5kcyA9IEwuYm91bmRzKHAxLCBwMik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IGBCb3VuZHNgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBvdGhlckJvdW5kcy5pbnRlcnNlY3RzKFtbMTAsIDEwXSwgWzQwLCA2MF1dKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5Cb3VuZHMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG5cdGlmICghYSkgeyByZXR1cm47IH1cclxuXHJcblx0dmFyIHBvaW50cyA9IGIgPyBbYSwgYl0gOiBhO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR0aGlzLmV4dGVuZChwb2ludHNbaV0pO1xyXG5cdH1cclxufTtcclxuXHJcbkwuQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChwb2ludDogUG9pbnQpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kcyB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50LlxyXG5cdGV4dGVuZDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHBvaW50ID0gTC5wb2ludChwb2ludCk7XHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1pbjogUG9pbnRcclxuXHRcdC8vIFRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtYXg6IFBvaW50XHJcblx0XHQvLyBUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cdFx0aWYgKCF0aGlzLm1pbiAmJiAhdGhpcy5tYXgpIHtcclxuXHRcdFx0dGhpcy5taW4gPSBwb2ludC5jbG9uZSgpO1xyXG5cdFx0XHR0aGlzLm1heCA9IHBvaW50LmNsb25lKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm1pbi54ID0gTWF0aC5taW4ocG9pbnQueCwgdGhpcy5taW4ueCk7XHJcblx0XHRcdHRoaXMubWF4LnggPSBNYXRoLm1heChwb2ludC54LCB0aGlzLm1heC54KTtcclxuXHRcdFx0dGhpcy5taW4ueSA9IE1hdGgubWluKHBvaW50LnksIHRoaXMubWluLnkpO1xyXG5cdFx0XHR0aGlzLm1heC55ID0gTWF0aC5tYXgocG9pbnQueSwgdGhpcy5tYXgueSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcihyb3VuZD86IEJvb2xlYW4pOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKHJvdW5kKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi54ICsgdGhpcy5tYXgueCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueSArIHRoaXMubWF4LnkpIC8gMiwgcm91bmQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm90dG9tTGVmdCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGJvdHRvbS1sZWZ0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Qm90dG9tTGVmdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHRoaXMubWluLngsIHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0VG9wUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSB0b3AtcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRUb3BSaWdodDogZnVuY3Rpb24gKCkgeyAvLyAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHRoaXMubWF4LngsIHRoaXMubWluLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2l6ZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1heC5zdWJ0cmFjdCh0aGlzLm1pbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKHBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cclxuXHRjb250YWluczogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIG1pbiwgbWF4O1xyXG5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMLlBvaW50KSB7XHJcblx0XHRcdG9iaiA9IEwucG9pbnQob2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IEwuYm91bmRzKG9iaik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEwuQm91bmRzKSB7XHJcblx0XHRcdG1pbiA9IG9iai5taW47XHJcblx0XHRcdG1heCA9IG9iai5tYXg7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtaW4gPSBtYXggPSBvYmo7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIChtaW4ueCA+PSB0aGlzLm1pbi54KSAmJlxyXG5cdFx0ICAgICAgIChtYXgueCA8PSB0aGlzLm1heC54KSAmJlxyXG5cdFx0ICAgICAgIChtaW4ueSA+PSB0aGlzLm1pbi55KSAmJlxyXG5cdFx0ICAgICAgIChtYXgueSA8PSB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG5cdC8vIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuXHRcdGJvdW5kcyA9IEwuYm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG5cdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHhJbnRlcnNlY3RzID0gKG1heDIueCA+PSBtaW4ueCkgJiYgKG1pbjIueCA8PSBtYXgueCksXHJcblx0XHQgICAgeUludGVyc2VjdHMgPSAobWF4Mi55ID49IG1pbi55KSAmJiAobWluMi55IDw9IG1heC55KTtcclxuXHJcblx0XHRyZXR1cm4geEludGVyc2VjdHMgJiYgeUludGVyc2VjdHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG5cdC8vIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcblx0b3ZlcmxhcHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG5cdFx0Ym91bmRzID0gTC5ib3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcblx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeE92ZXJsYXBzID0gKG1heDIueCA+IG1pbi54KSAmJiAobWluMi54IDwgbWF4LngpLFxyXG5cdFx0ICAgIHlPdmVybGFwcyA9IChtYXgyLnkgPiBtaW4ueSkgJiYgKG1pbjIueSA8IG1heC55KTtcclxuXHJcblx0XHRyZXR1cm4geE92ZXJsYXBzICYmIHlPdmVybGFwcztcclxuXHR9LFxyXG5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5taW4gJiYgdGhpcy5tYXgpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyh0b3BMZWZ0OiBQb2ludCwgYm90dG9tUmlnaHQ6IFBvaW50KVxyXG4vLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHR3byBjb29yZGluYXRlcyAodXN1YWxseSB0b3AtbGVmdCBhbmQgYm90dG9tLXJpZ2h0IGNvcm5lcnMpLlxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5ib3VuZHMocG9pbnRzOiBQb2ludFtdKVxyXG4vLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHRoZSBwb2ludHMgaXQgY29udGFpbnNcclxuTC5ib3VuZHMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG5cdGlmICghYSB8fCBhIGluc3RhbmNlb2YgTC5Cb3VuZHMpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEwuQm91bmRzKGEsIGIpO1xyXG59O1xyXG5cbi8qXHJcbiAqIEBjbGFzcyBUcmFuc2Zvcm1hdGlvblxyXG4gKiBAYWthIEwuVHJhbnNmb3JtYXRpb25cclxuICpcclxuICogUmVwcmVzZW50cyBhbiBhZmZpbmUgdHJhbnNmb3JtYXRpb246IGEgc2V0IG9mIGNvZWZmaWNpZW50cyBgYWAsIGBiYCwgYGNgLCBgZGBcclxuICogZm9yIHRyYW5zZm9ybWluZyBhIHBvaW50IG9mIGEgZm9ybSBgKHgsIHkpYCBpbnRvIGAoYSp4ICsgYiwgYyp5ICsgZClgIGFuZCBkb2luZ1xyXG4gKiB0aGUgcmV2ZXJzZS4gVXNlZCBieSBMZWFmbGV0IGluIGl0cyBwcm9qZWN0aW9ucyBjb2RlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdHJhbnNmb3JtYXRpb24gPSBuZXcgTC5UcmFuc2Zvcm1hdGlvbigyLCA1LCAtMSwgMTApLFxyXG4gKiBcdHAgPSBMLnBvaW50KDEsIDIpLFxyXG4gKiBcdHAyID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHApLCAvLyAgTC5wb2ludCg3LCA4KVxyXG4gKiBcdHAzID0gdHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocDIpOyAvLyAgTC5wb2ludCgxLCAyKVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gZmFjdG9yeSBuZXcgTC5UcmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIENyZWF0ZXMgYSBgVHJhbnNmb3JtYXRpb25gIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcbkwuVHJhbnNmb3JtYXRpb24gPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xyXG5cdHRoaXMuX2EgPSBhO1xyXG5cdHRoaXMuX2IgPSBiO1xyXG5cdHRoaXMuX2MgPSBjO1xyXG5cdHRoaXMuX2QgPSBkO1xyXG59O1xyXG5cclxuTC5UcmFuc2Zvcm1hdGlvbi5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCB0cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIHRyYW5zZm9ybWVkIHBvaW50LCBvcHRpb25hbGx5IG11bHRpcGxpZWQgYnkgdGhlIGdpdmVuIHNjYWxlLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyByZWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybShwb2ludC5jbG9uZSgpLCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtIChmYXN0ZXIpXHJcblx0X3RyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XHJcblx0XHRwb2ludC55ID0gc2NhbGUgKiAodGhpcy5fYyAqIHBvaW50LnkgKyB0aGlzLl9kKTtcclxuXHRcdHJldHVybiBwb2ludDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVudHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJldmVyc2UgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGdpdmVuIHBvaW50LCBvcHRpb25hbGx5IGRpdmlkZWRcclxuXHQvLyBieSB0aGUgZ2l2ZW4gc2NhbGUuIE9ubHkgYWNjZXB0cyByZWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dW50cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChcclxuXHRcdCAgICAgICAgKHBvaW50LnggLyBzY2FsZSAtIHRoaXMuX2IpIC8gdGhpcy5fYSxcclxuXHRcdCAgICAgICAgKHBvaW50LnkgLyBzY2FsZSAtIHRoaXMuX2QpIC8gdGhpcy5fYyk7XHJcblx0fVxyXG59O1xyXG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgRG9tVXRpbFxyXG4gKlxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Eb2N1bWVudF9PYmplY3RfTW9kZWwpXHJcbiAqIHRyZWUsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBNb3N0IGZ1bmN0aW9ucyBleHBlY3Rpbmcgb3IgcmV0dXJuaW5nIGEgYEhUTUxFbGVtZW50YCBhbHNvIHdvcmsgZm9yXHJcbiAqIFNWRyBlbGVtZW50cy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IGNsYXNzZXMgcmVmZXIgdG8gQ1NTIGNsYXNzZXNcclxuICogaW4gSFRNTCBhbmQgU1ZHIGNsYXNzZXMgaW4gU1ZHLlxyXG4gKi9cclxuXHJcbkwuRG9tVXRpbCA9IHtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGdldChpZDogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIGFuIGVsZW1lbnQgZ2l2ZW4gaXRzIERPTSBpZCwgb3IgcmV0dXJucyB0aGUgZWxlbWVudCBpdHNlbGZcclxuXHQvLyBpZiBpdCB3YXMgcGFzc2VkIGRpcmVjdGx5LlxyXG5cdGdldDogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRyZXR1cm4gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBnZXRTdHlsZShlbDogSFRNTEVsZW1lbnQsIHN0eWxlQXR0cmliOiBTdHJpbmcpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgYSBjZXJ0YWluIHN0eWxlIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxyXG5cdC8vIGluY2x1ZGluZyBjb21wdXRlZCB2YWx1ZXMgb3IgdmFsdWVzIHNldCB0aHJvdWdoIENTUy5cclxuXHRnZXRTdHlsZTogZnVuY3Rpb24gKGVsLCBzdHlsZSkge1xyXG5cclxuXHRcdHZhciB2YWx1ZSA9IGVsLnN0eWxlW3N0eWxlXSB8fCAoZWwuY3VycmVudFN0eWxlICYmIGVsLmN1cnJlbnRTdHlsZVtzdHlsZV0pO1xyXG5cclxuXHRcdGlmICgoIXZhbHVlIHx8IHZhbHVlID09PSAnYXV0bycpICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3KSB7XHJcblx0XHRcdHZhciBjc3MgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcclxuXHRcdFx0dmFsdWUgPSBjc3MgPyBjc3Nbc3R5bGVdIDogbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWUgPT09ICdhdXRvJyA/IG51bGwgOiB2YWx1ZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWU6IFN0cmluZywgY2xhc3NOYW1lPzogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ3JlYXRlcyBhbiBIVE1MIGVsZW1lbnQgd2l0aCBgdGFnTmFtZWAsIHNldHMgaXRzIGNsYXNzIHRvIGBjbGFzc05hbWVgLCBhbmQgb3B0aW9uYWxseSBhcHBlbmRzIGl0IHRvIGBjb250YWluZXJgIGVsZW1lbnQuXHJcblx0Y3JlYXRlOiBmdW5jdGlvbiAodGFnTmFtZSwgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcclxuXHJcblx0XHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG5cdFx0ZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8ICcnO1xyXG5cclxuXHRcdGlmIChjb250YWluZXIpIHtcclxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZWw7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHJlbW92ZShlbDogSFRNTEVsZW1lbnQpXHJcblx0Ly8gUmVtb3ZlcyBgZWxgIGZyb20gaXRzIHBhcmVudCBlbGVtZW50XHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdFx0aWYgKHBhcmVudCkge1xyXG5cdFx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQoZWwpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBlbXB0eShlbDogSFRNTEVsZW1lbnQpXHJcblx0Ly8gUmVtb3ZlcyBhbGwgb2YgYGVsYCdzIGNoaWxkcmVuIGVsZW1lbnRzIGZyb20gYGVsYFxyXG5cdGVtcHR5OiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHdoaWxlIChlbC5maXJzdENoaWxkKSB7XHJcblx0XHRcdGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiB0b0Zyb250KGVsOiBIVE1MRWxlbWVudClcclxuXHQvLyBNYWtlcyBgZWxgIHRoZSBsYXN0IGNoaWxkcmVuIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgaW4gZnJvbnQgb2YgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG5cdHRvRnJvbnQ6IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0ZWwucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHRvQmFjayhlbDogSFRNTEVsZW1lbnQpXHJcblx0Ly8gTWFrZXMgYGVsYCB0aGUgZmlyc3QgY2hpbGRyZW4gb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBiYWNrIGZyb20gdGhlIG90aGVyIGNoaWxkcmVuLlxyXG5cdHRvQmFjazogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRcdHBhcmVudC5pbnNlcnRCZWZvcmUoZWwsIHBhcmVudC5maXJzdENoaWxkKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gaGFzQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUgY29udGFpbnMgYG5hbWVgLlxyXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcclxuXHRcdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGNsYXNzTmFtZSA9IEwuRG9tVXRpbC5nZXRDbGFzcyhlbCk7XHJcblx0XHRyZXR1cm4gY2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykudGVzdChjbGFzc05hbWUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBhZGRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuXHQvLyBBZGRzIGBuYW1lYCB0byB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuXHRhZGRDbGFzczogZnVuY3Rpb24gKGVsLCBuYW1lKSB7XHJcblx0XHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dmFyIGNsYXNzZXMgPSBMLlV0aWwuc3BsaXRXb3JkcyhuYW1lKTtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRlbC5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKCFMLkRvbVV0aWwuaGFzQ2xhc3MoZWwsIG5hbWUpKSB7XHJcblx0XHRcdHZhciBjbGFzc05hbWUgPSBMLkRvbVV0aWwuZ2V0Q2xhc3MoZWwpO1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0Q2xhc3MoZWwsIChjbGFzc05hbWUgPyBjbGFzc05hbWUgKyAnICcgOiAnJykgKyBuYW1lKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcblx0Ly8gUmVtb3ZlcyBgbmFtZWAgZnJvbSB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24gKGVsLCBuYW1lKSB7XHJcblx0XHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRDbGFzcyhlbCwgTC5VdGlsLnRyaW0oKCcgJyArIEwuRG9tVXRpbC5nZXRDbGFzcyhlbCkgKyAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBzZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuXHQvLyBTZXRzIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcblx0c2V0Q2xhc3M6IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xyXG5cdFx0aWYgKGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0ZWwuY2xhc3NOYW1lID0gbmFtZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIGluIGNhc2Ugb2YgU1ZHIGVsZW1lbnRcclxuXHRcdFx0ZWwuY2xhc3NOYW1lLmJhc2VWYWwgPSBuYW1lO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBnZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcblx0Z2V0Q2xhc3M6IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0cmV0dXJuIGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQgPyBlbC5jbGFzc05hbWUgOiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc2V0T3BhY2l0eShlbDogSFRNTEVsZW1lbnQsIG9wYWNpdHk6IE51bWJlcilcclxuXHQvLyBTZXQgdGhlIG9wYWNpdHkgb2YgYW4gZWxlbWVudCAoaW5jbHVkaW5nIG9sZCBJRSBzdXBwb3J0KS5cclxuXHQvLyBgb3BhY2l0eWAgbXVzdCBiZSBhIG51bWJlciBmcm9tIGAwYCB0byBgMWAuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKGVsLCB2YWx1ZSkge1xyXG5cclxuXHRcdGlmICgnb3BhY2l0eScgaW4gZWwuc3R5bGUpIHtcclxuXHRcdFx0ZWwuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoJ2ZpbHRlcicgaW4gZWwuc3R5bGUpIHtcclxuXHRcdFx0TC5Eb21VdGlsLl9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfc2V0T3BhY2l0eUlFOiBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7XHJcblx0XHR2YXIgZmlsdGVyID0gZmFsc2UsXHJcblx0XHQgICAgZmlsdGVyTmFtZSA9ICdEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYSc7XHJcblxyXG5cdFx0Ly8gZmlsdGVycyBjb2xsZWN0aW9uIHRocm93cyBhbiBlcnJvciBpZiB3ZSB0cnkgdG8gcmV0cmlldmUgYSBmaWx0ZXIgdGhhdCBkb2Vzbid0IGV4aXN0XHJcblx0XHR0cnkge1xyXG5cdFx0XHRmaWx0ZXIgPSBlbC5maWx0ZXJzLml0ZW0oZmlsdGVyTmFtZSk7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdC8vIGRvbid0IHNldCBvcGFjaXR5IHRvIDEgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IHNldCBhbiBvcGFjaXR5LFxyXG5cdFx0XHQvLyBpdCBpc24ndCBuZWVkZWQgYW5kIGJyZWFrcyB0cmFuc3BhcmVudCBwbmdzLlxyXG5cdFx0XHRpZiAodmFsdWUgPT09IDEpIHsgcmV0dXJuOyB9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogMTAwKTtcclxuXHJcblx0XHRpZiAoZmlsdGVyKSB7XHJcblx0XHRcdGZpbHRlci5FbmFibGVkID0gKHZhbHVlICE9PSAxMDApO1xyXG5cdFx0XHRmaWx0ZXIuT3BhY2l0eSA9IHZhbHVlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZWwuc3R5bGUuZmlsdGVyICs9ICcgcHJvZ2lkOicgKyBmaWx0ZXJOYW1lICsgJyhvcGFjaXR5PScgKyB2YWx1ZSArICcpJztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gdGVzdFByb3AocHJvcHM6IFN0cmluZ1tdKTogU3RyaW5nfGZhbHNlXHJcblx0Ly8gR29lcyB0aHJvdWdoIHRoZSBhcnJheSBvZiBzdHlsZSBuYW1lcyBhbmQgcmV0dXJucyB0aGUgZmlyc3QgbmFtZVxyXG5cdC8vIHRoYXQgaXMgYSB2YWxpZCBzdHlsZSBuYW1lIGZvciBhbiBlbGVtZW50LiBJZiBubyBzdWNoIG5hbWUgaXMgZm91bmQsXHJcblx0Ly8gaXQgcmV0dXJucyBmYWxzZS4gVXNlZnVsIGZvciB2ZW5kb3ItcHJlZml4ZWQgc3R5bGVzIGxpa2UgYHRyYW5zZm9ybWAuXHJcblx0dGVzdFByb3A6IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cclxuXHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmIChwcm9wc1tpXSBpbiBzdHlsZSkge1xyXG5cdFx0XHRcdHJldHVybiBwcm9wc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWw6IEhUTUxFbGVtZW50LCBvZmZzZXQ6IFBvaW50LCBzY2FsZT86IE51bWJlcilcclxuXHQvLyBSZXNldHMgdGhlIDNEIENTUyB0cmFuc2Zvcm0gb2YgYGVsYCBzbyBpdCBpcyB0cmFuc2xhdGVkIGJ5IGBvZmZzZXRgIHBpeGVsc1xyXG5cdC8vIGFuZCBvcHRpb25hbGx5IHNjYWxlZCBieSBgc2NhbGVgLiBEb2VzIG5vdCBoYXZlIGFuIGVmZmVjdCBpZiB0aGVcclxuXHQvLyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCAzRCBDU1MgdHJhbnNmb3Jtcy5cclxuXHRzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uIChlbCwgb2Zmc2V0LCBzY2FsZSkge1xyXG5cdFx0dmFyIHBvcyA9IG9mZnNldCB8fCBuZXcgTC5Qb2ludCgwLCAwKTtcclxuXHJcblx0XHRlbC5zdHlsZVtMLkRvbVV0aWwuVFJBTlNGT1JNXSA9XHJcblx0XHRcdChMLkJyb3dzZXIuaWUzZCA/XHJcblx0XHRcdFx0J3RyYW5zbGF0ZSgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4KScgOlxyXG5cdFx0XHRcdCd0cmFuc2xhdGUzZCgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4LDApJykgK1xyXG5cdFx0XHQoc2NhbGUgPyAnIHNjYWxlKCcgKyBzY2FsZSArICcpJyA6ICcnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50LCBwb3NpdGlvbjogUG9pbnQpXHJcblx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYGVsYCB0byBjb29yZGluYXRlcyBzcGVjaWZpZWQgYnkgYHBvc2l0aW9uYCxcclxuXHQvLyB1c2luZyBDU1MgdHJhbnNsYXRlIG9yIHRvcC9sZWZ0IHBvc2l0aW9uaW5nIGRlcGVuZGluZyBvbiB0aGUgYnJvd3NlclxyXG5cdC8vICh1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBwb3NpdGlvbiBpdHMgbGF5ZXJzKS5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKGVsLCBwb2ludCkgeyAvLyAoSFRNTEVsZW1lbnQsIFBvaW50WywgQm9vbGVhbl0pXHJcblxyXG5cdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdFx0ZWwuX2xlYWZsZXRfcG9zID0gcG9pbnQ7XHJcblx0XHQvKmVzbGludC1lbmFibGUgKi9cclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLmFueTNkKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRUcmFuc2Zvcm0oZWwsIHBvaW50KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGVsLnN0eWxlLmxlZnQgPSBwb2ludC54ICsgJ3B4JztcclxuXHRcdFx0ZWwuc3R5bGUudG9wID0gcG9pbnQueSArICdweCc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgYW4gZWxlbWVudCBwcmV2aW91c2x5IHBvc2l0aW9uZWQgd2l0aCBzZXRQb3NpdGlvbi5cclxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHQvLyB0aGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZm9yIGVsZW1lbnRzIHByZXZpb3VzbHkgcG9zaXRpb25lZCB1c2luZyBzZXRQb3NpdGlvbixcclxuXHRcdC8vIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSB0aGUgcG9zaXRpb24gZm9yIHBlcmZvcm1hbmNlXHJcblxyXG5cdFx0cmV0dXJuIGVsLl9sZWFmbGV0X3BvcyB8fCBuZXcgTC5Qb2ludCgwLCAwKTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuXHQvLyBwcmVmaXggc3R5bGUgcHJvcGVydHkgbmFtZXNcclxuXHJcblx0Ly8gQHByb3BlcnR5IFRSQU5TRk9STTogU3RyaW5nXHJcblx0Ly8gVmVuZG9yLXByZWZpeGVkIGZyYW5zZm9ybSBzdHlsZSBuYW1lIChlLmcuIGAnd2Via2l0VHJhbnNmb3JtJ2AgZm9yIFdlYktpdCkuXHJcblx0TC5Eb21VdGlsLlRSQU5TRk9STSA9IEwuRG9tVXRpbC50ZXN0UHJvcChcclxuXHRcdFx0Wyd0cmFuc2Zvcm0nLCAnV2Via2l0VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJ10pO1xyXG5cclxuXHJcblx0Ly8gd2Via2l0VHJhbnNpdGlvbiBjb21lcyBmaXJzdCBiZWNhdXNlIHNvbWUgYnJvd3NlciB2ZXJzaW9ucyB0aGF0IGRyb3AgdmVuZG9yIHByZWZpeCBkb24ndCBkb1xyXG5cdC8vIHRoZSBzYW1lIGZvciB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCwgaW4gcGFydGljdWxhciB0aGUgQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxyXG5cclxuXHQvLyBAcHJvcGVydHkgVFJBTlNJVElPTjogU3RyaW5nXHJcblx0Ly8gVmVuZG9yLXByZWZpeGVkIHRyYW5zZm9ybSBzdHlsZSBuYW1lLlxyXG5cdHZhciB0cmFuc2l0aW9uID0gTC5Eb21VdGlsLlRSQU5TSVRJT04gPSBMLkRvbVV0aWwudGVzdFByb3AoXHJcblx0XHRcdFsnd2Via2l0VHJhbnNpdGlvbicsICd0cmFuc2l0aW9uJywgJ09UcmFuc2l0aW9uJywgJ01velRyYW5zaXRpb24nLCAnbXNUcmFuc2l0aW9uJ10pO1xyXG5cclxuXHRMLkRvbVV0aWwuVFJBTlNJVElPTl9FTkQgPVxyXG5cdFx0XHR0cmFuc2l0aW9uID09PSAnd2Via2l0VHJhbnNpdGlvbicgfHwgdHJhbnNpdGlvbiA9PT0gJ09UcmFuc2l0aW9uJyA/IHRyYW5zaXRpb24gKyAnRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGRpc2FibGVUZXh0U2VsZWN0aW9uKClcclxuXHQvLyBQcmV2ZW50cyB0aGUgdXNlciBmcm9tIGdlbmVyYXRpbmcgYHNlbGVjdHN0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZFxyXG5cdC8vIHdoZW4gdGhlIHVzZXIgZHJhZ3MgdGhlIG1vdXNlIHRocm91Z2ggYSBwYWdlIHdpdGggdGV4dC4gVXNlZCBpbnRlcm5hbGx5XHJcblx0Ly8gYnkgTGVhZmxldCB0byBvdmVycmlkZSB0aGUgYmVoYXZpb3VyIG9mIGFueSBjbGljay1hbmQtZHJhZyBpbnRlcmFjdGlvbiBvblxyXG5cdC8vIHRoZSBtYXAuIEFmZmVjdHMgZHJhZyBpbnRlcmFjdGlvbnMgb24gdGhlIHdob2xlIGRvY3VtZW50LlxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZW5hYmxlVGV4dFNlbGVjdGlvbigpXHJcblx0Ly8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG5cdGlmICgnb25zZWxlY3RzdGFydCcgaW4gZG9jdW1lbnQpIHtcclxuXHRcdEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5vbih3aW5kb3csICdzZWxlY3RzdGFydCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdFx0fTtcclxuXHRcdEwuRG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRMLkRvbUV2ZW50Lm9mZih3aW5kb3csICdzZWxlY3RzdGFydCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdFx0fTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciB1c2VyU2VsZWN0UHJvcGVydHkgPSBMLkRvbVV0aWwudGVzdFByb3AoXHJcblx0XHRcdFsndXNlclNlbGVjdCcsICdXZWJraXRVc2VyU2VsZWN0JywgJ09Vc2VyU2VsZWN0JywgJ01velVzZXJTZWxlY3QnLCAnbXNVc2VyU2VsZWN0J10pO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG5cdFx0XHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHRcdFx0XHR0aGlzLl91c2VyU2VsZWN0ID0gc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XTtcclxuXHRcdFx0XHRzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gJ25vbmUnO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdFx0TC5Eb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9IHRoaXMuX3VzZXJTZWxlY3Q7XHJcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX3VzZXJTZWxlY3Q7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpXHJcblx0Ly8gQXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbiksIGJ1dFxyXG5cdC8vIGZvciBgZHJhZ3N0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIGFuIGltYWdlLlxyXG5cdEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21FdmVudC5vbih3aW5kb3csICdkcmFnc3RhcnQnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHR9O1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKClcclxuXHQvLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZ2BdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuXHRMLkRvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21FdmVudC5vZmYod2luZG93LCAnZHJhZ3N0YXJ0JywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsOiBIVE1MRWxlbWVudClcclxuXHQvLyBNYWtlcyB0aGUgW291dGxpbmVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9vdXRsaW5lKVxyXG5cdC8vIG9mIHRoZSBlbGVtZW50IGBlbGAgaW52aXNpYmxlLiBVc2VkIGludGVybmFsbHkgYnkgTGVhZmxldCB0byBwcmV2ZW50XHJcblx0Ly8gZm9jdXNhYmxlIGVsZW1lbnRzIGZyb20gZGlzcGxheWluZyBhbiBvdXRsaW5lIHdoZW4gdGhlIHVzZXIgcGVyZm9ybXMgYVxyXG5cdC8vIGRyYWcgaW50ZXJhY3Rpb24gb24gdGhlbS5cclxuXHRMLkRvbVV0aWwucHJldmVudE91dGxpbmUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG5cdFx0d2hpbGUgKGVsZW1lbnQudGFiSW5kZXggPT09IC0xKSB7XHJcblx0XHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0XHRpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuc3R5bGUpIHsgcmV0dXJuOyB9XHJcblx0XHRMLkRvbVV0aWwucmVzdG9yZU91dGxpbmUoKTtcclxuXHRcdHRoaXMuX291dGxpbmVFbGVtZW50ID0gZWxlbWVudDtcclxuXHRcdHRoaXMuX291dGxpbmVTdHlsZSA9IGVsZW1lbnQuc3R5bGUub3V0bGluZTtcclxuXHRcdGVsZW1lbnQuc3R5bGUub3V0bGluZSA9ICdub25lJztcclxuXHRcdEwuRG9tRXZlbnQub24od2luZG93LCAna2V5ZG93bicsIEwuRG9tVXRpbC5yZXN0b3JlT3V0bGluZSwgdGhpcyk7XHJcblx0fTtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKClcclxuXHQvLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwucHJldmVudE91dGxpbmVgXSgpLlxyXG5cdEwuRG9tVXRpbC5yZXN0b3JlT3V0bGluZSA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fb3V0bGluZUVsZW1lbnQpIHsgcmV0dXJuOyB9XHJcblx0XHR0aGlzLl9vdXRsaW5lRWxlbWVudC5zdHlsZS5vdXRsaW5lID0gdGhpcy5fb3V0bGluZVN0eWxlO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX291dGxpbmVFbGVtZW50O1xyXG5cdFx0ZGVsZXRlIHRoaXMuX291dGxpbmVTdHlsZTtcclxuXHRcdEwuRG9tRXZlbnQub2ZmKHdpbmRvdywgJ2tleWRvd24nLCBMLkRvbVV0aWwucmVzdG9yZU91dGxpbmUsIHRoaXMpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxuLyogQGNsYXNzIExhdExuZ1xyXG4gKiBAYWthIEwuTGF0TG5nXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCBhIGNlcnRhaW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIHZhciBsYXRsbmcgPSBMLmxhdExuZyg1MC41LCAzMC41KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtIGFuZCBzaW1wbGUgb2JqZWN0IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICpcclxuICogYGBgXHJcbiAqIG1hcC5wYW5UbyhbNTAsIDMwXSk7XHJcbiAqIG1hcC5wYW5Ubyh7bG9uOiAzMCwgbGF0OiA1MH0pO1xyXG4gKiBtYXAucGFuVG8oe2xhdDogNTAsIGxuZzogMzB9KTtcclxuICogbWFwLnBhblRvKEwubGF0TG5nKDUwLCAzMCkpO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLkxhdExuZyA9IGZ1bmN0aW9uIChsYXQsIGxuZywgYWx0KSB7XHJcblx0aWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdExuZyBvYmplY3Q6ICgnICsgbGF0ICsgJywgJyArIGxuZyArICcpJyk7XHJcblx0fVxyXG5cclxuXHQvLyBAcHJvcGVydHkgbGF0OiBOdW1iZXJcclxuXHQvLyBMYXRpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sYXQgPSArbGF0O1xyXG5cclxuXHQvLyBAcHJvcGVydHkgbG5nOiBOdW1iZXJcclxuXHQvLyBMb25naXR1ZGUgaW4gZGVncmVlc1xyXG5cdHRoaXMubG5nID0gK2xuZztcclxuXHJcblx0Ly8gQHByb3BlcnR5IGFsdDogTnVtYmVyXHJcblx0Ly8gQWx0aXR1ZGUgaW4gbWV0ZXJzIChvcHRpb25hbClcclxuXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuYWx0ID0gK2FsdDtcclxuXHR9XHJcbn07XHJcblxyXG5MLkxhdExuZy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJMYXRMbmc6IExhdExuZywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBgTGF0TG5nYCBwb2ludCBpcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKS4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGVuIGJ5IHNldHRpbmcgYG1heE1hcmdpbmAgdG8gYSBzbWFsbCBudW1iZXIuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAob2JqLCBtYXhNYXJnaW4pIHtcclxuXHRcdGlmICghb2JqKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdG9iaiA9IEwubGF0TG5nKG9iaik7XHJcblxyXG5cdFx0dmFyIG1hcmdpbiA9IE1hdGgubWF4KFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxhdCAtIG9iai5sYXQpLFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxuZyAtIG9iai5sbmcpKTtcclxuXHJcblx0XHRyZXR1cm4gbWFyZ2luIDw9IChtYXhNYXJnaW4gPT09IHVuZGVmaW5lZCA/IDEuMEUtOSA6IG1heE1hcmdpbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCAoZm9yIGRlYnVnZ2luZyBwdXJwb3NlcykuXHJcblx0dG9TdHJpbmc6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHJldHVybiAnTGF0TG5nKCcgK1xyXG5cdFx0ICAgICAgICBMLlV0aWwuZm9ybWF0TnVtKHRoaXMubGF0LCBwcmVjaXNpb24pICsgJywgJyArXHJcblx0XHQgICAgICAgIEwuVXRpbC5mb3JtYXROdW0odGhpcy5sbmcsIHByZWNpc2lvbikgKyAnKSc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyTGF0TG5nOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSAoaW4gbWV0ZXJzKSB0byB0aGUgZ2l2ZW4gYExhdExuZ2AgY2FsY3VsYXRlZCB1c2luZyB0aGUgW0hhdmVyc2luZSBmb3JtdWxhXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhKS5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAob3RoZXIpIHtcclxuXHRcdHJldHVybiBMLkNSUy5FYXJ0aC5kaXN0YW5jZSh0aGlzLCBMLmxhdExuZyhvdGhlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdgIG9iamVjdCB3aXRoIHRoZSBsb25naXR1ZGUgd3JhcHBlZCBzbyBpdCdzIGFsd2F5cyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gTC5DUlMuRWFydGgud3JhcExhdExuZyh0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvQm91bmRzKHNpemVJbk1ldGVyczogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nQm91bmRzYCBvYmplY3QgaW4gd2hpY2ggZWFjaCBib3VuZGFyeSBpcyBgc2l6ZUluTWV0ZXJzYCBtZXRlcnMgYXBhcnQgZnJvbSB0aGUgYExhdExuZ2AuXHJcblx0dG9Cb3VuZHM6IGZ1bmN0aW9uIChzaXplSW5NZXRlcnMpIHtcclxuXHRcdHZhciBsYXRBY2N1cmFjeSA9IDE4MCAqIHNpemVJbk1ldGVycyAvIDQwMDc1MDE3LFxyXG5cdFx0ICAgIGxuZ0FjY3VyYWN5ID0gbGF0QWNjdXJhY3kgLyBNYXRoLmNvcygoTWF0aC5QSSAvIDE4MCkgKiB0aGlzLmxhdCk7XHJcblxyXG5cdFx0cmV0dXJuIEwubGF0TG5nQm91bmRzKFxyXG5cdFx0ICAgICAgICBbdGhpcy5sYXQgLSBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgLSBsbmdBY2N1cmFjeV0sXHJcblx0XHQgICAgICAgIFt0aGlzLmxhdCArIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyArIGxuZ0FjY3VyYWN5XSk7XHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcodGhpcy5sYXQsIHRoaXMubG5nLCB0aGlzLmFsdCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhsYXRpdHVkZTogTnVtYmVyLCBsb25naXR1ZGU6IE51bWJlciwgYWx0aXR1ZGU/OiBOdW1iZXIpOiBMYXRMbmdcclxuLy8gQ3JlYXRlcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggdGhlIGdpdmVuIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgKGFuZCBvcHRpb25hbGx5IGFsdGl0dWRlKS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFtOdW1iZXIsIE51bWJlcl1gIG9yIGBbTnVtYmVyLCBOdW1iZXIsIE51bWJlcl1gIGluc3RlYWQuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBPYmplY3QpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXJ9YCBvciBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlciwgYWx0OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5cclxuTC5sYXRMbmcgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG5cdGlmIChhIGluc3RhbmNlb2YgTC5MYXRMbmcpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAoTC5VdGlsLmlzQXJyYXkoYSkgJiYgdHlwZW9mIGFbMF0gIT09ICdvYmplY3QnKSB7XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDMpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhhWzBdLCBhWzFdLCBhWzJdKTtcclxuXHRcdH1cclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKGFbMF0sIGFbMV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdGlmIChhID09PSB1bmRlZmluZWQgfHwgYSA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgJ2xhdCcgaW4gYSkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhhLmxhdCwgJ2xuZycgaW4gYSA/IGEubG5nIDogYS5sb24sIGEuYWx0KTtcclxuXHR9XHJcblx0aWYgKGIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTC5MYXRMbmcoYSwgYiwgYyk7XHJcbn07XHJcblxuLypcclxuICogQGNsYXNzIExhdExuZ0JvdW5kc1xyXG4gKiBAYWthIEwuTGF0TG5nQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBnZW9ncmFwaGljYWwgYXJlYSBvbiBhIG1hcC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHNvdXRoV2VzdCA9IEwubGF0TG5nKDQwLjcxMiwgLTc0LjIyNyksXHJcbiAqIG5vcnRoRWFzdCA9IEwubGF0TG5nKDQwLjc3NCwgLTc0LjEyNSksXHJcbiAqIGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKHNvdXRoV2VzdCwgbm9ydGhFYXN0KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nQm91bmRzIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAuZml0Qm91bmRzKFtcclxuICogXHRbNDAuNzEyLCAtNzQuMjI3XSxcclxuICogXHRbNDAuNzc0LCAtNzQuMTI1XVxyXG4gKiBdKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5MYXRMbmdCb3VuZHMgPSBmdW5jdGlvbiAoc291dGhXZXN0LCBub3J0aEVhc3QpIHsgLy8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXHJcblx0aWYgKCFzb3V0aFdlc3QpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBsYXRsbmdzID0gbm9ydGhFYXN0ID8gW3NvdXRoV2VzdCwgbm9ydGhFYXN0XSA6IHNvdXRoV2VzdDtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKGxhdGxuZ3NbaV0pO1xyXG5cdH1cclxufTtcclxuXHJcbkwuTGF0TG5nQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Ly8gQG1ldGhvZCBleHRlbmQobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnRcclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBleHRlbmQob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBib3VuZHNcclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTC5MYXRMbmcpIHtcclxuXHRcdFx0c3cyID0gb2JqO1xyXG5cdFx0XHRuZTIgPSBvYmo7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMLkxhdExuZ0JvdW5kcykge1xyXG5cdFx0XHRzdzIgPSBvYmouX3NvdXRoV2VzdDtcclxuXHRcdFx0bmUyID0gb2JqLl9ub3J0aEVhc3Q7XHJcblxyXG5cdFx0XHRpZiAoIXN3MiB8fCAhbmUyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG9iaiA/IHRoaXMuZXh0ZW5kKEwubGF0TG5nKG9iaikgfHwgTC5sYXRMbmdCb3VuZHMob2JqKSkgOiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghc3cgJiYgIW5lKSB7XHJcblx0XHRcdHRoaXMuX3NvdXRoV2VzdCA9IG5ldyBMLkxhdExuZyhzdzIubGF0LCBzdzIubG5nKTtcclxuXHRcdFx0dGhpcy5fbm9ydGhFYXN0ID0gbmV3IEwuTGF0TG5nKG5lMi5sYXQsIG5lMi5sbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cubGF0ID0gTWF0aC5taW4oc3cyLmxhdCwgc3cubGF0KTtcclxuXHRcdFx0c3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcclxuXHRcdFx0bmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcclxuXHRcdFx0bmUubG5nID0gTWF0aC5tYXgobmUyLmxuZywgbmUubG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBiaWdnZXIgYm91bmRzIGNyZWF0ZWQgYnkgZXh0ZW5kaW5nIHRoZSBjdXJyZW50IGJvdW5kcyBieSBhIGdpdmVuIHBlcmNlbnRhZ2UgaW4gZWFjaCBkaXJlY3Rpb24uXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpICogYnVmZmVyUmF0aW8sXHJcblx0XHQgICAgd2lkdGhCdWZmZXIgPSBNYXRoLmFicyhzdy5sbmcgLSBuZS5sbmcpICogYnVmZmVyUmF0aW87XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgbmV3IEwuTGF0TG5nKHN3LmxhdCAtIGhlaWdodEJ1ZmZlciwgc3cubG5nIC0gd2lkdGhCdWZmZXIpLFxyXG5cdFx0ICAgICAgICBuZXcgTC5MYXRMbmcobmUubGF0ICsgaGVpZ2h0QnVmZmVyLCBuZS5sbmcgKyB3aWR0aEJ1ZmZlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sYXQgKyB0aGlzLl9ub3J0aEVhc3QubGF0KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubG5nICsgdGhpcy5fbm9ydGhFYXN0LmxuZykgLyAyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoV2VzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0U291dGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3Q7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldE5vcnRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyh0aGlzLmdldE5vcnRoKCksIHRoaXMuZ2V0V2VzdCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoRWFzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0U291dGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0V2VzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB3ZXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0V2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0U291dGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWFzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBlYXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0Tm9ydGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMgKGxhdGxuZzogTGF0TG5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcpIC0+IEJvb2xlYW5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMLkxhdExuZykge1xyXG5cdFx0XHRvYmogPSBMLmxhdExuZyhvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gTC5sYXRMbmdCb3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEwuTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5nZXRTb3V0aFdlc3QoKTtcclxuXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cyID0gbmUyID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAoc3cyLmxhdCA+PSBzdy5sYXQpICYmIChuZTIubGF0IDw9IG5lLmxhdCkgJiZcclxuXHRcdCAgICAgICAoc3cyLmxuZyA+PSBzdy5sbmcpICYmIChuZTIubG5nIDw9IG5lLmxuZyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIGxhdEludGVyc2VjdHMgPSAobmUyLmxhdCA+PSBzdy5sYXQpICYmIChzdzIubGF0IDw9IG5lLmxhdCksXHJcblx0XHQgICAgbG5nSW50ZXJzZWN0cyA9IChuZTIubG5nID49IHN3LmxuZykgJiYgKHN3Mi5sbmcgPD0gbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0SW50ZXJzZWN0cyAmJiBsbmdJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0T3ZlcmxhcHMgPSAobmUyLmxhdCA+IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPCBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ092ZXJsYXBzID0gKG5lMi5sbmcgPiBzdy5sbmcpICYmIChzdzIubG5nIDwgbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0T3ZlcmxhcHMgJiYgbG5nT3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0JCb3hTdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyB3aXRoIGJvdW5kaW5nIGJveCBjb29yZGluYXRlcyBpbiBhICdzb3V0aHdlc3RfbG5nLHNvdXRod2VzdF9sYXQsbm9ydGhlYXN0X2xuZyxub3J0aGVhc3RfbGF0JyBmb3JtYXQuIFVzZWZ1bCBmb3Igc2VuZGluZyByZXF1ZXN0cyB0byB3ZWIgc2VydmljZXMgdGhhdCByZXR1cm4gZ2VvIGRhdGEuXHJcblx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gW3RoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldE5vcnRoKCldLmpvaW4oJywnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaXMgZXF1aXZhbGVudCAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKSB0byB0aGUgZ2l2ZW4gYm91bmRzLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmVxdWFscyhib3VuZHMuZ2V0U291dGhXZXN0KCkpICYmXHJcblx0XHQgICAgICAgdGhpcy5fbm9ydGhFYXN0LmVxdWFscyhib3VuZHMuZ2V0Tm9ydGhFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNWYWxpZCgpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJvdW5kcyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWQuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMuX3NvdXRoV2VzdCAmJiB0aGlzLl9ub3J0aEVhc3QpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIFRPRE8gSW50ZXJuYXRpb25hbCBkYXRlIGxpbmU/XHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhzb3V0aFdlc3Q6IExhdExuZywgbm9ydGhFYXN0OiBMYXRMbmcpXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgYnkgZGVmaW5pbmcgc291dGgtd2VzdCBhbmQgbm9ydGgtZWFzdCBjb3JuZXJzIG9mIHRoZSByZWN0YW5nbGUuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMobGF0bG5nczogTGF0TG5nW10pXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgZGVmaW5lZCBieSB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50cyBpdCBjb250YWlucy4gVmVyeSB1c2VmdWwgZm9yIHpvb21pbmcgdGhlIG1hcCB0byBmaXQgYSBwYXJ0aWN1bGFyIHNldCBvZiBsb2NhdGlvbnMgd2l0aCBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuTC5sYXRMbmdCb3VuZHMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG5cdGlmIChhIGluc3RhbmNlb2YgTC5MYXRMbmdCb3VuZHMpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEwuTGF0TG5nQm91bmRzKGEsIGIpO1xyXG59O1xyXG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAc2VjdGlvblxyXG4gKiBMZWFmbGV0IGNvbWVzIHdpdGggYSBzZXQgb2YgYWxyZWFkeSBkZWZpbmVkIFByb2plY3Rpb25zIG91dCBvZiB0aGUgYm94OlxyXG4gKlxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTG9uTGF0XHJcbiAqXHJcbiAqIEVxdWlyZWN0YW5ndWxhciwgb3IgUGxhdGUgQ2FycmVlIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IHNpbXBsZSBwcm9qZWN0aW9uLFxyXG4gKiBtb3N0bHkgdXNlZCBieSBHSVMgZW50aHVzaWFzdHMuIERpcmVjdGx5IG1hcHMgYHhgIGFzIGxvbmdpdHVkZSwgYW5kIGB5YCBhc1xyXG4gKiBsYXRpdHVkZS4gQWxzbyBzdWl0YWJsZSBmb3IgZmxhdCB3b3JsZHMsIGUuZy4gZ2FtZSBtYXBzLiBVc2VkIGJ5IHRoZVxyXG4gKiBgRVBTRzozMzk1YCBhbmQgYFNpbXBsZWAgQ1JTLlxyXG4gKi9cclxuXHJcbkwuUHJvamVjdGlvbiA9IHt9O1xyXG5cclxuTC5Qcm9qZWN0aW9uLkxvbkxhdCA9IHtcclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQobGF0bG5nLmxuZywgbGF0bG5nLmxhdCk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcocG9pbnQueSwgcG9pbnQueCk7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiBMLmJvdW5kcyhbLTE4MCwgLTkwXSwgWzE4MCwgOTBdKVxyXG59O1xyXG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3JcclxuICpcclxuICogU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IGNvbW1vbiBwcm9qZWN0aW9uIGZvciBvbmxpbmUgbWFwcyxcclxuICogdXNlZCBieSBhbG1vc3QgYWxsIGZyZWUgYW5kIGNvbW1lcmNpYWwgdGlsZSBwcm92aWRlcnMuIEFzc3VtZXMgdGhhdCBFYXJ0aCBpc1xyXG4gKiBhIHNwaGVyZS4gVXNlZCBieSB0aGUgYEVQU0c6Mzg1N2AgQ1JTLlxyXG4gKi9cclxuXHJcbkwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvciA9IHtcclxuXHJcblx0UjogNjM3ODEzNyxcclxuXHRNQVhfTEFUSVRVREU6IDg1LjA1MTEyODc3OTgsXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuXHRcdCAgICBtYXggPSB0aGlzLk1BWF9MQVRJVFVERSxcclxuXHRcdCAgICBsYXQgPSBNYXRoLm1heChNYXRoLm1pbihtYXgsIGxhdGxuZy5sYXQpLCAtbWF4KSxcclxuXHRcdCAgICBzaW4gPSBNYXRoLnNpbihsYXQgKiBkKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoXHJcblx0XHRcdFx0dGhpcy5SICogbGF0bG5nLmxuZyAqIGQsXHJcblx0XHRcdFx0dGhpcy5SICogTWF0aC5sb2coKDEgKyBzaW4pIC8gKDEgLSBzaW4pKSAvIDIpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgZCA9IDE4MCAvIE1hdGguUEk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhcclxuXHRcdFx0KDIgKiBNYXRoLmF0YW4oTWF0aC5leHAocG9pbnQueSAvIHRoaXMuUikpIC0gKE1hdGguUEkgLyAyKSkgKiBkLFxyXG5cdFx0XHRwb2ludC54ICogZCAvIHRoaXMuUik7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGQgPSA2Mzc4MTM3ICogTWF0aC5QSTtcclxuXHRcdHJldHVybiBMLmJvdW5kcyhbLWQsIC1kXSwgW2QsIGRdKTtcclxuXHR9KSgpXHJcbn07XHJcblxuLypcclxuICogQGNsYXNzIENSU1xyXG4gKiBAYWthIEwuQ1JTXHJcbiAqIEFic3RyYWN0IGNsYXNzIHRoYXQgZGVmaW5lcyBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1zIGZvciBwcm9qZWN0aW5nXHJcbiAqIGdlb2dyYXBoaWNhbCBwb2ludHMgaW50byBwaXhlbCAoc2NyZWVuKSBjb29yZGluYXRlcyBhbmQgYmFjayAoYW5kIHRvXHJcbiAqIGNvb3JkaW5hdGVzIGluIG90aGVyIHVuaXRzIGZvciBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS4gU2VlXHJcbiAqIFtzcGF0aWFsIHJlZmVyZW5jZSBzeXN0ZW1dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29vcmRpbmF0ZV9yZWZlcmVuY2Vfc3lzdGVtKS5cclxuICpcclxuICogTGVhZmxldCBkZWZpbmVzIHRoZSBtb3N0IHVzdWFsIENSU3MgYnkgZGVmYXVsdC4gSWYgeW91IHdhbnQgdG8gdXNlIGFcclxuICogQ1JTIG5vdCBkZWZpbmVkIGJ5IGRlZmF1bHQsIHRha2UgYSBsb29rIGF0IHRoZVxyXG4gKiBbUHJvajRMZWFmbGV0XShodHRwczovL2dpdGh1Yi5jb20va2FydGVuYS9Qcm9qNExlYWZsZXQpIHBsdWdpbi5cclxuICovXHJcblxyXG5MLkNSUyA9IHtcclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvUG9pbnQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgZ2l2ZW4gem9vbS5cclxuXHRsYXRMbmdUb1BvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpLFxyXG5cdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbi5fdHJhbnNmb3JtKHByb2plY3RlZFBvaW50LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYGxhdExuZ1RvUG9pbnRgLiBQcm9qZWN0cyBwaXhlbCBjb29yZGluYXRlcyBvbiBhIGdpdmVuXHJcblx0Ly8gem9vbSBpbnRvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHRwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgdW50cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwb2ludCwgc2NhbGUpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBjb29yZGluYXRlcyBpbiB1bml0cyBhY2NlcHRlZCBmb3JcclxuXHQvLyB0aGlzIENSUyAoZS5nLiBtZXRlcnMgZm9yIEVQU0c6Mzg1NywgZm9yIHBhc3NpbmcgaXQgdG8gV01TIHNlcnZpY2VzKS5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgTGF0TG5nLlxyXG5cdC8vIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGUoem9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgdXNlZCB3aGVuIHRyYW5zZm9ybWluZyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgaW50b1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIHBhcnRpY3VsYXIgem9vbS4gRm9yIGV4YW1wbGUsIGl0IHJldHVybnNcclxuXHQvLyBgMjU2ICogMl56b29tYCBmb3IgTWVyY2F0b3ItYmFzZWQgQ1JTLlxyXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIDI1NiAqIE1hdGgucG93KDIsIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbShzY2FsZTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gSW52ZXJzZSBvZiBgc2NhbGUoKWAsIHJldHVybnMgdGhlIHpvb20gbGV2ZWwgY29ycmVzcG9uZGluZyB0byBhIHNjYWxlXHJcblx0Ly8gZmFjdG9yIG9mIGBzY2FsZWAuXHJcblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUgLyAyNTYpIC8gTWF0aC5MTjI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQcm9qZWN0ZWRCb3VuZHMoem9vbTogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGlvbidzIGJvdW5kcyBzY2FsZWQgYW5kIHRyYW5zZm9ybWVkIGZvciB0aGUgcHJvdmlkZWQgYHpvb21gLlxyXG5cdGdldFByb2plY3RlZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG5cdFx0dmFyIGIgPSB0aGlzLnByb2plY3Rpb24uYm91bmRzLFxyXG5cdFx0ICAgIHMgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWluLCBzKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShiLm1heCwgcyk7XHJcblxyXG5cdFx0cmV0dXJuIEwuYm91bmRzKG1pbiwgbWF4KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMjogTGF0TG5nKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cclxuXHQvLyBAcHJvcGVydHkgY29kZTogU3RyaW5nXHJcblx0Ly8gU3RhbmRhcmQgY29kZSBuYW1lIG9mIHRoZSBDUlMgcGFzc2VkIGludG8gV01TIHNlcnZpY2VzIChlLmcuIGAnRVBTRzozODU3J2ApXHJcblx0Ly9cclxuXHQvLyBAcHJvcGVydHkgd3JhcExuZzogTnVtYmVyW11cclxuXHQvLyBBbiBhcnJheSBvZiB0d28gbnVtYmVycyBkZWZpbmluZyB3aGV0aGVyIHRoZSBsb25naXR1ZGUgKGhvcml6b250YWwpIGNvb3JkaW5hdGVcclxuXHQvLyBheGlzIHdyYXBzIGFyb3VuZCBhIGdpdmVuIHJhbmdlIGFuZCBob3cuIERlZmF1bHRzIHRvIGBbLTE4MCwgMTgwXWAgaW4gbW9zdFxyXG5cdC8vIGdlb2dyYXBoaWNhbCBDUlNzLiBJZiBgdW5kZWZpbmVkYCwgdGhlIGxvbmdpdHVkZSBheGlzIGRvZXMgbm90IHdyYXAgYXJvdW5kLlxyXG5cdC8vXHJcblx0Ly8gQHByb3BlcnR5IHdyYXBMYXQ6IE51bWJlcltdXHJcblx0Ly8gTGlrZSBgd3JhcExuZ2AsIGJ1dCBmb3IgdGhlIGxhdGl0dWRlICh2ZXJ0aWNhbCkgYXhpcy5cclxuXHJcblx0Ly8gd3JhcExuZzogW21pbiwgbWF4XSxcclxuXHQvLyB3cmFwTGF0OiBbbWluLCBtYXhdLFxyXG5cclxuXHQvLyBAcHJvcGVydHkgaW5maW5pdGU6IEJvb2xlYW5cclxuXHQvLyBJZiB0cnVlLCB0aGUgY29vcmRpbmF0ZSBzcGFjZSB3aWxsIGJlIHVuYm91bmRlZCAoaW5maW5pdGUgaW4gYm90aCBheGVzKVxyXG5cdGluZmluaXRlOiBmYWxzZSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nKGxhdGxuZzogTGF0TG5nKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdgIHdoZXJlIGxhdCBhbmQgbG5nIGhhcyBiZWVuIHdyYXBwZWQgYWNjb3JkaW5nIHRvIHRoZVxyXG5cdC8vIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlIENSUydzIGJvdW5kcy5cclxuXHR3cmFwTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgbG5nID0gdGhpcy53cmFwTG5nID8gTC5VdGlsLndyYXBOdW0obGF0bG5nLmxuZywgdGhpcy53cmFwTG5nLCB0cnVlKSA6IGxhdGxuZy5sbmcsXHJcblx0XHQgICAgbGF0ID0gdGhpcy53cmFwTGF0ID8gTC5VdGlsLndyYXBOdW0obGF0bG5nLmxhdCwgdGhpcy53cmFwTGF0LCB0cnVlKSA6IGxhdGxuZy5sYXQsXHJcblx0XHQgICAgYWx0ID0gbGF0bG5nLmFsdDtcclxuXHJcblx0XHRyZXR1cm4gTC5sYXRMbmcobGF0LCBsbmcsIGFsdCk7XHJcblx0fVxyXG59O1xyXG5cbi8qXG4gKiBAbmFtZXNwYWNlIENSU1xuICogQGNycyBMLkNSUy5TaW1wbGVcbiAqXG4gKiBBIHNpbXBsZSBDUlMgdGhhdCBtYXBzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgaW50byBgeGAgYW5kIGB5YCBkaXJlY3RseS5cbiAqIE1heSBiZSB1c2VkIGZvciBtYXBzIG9mIGZsYXQgc3VyZmFjZXMgKGUuZy4gZ2FtZSBtYXBzKS4gTm90ZSB0aGF0IHRoZSBgeWBcbiAqIGF4aXMgc2hvdWxkIHN0aWxsIGJlIGludmVydGVkIChnb2luZyBmcm9tIGJvdHRvbSB0byB0b3ApLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogc2ltcGxlIGV1Y2xpZGVhbiBkaXN0YW5jZS5cbiAqL1xuXG5MLkNSUy5TaW1wbGUgPSBMLmV4dGVuZCh7fSwgTC5DUlMsIHtcblx0cHJvamVjdGlvbjogTC5Qcm9qZWN0aW9uLkxvbkxhdCxcblx0dHJhbnNmb3JtYXRpb246IG5ldyBMLlRyYW5zZm9ybWF0aW9uKDEsIDAsIC0xLCAwKSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRyZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG5cdH0sXG5cblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XG5cdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yO1xuXHR9LFxuXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciBkeCA9IGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcsXG5cdFx0ICAgIGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHR9LFxuXG5cdGluZmluaXRlOiB0cnVlXG59KTtcblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLkVhcnRoXG4gKlxuICogU2VydmVzIGFzIHRoZSBiYXNlIGZvciBDUlMgdGhhdCBhcmUgZ2xvYmFsIHN1Y2ggdGhhdCB0aGV5IGNvdmVyIHRoZSBlYXJ0aC5cbiAqIENhbiBvbmx5IGJlIHVzZWQgYXMgdGhlIGJhc2UgZm9yIG90aGVyIENSUyBhbmQgY2Fubm90IGJlIHVzZWQgZGlyZWN0bHksXG4gKiBzaW5jZSBpdCBkb2VzIG5vdCBoYXZlIGEgYGNvZGVgLCBgcHJvamVjdGlvbmAgb3IgYHRyYW5zZm9ybWF0aW9uYC4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAqIG1ldGVycy5cbiAqL1xuXG5MLkNSUy5FYXJ0aCA9IEwuZXh0ZW5kKHt9LCBMLkNSUywge1xuXHR3cmFwTG5nOiBbLTE4MCwgMTgwXSxcblxuXHQvLyBNZWFuIEVhcnRoIFJhZGl1cywgYXMgcmVjb21tZW5kZWQgZm9yIHVzZSBieVxuXHQvLyB0aGUgSW50ZXJuYXRpb25hbCBVbmlvbiBvZiBHZW9kZXN5IGFuZCBHZW9waHlzaWNzLFxuXHQvLyBzZWUgaHR0cDovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG5cdFI6IDYzNzEwMDAsXG5cblx0Ly8gZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIHBvaW50cyB1c2luZyBzcGhlcmljYWwgbGF3IG9mIGNvc2luZXMgYXBwcm94aW1hdGlvblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHR2YXIgcmFkID0gTWF0aC5QSSAvIDE4MCxcblx0XHQgICAgbGF0MSA9IGxhdGxuZzEubGF0ICogcmFkLFxuXHRcdCAgICBsYXQyID0gbGF0bG5nMi5sYXQgKiByYWQsXG5cdFx0ICAgIGEgPSBNYXRoLnNpbihsYXQxKSAqIE1hdGguc2luKGxhdDIpICtcblx0XHQgICAgICAgIE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBNYXRoLmNvcygobGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZykgKiByYWQpO1xuXG5cdFx0cmV0dXJuIHRoaXMuUiAqIE1hdGguYWNvcyhNYXRoLm1pbihhLCAxKSk7XG5cdH1cbn0pO1xuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0czODU3XHJcbiAqXHJcbiAqIFRoZSBtb3N0IGNvbW1vbiBDUlMgZm9yIG9ubGluZSBtYXBzLCB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbFxyXG4gKiB0aWxlIHByb3ZpZGVycy4gVXNlcyBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi4gU2V0IGluIGJ5IGRlZmF1bHQgaW5cclxuICogTWFwJ3MgYGNyc2Agb3B0aW9uLlxyXG4gKi9cclxuXHJcbkwuQ1JTLkVQU0czODU3ID0gTC5leHRlbmQoe30sIEwuQ1JTLkVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6Mzg1NycsXHJcblx0cHJvamVjdGlvbjogTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIG5ldyBMLlRyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuXHR9KCkpXHJcbn0pO1xyXG5cclxuTC5DUlMuRVBTRzkwMDkxMyA9IEwuZXh0ZW5kKHt9LCBMLkNSUy5FUFNHMzg1Nywge1xyXG5cdGNvZGU6ICdFUFNHOjkwMDkxMydcclxufSk7XHJcblxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHNDMyNlxyXG4gKlxyXG4gKiBBIGNvbW1vbiBDUlMgYW1vbmcgR0lTIGVudGh1c2lhc3RzLiBVc2VzIHNpbXBsZSBFcXVpcmVjdGFuZ3VsYXIgcHJvamVjdGlvbi5cclxuICovXHJcblxyXG5MLkNSUy5FUFNHNDMyNiA9IEwuZXh0ZW5kKHt9LCBMLkNSUy5FYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjQzMjYnLFxyXG5cdHByb2plY3Rpb246IEwuUHJvamVjdGlvbi5Mb25MYXQsXHJcblx0dHJhbnNmb3JtYXRpb246IG5ldyBMLlRyYW5zZm9ybWF0aW9uKDEgLyAxODAsIDEsIC0xIC8gMTgwLCAwLjUpXHJcbn0pO1xyXG5cbi8qXHJcbiAqIEBjbGFzcyBNYXBcclxuICogQGFrYSBMLk1hcFxyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gKlxyXG4gKiBUaGUgY2VudHJhbCBjbGFzcyBvZiB0aGUgQVBJIOKAlCBpdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG1hcCBvbiBhIHBhZ2UgYW5kIG1hbmlwdWxhdGUgaXQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIC8vIGluaXRpYWxpemUgdGhlIG1hcCBvbiB0aGUgXCJtYXBcIiBkaXYgd2l0aCBhIGdpdmVuIGNlbnRlciBhbmQgem9vbVxyXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcclxuICogXHRjZW50ZXI6IFs1MS41MDUsIC0wLjA5XSxcclxuICogXHR6b29tOiAxM1xyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqL1xyXG5cclxuTC5NYXAgPSBMLkV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIFN0YXRlIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gY3JzOiBDUlMgPSBMLkNSUy5FUFNHMzg1N1xyXG5cdFx0Ly8gVGhlIFtDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW1dKCNjcnMpIHRvIHVzZS4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdFxyXG5cdFx0Ly8gc3VyZSB3aGF0IGl0IG1lYW5zLlxyXG5cdFx0Y3JzOiBMLkNSUy5FUFNHMzg1NyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNlbnRlcjogTGF0TG5nID0gdW5kZWZpbmVkXHJcblx0XHQvLyBJbml0aWFsIGdlb2dyYXBoaWMgY2VudGVyIG9mIHRoZSBtYXBcclxuXHRcdGNlbnRlcjogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbTogTnVtYmVyID0gdW5kZWZpbmVkXHJcblx0XHQvLyBJbml0aWFsIG1hcCB6b29tIGxldmVsXHJcblx0XHR6b29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcclxuXHRcdC8vIE1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLiBPdmVycmlkZXMgYW55IGBtaW5ab29tYCBvcHRpb24gc2V0IG9uIG1hcCBsYXllcnMuXHJcblx0XHRtaW5ab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcclxuXHRcdC8vIE1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLiBPdmVycmlkZXMgYW55IGBtYXhab29tYCBvcHRpb24gc2V0IG9uIG1hcCBsYXllcnMuXHJcblx0XHRtYXhab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsYXllcnM6IExheWVyW10gPSBbXVxyXG5cdFx0Ly8gQXJyYXkgb2YgbGF5ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwIGluaXRpYWxseVxyXG5cdFx0bGF5ZXJzOiBbXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEJvdW5kczogTGF0TG5nQm91bmRzID0gbnVsbFxyXG5cdFx0Ly8gV2hlbiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSBtYXAgcmVzdHJpY3RzIHRoZSB2aWV3IHRvIHRoZSBnaXZlblxyXG5cdFx0Ly8gZ2VvZ3JhcGhpY2FsIGJvdW5kcywgYm91bmNpbmcgdGhlIHVzZXIgYmFjayB3aGVuIGhlIHRyaWVzIHRvIHBhblxyXG5cdFx0Ly8gb3V0c2lkZSB0aGUgdmlldy4gVG8gc2V0IHRoZSByZXN0cmljdGlvbiBkeW5hbWljYWxseSwgdXNlXHJcblx0XHQvLyBbYHNldE1heEJvdW5kc2BdKCNtYXAtc2V0bWF4Ym91bmRzKSBtZXRob2QuXHJcblx0XHRtYXhCb3VuZHM6IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlciA9ICpcclxuXHRcdC8vIFRoZSBkZWZhdWx0IG1ldGhvZCBmb3IgZHJhd2luZyB2ZWN0b3IgbGF5ZXJzIG9uIHRoZSBtYXAuIGBMLlNWR2BcclxuXHRcdC8vIG9yIGBMLkNhbnZhc2AgYnkgZGVmYXVsdCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0LlxyXG5cdFx0cmVuZGVyZXI6IHVuZGVmaW5lZCxcclxuXHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gQW5pbWF0aW9uIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gZmFkZUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHRpbGUgZmFkZSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdGZhZGVBbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXJrZXJab29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciBtYXJrZXJzIGFuaW1hdGUgdGhlaXIgem9vbSB3aXRoIHRoZSB6b29tIGFuaW1hdGlvbiwgaWYgZGlzYWJsZWRcclxuXHRcdC8vIHRoZXkgd2lsbCBkaXNhcHBlYXIgZm9yIHRoZSBsZW5ndGggb2YgdGhlIGFuaW1hdGlvbi4gQnkgZGVmYXVsdCBpdCdzXHJcblx0XHQvLyBlbmFibGVkIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdG1hcmtlclpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFuc2Zvcm0zRExpbWl0OiBOdW1iZXIgPSAyXjIzXHJcblx0XHQvLyBEZWZpbmVzIHRoZSBtYXhpbXVtIHNpemUgb2YgYSBDU1MgdHJhbnNsYXRpb24gdHJhbnNmb3JtLiBUaGUgZGVmYXVsdFxyXG5cdFx0Ly8gdmFsdWUgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIHVubGVzcyBhIHdlYiBicm93c2VyIHBvc2l0aW9ucyBsYXllcnMgaW5cclxuXHRcdC8vIHRoZSB3cm9uZyBwbGFjZSBhZnRlciBkb2luZyBhIGxhcmdlIGBwYW5CeWAuXHJcblx0XHR0cmFuc2Zvcm0zRExpbWl0OiA4Mzg4NjA4LCAvLyBQcmVjaXNpb24gbGltaXQgb2YgYSAzMi1iaXQgZmxvYXRcclxuXHJcblx0XHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIHpvb21TbmFwOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBGb3JjZXMgdGhlIG1hcCdzIHpvb20gbGV2ZWwgdG8gYWx3YXlzIGJlIGEgbXVsdGlwbGUgb2YgdGhpcywgcGFydGljdWxhcmx5XHJcblx0XHQvLyByaWdodCBhZnRlciBhIFtgZml0Qm91bmRzKClgXSgjbWFwLWZpdGJvdW5kcykgb3IgYSBwaW5jaC16b29tLlxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgdGhlIHpvb20gbGV2ZWwgc25hcHMgdG8gdGhlIG5lYXJlc3QgaW50ZWdlcjsgbG93ZXIgdmFsdWVzXHJcblx0XHQvLyAoZS5nLiBgMC41YCBvciBgMC4xYCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuIEEgdmFsdWUgb2YgYDBgXHJcblx0XHQvLyBtZWFucyB0aGUgem9vbSBsZXZlbCB3aWxsIG5vdCBiZSBzbmFwcGVkIGFmdGVyIGBmaXRCb3VuZHNgIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdHpvb21TbmFwOiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbURlbHRhOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBDb250cm9scyBob3cgbXVjaCB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB3aWxsIGNoYW5nZSBhZnRlciBhXHJcblx0XHQvLyBbYHpvb21JbigpYF0oI21hcC16b29taW4pLCBbYHpvb21PdXQoKWBdKCNtYXAtem9vbW91dCksIHByZXNzaW5nIGArYFxyXG5cdFx0Ly8gb3IgYC1gIG9uIHRoZSBrZXlib2FyZCwgb3IgdXNpbmcgdGhlIFt6b29tIGNvbnRyb2xzXSgjY29udHJvbC16b29tKS5cclxuXHRcdC8vIFZhbHVlcyBzbWFsbGVyIHRoYW4gYDFgIChlLmcuIGAwLjVgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS5cclxuXHRcdHpvb21EZWx0YTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYWNrUmVzaXplOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFwIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBicm93c2VyIHdpbmRvdyByZXNpemUgdG8gdXBkYXRlIGl0c2VsZi5cclxuXHRcdHRyYWNrUmVzaXplOiB0cnVlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7IC8vIChIVE1MRWxlbWVudCBvciBTdHJpbmcsIE9iamVjdClcclxuXHRcdG9wdGlvbnMgPSBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcihpZCk7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblxyXG5cdFx0Ly8gaGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTk4MFxyXG5cdFx0dGhpcy5fb25SZXNpemUgPSBMLmJpbmQodGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHMoKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gdGhpcy5fbGltaXRab29tKG9wdGlvbnMuem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuY2VudGVyICYmIG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc2V0VmlldyhMLmxhdExuZyhvcHRpb25zLmNlbnRlciksIG9wdGlvbnMuem9vbSwge3Jlc2V0OiB0cnVlfSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faGFuZGxlcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblxyXG5cdFx0dGhpcy5fYWRkTGF5ZXJzKHRoaXMub3B0aW9ucy5sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VmlldyhjZW50ZXI6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHdpdGggdGhlIGdpdmVuXHJcblx0Ly8gYW5pbWF0aW9uIG9wdGlvbnMuXHJcblx0c2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0Ly8gcmVwbGFjZWQgYnkgYW5pbWF0aW9uLXBvd2VyZWQgaW1wbGVtZW50YXRpb24gaW4gTWFwLlBhbkFuaW1hdGlvbi5qc1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0Wm9vbSgpIDogem9vbTtcclxuXHRcdHRoaXMuX3Jlc2V0VmlldyhMLmxhdExuZyhjZW50ZXIpLCB6b29tKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbSh6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgem9vbSBvZiB0aGUgbWFwLlxyXG5cdHNldFpvb206IGZ1bmN0aW9uICh6b29tLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tSW4oZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gSW5jcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbUluOiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdGRlbHRhID0gZGVsdGEgfHwgKEwuQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSArIGRlbHRhLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21PdXQoZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gRGVjcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbU91dDogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcblx0XHRkZWx0YSA9IGRlbHRhIHx8IChMLkJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gLSBkZWx0YSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgZ2VvZ3JhcGhpY2FsIHBvaW50IG9uIHRoZSBtYXBcclxuXHQvLyBzdGF0aW9uYXJ5IChlLmcuIHVzZWQgaW50ZXJuYWxseSBmb3Igc2Nyb2xsIHpvb20gYW5kIGRvdWJsZS1jbGljayB6b29tKS5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQob2Zmc2V0OiBQb2ludCwgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIHBpeGVsIG9uIHRoZSBtYXAgKHJlbGF0aXZlIHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIpIHN0YXRpb25hcnkuXHJcblx0c2V0Wm9vbUFyb3VuZDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgb3B0aW9ucykge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICBjb250YWluZXJQb2ludCA9IGxhdGxuZyBpbnN0YW5jZW9mIEwuUG9pbnQgPyBsYXRsbmcgOiB0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nKSxcclxuXHJcblx0XHQgICAgY2VudGVyT2Zmc2V0ID0gY29udGFpbmVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLm11bHRpcGx5QnkoMSAtIDEgLyBzY2FsZSksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF0TG5nKHZpZXdIYWxmLmFkZChjZW50ZXJPZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KG5ld0NlbnRlciwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Qm91bmRzQ2VudGVyWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0Ym91bmRzID0gYm91bmRzLmdldEJvdW5kcyA/IGJvdW5kcy5nZXRCb3VuZHMoKSA6IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdUTCA9IEwucG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSBMLnBvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cclxuXHRcdCAgICB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcywgZmFsc2UsIHBhZGRpbmdUTC5hZGQocGFkZGluZ0JSKSk7XHJcblxyXG5cdFx0em9vbSA9ICh0eXBlb2Ygb3B0aW9ucy5tYXhab29tID09PSAnbnVtYmVyJykgPyBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIHpvb20pIDogem9vbTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ09mZnNldCA9IHBhZGRpbmdCUi5zdWJ0cmFjdChwYWRkaW5nVEwpLmRpdmlkZUJ5KDIpLFxyXG5cclxuXHRcdCAgICBzd1BvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSksXHJcblx0XHQgICAgbmVQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIGNlbnRlciA9IHRoaXMudW5wcm9qZWN0KHN3UG9pbnQuYWRkKG5lUG9pbnQpLmRpdmlkZUJ5KDIpLmFkZChwYWRkaW5nT2Zmc2V0KSwgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcblx0XHRcdHpvb206IHpvb21cclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM6IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IGNvbnRhaW5zIHRoZSBnaXZlbiBnZW9ncmFwaGljYWwgYm91bmRzIHdpdGggdGhlXHJcblx0Ly8gbWF4aW11bSB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG5cdGZpdEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuXHRcdGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignQm91bmRzIGFyZSBub3QgdmFsaWQuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRhcmdldCA9IHRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20oYm91bmRzLCBvcHRpb25zKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZml0V29ybGQob3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IG1vc3RseSBjb250YWlucyB0aGUgd2hvbGUgd29ybGQgd2l0aCB0aGUgbWF4aW11bVxyXG5cdC8vIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcblx0Zml0V29ybGQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5maXRCb3VuZHMoW1stOTAsIC0xODBdLCBbOTAsIDE4MF1dLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhblRvKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIHRvIGEgZ2l2ZW4gY2VudGVyLlxyXG5cdHBhblRvOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7IC8vIChMYXRMbmcpXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KGNlbnRlciwgdGhpcy5fem9vbSwge3Bhbjogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuQnkob2Zmc2V0OiBQb2ludCk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgYnkgYSBnaXZlbiBudW1iZXIgb2YgcGl4ZWxzIChhbmltYXRlZCkuXHJcblx0cGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHsgLy8gKFBvaW50KVxyXG5cdFx0Ly8gcmVwbGFjZWQgd2l0aCBhbmltYXRlZCBwYW5CeSBpbiBNYXAuUGFuQW5pbWF0aW9uLmpzXHJcblx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cclxuXHRcdHRoaXMuX3Jhd1BhbkJ5KEwucG9pbnQob2Zmc2V0KSk7XHJcblxyXG5cdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNYXhCb3VuZHMoYm91bmRzOiBCb3VuZHMpOiB0aGlzXHJcblx0Ly8gUmVzdHJpY3RzIHRoZSBtYXAgdmlldyB0byB0aGUgZ2l2ZW4gYm91bmRzIChzZWUgdGhlIFttYXhCb3VuZHNdKCNtYXAtbWF4Ym91bmRzKSBvcHRpb24pLlxyXG5cdHNldE1heEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IG51bGw7XHJcblx0XHRcdHJldHVybiB0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBib3VuZHM7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5vbignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNaW5ab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBsb3dlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWluWm9vbV0oI21hcC1taW56b29tKSBvcHRpb24pLlxyXG5cdHNldE1pblpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR0aGlzLm9wdGlvbnMubWluWm9vbSA9IHpvb207XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiB0aGlzLmdldFpvb20oKSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNYXhab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB1cHBlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWF4Wm9vbV0oI21hcC1tYXh6b29tKSBvcHRpb24pLlxyXG5cdHNldE1heFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbSA9IHpvb207XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiAodGhpcy5nZXRab29tKCkgPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkluc2lkZUJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byB0aGUgY2xvc2VzdCB2aWV3IHRoYXQgd291bGQgbGllIGluc2lkZSB0aGUgZ2l2ZW4gYm91bmRzIChpZiBpdCdzIG5vdCBhbHJlYWR5KSwgY29udHJvbGxpbmcgdGhlIGFuaW1hdGlvbiB1c2luZyB0aGUgb3B0aW9ucyBzcGVjaWZpYywgaWYgYW55LlxyXG5cdHBhbkluc2lkZUJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gdHJ1ZTtcclxuXHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKGNlbnRlciwgdGhpcy5fem9vbSwgTC5sYXRMbmdCb3VuZHMoYm91bmRzKSk7XHJcblxyXG5cdFx0aWYgKCFjZW50ZXIuZXF1YWxzKG5ld0NlbnRlcikpIHtcclxuXHRcdFx0dGhpcy5wYW5UbyhuZXdDZW50ZXIsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShvcHRpb25zOiBab29tL1BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuXHQvLyBwYW4gYnkgZGVmYXVsdC4gSWYgYG9wdGlvbnMucGFuYCBpcyBgZmFsc2VgLCBwYW5uaW5nIHdpbGwgbm90IG9jY3VyLlxyXG5cdC8vIElmIGBvcHRpb25zLmRlYm91bmNlTW92ZWVuZGAgaXMgYHRydWVgLCBpdCB3aWxsIGRlbGF5IGBtb3ZlZW5kYCBldmVudCBzb1xyXG5cdC8vIHRoYXQgaXQgZG9lc24ndCBoYXBwZW4gb2Z0ZW4gZXZlbiBpZiB0aGUgbWV0aG9kIGlzIGNhbGxlZCBtYW55XHJcblx0Ly8gdGltZXMgaW4gYSByb3cuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUoYW5pbWF0ZTogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuXHJcblx0aW52YWxpZGF0ZVNpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdG9wdGlvbnMgPSBMLmV4dGVuZCh7XHJcblx0XHRcdGFuaW1hdGU6IGZhbHNlLFxyXG5cdFx0XHRwYW46IHRydWVcclxuXHRcdH0sIG9wdGlvbnMgPT09IHRydWUgPyB7YW5pbWF0ZTogdHJ1ZX0gOiBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgb2xkU2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xyXG5cdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5fbGFzdENlbnRlciA9IG51bGw7XHJcblxyXG5cdFx0dmFyIG5ld1NpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBvbGRDZW50ZXIgPSBvbGRTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gbmV3U2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG9sZENlbnRlci5zdWJ0cmFjdChuZXdDZW50ZXIpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAmJiBvcHRpb25zLnBhbikge1xyXG5cdFx0XHR0aGlzLnBhbkJ5KG9mZnNldCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKG9wdGlvbnMucGFuKSB7XHJcblx0XHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy5kZWJvdW5jZU1vdmVlbmQpIHtcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuXHRcdFx0XHR0aGlzLl9zaXplVGltZXIgPSBzZXRUaW1lb3V0KEwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdtb3ZlZW5kJyksIDIwMCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHJlc2l6ZTogUmVzaXplRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyByZXNpemVkLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgncmVzaXplJywge1xyXG5cdFx0XHRvbGRTaXplOiBvbGRTaXplLFxyXG5cdFx0XHRuZXdTaXplOiBuZXdTaXplXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcblx0Ly8gQG1ldGhvZCBzdG9wKCk6IHRoaXNcclxuXHQvLyBTdG9wcyB0aGUgY3VycmVudGx5IHJ1bm5pbmcgYHBhblRvYCBvciBgZmx5VG9gIGFuaW1hdGlvbiwgaWYgYW55LlxyXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9saW1pdFpvb20odGhpcy5fem9vbSkpO1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuem9vbVNuYXApIHtcclxuXHRcdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9zdG9wKCk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIFRPRE8gaGFuZGxlci5hZGRUb1xyXG5cdC8vIFRPRE8gQXBwcm9waWF0ZSBkb2NzIHNlY3Rpb24/XHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgYWRkSGFuZGxlcihuYW1lOiBTdHJpbmcsIEhhbmRsZXJDbGFzczogRnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gQWRkcyBhIG5ldyBgSGFuZGxlcmAgdG8gdGhlIG1hcCwgZ2l2ZW4gaXRzIG5hbWUgYW5kIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG5cdGFkZEhhbmRsZXI6IGZ1bmN0aW9uIChuYW1lLCBIYW5kbGVyQ2xhc3MpIHtcclxuXHRcdGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSB0aGlzW25hbWVdID0gbmV3IEhhbmRsZXJDbGFzcyh0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuXHRcdFx0aGFuZGxlci5lbmFibGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZSgpOiB0aGlzXHJcblx0Ly8gRGVzdHJveXMgdGhlIG1hcCBhbmQgY2xlYXJzIGFsbCByZWxhdGVkIGV2ZW50IGxpc3RlbmVycy5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKHRydWUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jb250YWluZXJJZCAhPT0gdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBiZWluZyByZXVzZWQgYnkgYW5vdGhlciBpbnN0YW5jZScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIHRocm93cyBlcnJvciBpbiBJRTYtOFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkO1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVySWQ7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRcdFx0dGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkID0gdW5kZWZpbmVkO1xyXG5cdFx0XHQvKmVzbGludC1lbmFibGUgKi9cclxuXHRcdFx0dGhpcy5fY29udGFpbmVySWQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9tYXBQYW5lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fY2xlYXJDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2NsZWFyQ29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NsZWFySGFuZGxlcnMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCB1bmxvYWQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBkZXN0cm95ZWQgd2l0aCBbcmVtb3ZlXSgjbWFwLXJlbW92ZSkgbWV0aG9kLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ3VubG9hZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5yZW1vdmUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVQYW5lKG5hbWU6IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIENyZWF0ZXMgYSBuZXcgW21hcCBwYW5lXSgjbWFwLXBhbmUpIHdpdGggdGhlIGdpdmVuIG5hbWUgaWYgaXQgZG9lc24ndCBleGlzdCBhbHJlYWR5LFxyXG5cdC8vIHRoZW4gcmV0dXJucyBpdC4gVGhlIHBhbmUgaXMgY3JlYXRlZCBhcyBhIGNoaWxkcmVuIG9mIGBjb250YWluZXJgLCBvclxyXG5cdC8vIGFzIGEgY2hpbGRyZW4gb2YgdGhlIG1haW4gbWFwIHBhbmUgaWYgbm90IHNldC5cclxuXHRjcmVhdGVQYW5lOiBmdW5jdGlvbiAobmFtZSwgY29udGFpbmVyKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtcGFuZScgKyAobmFtZSA/ICcgbGVhZmxldC0nICsgbmFtZS5yZXBsYWNlKCdQYW5lJywgJycpICsgJy1wYW5lJyA6ICcnKSxcclxuXHRcdCAgICBwYW5lID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIgfHwgdGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKG5hbWUpIHtcclxuXHRcdFx0dGhpcy5fcGFuZXNbbmFtZV0gPSBwYW5lO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgR2V0dGluZyBNYXAgU3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGNlbnRlciBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGFzdENlbnRlciAmJiAhdGhpcy5fbW92ZWQoKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fbGFzdENlbnRlcjtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIG1hcCB2aWV3XHJcblx0Z2V0Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3pvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyB2aXNpYmxlIGluIHRoZSBjdXJyZW50IG1hcCB2aWV3XHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIHN3ID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldEJvdHRvbUxlZnQoKSksXHJcblx0XHQgICAgbmUgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0VG9wUmlnaHQoKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhzdywgbmUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWluWm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWluWm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycyksIG9yIGAwYCBieSBkZWZhdWx0LlxyXG5cdGdldE1pblpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fbGF5ZXJzTWluWm9vbSB8fCAwIDogdGhpcy5vcHRpb25zLm1pblpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRNYXhab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtYXhab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKS5cclxuXHRnZXRNYXhab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdCh0aGlzLl9sYXllcnNNYXhab29tID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHRoaXMuX2xheWVyc01heFpvb20pIDpcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHNab29tKGJvdW5kczogTGF0TG5nQm91bmRzLCBpbnNpZGU/OiBCb29sZWFuKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBnaXZlbiBib3VuZHMgZml0IHRvIHRoZSBtYXBcclxuXHQvLyB2aWV3IGluIGl0cyBlbnRpcmV0eS4gSWYgYGluc2lkZWAgKG9wdGlvbmFsKSBpcyBzZXQgdG8gYHRydWVgLCB0aGUgbWV0aG9kXHJcblx0Ly8gaW5zdGVhZCByZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIG1hcCB2aWV3IGZpdHMgaW50b1xyXG5cdC8vIHRoZSBnaXZlbiBib3VuZHMgaW4gaXRzIGVudGlyZXR5LlxyXG5cdGdldEJvdW5kc1pvb206IGZ1bmN0aW9uIChib3VuZHMsIGluc2lkZSwgcGFkZGluZykgeyAvLyAoTGF0TG5nQm91bmRzWywgQm9vbGVhbiwgUG9pbnRdKSAtPiBOdW1iZXJcclxuXHRcdGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblx0XHRwYWRkaW5nID0gTC5wb2ludChwYWRkaW5nIHx8IFswLCAwXSk7XHJcblxyXG5cdFx0dmFyIHpvb20gPSB0aGlzLmdldFpvb20oKSB8fCAwLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG5cdFx0ICAgIG53ID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLFxyXG5cdFx0ICAgIHNlID0gYm91bmRzLmdldFNvdXRoRWFzdCgpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKS5zdWJ0cmFjdChwYWRkaW5nKSxcclxuXHRcdCAgICBib3VuZHNTaXplID0gdGhpcy5wcm9qZWN0KHNlLCB6b29tKS5zdWJ0cmFjdCh0aGlzLnByb2plY3QobncsIHpvb20pKSxcclxuXHRcdCAgICBzbmFwID0gTC5Ccm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMTtcclxuXHJcblx0XHR2YXIgc2NhbGUgPSBNYXRoLm1pbihzaXplLnggLyBib3VuZHNTaXplLngsIHNpemUueSAvIGJvdW5kc1NpemUueSk7XHJcblx0XHR6b29tID0gdGhpcy5nZXRTY2FsZVpvb20oc2NhbGUsIHpvb20pO1xyXG5cclxuXHRcdGlmIChzbmFwKSB7XHJcblx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyAoc25hcCAvIDEwMCkpICogKHNuYXAgLyAxMDApOyAvLyBkb24ndCBqdW1wIGlmIHdpdGhpbiAxJSBvZiBhIHNuYXAgbGV2ZWxcclxuXHRcdFx0em9vbSA9IGluc2lkZSA/IE1hdGguY2VpbCh6b29tIC8gc25hcCkgKiBzbmFwIDogTWF0aC5mbG9vcih6b29tIC8gc25hcCkgKiBzbmFwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2l6ZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgbWFwIGNvbnRhaW5lciAoaW4gcGl4ZWxzKS5cclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX3NpemUgfHwgdGhpcy5fc2l6ZUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5fc2l6ZSA9IG5ldyBMLlBvaW50KFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0KTtcclxuXHJcblx0XHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZS5jbG9uZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxCb3VuZHMoKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IG1hcCB2aWV3IGluIHByb2plY3RlZCBwaXhlbFxyXG5cdC8vIGNvb3JkaW5hdGVzIChzb21ldGltZXMgdXNlZnVsIGluIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcblx0Z2V0UGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB0b3BMZWZ0UG9pbnQgPSB0aGlzLl9nZXRUb3BMZWZ0UG9pbnQoY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiBuZXcgTC5Cb3VuZHModG9wTGVmdFBvaW50LCB0b3BMZWZ0UG9pbnQuYWRkKHRoaXMuZ2V0U2l6ZSgpKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETzogQ2hlY2sgc2VtYW50aWNzIC0gaXNuJ3QgdGhlIHBpeGVsIG9yaWdpbiB0aGUgMCwwIGNvb3JkIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIG1hcCBwYW5lPyBcImxlZnQgcG9pbnQgb2YgdGhlIG1hcCBsYXllclwiIGNhbiBiZSBjb25mdXNpbmcsIHNwZWNpYWxseVxyXG5cdC8vIHNpbmNlIHRoZXJlIGNhbiBiZSBuZWdhdGl2ZSBvZmZzZXRzLlxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxPcmlnaW4oKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0ZWQgcGl4ZWwgY29vcmRpbmF0ZXMgb2YgdGhlIHRvcCBsZWZ0IHBvaW50IG9mXHJcblx0Ly8gdGhlIG1hcCBsYXllciAodXNlZnVsIGluIGN1c3RvbSBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG5cdGdldFBpeGVsT3JpZ2luOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxPcmlnaW47XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbFdvcmxkQm91bmRzKHpvb20/OiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSB3b3JsZCdzIGJvdW5kcyBpbiBwaXhlbCBjb29yZGluYXRlcyBmb3Igem9vbSBsZXZlbCBgem9vbWAuXHJcblx0Ly8gSWYgYHpvb21gIGlzIG9taXR0ZWQsIHRoZSBtYXAncyBjdXJyZW50IHpvb20gbGV2ZWwgaXMgdXNlZC5cclxuXHRnZXRQaXhlbFdvcmxkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZ2V0UHJvamVjdGVkQm91bmRzKHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0Wm9vbSgpIDogem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBhbmUocGFuZTogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIGEgW21hcCBwYW5lXSgjbWFwLXBhbmUpLCBnaXZlbiBpdHMgbmFtZSBvciBpdHMgSFRNTCBlbGVtZW50IChpdHMgaWRlbnRpdHkpLlxyXG5cdGdldFBhbmU6IGZ1bmN0aW9uIChwYW5lKSB7XHJcblx0XHRyZXR1cm4gdHlwZW9mIHBhbmUgPT09ICdzdHJpbmcnID8gdGhpcy5fcGFuZXNbcGFuZV0gOiBwYW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGFuZXMoKTogT2JqZWN0XHJcblx0Ly8gUmV0dXJucyBhIHBsYWluIG9iamVjdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgW3BhbmVzXSgjbWFwLXBhbmUpIGFzIGtleXMgYW5kXHJcblx0Ly8gdGhlIHBhbmVzIGFzIHZhbHVlcy5cclxuXHRnZXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BhbmVzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBtYXAuXHJcblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAc2VjdGlvbiBDb252ZXJzaW9uIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRab29tU2NhbGUodG9ab29tOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSBmYWN0b3IgdG8gYmUgYXBwbGllZCB0byBhIG1hcCB0cmFuc2l0aW9uIGZyb20gem9vbSBsZXZlbFxyXG5cdC8vIGBmcm9tWm9vbWAgdG8gYHRvWm9vbWAuIFVzZWQgaW50ZXJuYWxseSB0byBoZWxwIHdpdGggem9vbSBhbmltYXRpb25zLlxyXG5cdGdldFpvb21TY2FsZTogZnVuY3Rpb24gKHRvWm9vbSwgZnJvbVpvb20pIHtcclxuXHRcdC8vIFRPRE8gcmVwbGFjZSB3aXRoIHVuaXZlcnNhbCBpbXBsZW1lbnRhdGlvbiBhZnRlciByZWZhY3RvcmluZyBwcm9qZWN0aW9uc1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcblx0XHRyZXR1cm4gY3JzLnNjYWxlKHRvWm9vbSkgLyBjcnMuc2NhbGUoZnJvbVpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2NhbGVab29tKHNjYWxlOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB6b29tIGxldmVsIHRoYXQgdGhlIG1hcCB3b3VsZCBlbmQgdXAgYXQsIGlmIGl0IGlzIGF0IGBmcm9tWm9vbWBcclxuXHQvLyBsZXZlbCBhbmQgZXZlcnl0aGluZyBpcyBzY2FsZWQgYnkgYSBmYWN0b3Igb2YgYHNjYWxlYC4gSW52ZXJzZSBvZlxyXG5cdC8vIFtgZ2V0Wm9vbVNjYWxlYF0oI21hcC1nZXRab29tU2NhbGUpLlxyXG5cdGdldFNjYWxlWm9vbTogZnVuY3Rpb24gKHNjYWxlLCBmcm9tWm9vbSkge1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcblx0XHR2YXIgem9vbSA9IGNycy56b29tKHNjYWxlICogY3JzLnNjYWxlKGZyb21ab29tKSk7XHJcblx0XHRyZXR1cm4gaXNOYU4oem9vbSkgPyBJbmZpbml0eSA6IHpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgYExhdExuZ2AgYWNjb3JkaW5nIHRvIHRoZSBwcm9qZWN0aW9uXHJcblx0Ly8gb2YgdGhlIG1hcCdzIENSUywgdGhlbiBzY2FsZXMgaXQgYWNjb3JkaW5nIHRvIGB6b29tYCBhbmQgdGhlIENSUydzXHJcblx0Ly8gYFRyYW5zZm9ybWF0aW9uYC4gVGhlIHJlc3VsdCBpcyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIENSUyBvcmlnaW4uXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkge1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMubGF0TG5nVG9Qb2ludChMLmxhdExuZyhsYXRsbmcpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQsIHpvb206IE51bWJlcik6IExhdExuZ1xyXG5cdC8vIEludmVyc2Ugb2YgW2Bwcm9qZWN0YF0oI21hcC1wcm9qZWN0KS5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMucG9pbnRUb0xhdExuZyhMLnBvaW50KHBvaW50KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcblx0bGF5ZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IEwucG9pbnQocG9pbnQpLmFkZCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KHByb2plY3RlZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG5cdGxhdExuZ1RvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0KEwubGF0TG5nKGxhdGxuZykpLl9yb3VuZCgpO1xyXG5cdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Ll9zdWJ0cmFjdCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBgbGF0YCBhbmQgYGxuZ2AgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gbWFwJ3MgQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGVcclxuXHQvLyBDUlMncyBib3VuZHMuXHJcblx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcblx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZyhMLmxhdExuZyhsYXRsbmcpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMjogTGF0TG5nKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGFjY29yZGluZyB0b1xyXG5cdC8vIHRoZSBtYXAncyBDUlMuIEJ5IGRlZmF1bHQgdGhpcyBtZWFzdXJlcyBkaXN0YW5jZSBpbiBtZXRlcnMuXHJcblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5kaXN0YW5jZShMLmxhdExuZyhsYXRsbmcxKSwgTC5sYXRMbmcobGF0bG5nMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmdcclxuXHQvLyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuXHRjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHJldHVybiBMLnBvaW50KHBvaW50KS5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG5cdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuXHRsYXllclBvaW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHJldHVybiBMLnBvaW50KHBvaW50KS5hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnNcclxuXHQvLyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KEwucG9pbnQocG9pbnQpKTtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG5cdC8vIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxhdExuZ1RvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHRoaXMubGF0TG5nVG9MYXllclBvaW50KEwubGF0TG5nKGxhdGxuZykpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZVxyXG5cdC8vIG1hcCBjb250YWluZXIgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudC5nZXRNb3VzZVBvc2l0aW9uKGUsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXllclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xhdExuZyhldjogTW91c2VFdmVudCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgd2hlcmUgdGhlXHJcblx0Ly8gZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9MYXRMbmc6IGZ1bmN0aW9uIChlKSB7IC8vIChNb3VzZUV2ZW50KVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIG1hcCBpbml0aWFsaXphdGlvbiBtZXRob2RzXHJcblxyXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuZ2V0KGlkKTtcclxuXHJcblx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgbm90IGZvdW5kLicpO1xyXG5cdFx0fSBlbHNlIGlmIChjb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0TC5Eb21FdmVudC5hZGRMaXN0ZW5lcihjb250YWluZXIsICdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCwgdGhpcyk7XHJcblx0XHR0aGlzLl9jb250YWluZXJJZCA9IEwuVXRpbC5zdGFtcChjb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xyXG5cclxuXHRcdHRoaXMuX2ZhZGVBbmltYXRlZCA9IHRoaXMub3B0aW9ucy5mYWRlQW5pbWF0aW9uICYmIEwuQnJvd3Nlci5hbnkzZDtcclxuXHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250YWluZXInICtcclxuXHRcdFx0KEwuQnJvd3Nlci50b3VjaCA/ICcgbGVhZmxldC10b3VjaCcgOiAnJykgK1xyXG5cdFx0XHQoTC5Ccm93c2VyLnJldGluYSA/ICcgbGVhZmxldC1yZXRpbmEnIDogJycpICtcclxuXHRcdFx0KEwuQnJvd3Nlci5pZWx0OSA/ICcgbGVhZmxldC1vbGRpZScgOiAnJykgK1xyXG5cdFx0XHQoTC5Ccm93c2VyLnNhZmFyaSA/ICcgbGVhZmxldC1zYWZhcmknIDogJycpICtcclxuXHRcdFx0KHRoaXMuX2ZhZGVBbmltYXRlZCA/ICcgbGVhZmxldC1mYWRlLWFuaW0nIDogJycpKTtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBMLkRvbVV0aWwuZ2V0U3R5bGUoY29udGFpbmVyLCAncG9zaXRpb24nKTtcclxuXHJcblx0XHRpZiAocG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgcG9zaXRpb24gIT09ICdyZWxhdGl2ZScgJiYgcG9zaXRpb24gIT09ICdmaXhlZCcpIHtcclxuXHRcdFx0Y29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0UGFuZXMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdENvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5faW5pdENvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcGFuZXMgPSB0aGlzLl9wYW5lcyA9IHt9O1xyXG5cdFx0dGhpcy5fcGFuZVJlbmRlcmVycyA9IHt9O1xyXG5cclxuXHRcdC8vIEBzZWN0aW9uXHJcblx0XHQvL1xyXG5cdFx0Ly8gUGFuZXMgYXJlIERPTSBlbGVtZW50cyB1c2VkIHRvIGNvbnRyb2wgdGhlIG9yZGVyaW5nIG9mIGxheWVycyBvbiB0aGUgbWFwLiBZb3VcclxuXHRcdC8vIGNhbiBhY2Nlc3MgcGFuZXMgd2l0aCBbYG1hcC5nZXRQYW5lYF0oI21hcC1nZXRwYW5lKSBvclxyXG5cdFx0Ly8gW2BtYXAuZ2V0UGFuZXNgXSgjbWFwLWdldHBhbmVzKSBtZXRob2RzLiBOZXcgcGFuZXMgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGVcclxuXHRcdC8vIFtgbWFwLmNyZWF0ZVBhbmVgXSgjbWFwLWNyZWF0ZXBhbmUpIG1ldGhvZC5cclxuXHRcdC8vXHJcblx0XHQvLyBFdmVyeSBtYXAgaGFzIHRoZSBmb2xsb3dpbmcgZGVmYXVsdCBwYW5lcyB0aGF0IGRpZmZlciBvbmx5IGluIHpJbmRleC5cclxuXHRcdC8vXHJcblx0XHQvLyBAcGFuZSBtYXBQYW5lOiBIVE1MRWxlbWVudCA9ICdhdXRvJ1xyXG5cdFx0Ly8gUGFuZSB0aGF0IGNvbnRhaW5zIGFsbCBvdGhlciBtYXAgcGFuZXNcclxuXHJcblx0XHR0aGlzLl9tYXBQYW5lID0gdGhpcy5jcmVhdGVQYW5lKCdtYXBQYW5lJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgTC5Qb2ludCgwLCAwKSk7XHJcblxyXG5cdFx0Ly8gQHBhbmUgdGlsZVBhbmU6IEhUTUxFbGVtZW50ID0gMjAwXHJcblx0XHQvLyBQYW5lIGZvciBgR3JpZExheWVyYHMgYW5kIGBUaWxlTGF5ZXJgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCd0aWxlUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgb3ZlcmxheVBhbmU6IEhUTUxFbGVtZW50ID0gNDAwXHJcblx0XHQvLyBQYW5lIGZvciB2ZWN0b3Igb3ZlcmxheXMgKGBQYXRoYHMpLCBsaWtlIGBQb2x5bGluZWBzIGFuZCBgUG9seWdvbmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3NoYWRvd1BhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHNoYWRvd1BhbmU6IEhUTUxFbGVtZW50ID0gNTAwXHJcblx0XHQvLyBQYW5lIGZvciBvdmVybGF5IHNoYWRvd3MgKGUuZy4gYE1hcmtlcmAgc2hhZG93cylcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnb3ZlcmxheVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG1hcmtlclBhbmU6IEhUTUxFbGVtZW50ID0gNjAwXHJcblx0XHQvLyBQYW5lIGZvciBgSWNvbmBzIG9mIGBNYXJrZXJgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdtYXJrZXJQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSB0b29sdGlwUGFuZTogSFRNTEVsZW1lbnQgPSA2NTBcclxuXHRcdC8vIFBhbmUgZm9yIHRvb2x0aXAuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3Rvb2x0aXBQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBwb3B1cFBhbmU6IEhUTUxFbGVtZW50ID0gNzAwXHJcblx0XHQvLyBQYW5lIGZvciBgUG9wdXBgcy5cclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgncG9wdXBQYW5lJyk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MocGFuZXMubWFya2VyUGFuZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5zaGFkb3dQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIHRoYXQgbW9kaWZ5IG1hcCBzdGF0ZVxyXG5cclxuXHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgTC5Qb2ludCgwLCAwKSk7XHJcblxyXG5cdFx0dmFyIGxvYWRpbmcgPSAhdGhpcy5fbG9hZGVkO1xyXG5cdFx0dGhpcy5fbG9hZGVkID0gdHJ1ZTtcclxuXHRcdHpvb20gPSB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcblxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cHJlcmVzZXQnKTtcclxuXHJcblx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG5cdFx0dGhpc1xyXG5cdFx0XHQuX21vdmVTdGFydCh6b29tQ2hhbmdlZClcclxuXHRcdFx0Ll9tb3ZlKGNlbnRlciwgem9vbSlcclxuXHRcdFx0Ll9tb3ZlRW5kKHpvb21DaGFuZ2VkKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgdmlld3Jlc2V0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIG5lZWRzIHRvIHJlZHJhdyBpdHMgY29udGVudCAodGhpcyB1c3VhbGx5IGhhcHBlbnNcclxuXHRcdC8vIG9uIG1hcCB6b29tIG9yIGxvYWQpLiBWZXJ5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgY3VzdG9tIG92ZXJsYXlzLlxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBpbml0aWFsaXplZCAod2hlbiBpdHMgY2VudGVyIGFuZCB6b29tIGFyZSBzZXRcclxuXHRcdC8vIGZvciB0aGUgZmlyc3QgdGltZSkuXHJcblx0XHRpZiAobG9hZGluZykge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbW92ZVN0YXJ0OiBmdW5jdGlvbiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgem9vbSBpcyBhYm91dCB0byBjaGFuZ2UgKGUuZy4gYmVmb3JlIHpvb20gYW5pbWF0aW9uKS5cclxuXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWV3IG9mIHRoZSBtYXAgc3RhcnRzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXApLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbXN0YXJ0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgZGF0YSkge1xyXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR6b29tID0gdGhpcy5fem9vbTtcclxuXHRcdH1cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblxyXG5cdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblx0XHR0aGlzLl9sYXN0Q2VudGVyID0gY2VudGVyO1xyXG5cdFx0dGhpcy5fcGl4ZWxPcmlnaW4gPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCB6b29tOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IGNoYW5nZSBpbiB6b29tIGxldmVsLCBpbmNsdWRpbmcgem9vbVxyXG5cdFx0Ly8gYW5kIGZseSBhbmltYXRpb25zLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkIHx8IChkYXRhICYmIGRhdGEucGluY2gpKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBtb3ZlbWVudCBvZiB0aGUgbWFwLCBpbmNsdWRpbmcgcGFuIGFuZFxyXG5cdFx0Ly8gZmx5IGFuaW1hdGlvbnMuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywgZGF0YSk7XHJcblx0fSxcclxuXHJcblx0X21vdmVFbmQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21lbmQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaGFzIGNoYW5nZWQsIGFmdGVyIGFueSBhbmltYXRpb25zLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgY2VudGVyIG9mIHRoZSBtYXAgc3RvcHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdG9wcGVkXHJcblx0XHQvLyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfc3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mbHlUb0ZyYW1lKTtcclxuXHRcdGlmICh0aGlzLl9wYW5BbmltKSB7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0uc3RvcCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Jhd1BhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tU3BhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWF4Wm9vbSgpIC0gdGhpcy5nZXRNaW5ab29tKCk7XHJcblx0fSxcclxuXHJcblx0X3Bhbkluc2lkZU1heEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9lbmZvcmNpbmdCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5wYW5JbnNpZGVCb3VuZHModGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NoZWNrSWZMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignU2V0IG1hcCBjZW50ZXIgYW5kIHpvb20gZmlyc3QuJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gRE9NIGV2ZW50IGhhbmRsaW5nXHJcblxyXG5cdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIGV2ZW50c1xyXG5cdF9pbml0RXZlbnRzOiBmdW5jdGlvbiAocmVtb3ZlKSB7XHJcblx0XHRpZiAoIUwuRG9tRXZlbnQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fdGFyZ2V0cyA9IHt9O1xyXG5cdFx0dGhpcy5fdGFyZ2V0c1tMLnN0YW1wKHRoaXMuX2NvbnRhaW5lcildID0gdGhpcztcclxuXHJcblx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyAnb2ZmJyA6ICdvbic7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAob3IgdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBkYmxjbGljazogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIChvciBkb3VibGUtdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZWRvd246IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZXVwOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW92ZXI6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGVudGVycyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3V0OiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW1vdmU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoaWxlIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgY29udGV4dG1lbnU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSByaWdodCBtb3VzZSBidXR0b24gb24gdGhlIG1hcCwgcHJldmVudHNcclxuXHRcdC8vIGRlZmF1bHQgYnJvd3NlciBjb250ZXh0IG1lbnUgZnJvbSBzaG93aW5nIGlmIHRoZXJlIGFyZSBsaXN0ZW5lcnMgb25cclxuXHRcdC8vIHRoaXMgZXZlbnQuIEFsc28gZmlyZWQgb24gbW9iaWxlIHdoZW4gdGhlIHVzZXIgaG9sZHMgYSBzaW5nbGUgdG91Y2hcclxuXHRcdC8vIGZvciBhIHNlY29uZCAoYWxzbyBjYWxsZWQgbG9uZyBwcmVzcykuXHJcblx0XHQvLyBAZXZlbnQga2V5cHJlc3M6IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcblx0XHRMLkRvbUV2ZW50W29uT2ZmXSh0aGlzLl9jb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCAnICtcclxuXHRcdFx0J21vdXNlb3ZlciBtb3VzZW91dCBtb3VzZW1vdmUgY29udGV4dG1lbnUga2V5cHJlc3MnLCB0aGlzLl9oYW5kbGVET01FdmVudCwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy50cmFja1Jlc2l6ZSkge1xyXG5cdFx0XHRMLkRvbUV2ZW50W29uT2ZmXSh3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5hbnkzZCAmJiB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG5cdFx0XHR0aGlzW29uT2ZmXSgnbW92ZWVuZCcsIHRoaXMuX29uTW92ZUVuZCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uUmVzaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKFxyXG5cdFx0ICAgICAgICBmdW5jdGlvbiAoKSB7IHRoaXMuaW52YWxpZGF0ZVNpemUoe2RlYm91bmNlTW92ZWVuZDogdHJ1ZX0pOyB9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfb25TY3JvbGw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3AgID0gMDtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxMZWZ0ID0gMDtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG5cdFx0aWYgKE1hdGgubWF4KE1hdGguYWJzKHBvcy54KSwgTWF0aC5hYnMocG9zLnkpKSA+PSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG5cdFx0XHQvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjAzODczIGJ1dCBXZWJraXQgYWxzbyBoYXZlXHJcblx0XHRcdC8vIGEgcGl4ZWwgb2Zmc2V0IG9uIHZlcnkgaGlnaCB2YWx1ZXMsIHNlZTogaHR0cDovL2pzZmlkZGxlLm5ldC9kZzZyNWhoYi9cclxuXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZmluZEV2ZW50VGFyZ2V0czogZnVuY3Rpb24gKGUsIHR5cGUpIHtcclxuXHRcdHZhciB0YXJnZXRzID0gW10sXHJcblx0XHQgICAgdGFyZ2V0LFxyXG5cdFx0ICAgIGlzSG92ZXIgPSB0eXBlID09PSAnbW91c2VvdXQnIHx8IHR5cGUgPT09ICdtb3VzZW92ZXInLFxyXG5cdFx0ICAgIHNyYyA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcclxuXHRcdCAgICBkcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuXHRcdHdoaWxlIChzcmMpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGhpcy5fdGFyZ2V0c1tMLnN0YW1wKHNyYyldO1xyXG5cdFx0XHRpZiAodGFyZ2V0ICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdwcmVjbGljaycpICYmICFlLl9zaW11bGF0ZWQgJiYgdGhpcy5fZHJhZ2dhYmxlTW92ZWQodGFyZ2V0KSkge1xyXG5cdFx0XHRcdC8vIFByZXZlbnQgZmlyaW5nIGNsaWNrIGFmdGVyIHlvdSBqdXN0IGRyYWdnZWQgYW4gb2JqZWN0LlxyXG5cdFx0XHRcdGRyYWdnaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGFyZ2V0ICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIgJiYgIUwuRG9tRXZlbnQuX2lzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkgeyBicmVhazsgfVxyXG5cdFx0XHRcdHRhcmdldHMucHVzaCh0YXJnZXQpO1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHNyYyA9PT0gdGhpcy5fY29udGFpbmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdHNyYyA9IHNyYy5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCAmJiAhZHJhZ2dpbmcgJiYgIWlzSG92ZXIgJiYgTC5Eb21FdmVudC5faXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7XHJcblx0XHRcdHRhcmdldHMgPSBbdGhpc107XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCB8fCBMLkRvbUV2ZW50Ll9za2lwcGVkKGUpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciB0eXBlID0gZS50eXBlID09PSAna2V5cHJlc3MnICYmIGUua2V5Q29kZSA9PT0gMTMgPyAnY2xpY2snIDogZS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnbW91c2Vkb3duJykge1xyXG5cdFx0XHQvLyBwcmV2ZW50cyBvdXRsaW5lIHdoZW4gY2xpY2tpbmcgb24ga2V5Ym9hcmQtZm9jdXNhYmxlIGVsZW1lbnRcclxuXHRcdFx0TC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lKGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZmlyZURPTUV2ZW50KGUsIHR5cGUpO1xyXG5cdH0sXHJcblxyXG5cdF9maXJlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlLCB0eXBlLCB0YXJnZXRzKSB7XHJcblxyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ2NsaWNrJykge1xyXG5cdFx0XHQvLyBGaXJlIGEgc3ludGhldGljICdwcmVjbGljaycgZXZlbnQgd2hpY2ggcHJvcGFnYXRlcyB1cCAobWFpbmx5IGZvciBjbG9zaW5nIHBvcHVwcykuXHJcblx0XHRcdC8vIEBldmVudCBwcmVjbGljazogTW91c2VFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCBiZWZvcmUgbW91c2UgY2xpY2sgb24gdGhlIG1hcCAoc29tZXRpbWVzIHVzZWZ1bCB3aGVuIHlvdVxyXG5cdFx0XHQvLyB3YW50IHNvbWV0aGluZyB0byBoYXBwZW4gb24gY2xpY2sgYmVmb3JlIGFueSBleGlzdGluZyBjbGlja1xyXG5cdFx0XHQvLyBoYW5kbGVycyBzdGFydCBydW5uaW5nKS5cclxuXHRcdFx0dmFyIHN5bnRoID0gTC5VdGlsLmV4dGVuZCh7fSwgZSk7XHJcblx0XHRcdHN5bnRoLnR5cGUgPSAncHJlY2xpY2snO1xyXG5cdFx0XHR0aGlzLl9maXJlRE9NRXZlbnQoc3ludGgsIHN5bnRoLnR5cGUsIHRhcmdldHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChlLl9zdG9wcGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIEZpbmQgdGhlIGxheWVyIHRoZSBldmVudCBpcyBwcm9wYWdhdGluZyBmcm9tIGFuZCBpdHMgcGFyZW50cy5cclxuXHRcdHRhcmdldHMgPSAodGFyZ2V0cyB8fCBbXSkuY29uY2F0KHRoaXMuX2ZpbmRFdmVudFRhcmdldHMoZSwgdHlwZSkpO1xyXG5cclxuXHRcdGlmICghdGFyZ2V0cy5sZW5ndGgpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHRhcmdldCA9IHRhcmdldHNbMF07XHJcblx0XHRpZiAodHlwZSA9PT0gJ2NvbnRleHRtZW51JyAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG5cdFx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRvcmlnaW5hbEV2ZW50OiBlXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChlLnR5cGUgIT09ICdrZXlwcmVzcycpIHtcclxuXHRcdFx0dmFyIGlzTWFya2VyID0gdGFyZ2V0IGluc3RhbmNlb2YgTC5NYXJrZXI7XHJcblx0XHRcdGRhdGEuY29udGFpbmVyUG9pbnQgPSBpc01hcmtlciA/XHJcblx0XHRcdFx0XHR0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodGFyZ2V0LmdldExhdExuZygpKSA6IHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XHJcblx0XHRcdGRhdGEubGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoZGF0YS5jb250YWluZXJQb2ludCk7XHJcblx0XHRcdGRhdGEubGF0bG5nID0gaXNNYXJrZXIgPyB0YXJnZXQuZ2V0TGF0TG5nKCkgOiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhkYXRhLmxheWVyUG9pbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0YXJnZXRzW2ldLmZpcmUodHlwZSwgZGF0YSwgdHJ1ZSk7XHJcblx0XHRcdGlmIChkYXRhLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgfHxcclxuXHRcdFx0XHQodGFyZ2V0c1tpXS5vcHRpb25zLm5vbkJ1YmJsaW5nRXZlbnRzICYmIEwuVXRpbC5pbmRleE9mKHRhcmdldHNbaV0ub3B0aW9ucy5ub25CdWJibGluZ0V2ZW50cywgdHlwZSkgIT09IC0xKSkgeyByZXR1cm47IH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZHJhZ2dhYmxlTW92ZWQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdG9iaiA9IG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcuZW5hYmxlZCgpID8gb2JqIDogdGhpcztcclxuXHRcdHJldHVybiAob2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5tb3ZlZCgpKSB8fCAodGhpcy5ib3hab29tICYmIHRoaXMuYm94Wm9vbS5tb3ZlZCgpKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJIYW5kbGVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2hhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZXJzW2ldLmRpc2FibGUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2Qgd2hlblJlYWR5KGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBSdW5zIHRoZSBnaXZlbiBmdW5jdGlvbiBgZm5gIHdoZW4gdGhlIG1hcCBnZXRzIGluaXRpYWxpemVkIHdpdGhcclxuXHQvLyBhIHZpZXcgKGNlbnRlciBhbmQgem9vbSkgYW5kIGF0IGxlYXN0IG9uZSBsYXllciwgb3IgaW1tZWRpYXRlbHlcclxuXHQvLyBpZiBpdCdzIGFscmVhZHkgaW5pdGlhbGl6ZWQsIG9wdGlvbmFsbHkgcGFzc2luZyBhIGZ1bmN0aW9uIGNvbnRleHQuXHJcblx0d2hlblJlYWR5OiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0Y2FsbGJhY2suY2FsbChjb250ZXh0IHx8IHRoaXMsIHt0YXJnZXQ6IHRoaXN9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMub24oJ2xvYWQnLCBjYWxsYmFjaywgY29udGV4dCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIGZvciBnZXR0aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHRfZ2V0TWFwUGFuZVBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lKSB8fCBuZXcgTC5Qb2ludCgwLCAwKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRyZXR1cm4gcG9zICYmICFwb3MuZXF1YWxzKFswLCAwXSk7XHJcblx0fSxcclxuXHJcblx0X2dldFRvcExlZnRQb2ludDogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHBpeGVsT3JpZ2luID0gY2VudGVyICYmIHpvb20gIT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkgOlxyXG5cdFx0XHR0aGlzLmdldFBpeGVsT3JpZ2luKCk7XHJcblx0XHRyZXR1cm4gcGl4ZWxPcmlnaW4uc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TmV3UGl4ZWxPcmlnaW46IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKS5fc3VidHJhY3Qodmlld0hhbGYpLl9hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfbGF0TG5nVG9OZXdMYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBjZW50ZXIpIHtcclxuXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QobGF0bG5nLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCk7XHJcblx0fSxcclxuXHJcblx0Ly8gbGF5ZXIgcG9pbnQgb2YgdGhlIGN1cnJlbnQgY2VudGVyXHJcblx0X2dldENlbnRlckxheWVyUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gb2Zmc2V0IG9mIHRoZSBzcGVjaWZpZWQgcGxhY2UgdG8gdGhlIGN1cnJlbnQgY2VudGVyIGluIHBpeGVsc1xyXG5cdF9nZXRDZW50ZXJPZmZzZXQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcpLnN1YnRyYWN0KHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IGNlbnRlciBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdENlbnRlcjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgYm91bmRzKSB7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGNlbnRlcjsgfVxyXG5cclxuXHRcdHZhciBjZW50ZXJQb2ludCA9IHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgdmlld0JvdW5kcyA9IG5ldyBMLkJvdW5kcyhjZW50ZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZiksIGNlbnRlclBvaW50LmFkZCh2aWV3SGFsZikpLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldEJvdW5kc09mZnNldCh2aWV3Qm91bmRzLCBib3VuZHMsIHpvb20pO1xyXG5cclxuXHRcdC8vIElmIG9mZnNldCBpcyBsZXNzIHRoYW4gYSBwaXhlbCwgaWdub3JlLlxyXG5cdFx0Ly8gVGhpcyBwcmV2ZW50cyB1bnN0YWJsZSBwcm9qZWN0aW9ucyBmcm9tIGdldHRpbmcgaW50b1xyXG5cdFx0Ly8gYW4gaW5maW5pdGUgbG9vcCBvZiB0aW55IG9mZnNldHMuXHJcblx0XHRpZiAob2Zmc2V0LnJvdW5kKCkuZXF1YWxzKFswLCAwXSkpIHtcclxuXHRcdFx0cmV0dXJuIGNlbnRlcjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QoY2VudGVyUG9pbnQuYWRkKG9mZnNldCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBvZmZzZXQgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQsIGJvdW5kcykge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIG9mZnNldDsgfVxyXG5cclxuXHRcdHZhciB2aWV3Qm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIG5ld0JvdW5kcyA9IG5ldyBMLkJvdW5kcyh2aWV3Qm91bmRzLm1pbi5hZGQob2Zmc2V0KSwgdmlld0JvdW5kcy5tYXguYWRkKG9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiBvZmZzZXQuYWRkKHRoaXMuX2dldEJvdW5kc09mZnNldChuZXdCb3VuZHMsIGJvdW5kcykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybnMgb2Zmc2V0IG5lZWRlZCBmb3IgcHhCb3VuZHMgdG8gZ2V0IGluc2lkZSBtYXhCb3VuZHMgYXQgYSBzcGVjaWZpZWQgem9vbVxyXG5cdF9nZXRCb3VuZHNPZmZzZXQ6IGZ1bmN0aW9uIChweEJvdW5kcywgbWF4Qm91bmRzLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkTWF4Qm91bmRzID0gTC5ib3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKVxyXG5cdFx0ICAgICksXHJcblx0XHQgICAgbWluT2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1pbi5zdWJ0cmFjdChweEJvdW5kcy5taW4pLFxyXG5cdFx0ICAgIG1heE9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5tYXguc3VidHJhY3QocHhCb3VuZHMubWF4KSxcclxuXHJcblx0XHQgICAgZHggPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC54LCAtbWF4T2Zmc2V0LngpLFxyXG5cdFx0ICAgIGR5ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueSwgLW1heE9mZnNldC55KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoZHgsIGR5KTtcclxuXHR9LFxyXG5cclxuXHRfcmVib3VuZDogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XHJcblx0XHRyZXR1cm4gbGVmdCArIHJpZ2h0ID4gMCA/XHJcblx0XHRcdE1hdGgucm91bmQobGVmdCAtIHJpZ2h0KSAvIDIgOlxyXG5cdFx0XHRNYXRoLm1heCgwLCBNYXRoLmNlaWwobGVmdCkpIC0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihyaWdodCkpO1xyXG5cdH0sXHJcblxyXG5cdF9saW1pdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcblx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcblx0XHQgICAgc25hcCA9IEwuQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDE7XHJcblx0XHRpZiAoc25hcCkge1xyXG5cdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gc25hcCkgKiBzbmFwO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBzZWN0aW9uXHJcblxyXG4vLyBAZmFjdG9yeSBMLm1hcChpZDogU3RyaW5nLCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gdGhlIERPTSBJRCBvZiBhIGA8ZGl2PmAgZWxlbWVudFxyXG4vLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbi8vXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLm1hcChlbDogSFRNTEVsZW1lbnQsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiBhbiBpbnN0YW5jZSBvZiBhIGA8ZGl2PmAgSFRNTCBlbGVtZW50XHJcbi8vIGFuZCBvcHRpb25hbGx5IGFuIG9iamVjdCBsaXRlcmFsIHdpdGggYE1hcCBvcHRpb25zYC5cclxuTC5tYXAgPSBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuTWFwKGlkLCBvcHRpb25zKTtcclxufTtcclxuXG5cbi8qXG4gKiBAY2xhc3MgTGF5ZXJcbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBAYWthIEwuTGF5ZXJcbiAqIEBha2EgSUxheWVyXG4gKlxuICogQSBzZXQgb2YgbWV0aG9kcyBmcm9tIHRoZSBMYXllciBiYXNlIGNsYXNzIHRoYXQgYWxsIExlYWZsZXQgbGF5ZXJzIHVzZS5cbiAqIEluaGVyaXRzIGFsbCBtZXRob2RzLCBvcHRpb25zIGFuZCBldmVudHMgZnJvbSBgTC5FdmVudGVkYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLk1hcmtlcihsYXRsbmcpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5hZGRUbyhtYXApO1xuICogbGF5ZXIucmVtb3ZlKCk7XG4gKiBgYGBcbiAqXG4gKiBAZXZlbnQgYWRkOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIGFkZGVkIHRvIGEgbWFwXG4gKlxuICogQGV2ZW50IHJlbW92ZTogRXZlbnRcbiAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gYSBtYXBcbiAqL1xuXG5cbkwuTGF5ZXIgPSBMLkV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ292ZXJsYXlQYW5lJ1xuXHRcdC8vIEJ5IGRlZmF1bHQgdGhlIGxheWVyIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCdzIFtvdmVybGF5IHBhbmVdKCNtYXAtb3ZlcmxheXBhbmUpLiBPdmVycmlkaW5nIHRoaXMgb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGxheWVyIHRvIGJlIHBsYWNlZCBvbiBhbm90aGVyIHBhbmUgYnkgZGVmYXVsdC5cblx0XHRwYW5lOiAnb3ZlcmxheVBhbmUnLFxuXHRcdG5vbkJ1YmJsaW5nRXZlbnRzOiBbXSAgLy8gQXJyYXkgb2YgZXZlbnRzIHRoYXQgc2hvdWxkIG5vdCBiZSBidWJibGVkIHRvIERPTSBwYXJlbnRzIChsaWtlIHRoZSBtYXApXG5cdH0sXG5cblx0LyogQHNlY3Rpb25cblx0ICogQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XG5cdCAqXG5cdCAqIEBtZXRob2QgYWRkVG8obWFwOiBNYXApOiB0aGlzXG5cdCAqIEFkZHMgdGhlIGxheWVyIHRvIHRoZSBnaXZlbiBtYXBcblx0ICovXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVGcm9tKHRoaXMuX21hcCB8fCB0aGlzLl9tYXBUb0FkZCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVGcm9tKG1hcDogTWFwKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBnaXZlbiBtYXBcblx0cmVtb3ZlRnJvbTogZnVuY3Rpb24gKG9iaikge1xuXHRcdGlmIChvYmopIHtcblx0XHRcdG9iai5yZW1vdmVMYXllcih0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRQYW5lKG5hbWU/IDogU3RyaW5nKTogSFRNTEVsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCByZXByZXNlbnRpbmcgdGhlIG5hbWVkIHBhbmUgb24gdGhlIG1hcC4gSWYgYG5hbWVgIGlzIG9taXR0ZWQsIHJldHVybnMgdGhlIHBhbmUgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldFBhbmU6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hcC5nZXRQYW5lKG5hbWUgPyAodGhpcy5vcHRpb25zW25hbWVdIHx8IG5hbWUpIDogdGhpcy5vcHRpb25zLnBhbmUpO1xuXHR9LFxuXG5cdGFkZEludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcblx0XHR0aGlzLl9tYXAuX3RhcmdldHNbTC5zdGFtcCh0YXJnZXRFbCldID0gdGhpcztcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG5cdFx0ZGVsZXRlIHRoaXMuX21hcC5fdGFyZ2V0c1tMLnN0YW1wKHRhcmdldEVsKV07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2xheWVyQWRkOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSBlLnRhcmdldDtcblxuXHRcdC8vIGNoZWNrIGluIGNhc2UgbGF5ZXIgZ2V0cyBhZGRlZCBhbmQgdGhlbiByZW1vdmVkIGJlZm9yZSB0aGUgbWFwIGlzIHJlYWR5XG5cdFx0aWYgKCFtYXAuaGFzTGF5ZXIodGhpcykpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XG5cblx0XHRpZiAodGhpcy5nZXRFdmVudHMpIHtcblx0XHRcdHZhciBldmVudHMgPSB0aGlzLmdldEV2ZW50cygpO1xuXHRcdFx0bWFwLm9uKGV2ZW50cywgdGhpcyk7XG5cdFx0XHR0aGlzLm9uY2UoJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bWFwLm9mZihldmVudHMsIHRoaXMpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vbkFkZChtYXApO1xuXG5cdFx0aWYgKHRoaXMuZ2V0QXR0cmlidXRpb24gJiYgdGhpcy5fbWFwLmF0dHJpYnV0aW9uQ29udHJvbCkge1xuXHRcdFx0dGhpcy5fbWFwLmF0dHJpYnV0aW9uQ29udHJvbC5hZGRBdHRyaWJ1dGlvbih0aGlzLmdldEF0dHJpYnV0aW9uKCkpO1xuXHRcdH1cblxuXHRcdHRoaXMuZmlyZSgnYWRkJyk7XG5cdFx0bWFwLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiB0aGlzfSk7XG5cdH1cbn0pO1xuXG4vKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuICogQHVuaW5oZXJpdGFibGVcbiAqXG4gKiBFdmVyeSBsYXllciBzaG91bGQgZXh0ZW5kIGZyb20gYEwuTGF5ZXJgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXG4gKlxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGNvZGUgdGhhdCBjcmVhdGVzIERPTSBlbGVtZW50cyBmb3IgdGhlIGxheWVyLCBhZGRzIHRoZW0gdG8gYG1hcCBwYW5lc2Agd2hlcmUgdGhleSBzaG91bGQgYmVsb25nIGFuZCBwdXRzIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllcikuXG4gKlxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGF5ZXIncyBlbGVtZW50cyBmcm9tIHRoZSBET00gYW5kIHJlbW92ZXMgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNsYXllci1vbmFkZCkuIENhbGxlZCBvbiBbYG1hcC5yZW1vdmVMYXllcihsYXllcilgXSgjbWFwLXJlbW92ZWxheWVyKS5cbiAqXG4gKiBAbWV0aG9kIGdldEV2ZW50cygpOiBPYmplY3RcbiAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IGxpa2UgYHsgdmlld3Jlc2V0OiB0aGlzLl9yZXNldCB9YCBmb3IgW2BhZGRFdmVudExpc3RlbmVyYF0oI2V2ZW50ZWQtYWRkZXZlbnRsaXN0ZW5lcikuIFRoZSBldmVudCBoYW5kbGVycyBpbiB0aGlzIG9iamVjdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgbWFwIHdpdGggeW91ciBsYXllci5cbiAqXG4gKiBAbWV0aG9kIGdldEF0dHJpYnV0aW9uKCk6IFN0cmluZ1xuICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhIHN0cmluZyBjb250YWluaW5nIEhUTUwgdG8gYmUgc2hvd24gb24gdGhlIGBBdHRyaWJ1dGlvbiBjb250cm9sYCB3aGVuZXZlciB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIGJlZm9yZUFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIE9wdGlvbmFsIG1ldGhvZC4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLCBiZWZvcmUgdGhlIGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAsIGJlZm9yZSBldmVudHMgYXJlIGluaXRpYWxpemVkLCB3aXRob3V0IHdhaXRpbmcgdW50aWwgdGhlIG1hcCBpcyBpbiBhIHVzYWJsZSBzdGF0ZS4gVXNlIGZvciBlYXJseSBpbml0aWFsaXphdGlvbiBvbmx5LlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXBcbiAqIEBzZWN0aW9uIExheWVyIGV2ZW50c1xuICpcbiAqIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBhIG5ldyBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLlxuICpcbiAqIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBzb21lIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwXG4gKlxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuICovXG5MLk1hcC5pbmNsdWRlKHtcblx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBtYXBcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IEwuc3RhbXAobGF5ZXIpO1xuXHRcdGlmICh0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xuXG5cdFx0bGF5ZXIuX21hcFRvQWRkID0gdGhpcztcblxuXHRcdGlmIChsYXllci5iZWZvcmVBZGQpIHtcblx0XHRcdGxheWVyLmJlZm9yZUFkZCh0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLndoZW5SZWFkeShsYXllci5fbGF5ZXJBZGQsIGxheWVyKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICghdGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0bGF5ZXIub25SZW1vdmUodGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyLmdldEF0dHJpYnV0aW9uICYmIHRoaXMuYXR0cmlidXRpb25Db250cm9sKSB7XG5cdFx0XHR0aGlzLmF0dHJpYnV0aW9uQ29udHJvbC5yZW1vdmVBdHRyaWJ1dGlvbihsYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcblx0XHR9XG5cblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XG5cdFx0XHRsYXllci5maXJlKCdyZW1vdmUnKTtcblx0XHR9XG5cblx0XHRsYXllci5fbWFwID0gbGF5ZXIuX21hcFRvQWRkID0gbnVsbDtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBtYXBcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHJldHVybiAhIWxheWVyICYmIChMLnN0YW1wKGxheWVyKSBpbiB0aGlzLl9sYXllcnMpO1xuXHR9LFxuXG5cdC8qIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcblx0ICogSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBtYXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cblx0ICogYGBgXG5cdCAqIG1hcC5lYWNoTGF5ZXIoZnVuY3Rpb24obGF5ZXIpe1xuXHQgKiAgICAgbGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xuXHQgKiB9KTtcblx0ICogYGBgXG5cdCAqL1xuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2FkZExheWVyczogZnVuY3Rpb24gKGxheWVycykge1xuXHRcdGxheWVycyA9IGxheWVycyA/IChMLlV0aWwuaXNBcnJheShsYXllcnMpID8gbGF5ZXJzIDogW2xheWVyc10pIDogW107XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmIChpc05hTihsYXllci5vcHRpb25zLm1heFpvb20pIHx8ICFpc05hTihsYXllci5vcHRpb25zLm1pblpvb20pKSB7XG5cdFx0XHR0aGlzLl96b29tQm91bmRMYXllcnNbTC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IEwuc3RhbXAobGF5ZXIpO1xuXG5cdFx0aWYgKHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF0pIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl96b29tQm91bmRMYXllcnNbaWRdO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlWm9vbUxldmVsczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtaW5ab29tID0gSW5maW5pdHksXG5cdFx0ICAgIG1heFpvb20gPSAtSW5maW5pdHksXG5cdFx0ICAgIG9sZFpvb21TcGFuID0gdGhpcy5fZ2V0Wm9vbVNwYW4oKTtcblxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fem9vbUJvdW5kTGF5ZXJzKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuX3pvb21Cb3VuZExheWVyc1tpXS5vcHRpb25zO1xuXG5cdFx0XHRtaW5ab29tID0gb3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyBtaW5ab29tIDogTWF0aC5taW4obWluWm9vbSwgb3B0aW9ucy5taW5ab29tKTtcblx0XHRcdG1heFpvb20gPSBvcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/IG1heFpvb20gOiBNYXRoLm1heChtYXhab29tLCBvcHRpb25zLm1heFpvb20pO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xheWVyc01heFpvb20gPSBtYXhab29tID09PSAtSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtYXhab29tO1xuXHRcdHRoaXMuX2xheWVyc01pblpvb20gPSBtaW5ab29tID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1pblpvb207XG5cblx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xuXHRcdC8vIEBldmVudCB6b29tbGV2ZWxzY2hhbmdlOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG51bWJlciBvZiB6b29tbGV2ZWxzIG9uIHRoZSBtYXAgaXMgY2hhbmdlZCBkdWVcblx0XHQvLyB0byBhZGRpbmcgb3IgcmVtb3ZpbmcgYSBsYXllci5cblx0XHRpZiAob2xkWm9vbVNwYW4gIT09IHRoaXMuX2dldFpvb21TcGFuKCkpIHtcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTWVyY2F0b3JcclxuICpcclxuICogRWxsaXB0aWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCBtb3JlIGNvbXBsZXggdGhhbiBTcGhlcmljYWwgTWVyY2F0b3IuIFRha2VzIGludG8gYWNjb3VudCB0aGF0IEVhcnRoIGlzIGEgZ2VvaWQsIG5vdCBhIHBlcmZlY3Qgc3BoZXJlLiBVc2VkIGJ5IHRoZSBFUFNHOjMzOTUgQ1JTLlxyXG4gKi9cclxuXHJcbkwuUHJvamVjdGlvbi5NZXJjYXRvciA9IHtcclxuXHRSOiA2Mzc4MTM3LFxyXG5cdFJfTUlOT1I6IDYzNTY3NTIuMzE0MjQ1MTc5LFxyXG5cclxuXHRib3VuZHM6IEwuYm91bmRzKFstMjAwMzc1MDguMzQyNzksIC0xNTQ5NjU3MC43Mzk3Ml0sIFsyMDAzNzUwOC4zNDI3OSwgMTg3NjQ2NTYuMjMxMzhdKSxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgeSA9IGxhdGxuZy5sYXQgKiBkLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICBjb24gPSBlICogTWF0aC5zaW4oeSk7XHJcblxyXG5cdFx0dmFyIHRzID0gTWF0aC50YW4oTWF0aC5QSSAvIDQgLSB5IC8gMikgLyBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuXHRcdHkgPSAtciAqIE1hdGgubG9nKE1hdGgubWF4KHRzLCAxRS0xMCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChsYXRsbmcubG5nICogZCAqIHIsIHkpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgZCA9IDE4MCAvIE1hdGguUEksXHJcblx0XHQgICAgciA9IHRoaXMuUixcclxuXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG5cdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcblx0XHQgICAgdHMgPSBNYXRoLmV4cCgtcG9pbnQueSAvIHIpLFxyXG5cdFx0ICAgIHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGRwaGkgPSAwLjEsIGNvbjsgaSA8IDE1ICYmIE1hdGguYWJzKGRwaGkpID4gMWUtNzsgaSsrKSB7XHJcblx0XHRcdGNvbiA9IGUgKiBNYXRoLnNpbihwaGkpO1xyXG5cdFx0XHRjb24gPSBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuXHRcdFx0ZHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyAqIGNvbikgLSBwaGk7XHJcblx0XHRcdHBoaSArPSBkcGhpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcocGhpICogZCwgcG9pbnQueCAqIGQgLyByKTtcclxuXHR9XHJcbn07XHJcblxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHMzM5NVxyXG4gKlxyXG4gKiBSYXJlbHkgdXNlZCBieSBzb21lIGNvbW1lcmNpYWwgdGlsZSBwcm92aWRlcnMuIFVzZXMgRWxsaXB0aWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLlxyXG4gKi9cclxuXHJcbkwuQ1JTLkVQU0czMzk1ID0gTC5leHRlbmQoe30sIEwuQ1JTLkVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6MzM5NScsXHJcblx0cHJvamVjdGlvbjogTC5Qcm9qZWN0aW9uLk1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogTC5Qcm9qZWN0aW9uLk1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIG5ldyBMLlRyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuXHR9KCkpXHJcbn0pO1xyXG5cbi8qXG4gKiBAY2xhc3MgR3JpZExheWVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5HcmlkTGF5ZXJcbiAqXG4gKiBHZW5lcmljIGNsYXNzIGZvciBoYW5kbGluZyBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cy4gVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIHRpbGUgbGF5ZXJzIGFuZCByZXBsYWNlcyBgVGlsZUxheWVyLkNhbnZhc2AuXG4gKiBHcmlkTGF5ZXIgY2FuIGJlIGV4dGVuZGVkIHRvIGNyZWF0ZSBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cyBsaWtlIGA8Y2FudmFzPmAsIGA8aW1nPmAgb3IgYDxkaXY+YC4gR3JpZExheWVyIHdpbGwgaGFuZGxlIGNyZWF0aW5nIGFuZCBhbmltYXRpbmcgdGhlc2UgRE9NIGVsZW1lbnRzIGZvciB5b3UuXG4gKlxuICpcbiAqIEBzZWN0aW9uIFN5bmNocm9ub3VzIHVzYWdlXG4gKiBAZXhhbXBsZVxuICpcbiAqIFRvIGNyZWF0ZSBhIGN1c3RvbSBsYXllciwgZXh0ZW5kIEdyaWRMYXllciBhbmQgaW1wbGVtZW50IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGEgYFBvaW50YCBvYmplY3Qgd2l0aCB0aGUgYHhgLCBgeWAsIGFuZCBgemAgKHpvb20gbGV2ZWwpIGNvb3JkaW5hdGVzIHRvIGRyYXcgeW91ciB0aWxlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3Jkcyl7XG4gKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gKlxuICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAqXG4gKiAgICAgICAgIC8vIGdldCBhIGNhbnZhcyBjb250ZXh0IGFuZCBkcmF3IHNvbWV0aGluZyBvbiBpdCB1c2luZyBjb29yZHMueCwgY29vcmRzLnkgYW5kIGNvb3Jkcy56XG4gKiAgICAgICAgIHZhciBjdHggPSB0aWxlLmdldENvbnRleHQoJzJkJyk7XG4gKlxuICogICAgICAgICAvLyByZXR1cm4gdGhlIHRpbGUgc28gaXQgY2FuIGJlIHJlbmRlcmVkIG9uIHNjcmVlblxuICogICAgICAgICByZXR1cm4gdGlsZTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWN0aW9uIEFzeW5jaHJvbm91cyB1c2FnZVxuICogQGV4YW1wbGVcbiAqXG4gKiBUaWxlIGNyZWF0aW9uIGNhbiBhbHNvIGJlIGFzeW5jaHJvbm91cywgdGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBhIHRoaXJkLXBhcnR5IGRyYXdpbmcgbGlicmFyeS4gT25jZSB0aGUgdGlsZSBpcyBmaW5pc2hlZCBkcmF3aW5nIGl0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGBkb25lKClgIGNhbGxiYWNrLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgZG9uZSl7XG4gKiAgICAgICAgIHZhciBlcnJvcjtcbiAqXG4gKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gKlxuICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAqXG4gKiAgICAgICAgIC8vIGRyYXcgc29tZXRoaW5nIGFzeW5jaHJvbm91c2x5IGFuZCBwYXNzIHRoZSB0aWxlIHRvIHRoZSBkb25lKCkgY2FsbGJhY2tcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGRvbmUoZXJyb3IsIHRpbGUpO1xuICogICAgICAgICB9LCAxMDAwKTtcbiAqXG4gKiAgICAgICAgIHJldHVybiB0aWxlO1xuICogICAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlY3Rpb25cbiAqL1xuXG5cbkwuR3JpZExheWVyID0gTC5MYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgR3JpZExheWVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gdGlsZVNpemU6IE51bWJlcnxQb2ludCA9IDI1NlxuXHRcdC8vIFdpZHRoIGFuZCBoZWlnaHQgb2YgdGlsZXMgaW4gdGhlIGdyaWQuIFVzZSBhIG51bWJlciBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBlcXVhbCwgb3IgYEwucG9pbnQod2lkdGgsIGhlaWdodClgIG90aGVyd2lzZS5cblx0XHR0aWxlU2l6ZTogMjU2LFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHQvLyBPcGFjaXR5IG9mIHRoZSB0aWxlcy4gQ2FuIGJlIHVzZWQgaW4gdGhlIGBjcmVhdGVUaWxlKClgIGZ1bmN0aW9uLlxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gZGVwZW5kc1xuXHRcdC8vIElmIGBmYWxzZWAsIG5ldyB0aWxlcyBhcmUgbG9hZGVkIGR1cmluZyBwYW5uaW5nLCBvdGhlcndpc2Ugb25seSBhZnRlciBpdCAoZm9yIGJldHRlciBwZXJmb3JtYW5jZSkuIGB0cnVlYCBieSBkZWZhdWx0IG9uIG1vYmlsZSBicm93c2Vycywgb3RoZXJ3aXNlIGBmYWxzZWAuXG5cdFx0dXBkYXRlV2hlbklkbGU6IEwuQnJvd3Nlci5tb2JpbGUsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5ab29taW5nOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIEJ5IGRlZmF1bHQsIGEgc21vb3RoIHpvb20gYW5pbWF0aW9uIChkdXJpbmcgYSBbdG91Y2ggem9vbV0oI21hcC10b3VjaHpvb20pIG9yIGEgW2BmbHlUbygpYF0oI21hcC1mbHl0bykpIHdpbGwgdXBkYXRlIGdyaWQgbGF5ZXJzIGV2ZXJ5IGludGVnZXIgem9vbSBsZXZlbC4gU2V0dGluZyB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHdpbGwgdXBkYXRlIHRoZSBncmlkIGxheWVyIG9ubHkgd2hlbiB0aGUgc21vb3RoIGFuaW1hdGlvbiBlbmRzLlxuXHRcdHVwZGF0ZVdoZW5ab29taW5nOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVJbnRlcnZhbDogTnVtYmVyID0gMjAwXG5cdFx0Ly8gVGlsZXMgd2lsbCBub3QgdXBkYXRlIG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IGB1cGRhdGVJbnRlcnZhbGAgbWlsbGlzZWNvbmRzIHdoZW4gcGFubmluZy5cblx0XHR1cGRhdGVJbnRlcnZhbDogMjAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBhdHRyaWJ1dGlvbjogU3RyaW5nID0gbnVsbFxuXHRcdC8vIFN0cmluZyB0byBiZSBzaG93biBpbiB0aGUgYXR0cmlidXRpb24gY29udHJvbCwgZGVzY3JpYmVzIHRoZSBsYXllciBkYXRhLCBlLmcuIFwiwqkgTWFwYm94XCIuXG5cdFx0YXR0cmlidXRpb246IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxuXHRcdC8vIFRoZSBleHBsaWNpdCB6SW5kZXggb2YgdGhlIHRpbGUgbGF5ZXIuXG5cdFx0ekluZGV4OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBib3VuZHM6IExhdExuZ0JvdW5kcyA9IHVuZGVmaW5lZFxuXHRcdC8vIElmIHNldCwgdGlsZXMgd2lsbCBvbmx5IGJlIGxvYWRlZCBpbnNpZGUgdGhlIHNldCBgTGF0TG5nQm91bmRzYC5cblx0XHRib3VuZHM6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcblx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIHRoYXQgdGlsZXMgd2lsbCBiZSBsb2FkZWQgYXQuIEJ5IGRlZmF1bHQgdGhlIGVudGlyZSBtYXAuXG5cdFx0bWluWm9vbTogMCxcblxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB0aGF0IHRpbGVzIHdpbGwgYmUgbG9hZGVkIGF0LlxuXHRcdG1heFpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbm9XcmFwOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIHRoZSBsYXllciBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgYW50aW1lcmlkaWFuLiBJZiBgdHJ1ZWAsIHRoZVxuXHRcdC8vIEdyaWRMYXllciB3aWxsIG9ubHkgYmUgZGlzcGxheWVkIG9uY2UgYXQgbG93IHpvb20gbGV2ZWxzLiBIYXMgbm9cblx0XHQvLyBlZmZlY3Qgd2hlbiB0aGUgW21hcCBDUlNdKCNtYXAtY3JzKSBkb2Vzbid0IHdyYXAgYXJvdW5kLlxuXHRcdG5vV3JhcDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0aWxlUGFuZSdcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBncmlkIGxheWVyIHdpbGwgYmUgYWRkZWQuXG5cdFx0cGFuZTogJ3RpbGVQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xuXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSB0aWxlIGxheWVyLiBFbXB0eSBieSBkZWZhdWx0LlxuXHRcdGNsYXNzTmFtZTogJycsXG5cblx0XHQvLyBAb3B0aW9uIGtlZXBCdWZmZXI6IE51bWJlciA9IDJcblx0XHQvLyBXaGVuIHBhbm5pbmcgdGhlIG1hcCwga2VlcCB0aGlzIG1hbnkgcm93cyBhbmQgY29sdW1ucyBvZiB0aWxlcyBiZWZvcmUgdW5sb2FkaW5nIHRoZW0uXG5cdFx0a2VlcEJ1ZmZlcjogMlxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcigpO1xuXG5cdFx0dGhpcy5fbGV2ZWxzID0ge307XG5cdFx0dGhpcy5fdGlsZXMgPSB7fTtcblxuXHRcdHRoaXMuX3Jlc2V0VmlldygpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5fYWRkWm9vbUxpbWl0KHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0bWFwLl9yZW1vdmVab29tTGltaXQodGhpcyk7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gbnVsbDtcblx0XHR0aGlzLl90aWxlWm9vbSA9IG51bGw7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRMLkRvbVV0aWwudG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1heCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdEwuRG9tVXRpbC50b0JhY2sodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5taW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEF0dHJpYnV0aW9uOiBTdHJpbmdcblx0Ly8gVXNlZCBieSB0aGUgYGF0dHJpYnV0aW9uIGNvbnRyb2xgLCByZXR1cm5zIHRoZSBbYXR0cmlidXRpb24gb3B0aW9uXSgjZ3JpZGxheWVyLWF0dHJpYnV0aW9uKS5cblx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW29wYWNpdHldKCNncmlkbGF5ZXItb3BhY2l0eSkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2dyaWRsYXllci16aW5kZXgpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gekluZGV4O1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0xvYWRpbmc6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IHRpbGUgaW4gdGhlIGdyaWQgbGF5ZXIgaGFzIG5vdCBmaW5pc2hlZCBsb2FkaW5nLlxuXHRpc0xvYWRpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9hZGluZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdzogdGhpc1xuXHQvLyBDYXVzZXMgdGhlIGxheWVyIHRvIGNsZWFyIGFsbCB0aGUgdGlsZXMgYW5kIHJlcXVlc3QgdGhlbSBhZ2Fpbi5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3ByZXJlc2V0OiB0aGlzLl9pbnZhbGlkYXRlQWxsLFxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl9vbk1vdmVFbmRcblx0XHR9O1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcblx0XHRcdC8vIHVwZGF0ZSB0aWxlcyBvbiBtb3ZlLCBidXQgbm90IG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciBnaXZlbiBpbnRlcnZhbFxuXHRcdFx0aWYgKCF0aGlzLl9vbk1vdmUpIHtcblx0XHRcdFx0dGhpcy5fb25Nb3ZlID0gTC5VdGlsLnRocm90dGxlKHRoaXMuX29uTW92ZUVuZCwgdGhpcy5vcHRpb25zLnVwZGF0ZUludGVydmFsLCB0aGlzKTtcblx0XHRcdH1cblxuXHRcdFx0ZXZlbnRzLm1vdmUgPSB0aGlzLl9vbk1vdmU7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgIHNoYWxsIHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxuXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG11c3QgYmUgb3ZlcnJpZGVuIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgLlxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGBjb29yZHNgLiBJZiB0aGUgYGRvbmVgIGNhbGxiYWNrXG5cdC8vIGlzIHNwZWNpZmllZCwgaXQgbXVzdCBiZSBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgZmluaXNoZWQgbG9hZGluZyBhbmQgZHJhd2luZy5cblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0fSxcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAbWV0aG9kIGdldFRpbGVTaXplOiBQb2ludFxuXHQvLyBOb3JtYWxpemVzIHRoZSBbdGlsZVNpemUgb3B0aW9uXSgjZ3JpZGxheWVyLXRpbGVzaXplKSBpbnRvIGEgcG9pbnQuIFVzZWQgYnkgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZC5cblx0Z2V0VGlsZVNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcyA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcblx0XHRyZXR1cm4gcyBpbnN0YW5jZW9mIEwuUG9pbnQgPyBzIDogbmV3IEwuUG9pbnQocywgcyk7XG5cdH0sXG5cblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9jb250YWluZXIgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcblx0XHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xuXHRcdH1cblx0fSxcblxuXHRfc2V0QXV0b1pJbmRleDogZnVuY3Rpb24gKGNvbXBhcmUpIHtcblx0XHQvLyBnbyB0aHJvdWdoIGFsbCBvdGhlciBsYXllcnMgb2YgdGhlIHNhbWUgcGFuZSwgc2V0IHpJbmRleCB0byBtYXggKyAxIChmcm9udCkgb3IgbWluIC0gMSAoYmFjaylcblxuXHRcdHZhciBsYXllcnMgPSB0aGlzLmdldFBhbmUoKS5jaGlsZHJlbixcblx0XHQgICAgZWRnZVpJbmRleCA9IC1jb21wYXJlKC1JbmZpbml0eSwgSW5maW5pdHkpOyAvLyAtSW5maW5pdHkgZm9yIG1heCwgSW5maW5pdHkgZm9yIG1pblxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGgsIHpJbmRleDsgaSA8IGxlbjsgaSsrKSB7XG5cblx0XHRcdHpJbmRleCA9IGxheWVyc1tpXS5zdHlsZS56SW5kZXg7XG5cblx0XHRcdGlmIChsYXllcnNbaV0gIT09IHRoaXMuX2NvbnRhaW5lciAmJiB6SW5kZXgpIHtcblx0XHRcdFx0ZWRnZVpJbmRleCA9IGNvbXBhcmUoZWRnZVpJbmRleCwgK3pJbmRleCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzRmluaXRlKGVkZ2VaSW5kZXgpKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gZWRnZVpJbmRleCArIGNvbXBhcmUoLTEsIDEpO1xuXHRcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHQvLyBJRSBkb2Vzbid0IGluaGVyaXQgZmlsdGVyIG9wYWNpdHkgcHJvcGVybHksIHNvIHdlJ3JlIGZvcmNlZCB0byBzZXQgaXQgb24gdGlsZXNcblx0XHRpZiAoTC5Ccm93c2VyLmllbHQ5KSB7IHJldHVybjsgfVxuXG5cdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHR2YXIgbm93ID0gK25ldyBEYXRlKCksXG5cdFx0ICAgIG5leHRGcmFtZSA9IGZhbHNlLFxuXHRcdCAgICB3aWxsUHJ1bmUgPSBmYWxzZTtcblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKCF0aWxlLmN1cnJlbnQgfHwgIXRpbGUubG9hZGVkKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdHZhciBmYWRlID0gTWF0aC5taW4oMSwgKG5vdyAtIHRpbGUubG9hZGVkKSAvIDIwMCk7XG5cblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUuZWwsIGZhZGUpO1xuXHRcdFx0aWYgKGZhZGUgPCAxKSB7XG5cdFx0XHRcdG5leHRGcmFtZSA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGlsZS5hY3RpdmUpIHsgd2lsbFBydW5lID0gdHJ1ZTsgfVxuXHRcdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHdpbGxQcnVuZSAmJiAhdGhpcy5fbm9QcnVuZSkgeyB0aGlzLl9wcnVuZVRpbGVzKCk7IH1cblxuXHRcdGlmIChuZXh0RnJhbWUpIHtcblx0XHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1sYXllciAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVMZXZlbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXG5cdFx0ICAgIG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcblxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdGlmICh0aGlzLl9sZXZlbHNbel0uZWwuY2hpbGRyZW4ubGVuZ3RoIHx8IHogPT09IHpvb20pIHtcblx0XHRcdFx0dGhpcy5fbGV2ZWxzW3pdLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb20gLSBNYXRoLmFicyh6b29tIC0geik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGVzQXRab29tKHopO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKCFsZXZlbCkge1xuXHRcdFx0bGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0gPSB7fTtcblxuXHRcdFx0bGV2ZWwuZWwgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC10aWxlLWNvbnRhaW5lciBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnLCB0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0bGV2ZWwuZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbTtcblxuXHRcdFx0bGV2ZWwub3JpZ2luID0gbWFwLnByb2plY3QobWFwLnVucHJvamVjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSksIHpvb20pLnJvdW5kKCk7XG5cdFx0XHRsZXZlbC56b29tID0gem9vbTtcblxuXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybShsZXZlbCwgbWFwLmdldENlbnRlcigpLCBtYXAuZ2V0Wm9vbSgpKTtcblxuXHRcdFx0Ly8gZm9yY2UgdGhlIGJyb3dzZXIgdG8gY29uc2lkZXIgdGhlIG5ld2x5IGFkZGVkIGVsZW1lbnQgZm9yIHRyYW5zaXRpb25cblx0XHRcdEwuVXRpbC5mYWxzZUZuKGxldmVsLmVsLm9mZnNldFdpZHRoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sZXZlbCA9IGxldmVsO1xuXG5cdFx0cmV0dXJuIGxldmVsO1xuXHR9LFxuXG5cdF9wcnVuZVRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIga2V5LCB0aWxlO1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHRcdGlmICh6b29tID4gdGhpcy5vcHRpb25zLm1heFpvb20gfHxcblx0XHRcdHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRpbGUuY3VycmVudDtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRpZiAodGlsZS5jdXJyZW50ICYmICF0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gdGlsZS5jb29yZHM7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV0YWluUGFyZW50KGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56IC0gNSkpIHtcblx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiArIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5yZXRhaW4pIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlVGlsZXNBdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAodGhpcy5fdGlsZXNba2V5XS5jb29yZHMueiAhPT0gem9vbSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZUFsbFRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbnZhbGlkYXRlQWxsOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG5cdFx0fVxuXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cblx0XHR0aGlzLl90aWxlWm9vbSA9IG51bGw7XG5cdH0sXG5cblx0X3JldGFpblBhcmVudDogZnVuY3Rpb24gKHgsIHksIHosIG1pblpvb20pIHtcblx0XHR2YXIgeDIgPSBNYXRoLmZsb29yKHggLyAyKSxcblx0XHQgICAgeTIgPSBNYXRoLmZsb29yKHkgLyAyKSxcblx0XHQgICAgejIgPSB6IC0gMSxcblx0XHQgICAgY29vcmRzMiA9IG5ldyBMLlBvaW50KCt4MiwgK3kyKTtcblx0XHRjb29yZHMyLnogPSArejI7XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkczIpLFxuXHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICh6MiA+IG1pblpvb20pIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXRhaW5QYXJlbnQoeDIsIHkyLCB6MiwgbWluWm9vbSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9yZXRhaW5DaGlsZHJlbjogZnVuY3Rpb24gKHgsIHksIHosIG1heFpvb20pIHtcblxuXHRcdGZvciAodmFyIGkgPSAyICogeDsgaSA8IDIgKiB4ICsgMjsgaSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMiAqIHk7IGogPCAyICogeSArIDI7IGorKykge1xuXG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgTC5Qb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB6ICsgMTtcblxuXHRcdFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyksXG5cdFx0XHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdFx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoeiArIDEgPCBtYXhab29tKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oaSwgaiwgeiArIDEsIG1heFpvb20pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGFuaW1hdGluZyA9IGUgJiYgKGUucGluY2ggfHwgZS5mbHlUbyk7XG5cdFx0dGhpcy5fc2V0Vmlldyh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCksIGFuaW1hdGluZywgYW5pbWF0aW5nKTtcblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fc2V0VmlldyhlLmNlbnRlciwgZS56b29tLCB0cnVlLCBlLm5vVXBkYXRlKTtcblx0fSxcblxuXHRfc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgbm9QcnVuZSwgbm9VcGRhdGUpIHtcblx0XHR2YXIgdGlsZVpvb20gPSBNYXRoLnJvdW5kKHpvb20pO1xuXHRcdGlmICgodGhpcy5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB8fFxuXHRcdCAgICAodGhpcy5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0dmFyIHRpbGVab29tQ2hhbmdlZCA9IHRoaXMub3B0aW9ucy51cGRhdGVXaGVuWm9vbWluZyAmJiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKTtcblxuXHRcdGlmICghbm9VcGRhdGUgfHwgdGlsZVpvb21DaGFuZ2VkKSB7XG5cblx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG5cblx0XHRcdGlmICh0aGlzLl9hYm9ydExvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fYWJvcnRMb2FkaW5nKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuXHRcdFx0dGhpcy5fcmVzZXRHcmlkKCk7XG5cblx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZShjZW50ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIW5vUHJ1bmUpIHtcblx0XHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGbGFnIHRvIHByZXZlbnQgX3VwZGF0ZU9wYWNpdHkgZnJvbSBwcnVuaW5nIHRpbGVzIGR1cmluZ1xuXHRcdFx0Ly8gYSB6b29tIGFuaW0gb3IgYSBwaW5jaCBnZXN0dXJlXG5cdFx0XHR0aGlzLl9ub1BydW5lID0gISFub1BydW5lO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm1zKGNlbnRlciwgem9vbSk7XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm1zOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0odGhpcy5fbGV2ZWxzW2ldLCBjZW50ZXIsIHpvb20pO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbVRyYW5zZm9ybTogZnVuY3Rpb24gKGxldmVsLCBjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIGxldmVsLnpvb20pLFxuXHRcdCAgICB0cmFuc2xhdGUgPSBsZXZlbC5vcmlnaW4ubXVsdGlwbHlCeShzY2FsZSlcblx0XHQgICAgICAgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpLnJvdW5kKCk7XG5cblx0XHRpZiAoTC5Ccm93c2VyLmFueTNkKSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0VHJhbnNmb3JtKGxldmVsLmVsLCB0cmFuc2xhdGUsIHNjYWxlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKGxldmVsLmVsLCB0cmFuc2xhdGUpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRHcmlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzLFxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuX3RpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXHRcdCAgICB0aWxlWm9vbSA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX3RpbGVab29tKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR0aGlzLl9nbG9iYWxUaWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKGJvdW5kcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fd3JhcFggPSBjcnMud3JhcExuZyAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1swXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzFdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdFx0dGhpcy5fd3JhcFkgPSBjcnMud3JhcExhdCAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFswXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzFdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdH0sXG5cblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9nZXRUaWxlZFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgbWFwWm9vbSA9IG1hcC5fYW5pbWF0aW5nWm9vbSA/IE1hdGgubWF4KG1hcC5fYW5pbWF0ZVRvWm9vbSwgbWFwLmdldFpvb20oKSkgOiBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUobWFwWm9vbSwgdGhpcy5fdGlsZVpvb20pLFxuXHRcdCAgICBwaXhlbENlbnRlciA9IG1hcC5wcm9qZWN0KGNlbnRlciwgdGhpcy5fdGlsZVpvb20pLmZsb29yKCksXG5cdFx0ICAgIGhhbGZTaXplID0gbWFwLmdldFNpemUoKS5kaXZpZGVCeShzY2FsZSAqIDIpO1xuXG5cdFx0cmV0dXJuIG5ldyBMLkJvdW5kcyhwaXhlbENlbnRlci5zdWJ0cmFjdChoYWxmU2l6ZSksIHBpeGVsQ2VudGVyLmFkZChoYWxmU2l6ZSkpO1xuXHR9LFxuXG5cdC8vIFByaXZhdGUgbWV0aG9kIHRvIGxvYWQgdGlsZXMgaW4gdGhlIGdyaWQncyBhY3RpdmUgem9vbSBsZXZlbCBhY2NvcmRpbmcgdG8gbWFwIGJvdW5kc1xuXHRfdXBkYXRlOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRpZiAoIW1hcCkgeyByZXR1cm47IH1cblx0XHR2YXIgem9vbSA9IG1hcC5nZXRab29tKCk7XG5cblx0XHRpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIHsgY2VudGVyID0gbWFwLmdldENlbnRlcigpOyB9XG5cdFx0aWYgKHRoaXMuX3RpbGVab29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XHQvLyBpZiBvdXQgb2YgbWluem9vbS9tYXh6b29tXG5cblx0XHR2YXIgcGl4ZWxCb3VuZHMgPSB0aGlzLl9nZXRUaWxlZFBpeGVsQm91bmRzKGNlbnRlciksXG5cdFx0ICAgIHRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UocGl4ZWxCb3VuZHMpLFxuXHRcdCAgICB0aWxlQ2VudGVyID0gdGlsZVJhbmdlLmdldENlbnRlcigpLFxuXHRcdCAgICBxdWV1ZSA9IFtdLFxuXHRcdCAgICBtYXJnaW4gPSB0aGlzLm9wdGlvbnMua2VlcEJ1ZmZlcixcblx0XHQgICAgbm9QcnVuZVJhbmdlID0gbmV3IEwuQm91bmRzKHRpbGVSYW5nZS5nZXRCb3R0b21MZWZ0KCkuc3VidHJhY3QoW21hcmdpbiwgLW1hcmdpbl0pLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVSYW5nZS5nZXRUb3BSaWdodCgpLmFkZChbbWFyZ2luLCAtbWFyZ2luXSkpO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR2YXIgYyA9IHRoaXMuX3RpbGVzW2tleV0uY29vcmRzO1xuXHRcdFx0aWYgKGMueiAhPT0gdGhpcy5fdGlsZVpvb20gfHwgIW5vUHJ1bmVSYW5nZS5jb250YWlucyhMLnBvaW50KGMueCwgYy55KSkpIHtcblx0XHRcdFx0dGhpcy5fdGlsZXNba2V5XS5jdXJyZW50ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gX3VwZGF0ZSBqdXN0IGxvYWRzIG1vcmUgdGlsZXMuIElmIHRoZSB0aWxlIHpvb20gbGV2ZWwgZGlmZmVycyB0b28gbXVjaFxuXHRcdC8vIGZyb20gdGhlIG1hcCdzLCBsZXQgX3NldFZpZXcgcmVzZXQgbGV2ZWxzIGFuZCBwcnVuZSBvbGQgdGlsZXMuXG5cdFx0aWYgKE1hdGguYWJzKHpvb20gLSB0aGlzLl90aWxlWm9vbSkgPiAxKSB7IHRoaXMuX3NldFZpZXcoY2VudGVyLCB6b29tKTsgcmV0dXJuOyB9XG5cblx0XHQvLyBjcmVhdGUgYSBxdWV1ZSBvZiBjb29yZGluYXRlcyB0byBsb2FkIHRpbGVzIGZyb21cblx0XHRmb3IgKHZhciBqID0gdGlsZVJhbmdlLm1pbi55OyBqIDw9IHRpbGVSYW5nZS5tYXgueTsgaisrKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gdGlsZVJhbmdlLm1pbi54OyBpIDw9IHRpbGVSYW5nZS5tYXgueDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgTC5Qb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB0aGlzLl90aWxlWm9vbTtcblxuXHRcdFx0XHRpZiAoIXRoaXMuX2lzVmFsaWRUaWxlKGNvb3JkcykpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW3RoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpXTtcblx0XHRcdFx0aWYgKHRpbGUpIHtcblx0XHRcdFx0XHR0aWxlLmN1cnJlbnQgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goY29vcmRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHNvcnQgdGlsZSBxdWV1ZSB0byBsb2FkIHRpbGVzIGluIG9yZGVyIG9mIHRoZWlyIGRpc3RhbmNlIHRvIGNlbnRlclxuXHRcdHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHJldHVybiBhLmRpc3RhbmNlVG8odGlsZUNlbnRlcikgLSBiLmRpc3RhbmNlVG8odGlsZUNlbnRlcik7XG5cdFx0fSk7XG5cblx0XHRpZiAocXVldWUubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHQvLyBpZiBpdCdzIHRoZSBmaXJzdCBiYXRjaCBvZiB0aWxlcyB0byBsb2FkXG5cdFx0XHRpZiAoIXRoaXMuX2xvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fbG9hZGluZyA9IHRydWU7XG5cdFx0XHRcdC8vIEBldmVudCBsb2FkaW5nOiBFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIHN0YXJ0cyBsb2FkaW5nIHRpbGVzLlxuXHRcdFx0XHR0aGlzLmZpcmUoJ2xvYWRpbmcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY3JlYXRlIERPTSBmcmFnbWVudCB0byBhcHBlbmQgdGlsZXMgaW4gb25lIGJhdGNoXG5cdFx0XHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLl9hZGRUaWxlKHF1ZXVlW2ldLCBmcmFnbWVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2xldmVsLmVsLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcblx0XHR9XG5cdH0sXG5cblx0X2lzVmFsaWRUaWxlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIGNycyA9IHRoaXMuX21hcC5vcHRpb25zLmNycztcblxuXHRcdGlmICghY3JzLmluZmluaXRlKSB7XG5cdFx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQncyBvdXQgb2YgYm91bmRzIGFuZCBub3Qgd3JhcHBlZFxuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZTtcblx0XHRcdGlmICgoIWNycy53cmFwTG5nICYmIChjb29yZHMueCA8IGJvdW5kcy5taW4ueCB8fCBjb29yZHMueCA+IGJvdW5kcy5tYXgueCkpIHx8XG5cdFx0XHQgICAgKCFjcnMud3JhcExhdCAmJiAoY29vcmRzLnkgPCBib3VuZHMubWluLnkgfHwgY29vcmRzLnkgPiBib3VuZHMubWF4LnkpKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5ib3VuZHMpIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCBkb2Vzbid0IGludGVyc2VjdCB0aGUgYm91bmRzIGluIG9wdGlvbnNcblx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyhjb29yZHMpO1xuXHRcdHJldHVybiBMLmxhdExuZ0JvdW5kcyh0aGlzLm9wdGlvbnMuYm91bmRzKS5vdmVybGFwcyh0aWxlQm91bmRzKTtcblx0fSxcblxuXHRfa2V5VG9Cb3VuZHM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpKTtcblx0fSxcblxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGl0cyBnZW9ncmFwaGljYWwgYm91bmRzXG5cdF90aWxlQ29vcmRzVG9Cb3VuZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXG5cdFx0ICAgIG53UG9pbnQgPSBjb29yZHMuc2NhbGVCeSh0aWxlU2l6ZSksXG5cdFx0ICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZCh0aWxlU2l6ZSksXG5cblx0XHQgICAgbncgPSBtYXAudW5wcm9qZWN0KG53UG9pbnQsIGNvb3Jkcy56KSxcblx0XHQgICAgc2UgPSBtYXAudW5wcm9qZWN0KHNlUG9pbnQsIGNvb3Jkcy56KTtcblxuXHRcdGlmICghdGhpcy5vcHRpb25zLm5vV3JhcCkge1xuXHRcdFx0bncgPSBtYXAud3JhcExhdExuZyhudyk7XG5cdFx0XHRzZSA9IG1hcC53cmFwTGF0TG5nKHNlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nQm91bmRzKG53LCBzZSk7XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBrZXkgZm9yIHRoZSB0aWxlIGNhY2hlXG5cdF90aWxlQ29vcmRzVG9LZXk6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnggKyAnOicgKyBjb29yZHMueSArICc6JyArIGNvb3Jkcy56O1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY2FjaGUga2V5IHRvIGNvb3JkaW5hdGVzXG5cdF9rZXlUb1RpbGVDb29yZHM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgayA9IGtleS5zcGxpdCgnOicpLFxuXHRcdCAgICBjb29yZHMgPSBuZXcgTC5Qb2ludCgra1swXSwgK2tbMV0pO1xuXHRcdGNvb3Jkcy56ID0gK2tbMl07XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fSxcblxuXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRpbGUuZWwpO1xuXG5cdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHQvLyBAZXZlbnQgdGlsZXVubG9hZDogVGlsZUV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVtb3ZlZCAoZS5nLiB3aGVuIGEgdGlsZSBnb2VzIG9mZiB0aGUgc2NyZWVuKS5cblx0XHR0aGlzLmZpcmUoJ3RpbGV1bmxvYWQnLCB7XG5cdFx0XHR0aWxlOiB0aWxlLmVsLFxuXHRcdFx0Y29vcmRzOiB0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9pbml0VGlsZTogZnVuY3Rpb24gKHRpbGUpIHtcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGlsZSwgJ2xlYWZsZXQtdGlsZScpO1xuXG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHRpbGUuc3R5bGUud2lkdGggPSB0aWxlU2l6ZS54ICsgJ3B4Jztcblx0XHR0aWxlLnN0eWxlLmhlaWdodCA9IHRpbGVTaXplLnkgKyAncHgnO1xuXG5cdFx0dGlsZS5vbnNlbGVjdHN0YXJ0ID0gTC5VdGlsLmZhbHNlRm47XG5cdFx0dGlsZS5vbm1vdXNlbW92ZSA9IEwuVXRpbC5mYWxzZUZuO1xuXG5cdFx0Ly8gdXBkYXRlIG9wYWNpdHkgb24gdGlsZXMgaW4gSUU3LTggYmVjYXVzZSBvZiBmaWx0ZXIgaW5oZXJpdGFuY2UgcHJvYmxlbXNcblx0XHRpZiAoTC5Ccm93c2VyLmllbHQ5ICYmIHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGlsZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXHRcdH1cblxuXHRcdC8vIHdpdGhvdXQgdGhpcyBoYWNrLCB0aWxlcyBkaXNhcHBlYXIgYWZ0ZXIgem9vbSBvbiBDaHJvbWUgZm9yIEFuZHJvaWRcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yMDc4XG5cdFx0aWYgKEwuQnJvd3Nlci5hbmRyb2lkICYmICFMLkJyb3dzZXIuYW5kcm9pZDIzKSB7XG5cdFx0XHR0aWxlLnN0eWxlLldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgY29udGFpbmVyKSB7XG5cdFx0dmFyIHRpbGVQb3MgPSB0aGlzLl9nZXRUaWxlUG9zKGNvb3JkcyksXG5cdFx0ICAgIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dmFyIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGUodGhpcy5fd3JhcENvb3Jkcyhjb29yZHMpLCBMLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMpKTtcblxuXHRcdHRoaXMuX2luaXRUaWxlKHRpbGUpO1xuXG5cdFx0Ly8gaWYgY3JlYXRlVGlsZSBpcyBkZWZpbmVkIHdpdGggYSBzZWNvbmQgYXJndW1lbnQgKFwiZG9uZVwiIGNhbGxiYWNrKSxcblx0XHQvLyB3ZSBrbm93IHRoYXQgdGlsZSBpcyBhc3luYyBhbmQgd2lsbCBiZSByZWFkeSBsYXRlcjsgb3RoZXJ3aXNlXG5cdFx0aWYgKHRoaXMuY3JlYXRlVGlsZS5sZW5ndGggPCAyKSB7XG5cdFx0XHQvLyBtYXJrIHRpbGUgYXMgcmVhZHksIGJ1dCBkZWxheSBvbmUgZnJhbWUgZm9yIG9wYWNpdHkgYW5pbWF0aW9uIHRvIGhhcHBlblxuXHRcdFx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoTC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzLCBudWxsLCB0aWxlKSk7XG5cdFx0fVxuXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRpbGUsIHRpbGVQb3MpO1xuXG5cdFx0Ly8gc2F2ZSB0aWxlIGluIGNhY2hlXG5cdFx0dGhpcy5fdGlsZXNba2V5XSA9IHtcblx0XHRcdGVsOiB0aWxlLFxuXHRcdFx0Y29vcmRzOiBjb29yZHMsXG5cdFx0XHRjdXJyZW50OiB0cnVlXG5cdFx0fTtcblxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aWxlKTtcblx0XHQvLyBAZXZlbnQgdGlsZWxvYWRzdGFydDogVGlsZUV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVxdWVzdGVkIGFuZCBzdGFydHMgbG9hZGluZy5cblx0XHR0aGlzLmZpcmUoJ3RpbGVsb2Fkc3RhcnQnLCB7XG5cdFx0XHR0aWxlOiB0aWxlLFxuXHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHR9KTtcblx0fSxcblxuXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdGlmIChlcnIpIHtcblx0XHRcdC8vIEBldmVudCB0aWxlZXJyb3I6IFRpbGVFcnJvckV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIGxvYWRpbmcgYSB0aWxlLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlZXJyb3InLCB7XG5cdFx0XHRcdGVycm9yOiBlcnIsXG5cdFx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cblx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHR0aWxlLmxvYWRlZCA9ICtuZXcgRGF0ZSgpO1xuXHRcdGlmICh0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGlsZS5lbCwgMCk7XG5cdFx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG5cdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdH1cblxuXHRcdGlmICghZXJyKSB7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGlsZS5lbCwgJ2xlYWZsZXQtdGlsZS1sb2FkZWQnKTtcblxuXHRcdFx0Ly8gQGV2ZW50IHRpbGVsb2FkOiBUaWxlRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGxvYWRzLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlbG9hZCcsIHtcblx0XHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9ub1RpbGVzVG9Mb2FkKCkpIHtcblx0XHRcdHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcblx0XHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBsb2FkZWQgYWxsIHZpc2libGUgdGlsZXMuXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcblxuXHRcdFx0aWYgKEwuQnJvd3Nlci5pZWx0OSB8fCAhdGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcblx0XHRcdFx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXYWl0IGEgYml0IG1vcmUgdGhhbiAwLjIgc2VjcyAodGhlIGR1cmF0aW9uIG9mIHRoZSB0aWxlIGZhZGUtaW4pXG5cdFx0XHRcdC8vIHRvIHRyaWdnZXIgYSBwcnVuaW5nLlxuXHRcdFx0XHRzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKSwgMjUwKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2dldFRpbGVQb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnNjYWxlQnkodGhpcy5nZXRUaWxlU2l6ZSgpKS5zdWJ0cmFjdCh0aGlzLl9sZXZlbC5vcmlnaW4pO1xuXHR9LFxuXG5cdF93cmFwQ29vcmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG5ld0Nvb3JkcyA9IG5ldyBMLlBvaW50KFxuXHRcdFx0dGhpcy5fd3JhcFggPyBMLlV0aWwud3JhcE51bShjb29yZHMueCwgdGhpcy5fd3JhcFgpIDogY29vcmRzLngsXG5cdFx0XHR0aGlzLl93cmFwWSA/IEwuVXRpbC53cmFwTnVtKGNvb3Jkcy55LCB0aGlzLl93cmFwWSkgOiBjb29yZHMueSk7XG5cdFx0bmV3Q29vcmRzLnogPSBjb29yZHMuejtcblx0XHRyZXR1cm4gbmV3Q29vcmRzO1xuXHR9LFxuXG5cdF9weEJvdW5kc1RvVGlsZVJhbmdlOiBmdW5jdGlvbiAoYm91bmRzKSB7XG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHJldHVybiBuZXcgTC5Cb3VuZHMoXG5cdFx0XHRib3VuZHMubWluLnVuc2NhbGVCeSh0aWxlU2l6ZSkuZmxvb3IoKSxcblx0XHRcdGJvdW5kcy5tYXgudW5zY2FsZUJ5KHRpbGVTaXplKS5jZWlsKCkuc3VidHJhY3QoWzEsIDFdKSk7XG5cdH0sXG5cblx0X25vVGlsZXNUb0xvYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5sb2FkZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5ncmlkTGF5ZXIob3B0aW9ucz86IEdyaWRMYXllciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBHcmlkTGF5ZXIgd2l0aCB0aGUgc3VwcGxpZWQgb3B0aW9ucy5cbkwuZ3JpZExheWVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLkdyaWRMYXllcihvcHRpb25zKTtcbn07XG5cbi8qXHJcbiAqIEBjbGFzcyBUaWxlTGF5ZXJcclxuICogQGluaGVyaXRzIEdyaWRMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBHcmlkTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLnRpbGVMYXllcignaHR0cDovL3tzfS50aWxlLm9zbS5vcmcve3p9L3t4fS97eX0ucG5nP3tmb299Jywge2ZvbzogJ2Jhcid9KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogQHNlY3Rpb24gVVJMIHRlbXBsYXRlXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIEEgc3RyaW5nIG9mIHRoZSBmb2xsb3dpbmcgZm9ybTpcclxuICpcclxuICogYGBgXHJcbiAqICdodHRwOi8ve3N9LnNvbWVkb21haW4uY29tL2JsYWJsYS97en0ve3h9L3t5fXtyfS5wbmcnXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBge3N9YCBtZWFucyBvbmUgb2YgdGhlIGF2YWlsYWJsZSBzdWJkb21haW5zICh1c2VkIHNlcXVlbnRpYWxseSB0byBoZWxwIHdpdGggYnJvd3NlciBwYXJhbGxlbCByZXF1ZXN0cyBwZXIgZG9tYWluIGxpbWl0YXRpb247IHN1YmRvbWFpbiB2YWx1ZXMgYXJlIHNwZWNpZmllZCBpbiBvcHRpb25zOyBgYWAsIGBiYCBvciBgY2AgYnkgZGVmYXVsdCwgY2FuIGJlIG9taXR0ZWQpLCBge3p9YCDigJQgem9vbSBsZXZlbCwgYHt4fWAgYW5kIGB7eX1gIOKAlCB0aWxlIGNvb3JkaW5hdGVzLiBge3J9YCBjYW4gYmUgdXNlZCB0byBhZGQgQDJ4IHRvIHRoZSBVUkwgdG8gbG9hZCByZXRpbmEgdGlsZXMuXHJcbiAqXHJcbiAqIFlvdSBjYW4gdXNlIGN1c3RvbSBrZXlzIGluIHRoZSB0ZW1wbGF0ZSwgd2hpY2ggd2lsbCBiZSBbZXZhbHVhdGVkXSgjdXRpbC10ZW1wbGF0ZSkgZnJvbSBUaWxlTGF5ZXIgb3B0aW9ucywgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBcclxuICogTC50aWxlTGF5ZXIoJ2h0dHA6Ly97c30uc29tZWRvbWFpbi5jb20ve2Zvb30ve3p9L3t4fS97eX0ucG5nJywge2ZvbzogJ2Jhcid9KTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbkwuVGlsZUxheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXHJcblx0XHQvLyBNaW5pbXVtIHpvb20gbnVtYmVyLlxyXG5cdFx0bWluWm9vbTogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IDE4XHJcblx0XHQvLyBNYXhpbXVtIHpvb20gbnVtYmVyLlxyXG5cdFx0bWF4Wm9vbTogMTgsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhOYXRpdmVab29tOiBOdW1iZXIgPSBudWxsXHJcblx0XHQvLyBNYXhpbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXHJcblx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGhpZ2hlciB0aGFuIGBtYXhOYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxyXG5cdFx0Ly8gZnJvbSBgbWF4TmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxyXG5cdFx0bWF4TmF0aXZlWm9vbTogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHN1YmRvbWFpbnM6IFN0cmluZ3xTdHJpbmdbXSA9ICdhYmMnXHJcblx0XHQvLyBTdWJkb21haW5zIG9mIHRoZSB0aWxlIHNlcnZpY2UuIENhbiBiZSBwYXNzZWQgaW4gdGhlIGZvcm0gb2Ygb25lIHN0cmluZyAod2hlcmUgZWFjaCBsZXR0ZXIgaXMgYSBzdWJkb21haW4gbmFtZSkgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuXHRcdHN1YmRvbWFpbnM6ICdhYmMnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZXJyb3JUaWxlVXJsOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVVJMIHRvIHRoZSB0aWxlIGltYWdlIHRvIHNob3cgaW4gcGxhY2Ugb2YgdGhlIHRpbGUgdGhhdCBmYWlsZWQgdG8gbG9hZC5cclxuXHRcdGVycm9yVGlsZVVybDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBUaGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSBvZmZzZXQgd2l0aCB0aGlzIHZhbHVlLlxyXG5cdFx0em9vbU9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRtczogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIGludmVyc2VzIFkgYXhpcyBudW1iZXJpbmcgZm9yIHRpbGVzICh0dXJuIHRoaXMgb24gZm9yIFtUTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS5cclxuXHRcdHRtczogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tUmV2ZXJzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgcmV2ZXJzZWQgKGBtYXhab29tIC0gem9vbWAgaW5zdGVhZCBvZiBgem9vbWApXHJcblx0XHR6b29tUmV2ZXJzZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBkZXRlY3RSZXRpbmE6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgIGFuZCB1c2VyIGlzIG9uIGEgcmV0aW5hIGRpc3BsYXksIGl0IHdpbGwgcmVxdWVzdCBmb3VyIHRpbGVzIG9mIGhhbGYgdGhlIHNwZWNpZmllZCBzaXplIGFuZCBhIGJpZ2dlciB6b29tIGxldmVsIGluIHBsYWNlIG9mIG9uZSB0byB1dGlsaXplIHRoZSBoaWdoIHJlc29sdXRpb24uXHJcblx0XHRkZXRlY3RSZXRpbmE6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgdHJ1ZSwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvICcnLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgdGlsZSBwaXhlbCBkYXRhLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRvcHRpb25zID0gTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdC8vIGRldGVjdGluZyByZXRpbmEgZGlzcGxheXMsIGFkanVzdGluZyB0aWxlU2l6ZSBhbmQgem9vbSBsZXZlbHNcclxuXHRcdGlmIChvcHRpb25zLmRldGVjdFJldGluYSAmJiBMLkJyb3dzZXIucmV0aW5hICYmIG9wdGlvbnMubWF4Wm9vbSA+IDApIHtcclxuXHJcblx0XHRcdG9wdGlvbnMudGlsZVNpemUgPSBNYXRoLmZsb29yKG9wdGlvbnMudGlsZVNpemUgLyAyKTtcclxuXHJcblx0XHRcdGlmICghb3B0aW9ucy56b29tUmV2ZXJzZSkge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldCsrO1xyXG5cdFx0XHRcdG9wdGlvbnMubWF4Wm9vbS0tO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldC0tO1xyXG5cdFx0XHRcdG9wdGlvbnMubWluWm9vbSsrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1heCgwLCBvcHRpb25zLm1pblpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucy5zdWJkb21haW5zID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRvcHRpb25zLnN1YmRvbWFpbnMgPSBvcHRpb25zLnN1YmRvbWFpbnMuc3BsaXQoJycpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xMzdcclxuXHRcdGlmICghTC5Ccm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0dGhpcy5vbigndGlsZXVubG9hZCcsIHRoaXMuX29uVGlsZVJlbW92ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBVcGRhdGVzIHRoZSBsYXllcidzIFVSTCB0ZW1wbGF0ZSBhbmQgcmVkcmF3cyBpdCAodW5sZXNzIGBub1JlZHJhd2AgaXMgc2V0IHRvIGB0cnVlYCkuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsLCBub1JlZHJhdykge1xyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBvdmVycmlkZXMgR3JpZExheWVyJ3MgW2BjcmVhdGVUaWxlKClgXSgjZ3JpZGxheWVyLWNyZWF0ZXRpbGUpXHJcblx0Ly8gdG8gcmV0dXJuIGFuIGA8aW1nPmAgSFRNTCBlbGVtZW50IHdpdGggdGhlIGFwcHJvcGlhdGUgaW1hZ2UgVVJMIGdpdmVuIGBjb29yZHNgLiBUaGUgYGRvbmVgXHJcblx0Ly8gY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGJlZW4gbG9hZGVkLlxyXG5cdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGRvbmUpIHtcclxuXHRcdHZhciB0aWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblxyXG5cdFx0TC5Eb21FdmVudC5vbih0aWxlLCAnbG9hZCcsIEwuYmluZCh0aGlzLl90aWxlT25Mb2FkLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblx0XHRMLkRvbUV2ZW50Lm9uKHRpbGUsICdlcnJvcicsIEwuYmluZCh0aGlzLl90aWxlT25FcnJvciwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4pIHtcclxuXHRcdFx0dGlsZS5jcm9zc09yaWdpbiA9ICcnO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8qXHJcblx0XHQgQWx0IHRhZyBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIHRvIGtlZXAgc2NyZWVuIHJlYWRlcnMgZnJvbSByZWFkaW5nIFVSTCBhbmQgZm9yIGNvbXBsaWFuY2UgcmVhc29uc1xyXG5cdFx0IGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC1URUNIUy9INjdcclxuXHRcdCovXHJcblx0XHR0aWxlLmFsdCA9ICcnO1xyXG5cclxuXHRcdHRpbGUuc3JjID0gdGhpcy5nZXRUaWxlVXJsKGNvb3Jkcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRpbGU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuXHQvLyBAdW5pbmhlcml0YWJsZVxyXG5cdC8vIExheWVycyBleHRlbmRpbmcgYFRpbGVMYXllcmAgbWlnaHQgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXHJcblx0Ly8gQG1ldGhvZCBnZXRUaWxlVXJsKGNvb3JkczogT2JqZWN0KTogU3RyaW5nXHJcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgcmV0dXJucyB0aGUgVVJMIGZvciBhIHRpbGUgZ2l2ZW4gaXRzIGNvb3JkaW5hdGVzLlxyXG5cdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIGNhbiBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIHByb3ZpZGUgY3VzdG9tIHRpbGUgVVJMIG5hbWluZyBzY2hlbWVzLlxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRyOiBMLkJyb3dzZXIucmV0aW5hID8gJ0AyeCcgOiAnJyxcclxuXHRcdFx0czogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3JkcyksXHJcblx0XHRcdHg6IGNvb3Jkcy54LFxyXG5cdFx0XHR5OiBjb29yZHMueSxcclxuXHRcdFx0ejogdGhpcy5fZ2V0Wm9vbUZvclVybCgpXHJcblx0XHR9O1xyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5fbWFwLm9wdGlvbnMuY3JzLmluZmluaXRlKSB7XHJcblx0XHRcdHZhciBpbnZlcnRlZFkgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2UubWF4LnkgLSBjb29yZHMueTtcclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy50bXMpIHtcclxuXHRcdFx0XHRkYXRhWyd5J10gPSBpbnZlcnRlZFk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGF0YVsnLXknXSA9IGludmVydGVkWTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gTC5VdGlsLnRlbXBsYXRlKHRoaXMuX3VybCwgTC5leHRlbmQoZGF0YSwgdGhpcy5vcHRpb25zKSk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkxvYWQ6IGZ1bmN0aW9uIChkb25lLCB0aWxlKSB7XHJcblx0XHQvLyBGb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzMzMlxyXG5cdFx0aWYgKEwuQnJvd3Nlci5pZWx0OSkge1xyXG5cdFx0XHRzZXRUaW1lb3V0KEwuYmluZChkb25lLCB0aGlzLCBudWxsLCB0aWxlKSwgMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkb25lKG51bGwsIHRpbGUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF90aWxlT25FcnJvcjogZnVuY3Rpb24gKGRvbmUsIHRpbGUsIGUpIHtcclxuXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvclRpbGVVcmw7XHJcblx0XHRpZiAoZXJyb3JVcmwpIHtcclxuXHRcdFx0dGlsZS5zcmMgPSBlcnJvclVybDtcclxuXHRcdH1cclxuXHRcdGRvbmUoZSwgdGlsZSk7XHJcblx0fSxcclxuXHJcblx0Z2V0VGlsZVNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgdGlsZVNpemUgPSBMLkdyaWRMYXllci5wcm90b3R5cGUuZ2V0VGlsZVNpemUuY2FsbCh0aGlzKSxcclxuXHRcdCAgICB6b29tID0gdGhpcy5fdGlsZVpvb20gKyB0aGlzLm9wdGlvbnMuem9vbU9mZnNldCxcclxuXHRcdCAgICB6b29tTiA9IHRoaXMub3B0aW9ucy5tYXhOYXRpdmVab29tO1xyXG5cclxuXHRcdC8vIGluY3JlYXNlIHRpbGUgc2l6ZSB3aGVuIG92ZXJzY2FsaW5nXHJcblx0XHRyZXR1cm4gem9vbU4gIT09IG51bGwgJiYgem9vbSA+IHpvb21OID9cclxuXHRcdFx0XHR0aWxlU2l6ZS5kaXZpZGVCeShtYXAuZ2V0Wm9vbVNjYWxlKHpvb21OLCB6b29tKSkucm91bmQoKSA6XHJcblx0XHRcdFx0dGlsZVNpemU7XHJcblx0fSxcclxuXHJcblx0X29uVGlsZVJlbW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGUudGlsZS5vbmxvYWQgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tRm9yVXJsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcblx0XHQgICAgem9vbSA9IHRoaXMuX3RpbGVab29tO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcblx0XHRcdHpvb20gPSBvcHRpb25zLm1heFpvb20gLSB6b29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHpvb20gKz0gb3B0aW9ucy56b29tT2Zmc2V0O1xyXG5cclxuXHRcdHJldHVybiBvcHRpb25zLm1heE5hdGl2ZVpvb20gIT09IG51bGwgPyBNYXRoLm1pbih6b29tLCBvcHRpb25zLm1heE5hdGl2ZVpvb20pIDogem9vbTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0U3ViZG9tYWluOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7XHJcblx0XHR2YXIgaW5kZXggPSBNYXRoLmFicyh0aWxlUG9pbnQueCArIHRpbGVQb2ludC55KSAlIHRoaXMub3B0aW9ucy5zdWJkb21haW5zLmxlbmd0aDtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpbmRleF07XHJcblx0fSxcclxuXHJcblx0Ly8gc3RvcHMgbG9hZGluZyBhbGwgdGlsZXMgaW4gdGhlIGJhY2tncm91bmQgbGF5ZXJcclxuXHRfYWJvcnRMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaSwgdGlsZTtcclxuXHRcdGZvciAoaSBpbiB0aGlzLl90aWxlcykge1xyXG5cdFx0XHRpZiAodGhpcy5fdGlsZXNbaV0uY29vcmRzLnogIT09IHRoaXMuX3RpbGVab29tKSB7XHJcblx0XHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2ldLmVsO1xyXG5cclxuXHRcdFx0XHR0aWxlLm9ubG9hZCA9IEwuVXRpbC5mYWxzZUZuO1xyXG5cdFx0XHRcdHRpbGUub25lcnJvciA9IEwuVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdFx0XHRpZiAoIXRpbGUuY29tcGxldGUpIHtcclxuXHRcdFx0XHRcdHRpbGUuc3JjID0gTC5VdGlsLmVtcHR5SW1hZ2VVcmw7XHJcblx0XHRcdFx0XHRMLkRvbVV0aWwucmVtb3ZlKHRpbGUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC50aWxlbGF5ZXIodXJsVGVtcGxhdGU6IFN0cmluZywgb3B0aW9ucz86IFRpbGVMYXllciBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSB0aWxlIGxheWVyIG9iamVjdCBnaXZlbiBhIGBVUkwgdGVtcGxhdGVgIGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG5cclxuTC50aWxlTGF5ZXIgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLlRpbGVMYXllcih1cmwsIG9wdGlvbnMpO1xyXG59O1xyXG5cbi8qXHJcbiAqIEBjbGFzcyBUaWxlTGF5ZXIuV01TXHJcbiAqIEBpbmhlcml0cyBUaWxlTGF5ZXJcclxuICogQGFrYSBMLlRpbGVMYXllci5XTVNcclxuICogVXNlZCB0byBkaXNwbGF5IFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMgYXMgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgVGlsZUxheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIG5leHJhZCA9IEwudGlsZUxheWVyLndtcyhcImh0dHA6Ly9tZXNvbmV0LmFncm9uLmlhc3RhdGUuZWR1L2NnaS1iaW4vd21zL25leHJhZC9uMHIuY2dpXCIsIHtcclxuICogXHRsYXllcnM6ICduZXhyYWQtbjByLTkwMDkxMycsXHJcbiAqIFx0Zm9ybWF0OiAnaW1hZ2UvcG5nJyxcclxuICogXHR0cmFuc3BhcmVudDogdHJ1ZSxcclxuICogXHRhdHRyaWJ1dGlvbjogXCJXZWF0aGVyIGRhdGEgwqkgMjAxMiBJRU0gTmV4cmFkXCJcclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuVGlsZUxheWVyLldNUyA9IEwuVGlsZUxheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBUaWxlTGF5ZXIuV01TIG9wdGlvbnNcclxuXHQvLyBJZiBhbnkgY3VzdG9tIG9wdGlvbnMgbm90IGRvY3VtZW50ZWQgaGVyZSBhcmUgdXNlZCwgdGhleSB3aWxsIGJlIHNlbnQgdG8gdGhlXHJcblx0Ly8gV01TIHNlcnZlciBhcyBleHRyYSBwYXJhbWV0ZXJzIGluIGVhY2ggcmVxdWVzdCBVUkwuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcclxuXHQvLyBbbm9uLXN0YW5kYXJkIHZlbmRvciBXTVMgcGFyYW1ldGVyc10oaHR0cDovL2RvY3MuZ2Vvc2VydmVyLm9yZy9zdGFibGUvZW4vdXNlci9zZXJ2aWNlcy93bXMvdmVuZG9yLmh0bWwpLlxyXG5cdGRlZmF1bHRXbXNQYXJhbXM6IHtcclxuXHRcdHNlcnZpY2U6ICdXTVMnLFxyXG5cdFx0cmVxdWVzdDogJ0dldE1hcCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsYXllcnM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyAqKihyZXF1aXJlZCkqKiBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgbGF5ZXJzIHRvIHNob3cuXHJcblx0XHRsYXllcnM6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc3R5bGVzOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIHN0eWxlcy5cclxuXHRcdHN0eWxlczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBmb3JtYXQ6IFN0cmluZyA9ICdpbWFnZS9qcGVnJ1xyXG5cdFx0Ly8gV01TIGltYWdlIGZvcm1hdCAodXNlIGAnaW1hZ2UvcG5nJ2AgZm9yIGxheWVycyB3aXRoIHRyYW5zcGFyZW5jeSkuXHJcblx0XHRmb3JtYXQ6ICdpbWFnZS9qcGVnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYW5zcGFyZW50OiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIFdNUyBzZXJ2aWNlIHdpbGwgcmV0dXJuIGltYWdlcyB3aXRoIHRyYW5zcGFyZW5jeS5cclxuXHRcdHRyYW5zcGFyZW50OiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHZlcnNpb246IFN0cmluZyA9ICcxLjEuMSdcclxuXHRcdC8vIFZlcnNpb24gb2YgdGhlIFdNUyBzZXJ2aWNlIHRvIHVzZVxyXG5cdFx0dmVyc2lvbjogJzEuMS4xJ1xyXG5cdH0sXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gY3JzOiBDUlMgPSBudWxsXHJcblx0XHQvLyBDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW0gdG8gdXNlIGZvciB0aGUgV01TIHJlcXVlc3RzLCBkZWZhdWx0cyB0b1xyXG5cdFx0Ly8gbWFwIENSUy4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdCBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcblx0XHRjcnM6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB1cHBlcmNhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCBXTVMgcmVxdWVzdCBwYXJhbWV0ZXIga2V5cyB3aWxsIGJlIHVwcGVyY2FzZS5cclxuXHRcdHVwcGVyY2FzZTogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdHZhciB3bXNQYXJhbXMgPSBMLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0V21zUGFyYW1zKTtcclxuXHJcblx0XHQvLyBhbGwga2V5cyB0aGF0IGFyZSBub3QgVGlsZUxheWVyIG9wdGlvbnMgZ28gdG8gV01TIHBhcmFtc1xyXG5cdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRcdGlmICghKGkgaW4gdGhpcy5vcHRpb25zKSkge1xyXG5cdFx0XHRcdHdtc1BhcmFtc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRvcHRpb25zID0gTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHdtc1BhcmFtcy53aWR0aCA9IHdtc1BhcmFtcy5oZWlnaHQgPSBvcHRpb25zLnRpbGVTaXplICogKG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEwuQnJvd3Nlci5yZXRpbmEgPyAyIDogMSk7XHJcblxyXG5cdFx0dGhpcy53bXNQYXJhbXMgPSB3bXNQYXJhbXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHJcblx0XHR0aGlzLl9jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IG1hcC5vcHRpb25zLmNycztcclxuXHRcdHRoaXMuX3dtc1ZlcnNpb24gPSBwYXJzZUZsb2F0KHRoaXMud21zUGFyYW1zLnZlcnNpb24pO1xyXG5cclxuXHRcdHZhciBwcm9qZWN0aW9uS2V5ID0gdGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgPyAnY3JzJyA6ICdzcnMnO1xyXG5cdFx0dGhpcy53bXNQYXJhbXNbcHJvamVjdGlvbktleV0gPSB0aGlzLl9jcnMuY29kZTtcclxuXHJcblx0XHRMLlRpbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHJcblx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyhjb29yZHMpLFxyXG5cdFx0ICAgIG53ID0gdGhpcy5fY3JzLnByb2plY3QodGlsZUJvdW5kcy5nZXROb3J0aFdlc3QoKSksXHJcblx0XHQgICAgc2UgPSB0aGlzLl9jcnMucHJvamVjdCh0aWxlQm91bmRzLmdldFNvdXRoRWFzdCgpKSxcclxuXHJcblx0XHQgICAgYmJveCA9ICh0aGlzLl93bXNWZXJzaW9uID49IDEuMyAmJiB0aGlzLl9jcnMgPT09IEwuQ1JTLkVQU0c0MzI2ID9cclxuXHRcdFx0ICAgIFtzZS55LCBudy54LCBudy55LCBzZS54XSA6XHJcblx0XHRcdCAgICBbbncueCwgc2UueSwgc2UueCwgbncueV0pLmpvaW4oJywnKSxcclxuXHJcblx0XHQgICAgdXJsID0gTC5UaWxlTGF5ZXIucHJvdG90eXBlLmdldFRpbGVVcmwuY2FsbCh0aGlzLCBjb29yZHMpO1xyXG5cclxuXHRcdHJldHVybiB1cmwgK1xyXG5cdFx0XHRMLlV0aWwuZ2V0UGFyYW1TdHJpbmcodGhpcy53bXNQYXJhbXMsIHVybCwgdGhpcy5vcHRpb25zLnVwcGVyY2FzZSkgK1xyXG5cdFx0XHQodGhpcy5vcHRpb25zLnVwcGVyY2FzZSA/ICcmQkJPWD0nIDogJyZiYm94PScpICsgYmJveDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBhcmFtcyhwYXJhbXM6IE9iamVjdCwgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIE1lcmdlcyBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IHBhcmFtZXRlcnMgYW5kIHJlLXJlcXVlc3RzIHRpbGVzIG9uIHRoZSBjdXJyZW50IHNjcmVlbiAodW5sZXNzIGBub1JlZHJhd2Agd2FzIHNldCB0byB0cnVlKS5cclxuXHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChwYXJhbXMsIG5vUmVkcmF3KSB7XHJcblxyXG5cdFx0TC5leHRlbmQodGhpcy53bXNQYXJhbXMsIHBhcmFtcyk7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC50aWxlTGF5ZXIud21zKGJhc2VVcmw6IFN0cmluZywgb3B0aW9uczogVGlsZUxheWVyLldNUyBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBXTVMgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBiYXNlIFVSTCBvZiB0aGUgV01TIHNlcnZpY2UgYW5kIGEgV01TIHBhcmFtZXRlcnMvb3B0aW9ucyBvYmplY3QuXHJcbkwudGlsZUxheWVyLndtcyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuVGlsZUxheWVyLldNUyh1cmwsIG9wdGlvbnMpO1xyXG59O1xyXG5cbi8qXHJcbiAqIEBjbGFzcyBJbWFnZU92ZXJsYXlcclxuICogQGFrYSBMLkltYWdlT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgc2luZ2xlIGltYWdlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGltYWdlVXJsID0gJ2h0dHA6Ly93d3cubGliLnV0ZXhhcy5lZHUvbWFwcy9oaXN0b3JpY2FsL25ld2Fya19ual8xOTIyLmpwZycsXHJcbiAqIFx0aW1hZ2VCb3VuZHMgPSBbWzQwLjcxMjIxNiwgLTc0LjIyNjU1XSwgWzQwLjc3Mzk0MSwgLTc0LjEyNTQ0XV07XHJcbiAqIEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsLCBpbWFnZUJvdW5kcykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5JbWFnZU92ZXJsYXkgPSBMLkxheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBJbWFnZU92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuXHRcdGFsdDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBpbWFnZSBvdmVybGF5IHdpbGwgZW1pdCBbbW91c2UgZXZlbnRzXSgjaW50ZXJhY3RpdmUtbGF5ZXIpIHdoZW4gY2xpY2tlZCBvciBob3ZlcmVkLlxyXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXR0cmlidXRpb246IFN0cmluZyA9IG51bGxcclxuXHRcdC8vIEFuIG9wdGlvbmFsIHN0cmluZyBjb250YWluaW5nIEhUTUwgdG8gYmUgc2hvd24gb24gdGhlIGBBdHRyaWJ1dGlvbiBjb250cm9sYFxyXG5cdFx0YXR0cmlidXRpb246IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiB0cnVlLCB0aGUgaW1hZ2Ugd2lsbCBoYXZlIGl0cyBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvICcnLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgaW1hZ2UgcGl4ZWwgZGF0YS5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykgeyAvLyAoU3RyaW5nLCBMYXRMbmdCb3VuZHMsIE9iamVjdClcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJbWFnZSgpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2ltYWdlLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pbWFnZSk7XHJcblx0XHR0aGlzLl9yZXNldCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2ltYWdlKTtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBvdmVybGF5LlxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGVPcHRzKSB7XHJcblx0XHRpZiAoc3R5bGVPcHRzLm9wYWNpdHkpIHtcclxuXHRcdFx0dGhpcy5zZXRPcGFjaXR5KHN0eWxlT3B0cy5vcGFjaXR5KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHRMLkRvbVV0aWwudG9Gcm9udCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdEwuRG9tVXRpbC50b0JhY2sodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgVVJMIG9mIHRoZSBpbWFnZS5cclxuXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwpIHtcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gdXJsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSBib3VuZHM7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9yZXNldCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0ge1xyXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldCxcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pbWFnZTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW1nID0gdGhpcy5faW1hZ2UgPSBMLkRvbVV0aWwuY3JlYXRlKCdpbWcnLFxyXG5cdFx0XHRcdCdsZWFmbGV0LWltYWdlLWxheWVyICcgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcgOiAnJykpO1xyXG5cclxuXHRcdGltZy5vbnNlbGVjdHN0YXJ0ID0gTC5VdGlsLmZhbHNlRm47XHJcblx0XHRpbWcub25tb3VzZW1vdmUgPSBMLlV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRpbWcub25sb2FkID0gTC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luKSB7XHJcblx0XHRcdGltZy5jcm9zc09yaWdpbiA9ICcnO1xyXG5cdFx0fVxyXG5cclxuXHRcdGltZy5zcmMgPSB0aGlzLl91cmw7XHJcblx0XHRpbWcuYWx0ID0gdGhpcy5vcHRpb25zLmFsdDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKGUuem9vbSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldE5vcnRoV2VzdCgpLCBlLnpvb20sIGUuY2VudGVyKTtcclxuXHJcblx0XHRMLkRvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2ltYWdlLCBvZmZzZXQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlLFxyXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBMLkJvdW5kcyhcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG5cdFx0ICAgICAgICB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXRTb3V0aEVhc3QoKSkpLFxyXG5cdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihpbWFnZSwgYm91bmRzLm1pbik7XHJcblxyXG5cdFx0aW1hZ2Uuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdGltYWdlLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ltYWdlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBmYWN0b3J5IEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsOiBTdHJpbmcsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogSW1hZ2VPdmVybGF5IG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiB0aGUgVVJMIG9mIHRoZSBpbWFnZSBhbmQgdGhlXHJcbi8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuTC5pbWFnZU92ZXJsYXkgPSBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuSW1hZ2VPdmVybGF5KHVybCwgYm91bmRzLCBvcHRpb25zKTtcclxufTtcclxuXG4vKlxyXG4gKiBAY2xhc3MgSWNvblxyXG4gKiBAYWthIEwuSWNvblxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcclxuICpcclxuICogUmVwcmVzZW50cyBhbiBpY29uIHRvIHByb3ZpZGUgd2hlbiBjcmVhdGluZyBhIG1hcmtlci5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIG15SWNvbiA9IEwuaWNvbih7XHJcbiAqICAgICBpY29uVXJsOiAnbXktaWNvbi5wbmcnLFxyXG4gKiAgICAgaWNvblJldGluYVVybDogJ215LWljb25AMngucG5nJyxcclxuICogICAgIGljb25TaXplOiBbMzgsIDk1XSxcclxuICogICAgIGljb25BbmNob3I6IFsyMiwgOTRdLFxyXG4gKiAgICAgcG9wdXBBbmNob3I6IFstMywgLTc2XSxcclxuICogICAgIHNoYWRvd1VybDogJ215LWljb24tc2hhZG93LnBuZycsXHJcbiAqICAgICBzaGFkb3dSZXRpbmFVcmw6ICdteS1pY29uLXNoYWRvd0AyeC5wbmcnLFxyXG4gKiAgICAgc2hhZG93U2l6ZTogWzY4LCA5NV0sXHJcbiAqICAgICBzaGFkb3dBbmNob3I6IFsyMiwgOTRdXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogYEwuSWNvbi5EZWZhdWx0YCBleHRlbmRzIGBMLkljb25gIGFuZCBpcyB0aGUgYmx1ZSBpY29uIExlYWZsZXQgdXNlcyBmb3IgbWFya2VycyBieSBkZWZhdWx0LlxyXG4gKlxyXG4gKi9cclxuXHJcbkwuSWNvbiA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEljb24gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogKioocmVxdWlyZWQpKiogVGhlIFVSTCB0byB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91ciBzY3JpcHQgcGF0aCkuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25SZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiBUaGUgVVJMIHRvIGEgcmV0aW5hIHNpemVkIHZlcnNpb24gb2YgdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXJcclxuXHQgKiBzY3JpcHQgcGF0aCkuIFVzZWQgZm9yIFJldGluYSBzY3JlZW4gZGV2aWNlcy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblNpemU6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFNpemUgb2YgdGhlIGljb24gaW1hZ2UgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uQW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIGljb24gKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpLiBUaGUgaWNvblxyXG5cdCAqIHdpbGwgYmUgYWxpZ25lZCBzbyB0aGF0IHRoaXMgcG9pbnQgaXMgYXQgdGhlIG1hcmtlcidzIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi4gQ2VudGVyZWRcclxuXHQgKiBieSBkZWZhdWx0IGlmIHNpemUgaXMgc3BlY2lmaWVkLCBhbHNvIGNhbiBiZSBzZXQgaW4gQ1NTIHdpdGggbmVnYXRpdmUgbWFyZ2lucy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gcG9wdXBBbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCBwb3B1cHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiBUaGUgVVJMIHRvIHRoZSBpY29uIHNoYWRvdyBpbWFnZS4gSWYgbm90IHNwZWNpZmllZCwgbm8gc2hhZG93IGltYWdlIHdpbGwgYmUgY3JlYXRlZC5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93UmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1NpemU6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFNpemUgb2YgdGhlIHNoYWRvdyBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd0FuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBzaGFkb3cgKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpICh0aGUgc2FtZVxyXG5cdCAqIGFzIGljb25BbmNob3IgaWYgbm90IHNwZWNpZmllZCkuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHQgKiBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byBib3RoIGljb24gYW5kIHNoYWRvdyBpbWFnZXMuIEVtcHR5IGJ5IGRlZmF1bHQuXHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVJY29uKG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ2FsbGVkIGludGVybmFsbHkgd2hlbiB0aGUgaWNvbiBoYXMgdG8gYmUgc2hvd24sIHJldHVybnMgYSBgPGltZz5gIEhUTUwgZWxlbWVudFxyXG5cdC8vIHN0eWxlZCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnMuXHJcblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdpY29uJywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVTaGFkb3cob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBBcyBgY3JlYXRlSWNvbmAsIGJ1dCBmb3IgdGhlIHNoYWRvdyBiZW5lYXRoIGl0LlxyXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdzaGFkb3cnLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSWNvbjogZnVuY3Rpb24gKG5hbWUsIG9sZEljb24pIHtcclxuXHRcdHZhciBzcmMgPSB0aGlzLl9nZXRJY29uVXJsKG5hbWUpO1xyXG5cclxuXHRcdGlmICghc3JjKSB7XHJcblx0XHRcdGlmIChuYW1lID09PSAnaWNvbicpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ljb25Vcmwgbm90IHNldCBpbiBJY29uIG9wdGlvbnMgKHNlZSB0aGUgZG9jcykuJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2NyZWF0ZUltZyhzcmMsIG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnSU1HJyA/IG9sZEljb24gOiBudWxsKTtcclxuXHRcdHRoaXMuX3NldEljb25TdHlsZXMoaW1nLCBuYW1lKTtcclxuXHJcblx0XHRyZXR1cm4gaW1nO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRJY29uU3R5bGVzOiBmdW5jdGlvbiAoaW1nLCBuYW1lKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHRcdHZhciBzaXplT3B0aW9uID0gb3B0aW9uc1tuYW1lICsgJ1NpemUnXTtcclxuXHJcblx0XHRpZiAodHlwZW9mIHNpemVPcHRpb24gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdHNpemVPcHRpb24gPSBbc2l6ZU9wdGlvbiwgc2l6ZU9wdGlvbl07XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNpemUgPSBMLnBvaW50KHNpemVPcHRpb24pLFxyXG5cdFx0ICAgIGFuY2hvciA9IEwucG9pbnQobmFtZSA9PT0gJ3NoYWRvdycgJiYgb3B0aW9ucy5zaGFkb3dBbmNob3IgfHwgb3B0aW9ucy5pY29uQW5jaG9yIHx8XHJcblx0XHQgICAgICAgICAgICBzaXplICYmIHNpemUuZGl2aWRlQnkoMiwgdHJ1ZSkpO1xyXG5cclxuXHRcdGltZy5jbGFzc05hbWUgPSAnbGVhZmxldC1tYXJrZXItJyArIG5hbWUgKyAnICcgKyAob3B0aW9ucy5jbGFzc05hbWUgfHwgJycpO1xyXG5cclxuXHRcdGlmIChhbmNob3IpIHtcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpbkxlZnQgPSAoLWFuY2hvci54KSArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5Ub3AgID0gKC1hbmNob3IueSkgKyAncHgnO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzaXplKSB7XHJcblx0XHRcdGltZy5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSW1nOiBmdW5jdGlvbiAoc3JjLCBlbCkge1xyXG5cdFx0ZWwgPSBlbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHRcdGVsLnNyYyA9IHNyYztcclxuXHRcdHJldHVybiBlbDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcclxuXHRcdHJldHVybiBMLkJyb3dzZXIucmV0aW5hICYmIHRoaXMub3B0aW9uc1tuYW1lICsgJ1JldGluYVVybCddIHx8IHRoaXMub3B0aW9uc1tuYW1lICsgJ1VybCddO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5pY29uKG9wdGlvbnM6IEljb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBpY29uIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXHJcbkwuaWNvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkljb24ob3B0aW9ucyk7XHJcbn07XHJcblxuLypcbiAqIEBtaW5pY2xhc3MgSWNvbi5EZWZhdWx0IChJY29uKVxuICogQGFrYSBMLkljb24uRGVmYXVsdFxuICogQHNlY3Rpb25cbiAqXG4gKiBBIHRyaXZpYWwgc3ViY2xhc3Mgb2YgYEljb25gLCByZXByZXNlbnRzIHRoZSBpY29uIHRvIHVzZSBpbiBgTWFya2VyYHMgd2hlblxuICogbm8gaWNvbiBpcyBzcGVjaWZpZWQuIFBvaW50cyB0byB0aGUgYmx1ZSBtYXJrZXIgaW1hZ2UgZGlzdHJpYnV0ZWQgd2l0aCBMZWFmbGV0XG4gKiByZWxlYXNlcy5cbiAqXG4gKiBJbiBvcmRlciB0byBjaGFuZ2UgdGhlIGRlZmF1bHQgaWNvbiwganVzdCBjaGFuZ2UgdGhlIHByb3BlcnRpZXMgb2YgYEwuSWNvbi5EZWZhdWx0LnByb3RvdHlwZS5vcHRpb25zYFxuICogKHdoaWNoIGlzIGEgc2V0IG9mIGBJY29uIG9wdGlvbnNgKS5cbiAqL1xuXG5MLkljb24uRGVmYXVsdCA9IEwuSWNvbi5leHRlbmQoe1xuXG5cdG9wdGlvbnM6IHtcblx0XHRpY29uVXJsOiAgICAgICAnbWFya2VyLWljb24ucG5nJyxcblx0XHRpY29uUmV0aW5hVXJsOiAnbWFya2VyLWljb24tMngucG5nJyxcblx0XHRzaGFkb3dVcmw6ICAgICAnbWFya2VyLXNoYWRvdy5wbmcnLFxuXHRcdGljb25TaXplOiAgICBbMjUsIDQxXSxcblx0XHRpY29uQW5jaG9yOiAgWzEyLCA0MV0sXG5cdFx0cG9wdXBBbmNob3I6IFsxLCAtMzRdLFxuXHRcdHRvb2x0aXBBbmNob3I6IFsxNiwgLTI4XSxcblx0XHRzaGFkb3dTaXplOiAgWzQxLCA0MV1cblx0fSxcblxuXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAoIUwuSWNvbi5EZWZhdWx0LmltYWdlUGF0aCkge1x0Ly8gRGVwcmVjYXRlZCwgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgb25seVxuXHRcdFx0TC5JY29uLkRlZmF1bHQuaW1hZ2VQYXRoID0gdGhpcy5fZGV0ZWN0SWNvblBhdGgoKTtcblx0XHR9XG5cblx0XHQvLyBAb3B0aW9uIGltYWdlUGF0aDogU3RyaW5nXG5cdFx0Ly8gYEwuSWNvbi5EZWZhdWx0YCB3aWxsIHRyeSB0byBhdXRvLWRldGVjdCB0aGUgYWJzb2x1dGUgbG9jYXRpb24gb2YgdGhlXG5cdFx0Ly8gYmx1ZSBpY29uIGltYWdlcy4gSWYgeW91IGFyZSBwbGFjaW5nIHRoZXNlIGltYWdlcyBpbiBhIG5vbi1zdGFuZGFyZFxuXHRcdC8vIHdheSwgc2V0IHRoaXMgb3B0aW9uIHRvIHBvaW50IHRvIHRoZSByaWdodCBhYnNvbHV0ZSBwYXRoLlxuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLmltYWdlUGF0aCB8fCBMLkljb24uRGVmYXVsdC5pbWFnZVBhdGgpICsgTC5JY29uLnByb3RvdHlwZS5fZ2V0SWNvblVybC5jYWxsKHRoaXMsIG5hbWUpO1xuXHR9LFxuXG5cdF9kZXRlY3RJY29uUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBlbCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICAnbGVhZmxldC1kZWZhdWx0LWljb24tcGF0aCcsIGRvY3VtZW50LmJvZHkpO1xuXHRcdHZhciBwYXRoID0gTC5Eb21VdGlsLmdldFN0eWxlKGVsLCAnYmFja2dyb3VuZC1pbWFnZScpIHx8XG5cdFx0ICAgICAgICAgICBMLkRvbVV0aWwuZ2V0U3R5bGUoZWwsICdiYWNrZ3JvdW5kSW1hZ2UnKTtcdC8vIElFOFxuXG5cdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG5cblx0XHRyZXR1cm4gcGF0aC5pbmRleE9mKCd1cmwnKSA9PT0gMCA/XG5cdFx0XHRwYXRoLnJlcGxhY2UoL151cmxcXChbXFxcIlxcJ10/LywgJycpLnJlcGxhY2UoL21hcmtlci1pY29uXFwucG5nW1xcXCJcXCddP1xcKSQvLCAnJykgOiAnJztcblx0fVxufSk7XG5cbi8qXHJcbiAqIEBjbGFzcyBNYXJrZXJcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqIEBha2EgTC5NYXJrZXJcclxuICogTC5NYXJrZXIgaXMgdXNlZCB0byBkaXNwbGF5IGNsaWNrYWJsZS9kcmFnZ2FibGUgaWNvbnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLm1hcmtlcihbNTAuNSwgMzAuNV0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuTWFya2VyID0gTC5MYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgTWFya2VyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGljb246IEljb24gPSAqXHJcblx0XHQvLyBJY29uIGNsYXNzIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBtYXJrZXIuIFNlZSBbSWNvbiBkb2N1bWVudGF0aW9uXSgjTC5JY29uKSBmb3IgZGV0YWlscyBvbiBob3cgdG8gY3VzdG9taXplIHRoZSBtYXJrZXIgaWNvbi4gSWYgbm90IHNwZWNpZmllZCwgYSBuZXcgYEwuSWNvbi5EZWZhdWx0YCBpcyB1c2VkLlxyXG5cdFx0aWNvbjogbmV3IEwuSWNvbi5EZWZhdWx0KCksXHJcblxyXG5cdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xyXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBkcmFnZ2FibGU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cclxuXHRcdGRyYWdnYWJsZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBjYW4gYmUgdGFiYmVkIHRvIHdpdGggYSBrZXlib2FyZCBhbmQgY2xpY2tlZCBieSBwcmVzc2luZyBlbnRlci5cclxuXHRcdGtleWJvYXJkOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdGl0bGU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYnJvd3NlciB0b29sdGlwIHRoYXQgYXBwZWFyIG9uIG1hcmtlciBob3ZlciAobm8gdG9vbHRpcCBieSBkZWZhdWx0KS5cclxuXHRcdHRpdGxlOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGljb24gaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcblx0XHRhbHQ6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4T2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBCeSBkZWZhdWx0LCBtYXJrZXIgaW1hZ2VzIHpJbmRleCBpcyBzZXQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBpdHMgbGF0aXR1ZGUuIFVzZSB0aGlzIG9wdGlvbiBpZiB5b3Ugd2FudCB0byBwdXQgdGhlIG1hcmtlciBvbiB0b3Agb2YgYWxsIG90aGVycyAob3IgYmVsb3cpLCBzcGVjaWZ5aW5nIGEgaGlnaCB2YWx1ZSBsaWtlIGAxMDAwYCAob3IgaGlnaCBuZWdhdGl2ZSB2YWx1ZSwgcmVzcGVjdGl2ZWx5KS5cclxuXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByaXNlT25Ib3ZlcjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBtYXJrZXIgd2lsbCBnZXQgb24gdG9wIG9mIG90aGVycyB3aGVuIHlvdSBob3ZlciB0aGUgbW91c2Ugb3ZlciBpdC5cclxuXHRcdHJpc2VPbkhvdmVyOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPZmZzZXQ6IE51bWJlciA9IDI1MFxyXG5cdFx0Ly8gVGhlIHotaW5kZXggb2Zmc2V0IHVzZWQgZm9yIHRoZSBgcmlzZU9uSG92ZXJgIGZlYXR1cmUuXHJcblx0XHRyaXNlT2Zmc2V0OiAyNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnbWFya2VyUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgaWNvbiB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogJ21hcmtlclBhbmUnLFxyXG5cclxuXHRcdC8vIEZJWE1FOiBzaGFkb3dQYW5lIGlzIG5vIGxvbmdlciBhIHZhbGlkIG9wdGlvblxyXG5cdFx0bm9uQnViYmxpbmdFdmVudHM6IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ2NvbnRleHRtZW51J11cclxuXHR9LFxyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqXHJcblx0ICogSW4gYWRkaXRpb24gdG8gW3NoYXJlZCBsYXllciBtZXRob2RzXSgjTGF5ZXIpIGxpa2UgYGFkZFRvKClgIGFuZCBgcmVtb3ZlKClgIGFuZCBbcG9wdXAgbWV0aG9kc10oI1BvcHVwKSBsaWtlIGJpbmRQb3B1cCgpIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLl96b29tQW5pbWF0ZWQgJiYgbWFwLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vbignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmICh0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmRyYWdnaW5nLnJlbW92ZUhvb2tzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRtYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHpvb206IHRoaXMudXBkYXRlLFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMudXBkYXRlXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgcG9zaXRpb24gdG8gdGhlIGdpdmVuIHBvaW50LlxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcclxuXHRcdHRoaXMuX2xhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNtYXJrZXItc2V0bGF0bG5nKSBvciBieSBbZHJhZ2dpbmddKCNtYXJrZXItZHJhZ2dpbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7b2xkTGF0TG5nOiBvbGRMYXRMbmcsIGxhdGxuZzogdGhpcy5fbGF0bG5nfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXhPZmZzZXQob2Zmc2V0OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleCBvZmZzZXRdKCNtYXJrZXItemluZGV4b2Zmc2V0KSBvZiB0aGUgbWFya2VyLlxyXG5cdHNldFpJbmRleE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCA9IG9mZnNldDtcclxuXHRcdHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0SWNvbihpY29uOiBJY29uKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG1hcmtlciBpY29uLlxyXG5cdHNldEljb246IGZ1bmN0aW9uIChpY29uKSB7XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLmljb24gPSBpY29uO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5iaW5kUG9wdXAodGhpcy5fcG9wdXAsIHRoaXMuX3BvcHVwLm9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pY29uO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZykucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuXHRcdCAgICBjbGFzc1RvQWRkID0gJ2xlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xyXG5cclxuXHRcdHZhciBpY29uID0gb3B0aW9ucy5pY29uLmNyZWF0ZUljb24odGhpcy5faWNvbiksXHJcblx0XHQgICAgYWRkSWNvbiA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIGlmIHdlJ3JlIG5vdCByZXVzaW5nIHRoZSBpY29uLCByZW1vdmUgdGhlIG9sZCBvbmUgYW5kIGluaXQgbmV3IG9uZVxyXG5cdFx0aWYgKGljb24gIT09IHRoaXMuX2ljb24pIHtcclxuXHRcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YWRkSWNvbiA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy50aXRsZSkge1xyXG5cdFx0XHRcdGljb24udGl0bGUgPSBvcHRpb25zLnRpdGxlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChvcHRpb25zLmFsdCkge1xyXG5cdFx0XHRcdGljb24uYWx0ID0gb3B0aW9ucy5hbHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgY2xhc3NUb0FkZCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMua2V5Ym9hcmQpIHtcclxuXHRcdFx0aWNvbi50YWJJbmRleCA9ICcwJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5ld1NoYWRvdyA9IG9wdGlvbnMuaWNvbi5jcmVhdGVTaGFkb3codGhpcy5fc2hhZG93KSxcclxuXHRcdCAgICBhZGRTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAobmV3U2hhZG93ICE9PSB0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0XHRcdGFkZFNoYWRvdyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdykge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MobmV3U2hhZG93LCBjbGFzc1RvQWRkKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG5ld1NoYWRvdztcclxuXHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRpZiAoYWRkSWNvbikge1xyXG5cdFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2luaXRJbnRlcmFjdGlvbigpO1xyXG5cdFx0aWYgKG5ld1NoYWRvdyAmJiBhZGRTaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKCdzaGFkb3dQYW5lJykuYXBwZW5kQ2hpbGQodGhpcy5fc2hhZG93KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlSWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5faWNvbik7XHJcblx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ljb24pO1xyXG5cclxuXHRcdHRoaXMuX2ljb24gPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfc2V0UG9zOiBmdW5jdGlvbiAocG9zKSB7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5faWNvbiwgcG9zKTtcclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9zaGFkb3csIHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fekluZGV4ID0gcG9zLnkgKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMuX3Jlc2V0WkluZGV4KCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0dGhpcy5faWNvbi5zdHlsZS56SW5kZXggPSB0aGlzLl96SW5kZXggKyBvZmZzZXQ7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAob3B0KSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBvcHQuem9vbSwgb3B0LmNlbnRlcikucm91bmQoKTtcclxuXHJcblx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEludGVyYWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2ljb24sICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblxyXG5cdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHRpZiAoTC5IYW5kbGVyLk1hcmtlckRyYWcpIHtcclxuXHRcdFx0dmFyIGRyYWdnYWJsZSA9IHRoaXMub3B0aW9ucy5kcmFnZ2FibGU7XHJcblx0XHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcblx0XHRcdFx0ZHJhZ2dhYmxlID0gdGhpcy5kcmFnZ2luZy5lbmFibGVkKCk7XHJcblx0XHRcdFx0dGhpcy5kcmFnZ2luZy5kaXNhYmxlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBuZXcgTC5IYW5kbGVyLk1hcmtlckRyYWcodGhpcyk7XHJcblxyXG5cdFx0XHRpZiAoZHJhZ2dhYmxlKSB7XHJcblx0XHRcdFx0dGhpcy5kcmFnZ2luZy5lbmFibGUoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG9wYWNpdHkgPSB0aGlzLm9wdGlvbnMub3BhY2l0eTtcclxuXHJcblx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9pY29uLCBvcGFjaXR5KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX3NoYWRvdywgb3BhY2l0eSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgwKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcblxyXG4vLyBAZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgTWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuTC5tYXJrZXIgPSBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLk1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xyXG59O1xyXG5cbi8qXG4gKiBAY2xhc3MgRGl2SWNvblxuICogQGFrYSBMLkRpdkljb25cbiAqIEBpbmhlcml0cyBJY29uXG4gKlxuICogUmVwcmVzZW50cyBhIGxpZ2h0d2VpZ2h0IGljb24gZm9yIG1hcmtlcnMgdGhhdCB1c2VzIGEgc2ltcGxlIGA8ZGl2PmBcbiAqIGVsZW1lbnQgaW5zdGVhZCBvZiBhbiBpbWFnZS4gSW5oZXJpdHMgZnJvbSBgSWNvbmAgYnV0IGlnbm9yZXMgdGhlIGBpY29uVXJsYCBhbmQgc2hhZG93IG9wdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiB2YXIgbXlJY29uID0gTC5kaXZJY29uKHtjbGFzc05hbWU6ICdteS1kaXYtaWNvbid9KTtcbiAqIC8vIHlvdSBjYW4gc2V0IC5teS1kaXYtaWNvbiBzdHlsZXMgaW4gQ1NTXG4gKlxuICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICpcbiAqIEJ5IGRlZmF1bHQsIGl0IGhhcyBhICdsZWFmbGV0LWRpdi1pY29uJyBDU1MgY2xhc3MgYW5kIGlzIHN0eWxlZCBhcyBhIGxpdHRsZSB3aGl0ZSBzcXVhcmUgd2l0aCBhIHNoYWRvdy5cbiAqL1xuXG5MLkRpdkljb24gPSBMLkljb24uZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBEaXZJY29uIG9wdGlvbnNcblx0XHRpY29uU2l6ZTogWzEyLCAxMl0sIC8vIGFsc28gY2FuIGJlIHNldCB0aHJvdWdoIENTU1xuXG5cdFx0Ly8gaWNvbkFuY2hvcjogKFBvaW50KSxcblx0XHQvLyBwb3B1cEFuY2hvcjogKFBvaW50KSxcblxuXHRcdC8vIEBvcHRpb24gaHRtbDogU3RyaW5nID0gJydcblx0XHQvLyBDdXN0b20gSFRNTCBjb2RlIHRvIHB1dCBpbnNpZGUgdGhlIGRpdiBlbGVtZW50LCBlbXB0eSBieSBkZWZhdWx0LlxuXHRcdGh0bWw6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBiZ1BvczogUG9pbnQgPSBbMCwgMF1cblx0XHQvLyBPcHRpb25hbCByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgYmFja2dyb3VuZCwgaW4gcGl4ZWxzXG5cdFx0YmdQb3M6IG51bGwsXG5cblx0XHRjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uJ1xuXHR9LFxuXG5cdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XG5cdFx0dmFyIGRpdiA9IChvbGRJY29uICYmIG9sZEljb24udGFnTmFtZSA9PT0gJ0RJVicpID8gb2xkSWNvbiA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0ZGl2LmlubmVySFRNTCA9IG9wdGlvbnMuaHRtbCAhPT0gZmFsc2UgPyBvcHRpb25zLmh0bWwgOiAnJztcblxuXHRcdGlmIChvcHRpb25zLmJnUG9zKSB7XG5cdFx0XHR2YXIgYmdQb3MgPSBMLnBvaW50KG9wdGlvbnMuYmdQb3MpO1xuXHRcdFx0ZGl2LnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9ICgtYmdQb3MueCkgKyAncHggJyArICgtYmdQb3MueSkgKyAncHgnO1xuXHRcdH1cblx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGRpdiwgJ2ljb24nKTtcblxuXHRcdHJldHVybiBkaXY7XG5cdH0sXG5cblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmRpdkljb24ob3B0aW9uczogRGl2SWNvbiBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIGBEaXZJY29uYCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuTC5kaXZJY29uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLkRpdkljb24ob3B0aW9ucyk7XG59O1xuXG4vKlxyXG4gKiBAY2xhc3MgRGl2T3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcclxuICogQGFrYSBMLkRpdk92ZXJsYXlcclxuICogQmFzZSBtb2RlbCBmb3IgTC5Qb3B1cCBhbmQgTC5Ub29sdGlwLiBJbmhlcml0IGZyb20gaXQgZm9yIGN1c3RvbSBwb3B1cCBsaWtlIHBsdWdpbnMuXHJcbiAqL1xyXG5cclxuLy8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcbkwuRGl2T3ZlcmxheSA9IEwuTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIERpdk92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDcpXHJcblx0XHQvLyBUaGUgb2Zmc2V0IG9mIHRoZSBwb3B1cCBwb3NpdGlvbi4gVXNlZnVsIHRvIGNvbnRyb2wgdGhlIGFuY2hvclxyXG5cdFx0Ly8gb2YgdGhlIHBvcHVwIHdoZW4gb3BlbmluZyBpdCBvbiBzb21lIG92ZXJsYXlzLlxyXG5cdFx0b2Zmc2V0OiBbMCwgN10sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHBvcHVwLlxyXG5cdFx0Y2xhc3NOYW1lOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdwb3B1cFBhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBwb3B1cCB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogJ3BvcHVwUGFuZSdcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3JlbW92ZVRpbWVvdXQpO1xyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5icmluZ1RvRnJvbnQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KEwuYmluZChMLkRvbVV0aWwucmVtb3ZlLCBMLkRvbVV0aWwsIHRoaXMuX2NvbnRhaW5lciksIDIwMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgb2YgcG9wdXAuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBvcGVuLlxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHRcdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwLlxyXG5cdGdldENvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Q29udGVudChodG1sQ29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgcG9wdXAuIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzb3VyY2UgbGF5ZXIgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAgdG8gYmUgdXNlZCBpbiB0aGUgcG9wdXAuXHJcblx0c2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gQWxpYXMgZm9yIFtnZXRDb250ZW50KCldKCNwb3B1cC1nZXRjb250ZW50KVxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1cGRhdGU6IG51bGxcclxuXHQvLyBVcGRhdGVzIHRoZSBwb3B1cCBjb250ZW50LCBsYXlvdXQgYW5kIHBvc2l0aW9uLiBVc2VmdWwgZm9yIHVwZGF0aW5nIHRoZSBwb3B1cCBhZnRlciBzb21ldGhpbmcgaW5zaWRlIGNoYW5nZWQsIGUuZy4gaW1hZ2UgbG9hZGVkLlxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcblx0XHR0aGlzLl91cGRhdGVDb250ZW50KCk7XHJcblx0XHR0aGlzLl91cGRhdGVMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcclxuXHJcblx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHpvb206IHRoaXMuX3VwZGF0ZVBvc2l0aW9uLFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3VwZGF0ZVBvc2l0aW9uXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNPcGVuOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgcG9wdXAgaXMgdmlzaWJsZSBvbiB0aGUgbWFwLlxyXG5cdGlzT3BlbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGlzIHBvcHVwIGluIGZyb250IG9mIG90aGVyIHBvcHVwcyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHRMLkRvbVV0aWwudG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGlzIHBvcHVwIHRvIHRoZSBiYWNrIG9mIG90aGVyIHBvcHVwcyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdEwuRG9tVXRpbC50b0JhY2sodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRlbnQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIG5vZGUgPSB0aGlzLl9jb250ZW50Tm9kZTtcclxuXHRcdHZhciBjb250ZW50ID0gKHR5cGVvZiB0aGlzLl9jb250ZW50ID09PSAnZnVuY3Rpb24nKSA/IHRoaXMuX2NvbnRlbnQodGhpcy5fc291cmNlIHx8IHRoaXMpIDogdGhpcy5fY29udGVudDtcclxuXHJcblx0XHRpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG5vZGUuaW5uZXJIVE1MID0gY29udGVudDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHdoaWxlIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xyXG5cdFx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRub2RlLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5maXJlKCdjb250ZW50dXBkYXRlJyk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxyXG5cdFx0ICAgIG9mZnNldCA9IEwucG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCksXHJcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2Zmc2V0ID0gb2Zmc2V0LmFkZChwb3MpLmFkZChhbmNob3IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBib3R0b20gPSB0aGlzLl9jb250YWluZXJCb3R0b20gPSAtb2Zmc2V0LnksXHJcblx0XHQgICAgbGVmdCA9IHRoaXMuX2NvbnRhaW5lckxlZnQgPSAtTWF0aC5yb3VuZCh0aGlzLl9jb250YWluZXJXaWR0aCAvIDIpICsgb2Zmc2V0Lng7XHJcblxyXG5cdFx0Ly8gYm90dG9tIHBvc2l0aW9uIHRoZSBwb3B1cCBpbiBjYXNlIHRoZSBoZWlnaHQgb2YgdGhlIHBvcHVwIGNoYW5nZXMgKGltYWdlcyBsb2FkaW5nIGV0YylcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5ib3R0b20gPSBib3R0b20gKyAncHgnO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gWzAsIDBdO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cbi8qXHJcbiAqIEBjbGFzcyBQb3B1cFxyXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxyXG4gKiBAYWthIEwuUG9wdXBcclxuICogVXNlZCB0byBvcGVuIHBvcHVwcyBpbiBjZXJ0YWluIHBsYWNlcyBvZiB0aGUgbWFwLiBVc2UgW01hcC5vcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSB0b1xyXG4gKiBvcGVuIHBvcHVwcyB3aGlsZSBtYWtpbmcgc3VyZSB0aGF0IG9ubHkgb25lIHBvcHVwIGlzIG9wZW4gYXQgb25lIHRpbWVcclxuICogKHJlY29tbWVuZGVkIGZvciB1c2FiaWxpdHkpLCBvciB1c2UgW01hcC5hZGRMYXllcl0oI21hcC1hZGRsYXllcikgdG8gb3BlbiBhcyBtYW55IGFzIHlvdSB3YW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSBwb3B1cCB0byBtYXJrZXIgY2xpY2sgYW5kIHRoZW4gb3BlbiBpdCwgaXQncyByZWFsbHkgZWFzeTpcclxuICpcclxuICogYGBganNcclxuICogbWFya2VyLmJpbmRQb3B1cChwb3B1cENvbnRlbnQpLm9wZW5Qb3B1cCgpO1xyXG4gKiBgYGBcclxuICogUGF0aCBvdmVybGF5cyBsaWtlIHBvbHlsaW5lcyBhbHNvIGhhdmUgYSBgYmluZFBvcHVwYCBtZXRob2QuXHJcbiAqIEhlcmUncyBhIG1vcmUgY29tcGxpY2F0ZWQgd2F5IHRvIG9wZW4gYSBwb3B1cCBvbiBhIG1hcDpcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvcHVwID0gTC5wb3B1cCgpXHJcbiAqIFx0LnNldExhdExuZyhsYXRsbmcpXHJcbiAqIFx0LnNldENvbnRlbnQoJzxwPkhlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHBvcHVwLjwvcD4nKVxyXG4gKiBcdC5vcGVuT24obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9wdXBcclxuTC5Qb3B1cCA9IEwuRGl2T3ZlcmxheS5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgUG9wdXAgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDMwMFxyXG5cdFx0Ly8gTWF4IHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG5cdFx0bWF4V2lkdGg6IDMwMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1pbldpZHRoOiBOdW1iZXIgPSA1MFxyXG5cdFx0Ly8gTWluIHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG5cdFx0bWluV2lkdGg6IDUwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4SGVpZ2h0OiBOdW1iZXIgPSBudWxsXHJcblx0XHQvLyBJZiBzZXQsIGNyZWF0ZXMgYSBzY3JvbGxhYmxlIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gaGVpZ2h0XHJcblx0XHQvLyBpbnNpZGUgYSBwb3B1cCBpZiBpdHMgY29udGVudCBleGNlZWRzIGl0LlxyXG5cdFx0bWF4SGVpZ2h0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gZG8gcGFubmluZyBhbmltYXRpb25cclxuXHRcdC8vIHRvIGZpdCB0aGUgb3BlbmVkIHBvcHVwLlxyXG5cdFx0YXV0b1BhbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogUG9pbnQgPSBudWxsXHJcblx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBtYXBcclxuXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IFBvaW50ID0gbnVsbFxyXG5cdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIG1hcFxyXG5cdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG5cdFx0YXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUsIDUpXHJcblx0XHQvLyBFcXVpdmFsZW50IG9mIHNldHRpbmcgYm90aCB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGF1dG9wYW4gcGFkZGluZyB0byB0aGUgc2FtZSB2YWx1ZS5cclxuXHRcdGF1dG9QYW5QYWRkaW5nOiBbNSwgNV0sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZWVwSW5WaWV3OiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFNldCBpdCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gcHJldmVudCB1c2VycyBmcm9tIHBhbm5pbmcgdGhlIHBvcHVwXHJcblx0XHQvLyBvZmYgb2YgdGhlIHNjcmVlbiB3aGlsZSBpdCBpcyBvcGVuLlxyXG5cdFx0a2VlcEluVmlldzogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZUJ1dHRvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIENvbnRyb2xzIHRoZSBwcmVzZW5jZSBvZiBhIGNsb3NlIGJ1dHRvbiBpbiB0aGUgcG9wdXAuXHJcblx0XHRjbG9zZUJ1dHRvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9DbG9zZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcblx0XHQvLyB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIHVzZXIgY2xpY2tzIHRoZSBtYXAgKHNldCBnbG9iYWxseSBieVxyXG5cdFx0Ly8gdGhlIE1hcCdzIFtjbG9zZVBvcHVwT25DbGlja10oI21hcC1jbG9zZXBvcHVwb25jbGljaykgb3B0aW9uKS5cclxuXHRcdGF1dG9DbG9zZTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcblx0XHRjbGFzc05hbWU6ICcnXHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG5cdC8vIEBtZXRob2Qgb3Blbk9uKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIHBvcHVwIHRvIHRoZSBtYXAgYW5kIGNsb3NlcyB0aGUgcHJldmlvdXMgb25lLiBUaGUgc2FtZSBhcyBgbWFwLm9wZW5Qb3B1cChwb3B1cClgLlxyXG5cdG9wZW5PbjogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9wZW5Qb3B1cCh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRMLkRpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaXMgb3BlbmVkIGluIHRoZSBtYXBcclxuXHRcdG1hcC5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkXHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0Ly8gRm9yIG5vbi1wYXRoIGxheWVycywgd2UgdG9nZ2xlIHRoZSBwb3B1cCB3aGVuIGNsaWNraW5nXHJcblx0XHRcdC8vIGFnYWluIHRoZSBsYXllciwgc28gcHJldmVudCB0aGUgbWFwIHRvIHJlb3BlbiBpdC5cclxuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgTC5QYXRoKSkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5vbigncHJlY2xpY2snLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0TC5EaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpbiB0aGUgbWFwIGlzIGNsb3NlZFxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBMLlBhdGgpKSB7XHJcblx0XHRcdFx0dGhpcy5fc291cmNlLm9mZigncHJlY2xpY2snLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSBMLkRpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xyXG5cclxuXHRcdGlmICgnY2xvc2VPbkNsaWNrJyBpbiB0aGlzLm9wdGlvbnMgPyB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIDogdGhpcy5fbWFwLm9wdGlvbnMuY2xvc2VQb3B1cE9uQ2xpY2spIHtcclxuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5fY2xvc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcblx0XHRcdGV2ZW50cy5tb3ZlZW5kID0gdGhpcy5fYWRqdXN0UGFuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0X2Nsb3NlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5jbG9zZVBvcHVwKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtcG9wdXAnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsXHJcblx0XHRcdHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArXHJcblx0XHRcdCcgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xyXG5cdFx0XHR2YXIgY2xvc2VCdXR0b24gPSB0aGlzLl9jbG9zZUJ1dHRvbiA9IEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCBwcmVmaXggKyAnLWNsb3NlLWJ1dHRvbicsIGNvbnRhaW5lcik7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmhyZWYgPSAnI2Nsb3NlJztcclxuXHRcdFx0Y2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJyYjMjE1Oyc7XHJcblxyXG5cdFx0XHRMLkRvbUV2ZW50Lm9uKGNsb3NlQnV0dG9uLCAnY2xpY2snLCB0aGlzLl9vbkNsb3NlQnV0dG9uQ2xpY2ssIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB3cmFwcGVyID0gdGhpcy5fd3JhcHBlciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctY29udGVudC13cmFwcGVyJywgY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50Jywgd3JhcHBlcik7XHJcblxyXG5cdFx0TC5Eb21FdmVudFxyXG5cdFx0XHQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24od3JhcHBlcilcclxuXHRcdFx0LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbih0aGlzLl9jb250ZW50Tm9kZSlcclxuXHRcdFx0Lm9uKHdyYXBwZXIsICdjb250ZXh0bWVudScsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHJcblx0XHR0aGlzLl90aXBDb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLXRpcC1jb250YWluZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fdGlwID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAnLCB0aGlzLl90aXBDb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250ZW50Tm9kZSxcclxuXHRcdCAgICBzdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICcnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xyXG5cclxuXHRcdHZhciB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHRcdHdpZHRoID0gTWF0aC5taW4od2lkdGgsIHRoaXMub3B0aW9ucy5tYXhXaWR0aCk7XHJcblx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCB0aGlzLm9wdGlvbnMubWluV2lkdGgpO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gKHdpZHRoICsgMSkgKyAncHgnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICcnO1xyXG5cclxuXHRcdHN0eWxlLmhlaWdodCA9ICcnO1xyXG5cclxuXHRcdHZhciBoZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxyXG5cdFx0ICAgIG1heEhlaWdodCA9IHRoaXMub3B0aW9ucy5tYXhIZWlnaHQsXHJcblx0XHQgICAgc2Nyb2xsZWRDbGFzcyA9ICdsZWFmbGV0LXBvcHVwLXNjcm9sbGVkJztcclxuXHJcblx0XHRpZiAobWF4SGVpZ2h0ICYmIGhlaWdodCA+IG1heEhlaWdodCkge1xyXG5cdFx0XHRzdHlsZS5oZWlnaHQgPSBtYXhIZWlnaHQgKyAncHgnO1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpLFxyXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5hdXRvUGFuIHx8ICh0aGlzLl9tYXAuX3BhbkFuaW0gJiYgdGhpcy5fbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIG1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KEwuRG9tVXRpbC5nZXRTdHlsZSh0aGlzLl9jb250YWluZXIsICdtYXJnaW5Cb3R0b20nKSwgMTApIHx8IDAsXHJcblx0XHQgICAgY29udGFpbmVySGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCArIG1hcmdpbkJvdHRvbSxcclxuXHRcdCAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxyXG5cdFx0ICAgIGxheWVyUG9zID0gbmV3IEwuUG9pbnQodGhpcy5fY29udGFpbmVyTGVmdCwgLWNvbnRhaW5lckhlaWdodCAtIHRoaXMuX2NvbnRhaW5lckJvdHRvbSk7XHJcblxyXG5cdFx0bGF5ZXJQb3MuX2FkZChMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSk7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lclBvcyA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChsYXllclBvcyksXHJcblx0XHQgICAgcGFkZGluZyA9IEwucG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nVEwgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ1RvcExlZnQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gTC5wb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBzaXplID0gbWFwLmdldFNpemUoKSxcclxuXHRcdCAgICBkeCA9IDAsXHJcblx0XHQgICAgZHkgPSAwO1xyXG5cclxuXHRcdGlmIChjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoICsgcGFkZGluZ0JSLnggPiBzaXplLngpIHsgLy8gcmlnaHRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoIC0gc2l6ZS54ICsgcGFkZGluZ0JSLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggLSBkeCAtIHBhZGRpbmdUTC54IDwgMCkgeyAvLyBsZWZ0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggLSBwYWRkaW5nVEwueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCArIHBhZGRpbmdCUi55ID4gc2l6ZS55KSB7IC8vIGJvdHRvbVxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0IC0gc2l6ZS55ICsgcGFkZGluZ0JSLnk7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgLSBkeSAtIHBhZGRpbmdUTC55IDwgMCkgeyAvLyB0b3BcclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSAtIHBhZGRpbmdUTC55O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBhdXRvcGFuc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgc3RhcnRzIGF1dG9wYW5uaW5nIHdoZW4gb3BlbmluZyBhIHBvcHVwLlxyXG5cdFx0aWYgKGR4IHx8IGR5KSB7XHJcblx0XHRcdG1hcFxyXG5cdFx0XHQgICAgLmZpcmUoJ2F1dG9wYW5zdGFydCcpXHJcblx0XHRcdCAgICAucGFuQnkoW2R4LCBkeV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vbkNsb3NlQnV0dG9uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9jbG9zZSgpO1xyXG5cdFx0TC5Eb21FdmVudC5zdG9wKGUpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHBvcHVwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XHJcblx0XHRyZXR1cm4gTC5wb2ludCh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvciA/IHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IoKSA6IFswLCAwXSk7XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvcHVwXHJcbi8vIEBmYWN0b3J5IEwucG9wdXAob3B0aW9ucz86IFBvcHVwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBgUG9wdXBgIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHBvcHVwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cclxuTC5wb3B1cCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRyZXR1cm4gbmV3IEwuUG9wdXAob3B0aW9ucywgc291cmNlKTtcclxufTtcclxuXHJcblxyXG4vKiBAbmFtZXNwYWNlIE1hcFxyXG4gKiBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcbiAqIEBvcHRpb24gY2xvc2VQb3B1cE9uQ2xpY2s6IEJvb2xlYW4gPSB0cnVlXHJcbiAqIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHBvcHVwcyB0byBjbG9zZSB3aGVuIHVzZXIgY2xpY2tzIHRoZSBtYXAuXHJcbiAqL1xyXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGNsb3NlUG9wdXBPbkNsaWNrOiB0cnVlXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuTC5NYXAuaW5jbHVkZSh7XHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAocG9wdXA6IFBvcHVwKTogdGhpc1xyXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgcG9wdXAgd2hpbGUgY2xvc2luZyB0aGUgcHJldmlvdXNseSBvcGVuZWQgKHRvIG1ha2Ugc3VyZSBvbmx5IG9uZSBpcyBvcGVuZWQgYXQgb25lIHRpbWUgZm9yIHVzYWJpbGl0eSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQ3JlYXRlcyBhIHBvcHVwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVucyBpdCBpbiB0aGUgZ2l2ZW4gcG9pbnQgb24gYSBtYXAuXHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAocG9wdXAsIGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0aWYgKCEocG9wdXAgaW5zdGFuY2VvZiBMLlBvcHVwKSkge1xyXG5cdFx0XHRwb3B1cCA9IG5ldyBMLlBvcHVwKG9wdGlvbnMpLnNldENvbnRlbnQocG9wdXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXRsbmcpIHtcclxuXHRcdFx0cG9wdXAuc2V0TGF0TG5nKGxhdGxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIocG9wdXApKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9wb3B1cC5vcHRpb25zLmF1dG9DbG9zZSkge1xyXG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9wb3B1cCA9IHBvcHVwO1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIocG9wdXApO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cChwb3B1cD86IFBvcHVwKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBvcGVuZWQgd2l0aCBbb3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgKG9yIHRoZSBnaXZlbiBvbmUpLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG5cdFx0aWYgKCFwb3B1cCB8fCBwb3B1cCA9PT0gdGhpcy5fcG9wdXApIHtcclxuXHRcdFx0cG9wdXAgPSB0aGlzLl9wb3B1cDtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHBvcHVwKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIocG9wdXApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXG4vKlxuICogQG5hbWVzcGFjZSBMYXllclxuICogQHNlY3Rpb24gUG9wdXAgbWV0aG9kcyBleGFtcGxlXG4gKlxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgcG9wdXBzIHRvIGl0LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFBvcHVwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xuICogbGF5ZXIub3BlblBvcHVwKCk7XG4gKiBsYXllci5jbG9zZVBvcHVwKCk7XG4gKiBgYGBcbiAqXG4gKiBQb3B1cHMgd2lsbCBhbHNvIGJlIGF1dG9tYXRpY2FsbHkgb3BlbmVkIHdoZW4gdGhlIGxheWVyIGlzIGNsaWNrZWQgb24gYW5kIGNsb3NlZCB3aGVuIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcCBvciBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cbiAqL1xuXG4vLyBAc2VjdGlvbiBQb3B1cCBtZXRob2RzXG5MLkxheWVyLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2QgYmluZFBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxQb3B1cCwgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIEJpbmRzIGEgcG9wdXAgdG8gdGhlIGxheWVyIHdpdGggdGhlIHBhc3NlZCBgY29udGVudGAgYW5kIHNldHMgdXAgdGhlXG5cdC8vIG5lY2Nlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxuXHQvLyB0aGUgbGF5ZXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC5cblx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuXG5cdFx0aWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBMLlBvcHVwKSB7XG5cdFx0XHRMLnNldE9wdGlvbnMoY29udGVudCwgb3B0aW9ucyk7XG5cdFx0XHR0aGlzLl9wb3B1cCA9IGNvbnRlbnQ7XG5cdFx0XHRjb250ZW50Ll9zb3VyY2UgPSB0aGlzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIXRoaXMuX3BvcHVwIHx8IG9wdGlvbnMpIHtcblx0XHRcdFx0dGhpcy5fcG9wdXAgPSBuZXcgTC5Qb3B1cChvcHRpb25zLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQpIHtcblx0XHRcdHRoaXMub24oe1xuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxuXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcblx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB1bmJpbmRQb3B1cCgpOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFBvcHVwYC5cblx0dW5iaW5kUG9wdXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcblx0XHRcdHRoaXMub2ZmKHtcblx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcblx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAobGF0bG5nPzogTGF0TG5nKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgYm91bmQgcG9wdXAgYXQgdGhlIHNwZWNpZmljZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgcG9wdXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cblx0b3BlblBvcHVwOiBmdW5jdGlvbiAobGF5ZXIsIGxhdGxuZykge1xuXHRcdGlmICghKGxheWVyIGluc3RhbmNlb2YgTC5MYXllcikpIHtcblx0XHRcdGxhdGxuZyA9IGxheWVyO1xuXHRcdFx0bGF5ZXIgPSB0aGlzO1xuXHRcdH1cblxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuRmVhdHVyZUdyb3VwKSB7XG5cdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIWxhdGxuZykge1xuXHRcdFx0bGF0bG5nID0gbGF5ZXIuZ2V0Q2VudGVyID8gbGF5ZXIuZ2V0Q2VudGVyKCkgOiBsYXllci5nZXRMYXRMbmcoKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fcG9wdXAgJiYgdGhpcy5fbWFwKSB7XG5cdFx0XHQvLyBzZXQgcG9wdXAgc291cmNlIHRvIHRoaXMgbGF5ZXJcblx0XHRcdHRoaXMuX3BvcHVwLl9zb3VyY2UgPSBsYXllcjtcblxuXHRcdFx0Ly8gdXBkYXRlIHRoZSBwb3B1cCAoY29udGVudCwgbGF5b3V0LCBlY3QuLi4pXG5cdFx0XHR0aGlzLl9wb3B1cC51cGRhdGUoKTtcblxuXHRcdFx0Ly8gb3BlbiB0aGUgcG9wdXAgb24gdGhlIG1hcFxuXHRcdFx0dGhpcy5fbWFwLm9wZW5Qb3B1cCh0aGlzLl9wb3B1cCwgbGF0bG5nKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3NlUG9wdXAoKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xuXHRcdFx0dGhpcy5fcG9wdXAuX2Nsb3NlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdG9nZ2xlUG9wdXAoKTogdGhpc1xuXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxuXHR0b2dnbGVQb3B1cDogZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xuXHRcdFx0aWYgKHRoaXMuX3BvcHVwLl9tYXApIHtcblx0XHRcdFx0dGhpcy5jbG9zZVBvcHVwKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm9wZW5Qb3B1cCh0YXJnZXQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzUG9wdXBPcGVuKCk6IGJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXG5cdGlzUG9wdXBPcGVuOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BvcHVwLmlzT3BlbigpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UG9wdXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxQb3B1cCk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0c2V0UG9wdXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRQb3B1cCgpOiBQb3B1cFxuXHQvLyBSZXR1cm5zIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRnZXRQb3B1cDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9wb3B1cDtcblx0fSxcblxuXHRfb3BlblBvcHVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XG5cblx0XHRpZiAoIXRoaXMuX3BvcHVwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBwcmV2ZW50IG1hcCBjbGlja1xuXHRcdEwuRG9tRXZlbnQuc3RvcChlKTtcblxuXHRcdC8vIGlmIHRoaXMgaW5oZXJpdHMgZnJvbSBQYXRoIGl0cyBhIHZlY3RvciBhbmQgd2UgY2FuIGp1c3Rcblx0XHQvLyBvcGVuIHRoZSBwb3B1cCBhdCB0aGUgbmV3IGxvY2F0aW9uXG5cdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5QYXRoKSB7XG5cdFx0XHR0aGlzLm9wZW5Qb3B1cChlLmxheWVyIHx8IGUudGFyZ2V0LCBlLmxhdGxuZyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gb3RoZXJ3aXNlIHRyZWF0IGl0IGxpa2UgYSBtYXJrZXIgYW5kIGZpZ3VyZSBvdXRcblx0XHQvLyBpZiB3ZSBzaG91bGQgdG9nZ2xlIGl0IG9wZW4vY2xvc2VkXG5cdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcih0aGlzLl9wb3B1cCkgJiYgdGhpcy5fcG9wdXAuX3NvdXJjZSA9PT0gbGF5ZXIpIHtcblx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm9wZW5Qb3B1cChsYXllciwgZS5sYXRsbmcpO1xuXHRcdH1cblx0fSxcblxuXHRfbW92ZVBvcHVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMuX3BvcHVwLnNldExhdExuZyhlLmxhdGxuZyk7XG5cdH1cbn0pO1xuXG4vKlxyXG4gKiBQb3B1cCBleHRlbnNpb24gdG8gTC5NYXJrZXIsIGFkZGluZyBwb3B1cC1yZWxhdGVkIG1ldGhvZHMuXHJcbiAqL1xyXG5cclxuTC5NYXJrZXIuaW5jbHVkZSh7XHJcblx0X2dldFBvcHVwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy5wb3B1cEFuY2hvciB8fCBbMCwgMF07XHJcblx0fVxyXG59KTtcclxuXG4vKlxuICogQGNsYXNzIFRvb2x0aXBcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XG4gKiBAYWthIEwuVG9vbHRpcFxuICogVXNlZCB0byBkaXNwbGF5IHNtYWxsIHRleHRzIG9uIHRvcCBvZiBtYXAgbGF5ZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIG1hcmtlci5iaW5kVG9vbHRpcChcIm15IHRvb2x0aXAgdGV4dFwiKS5vcGVuVG9vbHRpcCgpO1xuICogYGBgXG4gKiBOb3RlIGFib3V0IHRvb2x0aXAgb2Zmc2V0LiBMZWFmbGV0IHRha2VzIHR3byBvcHRpb25zIGluIGNvbnNpZGVyYXRpb25cbiAqIGZvciBjb21wdXRpbmcgdG9vbHRpcCBvZmZzZXRpbmc6XG4gKiAtIHRoZSBgb2Zmc2V0YCBUb29sdGlwIG9wdGlvbjogaXQgZGVmYXVsdHMgdG8gWzAsIDBdLCBhbmQgaXQncyBzcGVjaWZpYyB0byBvbmUgdG9vbHRpcC5cbiAqICAgQWRkIGEgcG9zaXRpdmUgeCBvZmZzZXQgdG8gbW92ZSB0aGUgdG9vbHRpcCB0byB0aGUgcmlnaHQsIGFuZCBhIHBvc2l0aXZlIHkgb2Zmc2V0IHRvXG4gKiAgIG1vdmUgaXQgdG8gdGhlIGJvdHRvbS4gTmVnYXRpdmVzIHdpbGwgbW92ZSB0byB0aGUgbGVmdCBhbmQgdG9wLlxuICogLSB0aGUgYHRvb2x0aXBBbmNob3JgIEljb24gb3B0aW9uOiB0aGlzIHdpbGwgb25seSBiZSBjb25zaWRlcmVkIGZvciBNYXJrZXIuIFlvdVxuICogICBzaG91bGQgYWRhcHQgdGhpcyB2YWx1ZSBpZiB5b3UgdXNlIGEgY3VzdG9tIGljb24uXG4gKi9cblxuXG4vLyBAbmFtZXNwYWNlIFRvb2x0aXBcbkwuVG9vbHRpcCA9IEwuRGl2T3ZlcmxheS5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgVG9vbHRpcCBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0b29sdGlwUGFuZSdcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSB0b29sdGlwIHdpbGwgYmUgYWRkZWQuXG5cdFx0cGFuZTogJ3Rvb2x0aXBQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDApXG5cdFx0Ly8gT3B0aW9uYWwgb2Zmc2V0IG9mIHRoZSB0b29sdGlwIHBvc2l0aW9uLlxuXHRcdG9mZnNldDogWzAsIDBdLFxuXG5cdFx0Ly8gQG9wdGlvbiBkaXJlY3Rpb246IFN0cmluZyA9ICdhdXRvJ1xuXHRcdC8vIERpcmVjdGlvbiB3aGVyZSB0byBvcGVuIHRoZSB0b29sdGlwLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOiBgcmlnaHRgLCBgbGVmdGAsXG5cdFx0Ly8gYHRvcGAsIGBib3R0b21gLCBgY2VudGVyYCwgYGF1dG9gLlxuXHRcdC8vIGBhdXRvYCB3aWxsIGR5bmFtaWNhbHkgc3dpdGNoIGJldHdlZW4gYHJpZ2h0YCBhbmQgYGxlZnRgIGFjY29yZGluZyB0byB0aGUgdG9vbHRpcFxuXHRcdC8vIHBvc2l0aW9uIG9uIHRoZSBtYXAuXG5cdFx0ZGlyZWN0aW9uOiAnYXV0bycsXG5cblx0XHQvLyBAb3B0aW9uIHBlcm1hbmVudDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0byBvcGVuIHRoZSB0b29sdGlwIHBlcm1hbmVudGx5IG9yIG9ubHkgb24gbW91c2VvdmVyLlxuXHRcdHBlcm1hbmVudDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIHN0aWNreTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHRvb2x0aXAgd2lsbCBmb2xsb3cgdGhlIG1vdXNlIGluc3RlYWQgb2YgYmVpbmcgZml4ZWQgYXQgdGhlIGZlYXR1cmUgY2VudGVyLlxuXHRcdHN0aWNreTogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGxpc3RlbiB0byB0aGUgZmVhdHVyZSBldmVudHMuXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAwLjlcblx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBvcGFjaXR5LlxuXHRcdG9wYWNpdHk6IDAuOVxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0TC5EaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG5cdFx0dGhpcy5zZXRPcGFjaXR5KHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGlzIG9wZW5lZCBpbiB0aGUgbWFwLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSk7XG5cblx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG5cdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkLlxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRMLkRpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpbiB0aGUgbWFwIGlzIGNsb3NlZC5cblx0XHRtYXAuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcblx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY2xvc2VkLlxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBMLkRpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKEwuQnJvd3Nlci50b3VjaCAmJiAhdGhpcy5vcHRpb25zLnBlcm1hbmVudCkge1xuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5fY2xvc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfY2xvc2U6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9tYXAuY2xvc2VUb29sdGlwKHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC10b29sdGlwJyxcblx0XHQgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICsgJyBsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcblxuXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gdGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKTtcblx0fSxcblxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7fSxcblxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7fSxcblxuXHRfc2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3MpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIGNlbnRlclBvaW50ID0gbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobWFwLmdldENlbnRlcigpKSxcblx0XHQgICAgdG9vbHRpcFBvaW50ID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvcyksXG5cdFx0ICAgIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb24sXG5cdFx0ICAgIHRvb2x0aXBXaWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aCxcblx0XHQgICAgdG9vbHRpcEhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXG5cdFx0ICAgIG9mZnNldCA9IEwucG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCksXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xuXG5cdFx0aWYgKGRpcmVjdGlvbiA9PT0gJ3RvcCcpIHtcblx0XHRcdHBvcyA9IHBvcy5hZGQoTC5wb2ludCgtdG9vbHRpcFdpZHRoIC8gMiArIG9mZnNldC54LCAtdG9vbHRpcEhlaWdodCArIG9mZnNldC55ICsgYW5jaG9yLnkpKTtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdHBvcyA9IHBvcy5zdWJ0cmFjdChMLnBvaW50KHRvb2x0aXBXaWR0aCAvIDIgLSBvZmZzZXQueCwgLW9mZnNldC55KSk7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRwb3MgPSBwb3Muc3VidHJhY3QoTC5wb2ludCh0b29sdGlwV2lkdGggLyAyICsgb2Zmc2V0LngsIHRvb2x0aXBIZWlnaHQgLyAyIC0gYW5jaG9yLnkgKyBvZmZzZXQueSkpO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnIHx8IGRpcmVjdGlvbiA9PT0gJ2F1dG8nICYmIHRvb2x0aXBQb2ludC54IDwgY2VudGVyUG9pbnQueCkge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ3JpZ2h0Jztcblx0XHRcdHBvcyA9IHBvcy5hZGQoW29mZnNldC54ICsgYW5jaG9yLngsIGFuY2hvci55IC0gdG9vbHRpcEhlaWdodCAvIDIgKyBvZmZzZXQueV0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAnbGVmdCc7XG5cdFx0XHRwb3MgPSBwb3Muc3VidHJhY3QoTC5wb2ludCh0b29sdGlwV2lkdGggKyBhbmNob3IueCAtIG9mZnNldC54LCB0b29sdGlwSGVpZ2h0IC8gMiAtIGFuY2hvci55IC0gb2Zmc2V0LnkpKTtcblx0XHR9XG5cblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLXJpZ2h0Jyk7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1sZWZ0Jyk7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC10b3AnKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWJvdHRvbScpO1xuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtJyArIGRpcmVjdGlvbik7XG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgcG9zKTtcblx0fSxcblxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIG9wYWNpdHkpO1xuXHRcdH1cblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlcik7XG5cdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcblx0fSxcblxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgdG9vbHRpcCBvbiB0aGUgc291cmNlIGxheWVyP1xuXHRcdHJldHVybiBMLnBvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IgJiYgIXRoaXMub3B0aW9ucy5zdGlja3kgPyB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IoKSA6IFswLCAwXSk7XG5cdH1cblxufSk7XG5cbi8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuLy8gQGZhY3RvcnkgTC50b29sdGlwKG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxuLy8gSW5zdGFudGlhdGVzIGEgVG9vbHRpcCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSB0b29sdGlwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cbkwudG9vbHRpcCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcblx0cmV0dXJuIG5ldyBMLlRvb2x0aXAob3B0aW9ucywgc291cmNlKTtcbn07XG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG5MLk1hcC5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgdG9vbHRpcC5cblx0Ly8gQGFsdGVybmF0aXZlXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQ3JlYXRlcyBhIHRvb2x0aXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW4gaXQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCwgbGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0aWYgKCEodG9vbHRpcCBpbnN0YW5jZW9mIEwuVG9vbHRpcCkpIHtcblx0XHRcdHRvb2x0aXAgPSBuZXcgTC5Ub29sdGlwKG9wdGlvbnMpLnNldENvbnRlbnQodG9vbHRpcCk7XG5cdFx0fVxuXG5cdFx0aWYgKGxhdGxuZykge1xuXHRcdFx0dG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5oYXNMYXllcih0b29sdGlwKSkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIodG9vbHRpcCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAodG9vbHRpcD86IFRvb2x0aXApOiB0aGlzXG5cdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBnaXZlbiBhcyBwYXJhbWV0ZXIuXG5cdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXApIHtcblx0XHRpZiAodG9vbHRpcCkge1xuXHRcdFx0dGhpcy5yZW1vdmVMYXllcih0b29sdGlwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufSk7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIExheWVyXG4gKiBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHMgZXhhbXBsZVxuICpcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHRvb2x0aXBzIHRvIGl0LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFRvb2x0aXAoJ0hpIFRoZXJlIScpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5vcGVuVG9vbHRpcCgpO1xuICogbGF5ZXIuY2xvc2VUb29sdGlwKCk7XG4gKiBgYGBcbiAqL1xuXG4vLyBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHNcbkwuTGF5ZXIuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBiaW5kVG9vbHRpcChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb258VG9vbHRpcCwgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQmluZHMgYSB0b29sdGlwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxuXHQvLyBuZWNjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcblx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXG5cdGJpbmRUb29sdGlwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuXG5cdFx0aWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBMLlRvb2x0aXApIHtcblx0XHRcdEwuc2V0T3B0aW9ucyhjb250ZW50LCBvcHRpb25zKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBjb250ZW50O1xuXHRcdFx0Y29udGVudC5fc291cmNlID0gdGhpcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCF0aGlzLl90b29sdGlwIHx8IG9wdGlvbnMpIHtcblx0XHRcdFx0dGhpcy5fdG9vbHRpcCA9IEwudG9vbHRpcChvcHRpb25zLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKCk7XG5cblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCAmJiB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpKSB7XG5cdFx0XHR0aGlzLm9wZW5Ub29sdGlwKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB1bmJpbmRUb29sdGlwKCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgdG9vbHRpcCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRUb29sdGlwYC5cblx0dW5iaW5kVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyh0cnVlKTtcblx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2luaXRUb29sdGlwSW50ZXJhY3Rpb25zOiBmdW5jdGlvbiAocmVtb3ZlKSB7XG5cdFx0aWYgKCFyZW1vdmUgJiYgdGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlID8gJ29mZicgOiAnb24nLFxuXHRcdCAgICBldmVudHMgPSB7XG5cdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VUb29sdGlwLFxuXHRcdFx0bW92ZTogdGhpcy5fbW92ZVRvb2x0aXBcblx0XHQgICAgfTtcblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5tb3VzZW92ZXIgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdGV2ZW50cy5tb3VzZW91dCA9IHRoaXMuY2xvc2VUb29sdGlwO1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kpIHtcblx0XHRcdFx0ZXZlbnRzLm1vdXNlbW92ZSA9IHRoaXMuX21vdmVUb29sdGlwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKEwuQnJvd3Nlci50b3VjaCkge1xuXHRcdFx0XHRldmVudHMuY2xpY2sgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXZlbnRzLmFkZCA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdH1cblx0XHR0aGlzW29uT2ZmXShldmVudHMpO1xuXHRcdHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkID0gIXJlbW92ZTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHRvb2x0aXAgYXQgdGhlIHNwZWNpZmljZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgdG9vbHRpcCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxuXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKGxheWVyLCBsYXRsbmcpIHtcblx0XHRpZiAoIShsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXIpKSB7XG5cdFx0XHRsYXRsbmcgPSBsYXllcjtcblx0XHRcdGxheWVyID0gdGhpcztcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLkZlYXR1cmVHcm91cCkge1xuXHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFsYXRsbmcpIHtcblx0XHRcdGxhdGxuZyA9IGxheWVyLmdldENlbnRlciA/IGxheWVyLmdldENlbnRlcigpIDogbGF5ZXIuZ2V0TGF0TG5nKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAgJiYgdGhpcy5fbWFwKSB7XG5cblx0XHRcdC8vIHNldCB0b29sdGlwIHNvdXJjZSB0byB0aGlzIGxheWVyXG5cdFx0XHR0aGlzLl90b29sdGlwLl9zb3VyY2UgPSBsYXllcjtcblxuXHRcdFx0Ly8gdXBkYXRlIHRoZSB0b29sdGlwIChjb250ZW50LCBsYXlvdXQsIGVjdC4uLilcblx0XHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlKCk7XG5cblx0XHRcdC8vIG9wZW4gdGhlIHRvb2x0aXAgb24gdGhlIG1hcFxuXHRcdFx0dGhpcy5fbWFwLm9wZW5Ub29sdGlwKHRoaXMuX3Rvb2x0aXAsIGxhdGxuZyk7XG5cblx0XHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG1heSBub3QgYmUgZGVmaW5lZCBpZiBub3QgcGVybWFuZW50IGFuZCBuZXZlclxuXHRcdFx0Ly8gb3BlbmVkLlxuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiB0aGlzLl90b29sdGlwLl9jb250YWluZXIpIHtcblx0XHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY2xpY2thYmxlJyk7XG5cdFx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCgpOiB0aGlzXG5cdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlmIGl0IGlzIG9wZW4uXG5cdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLl9jbG9zZSgpO1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiB0aGlzLl90b29sdGlwLl9jb250YWluZXIpIHtcblx0XHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY2xpY2thYmxlJyk7XG5cdFx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB0b2dnbGVUb29sdGlwKCk6IHRoaXNcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxuXHR0b2dnbGVUb29sdGlwOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLl9tYXApIHtcblx0XHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMub3BlblRvb2x0aXAodGFyZ2V0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc1Rvb2x0aXBPcGVuKCk6IGJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cblx0aXNUb29sdGlwT3BlbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwLmlzT3BlbigpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0VG9vbHRpcENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFRvb2x0aXApOiB0aGlzXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0c2V0VG9vbHRpcENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRUb29sdGlwKCk6IFRvb2x0aXBcblx0Ly8gUmV0dXJucyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRnZXRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG5cdH0sXG5cblx0X29wZW5Ub29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XG5cblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgIXRoaXMuX21hcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLm9wZW5Ub29sdGlwKGxheWVyLCB0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ID8gZS5sYXRsbmcgOiB1bmRlZmluZWQpO1xuXHR9LFxuXG5cdF9tb3ZlVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF0bG5nID0gZS5sYXRsbmcsIGNvbnRhaW5lclBvaW50LCBsYXllclBvaW50O1xuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ICYmIGUub3JpZ2luYWxFdmVudCkge1xuXHRcdFx0Y29udGFpbmVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS5vcmlnaW5hbEV2ZW50KTtcblx0XHRcdGxheWVyUG9pbnQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoY29udGFpbmVyUG9pbnQpO1xuXHRcdFx0bGF0bG5nID0gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcblx0XHR9XG5cdFx0dGhpcy5fdG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0fVxufSk7XG5cbi8qXHJcbiAqIFRvb2x0aXAgZXh0ZW5zaW9uIHRvIEwuTWFya2VyLCBhZGRpbmcgdG9vbHRpcC1yZWxhdGVkIG1ldGhvZHMuXHJcbiAqL1xyXG5cclxuTC5NYXJrZXIuaW5jbHVkZSh7XHJcblx0X2dldFRvb2x0aXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnRvb2x0aXBBbmNob3IgfHwgWzAsIDBdO1xyXG5cdH1cclxufSk7XHJcblxuLypcclxuICogQGNsYXNzIExheWVyR3JvdXBcclxuICogQGFrYSBMLkxheWVyR3JvdXBcclxuICogQGluaGVyaXRzIExheWVyXHJcbiAqXHJcbiAqIFVzZWQgdG8gZ3JvdXAgc2V2ZXJhbCBsYXllcnMgYW5kIGhhbmRsZSB0aGVtIGFzIG9uZS4gSWYgeW91IGFkZCBpdCB0byB0aGUgbWFwLFxyXG4gKiBhbnkgbGF5ZXJzIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgZ3JvdXAgd2lsbCBiZSBhZGRlZC9yZW1vdmVkIG9uIHRoZSBtYXAgYXNcclxuICogd2VsbC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmxheWVyR3JvdXAoW21hcmtlcjEsIG1hcmtlcjJdKVxyXG4gKiBcdC5hZGRMYXllcihwb2x5bGluZSlcclxuICogXHQuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5MYXllckdyb3VwID0gTC5MYXllci5leHRlbmQoe1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHR2YXIgaSwgbGVuO1xyXG5cclxuXHRcdGlmIChsYXllcnMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIGdyb3VwLlxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBncm91cC5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGlkOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgZnJvbSB0aGUgZ3JvdXAuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gbGF5ZXIgaW4gdGhpcy5fbGF5ZXJzID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgdGhpcy5fbGF5ZXJzW2lkXSkge1xyXG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2lkXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0cmV0dXJuICEhbGF5ZXIgJiYgKGxheWVyIGluIHRoaXMuX2xheWVycyB8fCB0aGlzLmdldExheWVySWQobGF5ZXIpIGluIHRoaXMuX2xheWVycyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbGVhckxheWVycygpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbGwgdGhlIGxheWVycyBmcm9tIHRoZSBncm91cC5cclxuXHRjbGVhckxheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnZva2UobWV0aG9kTmFtZTogU3RyaW5nLCDigKYpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYG1ldGhvZE5hbWVgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIGFueVxyXG5cdC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVycy4gSGFzIG5vIGVmZmVjdCBpZiB0aGUgbGF5ZXJzIGNvbnRhaW5lZCBkbyBub3RcclxuXHQvLyBpbXBsZW1lbnQgYG1ldGhvZE5hbWVgLlxyXG5cdGludm9rZTogZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuXHRcdCAgICBpLCBsYXllcjtcclxuXHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyW21ldGhvZE5hbWVdKSB7XHJcblx0XHRcdFx0bGF5ZXJbbWV0aG9kTmFtZV0uYXBwbHkobGF5ZXIsIGFyZ3MpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdG1hcC5hZGRMYXllcih0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBncm91cCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxyXG5cdC8vIGBgYGpzXHJcblx0Ly8gZ3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdC8vIFx0bGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xyXG5cdC8vIH0pO1xyXG5cdC8vIGBgYFxyXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXIoaWQ6IE51bWJlcik6IExheWVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQuXHJcblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpZF07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcnMoKTogTGF5ZXJbXVxyXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBsYXllcnMgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdGdldExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGxheWVycyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVycy5wdXNoKHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbGF5ZXJzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENhbGxzIGBzZXRaSW5kZXhgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIHRoZSB6LWluZGV4LlxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRaSW5kZXgnLCB6SW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXJJZChsYXllcjogTGF5ZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnRlcm5hbCBJRCBmb3IgYSBsYXllclxyXG5cdGdldExheWVySWQ6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0cmV0dXJuIEwuc3RhbXAobGF5ZXIpO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXllckdyb3VwKGxheWVyczogTGF5ZXJbXSlcclxuLy8gQ3JlYXRlIGEgbGF5ZXIgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzLlxyXG5MLmxheWVyR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0cmV0dXJuIG5ldyBMLkxheWVyR3JvdXAobGF5ZXJzKTtcclxufTtcclxuXG4vKlxyXG4gKiBAY2xhc3MgRmVhdHVyZUdyb3VwXHJcbiAqIEBha2EgTC5GZWF0dXJlR3JvdXBcclxuICogQGluaGVyaXRzIExheWVyR3JvdXBcclxuICpcclxuICogRXh0ZW5kZWQgYExheWVyR3JvdXBgIHRoYXQgbWFrZXMgaXQgZWFzaWVyIHRvIGRvIHRoZSBzYW1lIHRoaW5nIHRvIGFsbCBpdHMgbWVtYmVyIGxheWVyczpcclxuICogICogW2BiaW5kUG9wdXBgXSgjbGF5ZXItYmluZHBvcHVwKSBiaW5kcyBhIHBvcHVwIHRvIGFsbCBvZiB0aGUgbGF5ZXJzIGF0IG9uY2UgKGxpa2V3aXNlIHdpdGggW2BiaW5kVG9vbHRpcGBdKCNsYXllci1iaW5kdG9vbHRpcCkpXHJcbiAqICAqIEV2ZW50cyBhcmUgcHJvcGFnYXRlZCB0byB0aGUgYEZlYXR1cmVHcm91cGAsIHNvIGlmIHRoZSBncm91cCBoYXMgYW4gZXZlbnRcclxuICogaGFuZGxlciwgaXQgd2lsbCBoYW5kbGUgZXZlbnRzIGZyb20gYW55IG9mIHRoZSBsYXllcnMuIFRoaXMgaW5jbHVkZXMgbW91c2UgZXZlbnRzXHJcbiAqIGFuZCBjdXN0b20gZXZlbnRzLlxyXG4gKiAgKiBIYXMgYGxheWVyYWRkYCBhbmQgYGxheWVycmVtb3ZlYCBldmVudHNcclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5mZWF0dXJlR3JvdXAoW21hcmtlcjEsIG1hcmtlcjIsIHBvbHlsaW5lXSlcclxuICogXHQuYmluZFBvcHVwKCdIZWxsbyB3b3JsZCEnKVxyXG4gKiBcdC5vbignY2xpY2snLCBmdW5jdGlvbigpIHsgYWxlcnQoJ0NsaWNrZWQgb24gYSBtZW1iZXIgb2YgdGhlIGdyb3VwIScpOyB9KVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLkZlYXR1cmVHcm91cCA9IEwuTGF5ZXJHcm91cC5leHRlbmQoe1xyXG5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIuYWRkRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TC5MYXllckdyb3VwLnByb3RvdHlwZS5hZGRMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyBhZGRlZCB0byB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxheWVyIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcl07XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TC5MYXllckdyb3VwLnByb3RvdHlwZS5yZW1vdmVMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGdpdmVuIHBhdGggb3B0aW9ucyB0byBlYWNoIGxheWVyIG9mIHRoZSBncm91cCB0aGF0IGhhcyBhIGBzZXRTdHlsZWAgbWV0aG9kLlxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0U3R5bGUnLCBzdHlsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIHRvcCBvZiBhbGwgb3RoZXIgbGF5ZXJzXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9Gcm9udCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIHRvcCBvZiBhbGwgb3RoZXIgbGF5ZXJzXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0JhY2snKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBMYXRMbmdCb3VuZHMgb2YgdGhlIEZlYXR1cmUgR3JvdXAgKGNyZWF0ZWQgZnJvbSBib3VuZHMgYW5kIGNvb3JkaW5hdGVzIG9mIGl0cyBjaGlsZHJlbikuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHZhciBsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XHJcblx0XHRcdGJvdW5kcy5leHRlbmQobGF5ZXIuZ2V0Qm91bmRzID8gbGF5ZXIuZ2V0Qm91bmRzKCkgOiBsYXllci5nZXRMYXRMbmcoKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAZmFjdG9yeSBMLmZlYXR1cmVHcm91cChsYXllcnM6IExheWVyW10pXHJcbi8vIENyZWF0ZSBhIGZlYXR1cmUgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzLlxyXG5MLmZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcbn07XHJcblxuLypcbiAqIEBjbGFzcyBSZW5kZXJlclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuUmVuZGVyZXJcbiAqXG4gKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3IgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zIChgU1ZHYCwgYENhbnZhc2ApLiBIYW5kbGVzIHRoZVxuICogRE9NIGNvbnRhaW5lciBvZiB0aGUgcmVuZGVyZXIsIGl0cyBib3VuZHMsIGFuZCBpdHMgem9vbSBhbmltYXRpb24uXG4gKlxuICogQSBgUmVuZGVyZXJgIHdvcmtzIGFzIGFuIGltcGxpY2l0IGxheWVyIGdyb3VwIGZvciBhbGwgYFBhdGhgcyAtIHRoZSByZW5kZXJlclxuICogaXRzZWxmIGNhbiBiZSBhZGRlZCBvciByZW1vdmVkIHRvIHRoZSBtYXAuIEFsbCBwYXRocyB1c2UgYSByZW5kZXJlciwgd2hpY2ggY2FuXG4gKiBiZSBpbXBsaWNpdCAodGhlIG1hcCB3aWxsIGRlY2lkZSB0aGUgdHlwZSBvZiByZW5kZXJlciBhbmQgdXNlIGl0IGF1dG9tYXRpY2FsbHkpXG4gKiBvciBleHBsaWNpdCAodXNpbmcgdGhlIFtgcmVuZGVyZXJgXSgjcGF0aC1yZW5kZXJlcikgb3B0aW9uIG9mIHRoZSBwYXRoKS5cbiAqXG4gKiBEbyBub3QgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHksIHVzZSBgU1ZHYCBhbmQgYENhbnZhc2AgaW5zdGVhZC5cbiAqXG4gKiBAZXZlbnQgdXBkYXRlOiBFdmVudFxuICogRmlyZWQgd2hlbiB0aGUgcmVuZGVyZXIgdXBkYXRlcyBpdHMgYm91bmRzLCBjZW50ZXIgYW5kIHpvb20sIGZvciBleGFtcGxlIHdoZW5cbiAqIGl0cyBtYXAgaGFzIG1vdmVkXG4gKi9cblxuTC5SZW5kZXJlciA9IEwuTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFJlbmRlcmVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFkZGluZzogTnVtYmVyID0gMC4xXG5cdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIHRoZSBjbGlwIGFyZWEgYXJvdW5kIHRoZSBtYXAgdmlldyAocmVsYXRpdmUgdG8gaXRzIHNpemUpXG5cdFx0Ly8gZS5nLiAwLjEgd291bGQgYmUgMTAlIG9mIG1hcCB2aWV3IGluIGVhY2ggZGlyZWN0aW9uXG5cdFx0cGFkZGluZzogMC4xXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0TC5zdGFtcCh0aGlzKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7IC8vIGRlZmluZWQgYnkgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zXG5cblx0XHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IHtcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXQsXG5cdFx0XHR6b29tOiB0aGlzLl9vblpvb20sXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl91cGRhdGVcblx0XHR9O1xuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX29uQW5pbVpvb207XG5cdFx0fVxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X29uQW5pbVpvb206IGZ1bmN0aW9uIChldikge1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybShldi5jZW50ZXIsIGV2Lnpvb20pO1xuXHR9LFxuXG5cdF9vblpvb206IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0odGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcblx0fSxcblxuXHRfdXBkYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCB0aGlzLl96b29tKSxcblx0XHQgICAgcG9zaXRpb24gPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSxcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLm11bHRpcGx5QnkoMC41ICsgdGhpcy5vcHRpb25zLnBhZGRpbmcpLFxuXHRcdCAgICBjdXJyZW50Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9jZW50ZXIsIHpvb20pLFxuXHRcdCAgICBkZXN0Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdChjZW50ZXIsIHpvb20pLFxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBkZXN0Q2VudGVyUG9pbnQuc3VidHJhY3QoY3VycmVudENlbnRlclBvaW50KSxcblxuXHRcdCAgICB0b3BMZWZ0T2Zmc2V0ID0gdmlld0hhbGYubXVsdGlwbHlCeSgtc2NhbGUpLmFkZChwb3NpdGlvbikuYWRkKHZpZXdIYWxmKS5zdWJ0cmFjdChjZW50ZXJPZmZzZXQpO1xuXG5cdFx0aWYgKEwuQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0TC5Eb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9jb250YWluZXIsIHRvcExlZnRPZmZzZXQsIHNjYWxlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20pO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBVcGRhdGUgcGl4ZWwgYm91bmRzIG9mIHJlbmRlcmVyIGNvbnRhaW5lciAoZm9yIHBvc2l0aW9uaW5nL3NpemluZy9jbGlwcGluZyBsYXRlcilcblx0XHQvLyBTdWJjbGFzc2VzIGFyZSByZXNwb25zaWJsZSBvZiBmaXJpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxuXHRcdHZhciBwID0gdGhpcy5vcHRpb25zLnBhZGRpbmcsXG5cdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtaW4gPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoc2l6ZS5tdWx0aXBseUJ5KC1wKSkucm91bmQoKTtcblxuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBMLkJvdW5kcyhtaW4sIG1pbi5hZGQoc2l6ZS5tdWx0aXBseUJ5KDEgKyBwICogMikpLnJvdW5kKCkpO1xuXG5cdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuXHRcdHRoaXMuX3pvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHR9XG59KTtcblxuXG5MLk1hcC5pbmNsdWRlKHtcblx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBtZXRob2QgZ2V0UmVuZGVyZXIobGF5ZXI6IFBhdGgpOiBSZW5kZXJlclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVuZGVyIHRoZSBnaXZlblxuXHQvLyBgUGF0aGAuIEl0IHdpbGwgZW5zdXJlIHRoYXQgdGhlIGByZW5kZXJlcmAgb3B0aW9ucyBvZiB0aGUgbWFwIGFuZCBwYXRoc1xuXHQvLyBhcmUgcmVzcGVjdGVkLCBhbmQgdGhhdCB0aGUgcmVuZGVyZXJzIGRvIGV4aXN0IG9uIHRoZSBtYXAuXG5cdGdldFJlbmRlcmVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHQvLyBAbmFtZXNwYWNlIFBhdGg7IEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyXG5cdFx0Ly8gVXNlIHRoaXMgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCBmb3IgdGhpcyBwYXRoLiBUYWtlc1xuXHRcdC8vIHByZWNlZGVuY2Ugb3ZlciB0aGUgbWFwJ3MgW2RlZmF1bHQgcmVuZGVyZXJdKCNtYXAtcmVuZGVyZXIpLlxuXHRcdHZhciByZW5kZXJlciA9IGxheWVyLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fZ2V0UGFuZVJlbmRlcmVyKGxheWVyLm9wdGlvbnMucGFuZSkgfHwgdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX3JlbmRlcmVyO1xuXG5cdFx0aWYgKCFyZW5kZXJlcikge1xuXHRcdFx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBvcHRpb24gcHJlZmVyQ2FudmFzOiBCb29sZWFuID0gZmFsc2Vcblx0XHRcdC8vIFdoZXRoZXIgYFBhdGhgcyBzaG91bGQgYmUgcmVuZGVyZWQgb24gYSBgQ2FudmFzYCByZW5kZXJlci5cblx0XHRcdC8vIEJ5IGRlZmF1bHQsIGFsbCBgUGF0aGBzIGFyZSByZW5kZXJlZCBpbiBhIGBTVkdgIHJlbmRlcmVyLlxuXHRcdFx0cmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlciA9ICh0aGlzLm9wdGlvbnMucHJlZmVyQ2FudmFzICYmIEwuY2FudmFzKCkpIHx8IEwuc3ZnKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmhhc0xheWVyKHJlbmRlcmVyKSkge1xuXHRcdFx0dGhpcy5hZGRMYXllcihyZW5kZXJlcik7XG5cdFx0fVxuXHRcdHJldHVybiByZW5kZXJlcjtcblx0fSxcblxuXHRfZ2V0UGFuZVJlbmRlcmVyOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmIChuYW1lID09PSAnb3ZlcmxheVBhbmUnIHx8IG5hbWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciByZW5kZXJlciA9IHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV07XG5cdFx0aWYgKHJlbmRlcmVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJlbmRlcmVyID0gKEwuU1ZHICYmIEwuc3ZnKHtwYW5lOiBuYW1lfSkpIHx8IChMLkNhbnZhcyAmJiBMLmNhbnZhcyh7cGFuZTogbmFtZX0pKTtcblx0XHRcdHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV0gPSByZW5kZXJlcjtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9XG59KTtcblxuLypcbiAqIEBjbGFzcyBQYXRoXG4gKiBAYWthIEwuUGF0aFxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXG4gKlxuICogQW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBjb250YWlucyBvcHRpb25zIGFuZCBjb25zdGFudHMgc2hhcmVkIGJldHdlZW4gdmVjdG9yXG4gKiBvdmVybGF5cyAoUG9seWdvbiwgUG9seWxpbmUsIENpcmNsZSkuIERvIG5vdCB1c2UgaXQgZGlyZWN0bHkuIEV4dGVuZHMgYExheWVyYC5cbiAqL1xuXG5MLlBhdGggPSBMLkxheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBQYXRoIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gc3Ryb2tlOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gZHJhdyBzdHJva2UgYWxvbmcgdGhlIHBhdGguIFNldCBpdCB0byBgZmFsc2VgIHRvIGRpc2FibGUgYm9yZGVycyBvbiBwb2x5Z29ucyBvciBjaXJjbGVzLlxuXHRcdHN0cm9rZTogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gY29sb3I6IFN0cmluZyA9ICcjMzM4OGZmJ1xuXHRcdC8vIFN0cm9rZSBjb2xvclxuXHRcdGNvbG9yOiAnIzMzODhmZicsXG5cblx0XHQvLyBAb3B0aW9uIHdlaWdodDogTnVtYmVyID0gM1xuXHRcdC8vIFN0cm9rZSB3aWR0aCBpbiBwaXhlbHNcblx0XHR3ZWlnaHQ6IDMsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuXHRcdC8vIFN0cm9rZSBvcGFjaXR5XG5cdFx0b3BhY2l0eTogMSxcblxuXHRcdC8vIEBvcHRpb24gbGluZUNhcDogU3RyaW5nPSAncm91bmQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBlbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWxpbmVjYXApIG9mIHRoZSBzdHJva2UuXG5cdFx0bGluZUNhcDogJ3JvdW5kJyxcblxuXHRcdC8vIEBvcHRpb24gbGluZUpvaW46IFN0cmluZyA9ICdyb3VuZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGNvcm5lcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWxpbmVqb2luKSBvZiB0aGUgc3Ryb2tlLlxuXHRcdGxpbmVKb2luOiAncm91bmQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBkYXNoQXJyYXk6IFN0cmluZyA9IG51bGxcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIHN0cm9rZSBbZGFzaCBwYXR0ZXJuXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNoYXJyYXkpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG5cdFx0ZGFzaEFycmF5OiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBkYXNoT2Zmc2V0OiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBbZGlzdGFuY2UgaW50byB0aGUgZGFzaCBwYXR0ZXJuIHRvIHN0YXJ0IHRoZSBkYXNoXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNob2Zmc2V0KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuXHRcdGRhc2hPZmZzZXQ6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGw6IEJvb2xlYW4gPSBkZXBlbmRzXG5cdFx0Ly8gV2hldGhlciB0byBmaWxsIHRoZSBwYXRoIHdpdGggY29sb3IuIFNldCBpdCB0byBgZmFsc2VgIHRvIGRpc2FibGUgZmlsbGluZyBvbiBwb2x5Z29ucyBvciBjaXJjbGVzLlxuXHRcdGZpbGw6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsQ29sb3I6IFN0cmluZyA9ICpcblx0XHQvLyBGaWxsIGNvbG9yLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgb2YgdGhlIFtgY29sb3JgXSgjcGF0aC1jb2xvcikgb3B0aW9uXG5cdFx0ZmlsbENvbG9yOiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsT3BhY2l0eTogTnVtYmVyID0gMC4yXG5cdFx0Ly8gRmlsbCBvcGFjaXR5LlxuXHRcdGZpbGxPcGFjaXR5OiAwLjIsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxSdWxlOiBTdHJpbmcgPSAnZXZlbm9kZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW2hvdyB0aGUgaW5zaWRlIG9mIGEgc2hhcGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvZmlsbC1ydWxlKSBpcyBkZXRlcm1pbmVkLlxuXHRcdGZpbGxSdWxlOiAnZXZlbm9kZCcsXG5cblx0XHQvLyBjbGFzc05hbWU6ICcnLFxuXG5cdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xuXHRcdGludGVyYWN0aXZlOiB0cnVlXG5cdH0sXG5cblx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0Ly8gUmVuZGVyZXIgaXMgc2V0IGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRvIGNhbGwgcmVuZGVyZXIuZ2V0RXZlbnRzXG5cdFx0Ly8gYmVmb3JlIHRoaXMuZ2V0RXZlbnRzLlxuXHRcdHRoaXMuX3JlbmRlcmVyID0gbWFwLmdldFJlbmRlcmVyKHRoaXMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2luaXRQYXRoKHRoaXMpO1xuXHRcdHRoaXMuX3Jlc2V0KCk7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2FkZFBhdGgodGhpcyk7XG5cdFx0dGhpcy5fcmVuZGVyZXIub24oJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fcmVtb3ZlUGF0aCh0aGlzKTtcblx0XHR0aGlzLl9yZW5kZXJlci5vZmYoJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHpvb21lbmQ6IHRoaXMuX3Byb2plY3QsXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XG5cdFx0fTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdygpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIGxheWVyLiBTb21ldGltZXMgdXNlZnVsIGFmdGVyIHlvdSBjaGFuZ2VkIHRoZSBjb29yZGluYXRlcyB0aGF0IHRoZSBwYXRoIHVzZXMuXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQYXRoKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIGFwcGVhcmFuY2Ugb2YgYSBQYXRoIGJhc2VkIG9uIHRoZSBvcHRpb25zIGluIHRoZSBgUGF0aCBvcHRpb25zYCBvYmplY3QuXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcblx0XHRMLnNldE9wdGlvbnModGhpcywgc3R5bGUpO1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVN0eWxlKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9Gcm9udCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0JhY2sodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBkZWZpbmVkIGluIGNoaWxkcmVuIGNsYXNzZXNcblx0XHR0aGlzLl9wcm9qZWN0KCk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X2NsaWNrVG9sZXJhbmNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdXNlZCB3aGVuIGRvaW5nIGhpdCBkZXRlY3Rpb24gZm9yIENhbnZhcyBsYXllcnNcblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5zdHJva2UgPyB0aGlzLm9wdGlvbnMud2VpZ2h0IC8gMiA6IDApICsgKEwuQnJvd3Nlci50b3VjaCA/IDEwIDogMCk7XG5cdH1cbn0pO1xuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIExpbmVVdGlsXHJcbiAqXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBvbHlpbmUgcG9pbnRzIHByb2Nlc3NpbmcsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIG1ha2UgcG9seWxpbmVzIGxpZ2h0bmluZy1mYXN0LlxyXG4gKi9cclxuXHJcbkwuTGluZVV0aWwgPSB7XHJcblxyXG5cdC8vIFNpbXBsaWZ5IHBvbHlsaW5lIHdpdGggdmVydGV4IHJlZHVjdGlvbiBhbmQgRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLlxyXG5cdC8vIEltcHJvdmVzIHJlbmRlcmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgYnkgbGVzc2VuaW5nIHRoZSBudW1iZXIgb2YgcG9pbnRzIHRvIGRyYXcuXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHM6IFBvaW50W10sIHRvbGVyYW5jZTogTnVtYmVyKTogUG9pbnRbXVxyXG5cdC8vIERyYW1hdGljYWxseSByZWR1Y2VzIHRoZSBudW1iZXIgb2YgcG9pbnRzIGluIGEgcG9seWxpbmUgd2hpbGUgcmV0YWluaW5nXHJcblx0Ly8gaXRzIHNoYXBlIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIHNpbXBsaWZpZWQgcG9pbnRzLCB1c2luZyB0aGVcclxuXHQvLyBbRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtKS5cclxuXHQvLyBVc2VkIGZvciBhIGh1Z2UgcGVyZm9ybWFuY2UgYm9vc3Qgd2hlbiBwcm9jZXNzaW5nL2Rpc3BsYXlpbmcgTGVhZmxldCBwb2x5bGluZXMgZm9yXHJcblx0Ly8gZWFjaCB6b29tIGxldmVsIGFuZCBhbHNvIHJlZHVjaW5nIHZpc3VhbCBub2lzZS4gdG9sZXJhbmNlIGFmZmVjdHMgdGhlIGFtb3VudCBvZlxyXG5cdC8vIHNpbXBsaWZpY2F0aW9uIChsZXNzZXIgdmFsdWUgbWVhbnMgaGlnaGVyIHF1YWxpdHkgYnV0IHNsb3dlciBhbmQgd2l0aCBtb3JlIHBvaW50cykuXHJcblx0Ly8gQWxzbyByZWxlYXNlZCBhcyBhIHNlcGFyYXRlZCBtaWNyby1saWJyYXJ5IFtTaW1wbGlmeS5qc10oaHR0cDovL21vdXJuZXIuZ2l0aHViLmNvbS9zaW1wbGlmeS1qcy8pLlxyXG5cdHNpbXBsaWZ5OiBmdW5jdGlvbiAocG9pbnRzLCB0b2xlcmFuY2UpIHtcclxuXHRcdGlmICghdG9sZXJhbmNlIHx8ICFwb2ludHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBwb2ludHMuc2xpY2UoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgKiB0b2xlcmFuY2U7XHJcblxyXG5cdFx0Ly8gc3RhZ2UgMTogdmVydGV4IHJlZHVjdGlvblxyXG5cdFx0cG9pbnRzID0gdGhpcy5fcmVkdWNlUG9pbnRzKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHRcdC8vIHN0YWdlIDI6IERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvblxyXG5cdFx0cG9pbnRzID0gdGhpcy5fc2ltcGxpZnlEUChwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBwb2ludFRvU2VnbWVudERpc3RhbmNlKHA6IFBvaW50LCBwMTogUG9pbnQsIHAyOiBQb2ludCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnQgYHBgIGFuZCBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuXHRwb2ludFRvU2VnbWVudERpc3RhbmNlOiAgZnVuY3Rpb24gKHAsIHAxLCBwMikge1xyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHRydWUpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gY2xvc2VzdFBvaW50T25TZWdtZW50KHA6IFBvaW50LCBwMTogUG9pbnQsIHAyOiBQb2ludCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGNsb3Nlc3QgcG9pbnQgZnJvbSBhIHBvaW50IGBwYCBvbiBhIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG5cdGNsb3Nlc3RQb2ludE9uU2VnbWVudDogZnVuY3Rpb24gKHAsIHAxLCBwMikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMik7XHJcblx0fSxcclxuXHJcblx0Ly8gRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLCBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtXHJcblx0X3NpbXBsaWZ5RFA6IGZ1bmN0aW9uIChwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblxyXG5cdFx0dmFyIGxlbiA9IHBvaW50cy5sZW5ndGgsXHJcblx0XHQgICAgQXJyYXlDb25zdHJ1Y3RvciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSB1bmRlZmluZWQgKyAnJyA/IFVpbnQ4QXJyYXkgOiBBcnJheSxcclxuXHRcdCAgICBtYXJrZXJzID0gbmV3IEFycmF5Q29uc3RydWN0b3IobGVuKTtcclxuXHJcblx0XHRtYXJrZXJzWzBdID0gbWFya2Vyc1tsZW4gLSAxXSA9IDE7XHJcblxyXG5cdFx0dGhpcy5fc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgMCwgbGVuIC0gMSk7XHJcblxyXG5cdFx0dmFyIGksXHJcblx0XHQgICAgbmV3UG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmIChtYXJrZXJzW2ldKSB7XHJcblx0XHRcdFx0bmV3UG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXdQb2ludHM7XHJcblx0fSxcclxuXHJcblx0X3NpbXBsaWZ5RFBTdGVwOiBmdW5jdGlvbiAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGxhc3QpIHtcclxuXHJcblx0XHR2YXIgbWF4U3FEaXN0ID0gMCxcclxuXHRcdCAgICBpbmRleCwgaSwgc3FEaXN0O1xyXG5cclxuXHRcdGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8PSBsYXN0IC0gMTsgaSsrKSB7XHJcblx0XHRcdHNxRGlzdCA9IHRoaXMuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdLCB0cnVlKTtcclxuXHJcblx0XHRcdGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcclxuXHRcdFx0XHRpbmRleCA9IGk7XHJcblx0XHRcdFx0bWF4U3FEaXN0ID0gc3FEaXN0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XHJcblx0XHRcdG1hcmtlcnNbaW5kZXhdID0gMTtcclxuXHJcblx0XHRcdHRoaXMuX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBpbmRleCk7XHJcblx0XHRcdHRoaXMuX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGluZGV4LCBsYXN0KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyByZWR1Y2UgcG9pbnRzIHRoYXQgYXJlIHRvbyBjbG9zZSB0byBlYWNoIG90aGVyIHRvIGEgc2luZ2xlIHBvaW50XHJcblx0X3JlZHVjZVBvaW50czogZnVuY3Rpb24gKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHRcdHZhciByZWR1Y2VkUG9pbnRzID0gW3BvaW50c1swXV07XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDEsIHByZXYgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuX3NxRGlzdChwb2ludHNbaV0sIHBvaW50c1twcmV2XSkgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0XHRcdHByZXYgPSBpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAocHJldiA8IGxlbiAtIDEpIHtcclxuXHRcdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tsZW4gLSAxXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVkdWNlZFBvaW50cztcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGNsaXBTZWdtZW50KGE6IFBvaW50LCBiOiBQb2ludCwgYm91bmRzOiBCb3VuZHMsIHVzZUxhc3RDb2RlPzogQm9vbGVhbiwgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXXxCb29sZWFuXHJcblx0Ly8gQ2xpcHMgdGhlIHNlZ21lbnQgYSB0byBiIGJ5IHJlY3Rhbmd1bGFyIGJvdW5kcyB3aXRoIHRoZVxyXG5cdC8vIFtDb2hlbi1TdXRoZXJsYW5kIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29oZW4lRTIlODAlOTNTdXRoZXJsYW5kX2FsZ29yaXRobSlcclxuXHQvLyAobW9kaWZ5aW5nIHRoZSBzZWdtZW50IHBvaW50cyBkaXJlY3RseSEpLiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlsaW5lXHJcblx0Ly8gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZyBwZXJmb3JtYW5jZS5cclxuXHRjbGlwU2VnbWVudDogZnVuY3Rpb24gKGEsIGIsIGJvdW5kcywgdXNlTGFzdENvZGUsIHJvdW5kKSB7XHJcblx0XHR2YXIgY29kZUEgPSB1c2VMYXN0Q29kZSA/IHRoaXMuX2xhc3RDb2RlIDogdGhpcy5fZ2V0Qml0Q29kZShhLCBib3VuZHMpLFxyXG5cdFx0ICAgIGNvZGVCID0gdGhpcy5fZ2V0Qml0Q29kZShiLCBib3VuZHMpLFxyXG5cclxuXHRcdCAgICBjb2RlT3V0LCBwLCBuZXdDb2RlO1xyXG5cclxuXHRcdC8vIHNhdmUgMm5kIGNvZGUgdG8gYXZvaWQgY2FsY3VsYXRpbmcgaXQgb24gdGhlIG5leHQgc2VnbWVudFxyXG5cdFx0dGhpcy5fbGFzdENvZGUgPSBjb2RlQjtcclxuXHJcblx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHQvLyBpZiBhLGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCBhY2NlcHQpXHJcblx0XHRcdGlmICghKGNvZGVBIHwgY29kZUIpKSB7XHJcblx0XHRcdFx0cmV0dXJuIFthLCBiXTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gaWYgYSxiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIHJlamVjdClcclxuXHRcdFx0aWYgKGNvZGVBICYgY29kZUIpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIG90aGVyIGNhc2VzXHJcblx0XHRcdGNvZGVPdXQgPSBjb2RlQSB8fCBjb2RlQjtcclxuXHRcdFx0cCA9IHRoaXMuX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZU91dCwgYm91bmRzLCByb3VuZCk7XHJcblx0XHRcdG5ld0NvZGUgPSB0aGlzLl9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblxyXG5cdFx0XHRpZiAoY29kZU91dCA9PT0gY29kZUEpIHtcclxuXHRcdFx0XHRhID0gcDtcclxuXHRcdFx0XHRjb2RlQSA9IG5ld0NvZGU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0YiA9IHA7XHJcblx0XHRcdFx0Y29kZUIgPSBuZXdDb2RlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2dldEVkZ2VJbnRlcnNlY3Rpb246IGZ1bmN0aW9uIChhLCBiLCBjb2RlLCBib3VuZHMsIHJvdW5kKSB7XHJcblx0XHR2YXIgZHggPSBiLnggLSBhLngsXHJcblx0XHQgICAgZHkgPSBiLnkgLSBhLnksXHJcblx0XHQgICAgbWluID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHgsIHk7XHJcblxyXG5cdFx0aWYgKGNvZGUgJiA4KSB7IC8vIHRvcFxyXG5cdFx0XHR4ID0gYS54ICsgZHggKiAobWF4LnkgLSBhLnkpIC8gZHk7XHJcblx0XHRcdHkgPSBtYXgueTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKGNvZGUgJiA0KSB7IC8vIGJvdHRvbVxyXG5cdFx0XHR4ID0gYS54ICsgZHggKiAobWluLnkgLSBhLnkpIC8gZHk7XHJcblx0XHRcdHkgPSBtaW4ueTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKGNvZGUgJiAyKSB7IC8vIHJpZ2h0XHJcblx0XHRcdHggPSBtYXgueDtcclxuXHRcdFx0eSA9IGEueSArIGR5ICogKG1heC54IC0gYS54KSAvIGR4O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoY29kZSAmIDEpIHsgLy8gbGVmdFxyXG5cdFx0XHR4ID0gbWluLng7XHJcblx0XHRcdHkgPSBhLnkgKyBkeSAqIChtaW4ueCAtIGEueCkgLyBkeDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoeCwgeSwgcm91bmQpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRCaXRDb2RlOiBmdW5jdGlvbiAocCwgYm91bmRzKSB7XHJcblx0XHR2YXIgY29kZSA9IDA7XHJcblxyXG5cdFx0aWYgKHAueCA8IGJvdW5kcy5taW4ueCkgeyAvLyBsZWZ0XHJcblx0XHRcdGNvZGUgfD0gMTtcclxuXHRcdH0gZWxzZSBpZiAocC54ID4gYm91bmRzLm1heC54KSB7IC8vIHJpZ2h0XHJcblx0XHRcdGNvZGUgfD0gMjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAocC55IDwgYm91bmRzLm1pbi55KSB7IC8vIGJvdHRvbVxyXG5cdFx0XHRjb2RlIHw9IDQ7XHJcblx0XHR9IGVsc2UgaWYgKHAueSA+IGJvdW5kcy5tYXgueSkgeyAvLyB0b3BcclxuXHRcdFx0Y29kZSB8PSA4O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb2RlO1xyXG5cdH0sXHJcblxyXG5cdC8vIHNxdWFyZSBkaXN0YW5jZSAodG8gYXZvaWQgdW5uZWNlc3NhcnkgTWF0aC5zcXJ0IGNhbGxzKVxyXG5cdF9zcURpc3Q6IGZ1bmN0aW9uIChwMSwgcDIpIHtcclxuXHRcdHZhciBkeCA9IHAyLnggLSBwMS54LFxyXG5cdFx0ICAgIGR5ID0gcDIueSAtIHAxLnk7XHJcblx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcblx0fSxcclxuXHJcblx0Ly8gcmV0dXJuIGNsb3Nlc3QgcG9pbnQgb24gc2VnbWVudCBvciBkaXN0YW5jZSB0byB0aGF0IHBvaW50XHJcblx0X3NxQ2xvc2VzdFBvaW50T25TZWdtZW50OiBmdW5jdGlvbiAocCwgcDEsIHAyLCBzcURpc3QpIHtcclxuXHRcdHZhciB4ID0gcDEueCxcclxuXHRcdCAgICB5ID0gcDEueSxcclxuXHRcdCAgICBkeCA9IHAyLnggLSB4LFxyXG5cdFx0ICAgIGR5ID0gcDIueSAtIHksXHJcblx0XHQgICAgZG90ID0gZHggKiBkeCArIGR5ICogZHksXHJcblx0XHQgICAgdDtcclxuXHJcblx0XHRpZiAoZG90ID4gMCkge1xyXG5cdFx0XHR0ID0gKChwLnggLSB4KSAqIGR4ICsgKHAueSAtIHkpICogZHkpIC8gZG90O1xyXG5cclxuXHRcdFx0aWYgKHQgPiAxKSB7XHJcblx0XHRcdFx0eCA9IHAyLng7XHJcblx0XHRcdFx0eSA9IHAyLnk7XHJcblx0XHRcdH0gZWxzZSBpZiAodCA+IDApIHtcclxuXHRcdFx0XHR4ICs9IGR4ICogdDtcclxuXHRcdFx0XHR5ICs9IGR5ICogdDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGR4ID0gcC54IC0geDtcclxuXHRcdGR5ID0gcC55IC0geTtcclxuXHJcblx0XHRyZXR1cm4gc3FEaXN0ID8gZHggKiBkeCArIGR5ICogZHkgOiBuZXcgTC5Qb2ludCh4LCB5KTtcclxuXHR9XHJcbn07XHJcblxuLypcbiAqIEBjbGFzcyBQb2x5bGluZVxuICogQGFrYSBMLlBvbHlsaW5lXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWxpbmUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBhdGhgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogXHRbLTEyMi42OCwgNDUuNTFdLFxuICogXHRbLTEyMi40MywgMzcuNzddLFxuICogXHRbLTExOC4yLCAzNC4wNF1cbiAqIF07XG4gKlxuICogdmFyIHBvbHlsaW5lID0gTC5wb2x5bGluZShsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlsaW5lXG4gKiBtYXAuZml0Qm91bmRzKHBvbHlsaW5lLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgYE11bHRpUG9seWxpbmVgIHNoYXBlOlxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBhcnJheXMgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiBcdFtbLTEyMi42OCwgNDUuNTFdLFxuICogXHQgWy0xMjIuNDMsIDM3Ljc3XSxcbiAqIFx0IFstMTE4LjIsIDM0LjA0XV0sXG4gKiBcdFtbLTczLjkxLCA0MC43OF0sXG4gKiBcdCBbLTg3LjYyLCA0MS44M10sXG4gKiBcdCBbLTk2LjcyLCAzMi43Nl1dXG4gKiBdO1xuICogYGBgXG4gKi9cblxuTC5Qb2x5bGluZSA9IEwuUGF0aC5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUG9seWxpbmUgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzbW9vdGhGYWN0b3I6IE51bWJlciA9IDEuMFxuXHRcdC8vIEhvdyBtdWNoIHRvIHNpbXBsaWZ5IHRoZSBwb2x5bGluZSBvbiBlYWNoIHpvb20gbGV2ZWwuIE1vcmUgbWVhbnNcblx0XHQvLyBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIHNtb290aGVyIGxvb2ssIGFuZCBsZXNzIG1lYW5zIG1vcmUgYWNjdXJhdGUgcmVwcmVzZW50YXRpb24uXG5cdFx0c21vb3RoRmFjdG9yOiAxLjAsXG5cblx0XHQvLyBAb3B0aW9uIG5vQ2xpcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gRGlzYWJsZSBwb2x5bGluZSBjbGlwcGluZy5cblx0XHRub0NsaXA6IGZhbHNlXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldExhdExuZ3MoKTogTGF0TG5nW11cblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcG9pbnRzIGluIHRoZSBwYXRoLCBvciBuZXN0ZWQgYXJyYXlzIG9mIHBvaW50cyBpbiBjYXNlIG9mIG11bHRpLXBvbHlsaW5lLlxuXHRnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZ3M7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmdzKGxhdGxuZ3M6IExhdExuZ1tdKTogdGhpc1xuXHQvLyBSZXBsYWNlcyBhbGwgdGhlIHBvaW50cyBpbiB0aGUgcG9seWxpbmUgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cy5cblx0c2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNFbXB0eSgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBQb2x5bGluZSBoYXMgbm8gTGF0TG5ncy5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGg7XG5cdH0sXG5cblx0Y2xvc2VzdExheWVyUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHksXG5cdFx0ICAgIG1pblBvaW50ID0gbnVsbCxcblx0XHQgICAgY2xvc2VzdCA9IEwuTGluZVV0aWwuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50LFxuXHRcdCAgICBwMSwgcDI7XG5cblx0XHRmb3IgKHZhciBqID0gMCwgakxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xuXHRcdFx0dmFyIHBvaW50cyA9IHRoaXMuX3BhcnRzW2pdO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMSwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHAxID0gcG9pbnRzW2kgLSAxXTtcblx0XHRcdFx0cDIgPSBwb2ludHNbaV07XG5cblx0XHRcdFx0dmFyIHNxRGlzdCA9IGNsb3Nlc3QocCwgcDEsIHAyLCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoc3FEaXN0IDwgbWluRGlzdGFuY2UpIHtcblx0XHRcdFx0XHRtaW5EaXN0YW5jZSA9IHNxRGlzdDtcblx0XHRcdFx0XHRtaW5Qb2ludCA9IGNsb3Nlc3QocCwgcDEsIHAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobWluUG9pbnQpIHtcblx0XHRcdG1pblBvaW50LmRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1pblBvaW50O1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBwb2x5bGluZS5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuXHRcdH1cblxuXHRcdHZhciBpLCBoYWxmRGlzdCwgc2VnRGlzdCwgZGlzdCwgcDEsIHAyLCByYXRpbyxcblx0XHQgICAgcG9pbnRzID0gdGhpcy5fcmluZ3NbMF0sXG5cdFx0ICAgIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm4gbnVsbDsgfVxuXG5cdFx0Ly8gcG9seWxpbmUgY2VudHJvaWQgYWxnb3JpdGhtOyBvbmx5IHVzZXMgdGhlIGZpcnN0IHJpbmcgaWYgdGhlcmUgYXJlIG11bHRpcGxlXG5cblx0XHRmb3IgKGkgPSAwLCBoYWxmRGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcblx0XHRcdGhhbGZEaXN0ICs9IHBvaW50c1tpXS5kaXN0YW5jZVRvKHBvaW50c1tpICsgMV0pIC8gMjtcblx0XHR9XG5cblx0XHQvLyBUaGUgbGluZSBpcyBzbyBzbWFsbCBpbiB0aGUgY3VycmVudCB2aWV3IHRoYXQgYWxsIHBvaW50cyBhcmUgb24gdGhlIHNhbWUgcGl4ZWwuXG5cdFx0aWYgKGhhbGZEaXN0ID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhwb2ludHNbMF0pO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG5cdFx0XHRwMSA9IHBvaW50c1tpXTtcblx0XHRcdHAyID0gcG9pbnRzW2kgKyAxXTtcblx0XHRcdHNlZ0Rpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcblx0XHRcdGRpc3QgKz0gc2VnRGlzdDtcblxuXHRcdFx0aWYgKGRpc3QgPiBoYWxmRGlzdCkge1xuXHRcdFx0XHRyYXRpbyA9IChkaXN0IC0gaGFsZkRpc3QpIC8gc2VnRGlzdDtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoW1xuXHRcdFx0XHRcdHAyLnggLSByYXRpbyAqIChwMi54IC0gcDEueCksXG5cdFx0XHRcdFx0cDIueSAtIHJhdGlvICogKHAyLnkgLSBwMS55KVxuXHRcdFx0XHRdKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG5cdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYWRkTGF0TG5nKGxhdGxuZzogTGF0TG5nLCBsYXRsbmdzPyBMYXRMbmdbXSk6IHRoaXNcblx0Ly8gQWRkcyBhIGdpdmVuIHBvaW50IHRvIHRoZSBwb2x5bGluZS4gQnkgZGVmYXVsdCwgYWRkcyB0byB0aGUgZmlyc3QgcmluZyBvZlxuXHQvLyB0aGUgcG9seWxpbmUgaW4gY2FzZSBvZiBhIG11bHRpLXBvbHlsaW5lLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZ1xuXHQvLyBhIHNwZWNpZmljIHJpbmcgYXMgYSBMYXRMbmcgYXJyYXkgKHRoYXQgeW91IGNhbiBlYXJsaWVyIGFjY2VzcyB3aXRoIFtgZ2V0TGF0TG5nc2BdKCNwb2x5bGluZS1nZXRsYXRsbmdzKSkuXG5cdGFkZExhdExuZzogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncykge1xuXHRcdGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2RlZmF1bHRTaGFwZSgpO1xuXHRcdGxhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XG5cdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XG5cdFx0dGhpcy5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcygpO1xuXHRcdHRoaXMuX2xhdGxuZ3MgPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIEwuUG9seWxpbmUuX2ZsYXQodGhpcy5fbGF0bG5ncykgPyB0aGlzLl9sYXRsbmdzIDogdGhpcy5fbGF0bG5nc1swXTtcblx0fSxcblxuXHQvLyByZWN1cnNpdmVseSBjb252ZXJ0IGxhdGxuZ3MgaW5wdXQgaW50byBhY3R1YWwgTGF0TG5nIGluc3RhbmNlczsgY2FsY3VsYXRlIGJvdW5kcyBhbG9uZyB0aGUgd2F5XG5cdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0ICAgIGZsYXQgPSBMLlBvbHlsaW5lLl9mbGF0KGxhdGxuZ3MpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChmbGF0KSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IEwubGF0TG5nKGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKHJlc3VsdFtpXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHB4Qm91bmRzID0gbmV3IEwuQm91bmRzKCk7XG5cdFx0dGhpcy5fcmluZ3MgPSBbXTtcblx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyh0aGlzLl9sYXRsbmdzLCB0aGlzLl9yaW5ncywgcHhCb3VuZHMpO1xuXG5cdFx0dmFyIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuXHRcdCAgICBwID0gbmV3IEwuUG9pbnQodywgdyk7XG5cblx0XHRpZiAodGhpcy5fYm91bmRzLmlzVmFsaWQoKSAmJiBweEJvdW5kcy5pc1ZhbGlkKCkpIHtcblx0XHRcdHB4Qm91bmRzLm1pbi5fc3VidHJhY3QocCk7XG5cdFx0XHRweEJvdW5kcy5tYXguX2FkZChwKTtcblx0XHRcdHRoaXMuX3B4Qm91bmRzID0gcHhCb3VuZHM7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIHJlY3Vyc2l2ZWx5IHR1cm5zIGxhdGxuZ3MgaW50byBhIHNldCBvZiByaW5ncyB3aXRoIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRfcHJvamVjdExhdGxuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcykge1xuXHRcdHZhciBmbGF0ID0gbGF0bG5nc1swXSBpbnN0YW5jZW9mIEwuTGF0TG5nLFxuXHRcdCAgICBsZW4gPSBsYXRsbmdzLmxlbmd0aCxcblx0XHQgICAgaSwgcmluZztcblxuXHRcdGlmIChmbGF0KSB7XG5cdFx0XHRyaW5nID0gW107XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmluZ1tpXSA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nc1tpXSk7XG5cdFx0XHRcdHByb2plY3RlZEJvdW5kcy5leHRlbmQocmluZ1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQucHVzaChyaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKGxhdGxuZ3NbaV0sIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gY2xpcCBwb2x5bGluZSBieSByZW5kZXJlciBib3VuZHMgc28gdGhhdCB3ZSBoYXZlIGxlc3MgdG8gcmVuZGVyIGZvciBwZXJmb3JtYW5jZVxuXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzO1xuXG5cdFx0dGhpcy5fcGFydHMgPSBbXTtcblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHQgICAgaSwgaiwgaywgbGVuLCBsZW4yLCBzZWdtZW50LCBwb2ludHM7XG5cblx0XHRmb3IgKGkgPSAwLCBrID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBvaW50cyA9IHRoaXMuX3JpbmdzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjIgLSAxOyBqKyspIHtcblx0XHRcdFx0c2VnbWVudCA9IEwuTGluZVV0aWwuY2xpcFNlZ21lbnQocG9pbnRzW2pdLCBwb2ludHNbaiArIDFdLCBib3VuZHMsIGosIHRydWUpO1xuXG5cdFx0XHRcdGlmICghc2VnbWVudCkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdHBhcnRzW2tdID0gcGFydHNba10gfHwgW107XG5cdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFswXSk7XG5cblx0XHRcdFx0Ly8gaWYgc2VnbWVudCBnb2VzIG91dCBvZiBzY3JlZW4sIG9yIGl0J3MgdGhlIGxhc3Qgb25lLCBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmUgcGFydFxuXHRcdFx0XHRpZiAoKHNlZ21lbnRbMV0gIT09IHBvaW50c1tqICsgMV0pIHx8IChqID09PSBsZW4yIC0gMikpIHtcblx0XHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMV0pO1xuXHRcdFx0XHRcdGsrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBzaW1wbGlmeSBlYWNoIGNsaXBwZWQgcGFydCBvZiB0aGUgcG9seWxpbmUgZm9yIHBlcmZvcm1hbmNlXG5cdF9zaW1wbGlmeVBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdCAgICB0b2xlcmFuY2UgPSB0aGlzLm9wdGlvbnMuc21vb3RoRmFjdG9yO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0c1tpXSA9IEwuTGluZVV0aWwuc2ltcGxpZnkocGFydHNbaV0sIHRvbGVyYW5jZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2NsaXBQb2ludHMoKTtcblx0XHR0aGlzLl9zaW1wbGlmeVBvaW50cygpO1xuXHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMpO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5wb2x5bGluZShsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBwb2x5bGluZSBvYmplY3QgZ2l2ZW4gYW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cyBhbmRcbi8vIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuIFlvdSBjYW4gY3JlYXRlIGEgYFBvbHlsaW5lYCBvYmplY3Qgd2l0aFxuLy8gbXVsdGlwbGUgc2VwYXJhdGUgbGluZXMgKGBNdWx0aVBvbHlsaW5lYCkgYnkgcGFzc2luZyBhbiBhcnJheSBvZiBhcnJheXNcbi8vIG9mIGdlb2dyYXBoaWMgcG9pbnRzLlxuTC5wb2x5bGluZSA9IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5Qb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcbn07XG5cbkwuUG9seWxpbmUuX2ZsYXQgPSBmdW5jdGlvbiAobGF0bG5ncykge1xuXHQvLyB0cnVlIGlmIGl0J3MgYSBmbGF0IGFycmF5IG9mIGxhdGxuZ3M7IGZhbHNlIGlmIG5lc3RlZFxuXHRyZXR1cm4gIUwuVXRpbC5pc0FycmF5KGxhdGxuZ3NbMF0pIHx8ICh0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICd1bmRlZmluZWQnKTtcbn07XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgUG9seVV0aWxcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWdvbiBnZW9tZXRyaWVzLlxyXG4gKi9cclxuXHJcbkwuUG9seVV0aWwgPSB7fTtcclxuXHJcbi8qIEBmdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHM6IFBvaW50W10sIGJvdW5kczogQm91bmRzLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdXHJcbiAqIENsaXBzIHRoZSBwb2x5Z29uIGdlb21ldHJ5IGRlZmluZWQgYnkgdGhlIGdpdmVuIGBwb2ludHNgIGJ5IHRoZSBnaXZlbiBib3VuZHMgKHVzaW5nIHRoZSBbU3V0aGVybGFuZC1Ib2RnZW1hbiBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1dGhlcmxhbmQlRTIlODAlOTNIb2RnbWFuX2FsZ29yaXRobSkpLlxyXG4gKiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlnb24gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZ1xyXG4gKiBwZXJmb3JtYW5jZS4gTm90ZSB0aGF0IHBvbHlnb24gcG9pbnRzIG5lZWRzIGRpZmZlcmVudCBhbGdvcml0aG0gZm9yIGNsaXBwaW5nXHJcbiAqIHRoYW4gcG9seWxpbmUsIHNvIHRoZXJlJ3MgYSBzZXBlcmF0ZSBtZXRob2QgZm9yIGl0LlxyXG4gKi9cclxuTC5Qb2x5VXRpbC5jbGlwUG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMsIGJvdW5kcywgcm91bmQpIHtcclxuXHR2YXIgY2xpcHBlZFBvaW50cyxcclxuXHQgICAgZWRnZXMgPSBbMSwgNCwgMiwgOF0sXHJcblx0ICAgIGksIGosIGssXHJcblx0ICAgIGEsIGIsXHJcblx0ICAgIGxlbiwgZWRnZSwgcCxcclxuXHQgICAgbHUgPSBMLkxpbmVVdGlsO1xyXG5cclxuXHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHBvaW50c1tpXS5fY29kZSA9IGx1Ll9nZXRCaXRDb2RlKHBvaW50c1tpXSwgYm91bmRzKTtcclxuXHR9XHJcblxyXG5cdC8vIGZvciBlYWNoIGVkZ2UgKGxlZnQsIGJvdHRvbSwgcmlnaHQsIHRvcClcclxuXHRmb3IgKGsgPSAwOyBrIDwgNDsgaysrKSB7XHJcblx0XHRlZGdlID0gZWRnZXNba107XHJcblx0XHRjbGlwcGVkUG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcclxuXHRcdFx0YSA9IHBvaW50c1tpXTtcclxuXHRcdFx0YiA9IHBvaW50c1tqXTtcclxuXHJcblx0XHRcdC8vIGlmIGEgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvd1xyXG5cdFx0XHRpZiAoIShhLl9jb2RlICYgZWRnZSkpIHtcclxuXHRcdFx0XHQvLyBpZiBiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGdvZXMgb3V0IG9mIHNjcmVlbilcclxuXHRcdFx0XHRpZiAoYi5fY29kZSAmIGVkZ2UpIHtcclxuXHRcdFx0XHRcdHAgPSBsdS5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRcdHAuX2NvZGUgPSBsdS5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG5cdFx0XHQvLyBlbHNlIGlmIGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBlbnRlcnMgdGhlIHNjcmVlbilcclxuXHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdHAgPSBsdS5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRwLl9jb2RlID0gbHUuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHBvaW50cyA9IGNsaXBwZWRQb2ludHM7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59O1xyXG5cbi8qXG4gKiBAY2xhc3MgUG9seWdvblxuICogQGFrYSBMLlBvbHlnb25cbiAqIEBpbmhlcml0cyBQb2x5bGluZVxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWdvbiBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWxpbmVgLlxuICpcbiAqIE5vdGUgdGhhdCBwb2ludHMgeW91IHBhc3Mgd2hlbiBjcmVhdGluZyBhIHBvbHlnb24gc2hvdWxkbid0IGhhdmUgYW4gYWRkaXRpb25hbCBsYXN0IHBvaW50IGVxdWFsIHRvIHRoZSBmaXJzdCBvbmUg4oCUIGl0J3MgYmV0dGVyIHRvIGZpbHRlciBvdXQgc3VjaCBwb2ludHMuXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5Z29uIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbWy0xMTEuMDMsIDQxXSxbLTExMS4wNCwgNDVdLFstMTA0LjA1LCA0NV0sWy0xMDQuMDUsIDQxXV07XG4gKlxuICogdmFyIHBvbHlnb24gPSBMLnBvbHlnb24obGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5Z29uXG4gKiBtYXAuZml0Qm91bmRzKHBvbHlnb24uZ2V0Qm91bmRzKCkpO1xuICogYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIHBhc3MgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGxhdGxuZ3MsIHdpdGggdGhlIGZpcnN0IGFycmF5IHJlcHJlc2VudGluZyB0aGUgb3V0ZXIgc2hhcGUgYW5kIHRoZSBvdGhlciBhcnJheXMgcmVwcmVzZW50aW5nIGhvbGVzIGluIHRoZSBvdXRlciBzaGFwZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiAgIFtbLTExMS4wMywgNDFdLFstMTExLjA0LCA0NV0sWy0xMDQuMDUsIDQ1XSxbLTEwNC4wNSwgNDFdXSwgLy8gb3V0ZXIgcmluZ1xuICogICBbWy0xMDguNTgsMzcuMjldLFstMTA4LjU4LDQwLjcxXSxbLTEwMi41MCw0MC43MV0sWy0xMDIuNTAsMzcuMjldXSAvLyBob2xlXG4gKiBdO1xuICogYGBgXG4gKlxuICogQWRkaXRpb25hbGx5LCB5b3UgY2FuIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBNdWx0aVBvbHlnb24gc2hhcGUuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbIC8vIGZpcnN0IHBvbHlnb25cbiAqICAgICBbWy0xMTEuMDMsIDQxXSxbLTExMS4wNCwgNDVdLFstMTA0LjA1LCA0NV0sWy0xMDQuMDUsIDQxXV0sIC8vIG91dGVyIHJpbmdcbiAqICAgICBbWy0xMDguNTgsMzcuMjldLFstMTA4LjU4LDQwLjcxXSxbLTEwMi41MCw0MC43MV0sWy0xMDIuNTAsMzcuMjldXSAvLyBob2xlXG4gKiAgIF0sXG4gKiAgIFsgLy8gc2Vjb25kIHBvbHlnb25cbiAqICAgICBbWy0xMDkuMDUsIDM3XSxbLTEwOS4wMywgNDFdLFstMTAyLjA1LCA0MV0sWy0xMDIuMDQsIDM3XSxbLTEwOS4wNSwgMzhdXVxuICogICBdXG4gKiBdO1xuICogYGBgXG4gKi9cblxuTC5Qb2x5Z29uID0gTC5Qb2x5bGluZS5leHRlbmQoe1xuXG5cdG9wdGlvbnM6IHtcblx0XHRmaWxsOiB0cnVlXG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGggfHwgIXRoaXMuX2xhdGxuZ3NbMF0ubGVuZ3RoO1xuXHR9LFxuXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcblx0XHR9XG5cblx0XHR2YXIgaSwgaiwgcDEsIHAyLCBmLCBhcmVhLCB4LCB5LCBjZW50ZXIsXG5cdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdLFxuXHRcdCAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuIG51bGw7IH1cblxuXHRcdC8vIHBvbHlnb24gY2VudHJvaWQgYWxnb3JpdGhtOyBvbmx5IHVzZXMgdGhlIGZpcnN0IHJpbmcgaWYgdGhlcmUgYXJlIG11bHRpcGxlXG5cblx0XHRhcmVhID0geCA9IHkgPSAwO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcblx0XHRcdHAxID0gcG9pbnRzW2ldO1xuXHRcdFx0cDIgPSBwb2ludHNbal07XG5cblx0XHRcdGYgPSBwMS55ICogcDIueCAtIHAyLnkgKiBwMS54O1xuXHRcdFx0eCArPSAocDEueCArIHAyLngpICogZjtcblx0XHRcdHkgKz0gKHAxLnkgKyBwMi55KSAqIGY7XG5cdFx0XHRhcmVhICs9IGYgKiAzO1xuXHRcdH1cblxuXHRcdGlmIChhcmVhID09PSAwKSB7XG5cdFx0XHQvLyBQb2x5Z29uIGlzIHNvIHNtYWxsIHRoYXQgYWxsIHBvaW50cyBhcmUgb24gc2FtZSBwaXhlbC5cblx0XHRcdGNlbnRlciA9IHBvaW50c1swXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2VudGVyID0gW3ggLyBhcmVhLCB5IC8gYXJlYV07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGNlbnRlcik7XG5cdH0sXG5cblx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciByZXN1bHQgPSBMLlBvbHlsaW5lLnByb3RvdHlwZS5fY29udmVydExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKSxcblx0XHQgICAgbGVuID0gcmVzdWx0Lmxlbmd0aDtcblxuXHRcdC8vIHJlbW92ZSBsYXN0IHBvaW50IGlmIGl0IGVxdWFscyBmaXJzdCBvbmVcblx0XHRpZiAobGVuID49IDIgJiYgcmVzdWx0WzBdIGluc3RhbmNlb2YgTC5MYXRMbmcgJiYgcmVzdWx0WzBdLmVxdWFscyhyZXN1bHRbbGVuIC0gMV0pKSB7XG5cdFx0XHRyZXN1bHQucG9wKCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0TC5Qb2x5bGluZS5wcm90b3R5cGUuX3NldExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKTtcblx0XHRpZiAoTC5Qb2x5bGluZS5fZmxhdCh0aGlzLl9sYXRsbmdzKSkge1xuXHRcdFx0dGhpcy5fbGF0bG5ncyA9IFt0aGlzLl9sYXRsbmdzXTtcblx0XHR9XG5cdH0sXG5cblx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBMLlBvbHlsaW5lLl9mbGF0KHRoaXMuX2xhdGxuZ3NbMF0pID8gdGhpcy5fbGF0bG5nc1swXSA6IHRoaXMuX2xhdGxuZ3NbMF1bMF07XG5cdH0sXG5cblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwb2x5Z29ucyBuZWVkIGEgZGlmZmVyZW50IGNsaXBwaW5nIGFsZ29yaXRobSBzbyB3ZSByZWRlZmluZSB0aGF0XG5cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcyxcblx0XHQgICAgdyA9IHRoaXMub3B0aW9ucy53ZWlnaHQsXG5cdFx0ICAgIHAgPSBuZXcgTC5Qb2ludCh3LCB3KTtcblxuXHRcdC8vIGluY3JlYXNlIGNsaXAgcGFkZGluZyBieSBzdHJva2Ugd2lkdGggdG8gYXZvaWQgc3Ryb2tlIG9uIGNsaXAgZWRnZXNcblx0XHRib3VuZHMgPSBuZXcgTC5Cb3VuZHMoYm91bmRzLm1pbi5zdWJ0cmFjdChwKSwgYm91bmRzLm1heC5hZGQocCkpO1xuXG5cdFx0dGhpcy5fcGFydHMgPSBbXTtcblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoLCBjbGlwcGVkOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGNsaXBwZWQgPSBMLlBvbHlVdGlsLmNsaXBQb2x5Z29uKHRoaXMuX3JpbmdzW2ldLCBib3VuZHMsIHRydWUpO1xuXHRcdFx0aWYgKGNsaXBwZWQubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX3BhcnRzLnB1c2goY2xpcHBlZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcywgdHJ1ZSk7XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwucG9seWdvbihsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5MLnBvbHlnb24gPSBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcbn07XG5cbi8qXG4gKiBMLlJlY3RhbmdsZSBleHRlbmRzIFBvbHlnb24gYW5kIGNyZWF0ZXMgYSByZWN0YW5nbGUgd2hlbiBwYXNzZWQgYSBMYXRMbmdCb3VuZHMgb2JqZWN0LlxuICovXG5cbi8qXG4gKiBAY2xhc3MgUmVjdGFuZ2xlXG4gKiBAYWthIEwuUmV0YW5nbGVcbiAqIEBpbmhlcml0cyBQb2x5Z29uXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyByZWN0YW5nbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlnb25gLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGRlZmluZSByZWN0YW5nbGUgZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuICogdmFyIGJvdW5kcyA9IFtbNTQuNTU5MzIyLCAtNS43Njc4MjJdLCBbNTYuMTIxMDYwNCwgLTMuMDIxMjQwXV07XG4gKlxuICogLy8gY3JlYXRlIGFuIG9yYW5nZSByZWN0YW5nbGVcbiAqIEwucmVjdGFuZ2xlKGJvdW5kcywge2NvbG9yOiBcIiNmZjc4MDBcIiwgd2VpZ2h0OiAxfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHJlY3RhbmdsZSBib3VuZHNcbiAqIG1hcC5maXRCb3VuZHMoYm91bmRzKTtcbiAqIGBgYFxuICpcbiAqL1xuXG5cbkwuUmVjdGFuZ2xlID0gTC5Qb2x5Z29uLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcblx0XHRMLlBvbHlnb24ucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSwgb3B0aW9ucyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIHJlY3RhbmdsZSB3aXRoIHRoZSBwYXNzZWQgYm91bmRzLlxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRMYXRMbmdzKHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpKTtcblx0fSxcblxuXHRfYm91bmRzVG9MYXRMbmdzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG5cdFx0bGF0TG5nQm91bmRzID0gTC5sYXRMbmdCb3VuZHMobGF0TG5nQm91bmRzKTtcblx0XHRyZXR1cm4gW1xuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpXG5cdFx0XTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5yZWN0YW5nbGUobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuTC5yZWN0YW5nbGUgPSBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5SZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKTtcbn07XG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlTWFya2VyXG4gKiBAYWthIEwuQ2lyY2xlTWFya2VyXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2lyY2xlIG9mIGEgZml4ZWQgc2l6ZSB3aXRoIHJhZGl1cyBzcGVjaWZpZWQgaW4gcGl4ZWxzLiBFeHRlbmRzIGBQYXRoYC5cbiAqL1xuXG5MLkNpcmNsZU1hcmtlciA9IEwuUGF0aC5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgQ2lyY2xlTWFya2VyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdGZpbGw6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyID0gMTBcblx0XHQvLyBSYWRpdXMgb2YgdGhlIGNpcmNsZSBtYXJrZXIsIGluIHBpeGVsc1xuXHRcdHJhZGl1czogMTBcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX2xhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XG5cdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRMbmc6IExhdExuZyk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYSBjaXJjbGUgbWFya2VyIHRvIGEgbmV3IGxvY2F0aW9uLlxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMucmVkcmF3KCk7XG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUgbWFya2VyLiBVbml0cyBhcmUgaW4gcGl4ZWxzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLm9wdGlvbnMucmFkaXVzID0gdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiB0aGUgY2lyY2xlXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXM7XG5cdH0sXG5cblx0c2V0U3R5bGUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdHZhciByYWRpdXMgPSBvcHRpb25zICYmIG9wdGlvbnMucmFkaXVzIHx8IHRoaXMuX3JhZGl1cztcblx0XHRMLlBhdGgucHJvdG90eXBlLnNldFN0eWxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5zZXRSYWRpdXMocmFkaXVzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHR9LFxuXG5cdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgciA9IHRoaXMuX3JhZGl1cyxcblx0XHQgICAgcjIgPSB0aGlzLl9yYWRpdXNZIHx8IHIsXG5cdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuXHRcdCAgICBwID0gW3IgKyB3LCByMiArIHddO1xuXHRcdHRoaXMuX3B4Qm91bmRzID0gbmV3IEwuQm91bmRzKHRoaXMuX3BvaW50LnN1YnRyYWN0KHApLCB0aGlzLl9wb2ludC5hZGQocCkpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZUNpcmNsZSh0aGlzKTtcblx0fSxcblxuXHRfZW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzICYmICF0aGlzLl9yZW5kZXJlci5fYm91bmRzLmludGVyc2VjdHModGhpcy5fcHhCb3VuZHMpO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZU1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZU1hcmtlciBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbkwuY2lyY2xlTWFya2VyID0gZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuQ2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XG59O1xuXG4vKlxuICogQGNsYXNzIENpcmNsZVxuICogQGFrYSBMLkNpcmNsZVxuICogQGluaGVyaXRzIENpcmNsZU1hcmtlclxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgY2lyY2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBDaXJjbGVNYXJrZXJgLlxuICpcbiAqIEl0J3MgYW4gYXBwcm94aW1hdGlvbiBhbmQgc3RhcnRzIHRvIGRpdmVyZ2UgZnJvbSBhIHJlYWwgY2lyY2xlIGNsb3NlciB0byBwb2xlcyAoZHVlIHRvIHByb2plY3Rpb24gZGlzdG9ydGlvbikuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogTC5jaXJjbGUoWzUwLjUsIDMwLjVdLCB7cmFkaXVzOiAyMDB9KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxuTC5DaXJjbGUgPSBMLkNpcmNsZU1hcmtlci5leHRlbmQoe1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGZhY3RvcnkgKGxhdGxuZywgcmFkaXVzLCBvcHRpb25zPylcblx0XHRcdG9wdGlvbnMgPSBMLmV4dGVuZCh7fSwgbGVnYWN5T3B0aW9ucywge3JhZGl1czogb3B0aW9uc30pO1xuXHRcdH1cblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcblxuXHRcdGlmIChpc05hTih0aGlzLm9wdGlvbnMucmFkaXVzKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0NpcmNsZSByYWRpdXMgY2Fubm90IGJlIE5hTicpOyB9XG5cblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIEBha2EgQ2lyY2xlIG9wdGlvbnNcblx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyOyBSYWRpdXMgb2YgdGhlIGNpcmNsZSwgaW4gbWV0ZXJzLlxuXHRcdHRoaXMuX21SYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG5cdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuXHRcdHRoaXMuX21SYWRpdXMgPSByYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbVJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBoYWxmID0gW3RoaXMuX3JhZGl1cywgdGhpcy5fcmFkaXVzWSB8fCB0aGlzLl9yYWRpdXNdO1xuXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuc3VidHJhY3QoaGFsZikpLFxuXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5hZGQoaGFsZikpKTtcblx0fSxcblxuXHRzZXRTdHlsZTogTC5QYXRoLnByb3RvdHlwZS5zZXRTdHlsZSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGxuZyA9IHRoaXMuX2xhdGxuZy5sbmcsXG5cdFx0ICAgIGxhdCA9IHRoaXMuX2xhdGxuZy5sYXQsXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0aWYgKGNycy5kaXN0YW5jZSA9PT0gTC5DUlMuRWFydGguZGlzdGFuY2UpIHtcblx0XHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdCAgICBsYXRSID0gKHRoaXMuX21SYWRpdXMgLyBMLkNSUy5FYXJ0aC5SKSAvIGQsXG5cdFx0XHQgICAgdG9wID0gbWFwLnByb2plY3QoW2xhdCArIGxhdFIsIGxuZ10pLFxuXHRcdFx0ICAgIGJvdHRvbSA9IG1hcC5wcm9qZWN0KFtsYXQgLSBsYXRSLCBsbmddKSxcblx0XHRcdCAgICBwID0gdG9wLmFkZChib3R0b20pLmRpdmlkZUJ5KDIpLFxuXHRcdFx0ICAgIGxhdDIgPSBtYXAudW5wcm9qZWN0KHApLmxhdCxcblx0XHRcdCAgICBsbmdSID0gTWF0aC5hY29zKChNYXRoLmNvcyhsYXRSICogZCkgLSBNYXRoLnNpbihsYXQgKiBkKSAqIE1hdGguc2luKGxhdDIgKiBkKSkgL1xuXHRcdFx0ICAgICAgICAgICAgKE1hdGguY29zKGxhdCAqIGQpICogTWF0aC5jb3MobGF0MiAqIGQpKSkgLyBkO1xuXG5cdFx0XHRpZiAoaXNOYU4obG5nUikgfHwgbG5nUiA9PT0gMCkge1xuXHRcdFx0XHRsbmdSID0gbGF0UiAvIE1hdGguY29zKE1hdGguUEkgLyAxODAgKiBsYXQpOyAvLyBGYWxsYmFjayBmb3IgZWRnZSBjYXNlLCAjMjQyNVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9wb2ludCA9IHAuc3VidHJhY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gaXNOYU4obG5nUikgPyAwIDogTWF0aC5tYXgoTWF0aC5yb3VuZChwLnggLSBtYXAucHJvamVjdChbbGF0MiwgbG5nIC0gbG5nUl0pLngpLCAxKTtcblx0XHRcdHRoaXMuX3JhZGl1c1kgPSBNYXRoLm1heChNYXRoLnJvdW5kKHAueSAtIHRvcC55KSwgMSk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGxhdGxuZzIgPSBjcnMudW5wcm9qZWN0KGNycy5wcm9qZWN0KHRoaXMuX2xhdGxuZykuc3VidHJhY3QoW3RoaXMuX21SYWRpdXMsIDBdKSk7XG5cblx0XHRcdHRoaXMuX3BvaW50ID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5fcG9pbnQueCAtIG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nMikueDtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9ucyBvYmplY3Rcbi8vIHdoaWNoIGNvbnRhaW5zIHRoZSBjaXJjbGUgcmFkaXVzLlxuLy8gQGFsdGVybmF0aXZlXG4vLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgcmFkaXVzOiBOdW1iZXIsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbi8vIE9ic29sZXRlIHdheSBvZiBpbnN0YW50aWF0aW5nIGEgY2lyY2xlLCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGNvZGUuXG4vLyBEbyBub3QgdXNlIGluIG5ldyBhcHBsaWNhdGlvbnMgb3IgcGx1Z2lucy5cbkwuY2lyY2xlID0gZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuQ2lyY2xlKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucyk7XG59O1xuXG4vKlxuICogQGNsYXNzIFNWR1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuU1ZHXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXN2ZyksIFNWRyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IEFuZHJvaWQgMi54IGFuZCAzLnguXG4gKlxuICogQWx0aG91Z2ggU1ZHIGlzIG5vdCBhdmFpbGFibGUgb24gSUU3IGFuZCBJRTgsIHRoZXNlIGJyb3dzZXJzIHN1cHBvcnRcbiAqIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpXG4gKiAoYSBub3cgZGVwcmVjYXRlZCB0ZWNobm9sb2d5KSwgYW5kIHRoZSBTVkcgcmVuZGVyZXIgd2lsbCBmYWxsIGJhY2sgdG8gVk1MIGluXG4gKiB0aGlzIGNhc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBVc2UgU1ZHIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAqIFx0cmVuZGVyZXI6IEwuc3ZnKClcbiAqIH0pO1xuICogYGBgXG4gKlxuICogVXNlIGEgU1ZHIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gKiB2YXIgbXlSZW5kZXJlciA9IEwuc3ZnKHsgcGFkZGluZzogMC41IH0pO1xuICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiBgYGBcbiAqL1xuXG5MLlNWRyA9IEwuUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0gTC5SZW5kZXJlci5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cdFx0ZXZlbnRzLnpvb21zdGFydCA9IHRoaXMuX29uWm9vbVN0YXJ0O1xuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBMLlNWRy5jcmVhdGUoJ3N2ZycpO1xuXG5cdFx0Ly8gbWFrZXMgaXQgcG9zc2libGUgdG8gY2xpY2sgdGhyb3VnaCBzdmcgcm9vdDsgd2UnbGwgcmVzZXQgaXQgYmFjayBpbiBpbmRpdmlkdWFsIHBhdGhzXG5cdFx0dGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuXG5cdFx0dGhpcy5fcm9vdEdyb3VwID0gTC5TVkcuY3JlYXRlKCdnJyk7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3Jvb3RHcm91cCk7XG5cdH0sXG5cblx0X29uWm9vbVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gRHJhZy10aGVuLXBpbmNoIGludGVyYWN0aW9ucyBtaWdodCBtZXNzIHVwIHRoZSBjZW50ZXIgYW5kIHpvb20uXG5cdFx0Ly8gSW4gdGhpcyBjYXNlLCB0aGUgZWFzaWVzdCB3YXkgdG8gcHJldmVudCB0aGlzIGlzIHJlLWRvIHRoZSByZW5kZXJlclxuXHRcdC8vICAgYm91bmRzIGFuZCBwYWRkaW5nIHdoZW4gdGhlIHpvb21pbmcgc3RhcnRzLlxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuXHRcdEwuUmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblxuXHRcdC8vIHNldCBzaXplIG9mIHN2Zy1jb250YWluZXIgaWYgY2hhbmdlZFxuXHRcdGlmICghdGhpcy5fc3ZnU2l6ZSB8fCAhdGhpcy5fc3ZnU2l6ZS5lcXVhbHMoc2l6ZSkpIHtcblx0XHRcdHRoaXMuX3N2Z1NpemUgPSBzaXplO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplLngpO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2l6ZS55KTtcblx0XHR9XG5cblx0XHQvLyBtb3ZlbWVudDogdXBkYXRlIGNvbnRhaW5lciB2aWV3Qm94IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjaGFuZ2UgY29vcmRpbmF0ZXMgb2YgaW5kaXZpZHVhbCBsYXllcnNcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFtiLm1pbi54LCBiLm1pbi55LCBzaXplLngsIHNpemUueV0uam9pbignICcpKTtcblxuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0Ly8gbWV0aG9kcyBiZWxvdyBhcmUgY2FsbGVkIGJ5IHZlY3RvciBsYXllcnMgaW1wbGVtZW50YXRpb25zXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoID0gTC5TVkcuY3JlYXRlKCdwYXRoJyk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIFBhdGhcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEN1c3RvbSBjbGFzcyBuYW1lIHNldCBvbiBhbiBlbGVtZW50LiBPbmx5IGZvciBTVkcgcmVuZGVyZXIuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKSB7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MocGF0aCwgbGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpO1xuXHRcdH1cblxuXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MocGF0aCwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3Jvb3RHcm91cC5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQobGF5ZXIuX3BhdGgpO1xuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRMLkRvbVV0aWwucmVtb3ZlKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCxcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cblx0XHRpZiAoIXBhdGgpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCBvcHRpb25zLmNvbG9yKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utb3BhY2l0eScsIG9wdGlvbnMub3BhY2l0eSk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgb3B0aW9ucy53ZWlnaHQpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgb3B0aW9ucy5saW5lQ2FwKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCBvcHRpb25zLmxpbmVKb2luKTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jywgb3B0aW9ucy5kYXNoQXJyYXkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaE9mZnNldCkge1xuXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnLCBvcHRpb25zLmRhc2hPZmZzZXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnbm9uZScpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcik7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1vcGFjaXR5Jywgb3B0aW9ucy5maWxsT3BhY2l0eSk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1ydWxlJywgb3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIEwuU1ZHLnBvaW50c1RvUGF0aChsYXllci5fcGFydHMsIGNsb3NlZCkpO1xuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuXHRcdCAgICByID0gbGF5ZXIuX3JhZGl1cyxcblx0XHQgICAgcjIgPSBsYXllci5fcmFkaXVzWSB8fCByLFxuXHRcdCAgICBhcmMgPSAnYScgKyByICsgJywnICsgcjIgKyAnIDAgMSwwICc7XG5cblx0XHQvLyBkcmF3aW5nIGEgY2lyY2xlIHdpdGggdHdvIGhhbGYtYXJjc1xuXHRcdHZhciBkID0gbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0XHQnTScgKyAocC54IC0gcikgKyAnLCcgKyBwLnkgK1xuXHRcdFx0XHRhcmMgKyAociAqIDIpICsgJywwICcgK1xuXHRcdFx0XHRhcmMgKyAoLXIgKiAyKSArICcsMCAnO1xuXG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgZCk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGgpO1xuXHR9LFxuXG5cdC8vIFNWRyBkb2VzIG5vdCBoYXZlIHRoZSBjb25jZXB0IG9mIHpJbmRleCBzbyB3ZSByZXNvcnQgdG8gY2hhbmdpbmcgdGhlIERPTSBvcmRlciBvZiBlbGVtZW50c1xuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRMLkRvbVV0aWwudG9Gcm9udChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRMLkRvbVV0aWwudG9CYWNrKGxheWVyLl9wYXRoKTtcblx0fVxufSk7XG5cblxuLy8gQG5hbWVzcGFjZSBTVkc7IEBzZWN0aW9uXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuU1ZHOlxuTC5leHRlbmQoTC5TVkcsIHtcblx0Ly8gQGZ1bmN0aW9uIGNyZWF0ZShuYW1lOiBTdHJpbmcpOiBTVkdFbGVtZW50XG5cdC8vIFJldHVybnMgYSBpbnN0YW5jZSBvZiBbU1ZHRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpLFxuXHQvLyBjb3JyZXNwb25kaW5nIHRvIHRoZSBjbGFzcyBuYW1lIHBhc3NlZC4gRm9yIGV4YW1wbGUsIHVzaW5nICdsaW5lJyB3aWxsIHJldHVyblxuXHQvLyBhbiBpbnN0YW5jZSBvZiBbU1ZHTGluZUVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdMaW5lRWxlbWVudCkuXG5cdGNyZWF0ZTogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xuXHR9LFxuXG5cdC8vIEBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3M6IFBvaW50W10sIGNsb3NlZDogQm9vbGVhbik6IFN0cmluZ1xuXHQvLyBHZW5lcmF0ZXMgYSBTVkcgcGF0aCBzdHJpbmcgZm9yIG11bHRpcGxlIHJpbmdzLCB3aXRoIGVhY2ggcmluZyB0dXJuaW5nXG5cdC8vIGludG8gXCJNLi5MLi5MLi5cIiBpbnN0cnVjdGlvbnNcblx0cG9pbnRzVG9QYXRoOiBmdW5jdGlvbiAocmluZ3MsIGNsb3NlZCkge1xuXHRcdHZhciBzdHIgPSAnJyxcblx0XHQgICAgaSwgaiwgbGVuLCBsZW4yLCBwb2ludHMsIHA7XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cG9pbnRzID0gcmluZ3NbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRcdHAgPSBwb2ludHNbal07XG5cdFx0XHRcdHN0ciArPSAoaiA/ICdMJyA6ICdNJykgKyBwLnggKyAnICcgKyBwLnk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNsb3NlcyB0aGUgcmluZyBmb3IgcG9seWdvbnM7IFwieFwiIGlzIFZNTCBzeW50YXhcblx0XHRcdHN0ciArPSBjbG9zZWQgPyAoTC5Ccm93c2VyLnN2ZyA/ICd6JyA6ICd4JykgOiAnJztcblx0XHR9XG5cblx0XHQvLyBTVkcgY29tcGxhaW5zIGFib3V0IGVtcHR5IHBhdGggc3RyaW5nc1xuXHRcdHJldHVybiBzdHIgfHwgJ00wIDAnO1xuXHR9XG59KTtcblxuLy8gQG5hbWVzcGFjZSBCcm93c2VyOyBAcHJvcGVydHkgc3ZnOiBCb29sZWFuXG4vLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbU1ZHXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcpLlxuTC5Ccm93c2VyLnN2ZyA9ICEhKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiBMLlNWRy5jcmVhdGUoJ3N2ZycpLmNyZWF0ZVNWR1JlY3QpO1xuXG5cbi8vIEBuYW1lc3BhY2UgU1ZHXG4vLyBAZmFjdG9yeSBMLnN2ZyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBTVkcgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbkwuc3ZnID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIEwuQnJvd3Nlci5zdmcgfHwgTC5Ccm93c2VyLnZtbCA/IG5ldyBMLlNWRyhvcHRpb25zKSA6IG51bGw7XG59O1xuXG4vKlxuICogVGhhbmtzIHRvIERtaXRyeSBCYXJhbm92c2t5IGFuZCBoaXMgUmFwaGFlbCBsaWJyYXJ5IGZvciBpbnNwaXJhdGlvbiFcbiAqL1xuXG4vKlxuICogQGNsYXNzIFNWR1xuICpcbiAqIEFsdGhvdWdoIFNWRyBpcyBub3QgYXZhaWxhYmxlIG9uIElFNyBhbmQgSUU4LCB0aGVzZSBicm93c2VycyBzdXBwb3J0IFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpLCBhbmQgdGhlIFNWRyByZW5kZXJlciB3aWxsIGZhbGwgYmFjayB0byBWTUwgaW4gdGhpcyBjYXNlLlxuICpcbiAqIFZNTCB3YXMgZGVwcmVjYXRlZCBpbiAyMDEyLCB3aGljaCBtZWFucyBWTUwgZnVuY3Rpb25hbGl0eSBleGlzdHMgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqIHdpdGggb2xkIHZlcnNpb25zIG9mIEludGVybmV0IEV4cGxvcmVyLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgQnJvd3NlcjsgQHByb3BlcnR5IHZtbDogQm9vbGVhblxuLy8gYHRydWVgIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpLlxuTC5Ccm93c2VyLnZtbCA9ICFMLkJyb3dzZXIuc3ZnICYmIChmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdGRpdi5pbm5lckhUTUwgPSAnPHY6c2hhcGUgYWRqPVwiMVwiLz4nO1xuXG5cdFx0dmFyIHNoYXBlID0gZGl2LmZpcnN0Q2hpbGQ7XG5cdFx0c2hhcGUuc3R5bGUuYmVoYXZpb3IgPSAndXJsKCNkZWZhdWx0I1ZNTCknO1xuXG5cdFx0cmV0dXJuIHNoYXBlICYmICh0eXBlb2Ygc2hhcGUuYWRqID09PSAnb2JqZWN0Jyk7XG5cblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSgpKTtcblxuLy8gcmVkZWZpbmUgc29tZSBTVkcgbWV0aG9kcyB0byBoYW5kbGUgVk1MIHN5bnRheCB3aGljaCBpcyBzaW1pbGFyIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXNcbkwuU1ZHLmluY2x1ZGUoIUwuQnJvd3Nlci52bWwgPyB7fSA6IHtcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXZtbC1jb250YWluZXInKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblx0XHRMLlJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyID0gTC5TVkcuY3JlYXRlKCdzaGFwZScpO1xuXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdm1sLXNoYXBlICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXG5cdFx0Y29udGFpbmVyLmNvb3Jkc2l6ZSA9ICcxIDEnO1xuXG5cdFx0bGF5ZXIuX3BhdGggPSBMLlNWRy5jcmVhdGUoJ3BhdGgnKTtcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGF5ZXIuX3BhdGgpO1xuXG5cdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG5cdFx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZShjb250YWluZXIpO1xuXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgc3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSxcblx0XHQgICAgZmlsbCA9IGxheWVyLl9maWxsLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucyxcblx0XHQgICAgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblxuXHRcdGNvbnRhaW5lci5zdHJva2VkID0gISFvcHRpb25zLnN0cm9rZTtcblx0XHRjb250YWluZXIuZmlsbGVkID0gISFvcHRpb25zLmZpbGw7XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcblx0XHRcdGlmICghc3Ryb2tlKSB7XG5cdFx0XHRcdHN0cm9rZSA9IGxheWVyLl9zdHJva2UgPSBMLlNWRy5jcmVhdGUoJ3N0cm9rZScpO1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHN0cm9rZSk7XG5cdFx0XHRzdHJva2Uud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQgKyAncHgnO1xuXHRcdFx0c3Ryb2tlLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdHN0cm9rZS5vcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9IEwuVXRpbC5pc0FycmF5KG9wdGlvbnMuZGFzaEFycmF5KSA/XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5qb2luKCcgJykgOlxuXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkucmVwbGFjZSgvKCAqLCAqKS9nLCAnICcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9ICcnO1xuXHRcdFx0fVxuXHRcdFx0c3Ryb2tlLmVuZGNhcCA9IG9wdGlvbnMubGluZUNhcC5yZXBsYWNlKCdidXR0JywgJ2ZsYXQnKTtcblx0XHRcdHN0cm9rZS5qb2luc3R5bGUgPSBvcHRpb25zLmxpbmVKb2luO1xuXG5cdFx0fSBlbHNlIGlmIChzdHJva2UpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChzdHJva2UpO1xuXHRcdFx0bGF5ZXIuX3N0cm9rZSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0aWYgKCFmaWxsKSB7XG5cdFx0XHRcdGZpbGwgPSBsYXllci5fZmlsbCA9IEwuU1ZHLmNyZWF0ZSgnZmlsbCcpO1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGZpbGwpO1xuXHRcdFx0ZmlsbC5jb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRmaWxsLm9wYWNpdHkgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuXG5cdFx0fSBlbHNlIGlmIChmaWxsKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoZmlsbCk7XG5cdFx0XHRsYXllci5fZmlsbCA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LnJvdW5kKCksXG5cdFx0ICAgIHIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLFxuXHRcdCAgICByMiA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kgfHwgcik7XG5cblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG5cdFx0XHRcdCdBTCAnICsgcC54ICsgJywnICsgcC55ICsgJyAnICsgciArICcsJyArIHIyICsgJyAwLCcgKyAoNjU1MzUgKiAzNjApKTtcblx0fSxcblxuXHRfc2V0UGF0aDogZnVuY3Rpb24gKGxheWVyLCBwYXRoKSB7XG5cdFx0bGF5ZXIuX3BhdGgudiA9IHBhdGg7XG5cdH0sXG5cblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0TC5Eb21VdGlsLnRvRnJvbnQobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRMLkRvbVV0aWwudG9CYWNrKGxheWVyLl9jb250YWluZXIpO1xuXHR9XG59KTtcblxuaWYgKEwuQnJvd3Nlci52bWwpIHtcblx0TC5TVkcuY3JlYXRlID0gKGZ1bmN0aW9uICgpIHtcblx0XHR0cnkge1xuXHRcdFx0ZG9jdW1lbnQubmFtZXNwYWNlcy5hZGQoJ2x2bWwnLCAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGx2bWw6JyArIG5hbWUgKyAnIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzwnICsgbmFtZSArICcgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0pKCk7XG59XG5cbi8qXG4gKiBAY2xhc3MgQ2FudmFzXG4gKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAqIEBha2EgTC5DYW52YXNcbiAqXG4gKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxuICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAqXG4gKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9Y2FudmFzKSwgQ2FudmFzIGlzIG5vdFxuICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgSUU4LCBhbmQgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcyBtaWdodFxuICogbm90IGRpc3BsYXkgcHJvcGVybHkgaW4gc29tZSBlZGdlIGNhc2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIENhbnZhcyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLmNhbnZhcygpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIENhbnZhcyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLmNhbnZhcyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxuTC5DYW52YXMgPSBMLlJlbmRlcmVyLmV4dGVuZCh7XG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHRMLlJlbmRlcmVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMpO1xuXG5cdFx0dGhpcy5fbGF5ZXJzID0gdGhpcy5fbGF5ZXJzIHx8IHt9O1xuXG5cdFx0Ly8gUmVkcmF3IHZlY3RvcnMgc2luY2UgY2FudmFzIGlzIGNsZWFyZWQgdXBvbiByZW1vdmFsLFxuXHRcdC8vIGluIGNhc2Ugb2YgcmVtb3ZpbmcgdGhlIHJlbmRlcmVyIGl0c2VsZiBmcm9tIHRoZSBtYXAuXG5cdFx0dGhpcy5fZHJhdygpO1xuXHR9LFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG5cdFx0TC5Eb21FdmVudFxuXHRcdFx0Lm9uKGNvbnRhaW5lciwgJ21vdXNlbW92ZScsIEwuVXRpbC50aHJvdHRsZSh0aGlzLl9vbk1vdXNlTW92ZSwgMzIsIHRoaXMpLCB0aGlzKVxuXHRcdFx0Lm9uKGNvbnRhaW5lciwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIGNvbnRleHRtZW51JywgdGhpcy5fb25DbGljaywgdGhpcylcblx0XHRcdC5vbihjb250YWluZXIsICdtb3VzZW91dCcsIHRoaXMuX2hhbmRsZU1vdXNlT3V0LCB0aGlzKTtcblxuXHRcdHRoaXMuX2N0eCA9IGNvbnRhaW5lci5nZXRDb250ZXh0KCcyZCcpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2RyYXduTGF5ZXJzID0ge307XG5cblx0XHRMLlJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cblx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG5cdFx0ICAgIG0gPSBMLkJyb3dzZXIucmV0aW5hID8gMiA6IDE7XG5cblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cblx0XHQvLyBzZXQgY2FudmFzIHNpemUgKGFsc28gY2xlYXJpbmcgaXQpOyB1c2UgZG91YmxlIHNpemUgb24gcmV0aW5hXG5cdFx0Y29udGFpbmVyLndpZHRoID0gbSAqIHNpemUueDtcblx0XHRjb250YWluZXIuaGVpZ2h0ID0gbSAqIHNpemUueTtcblx0XHRjb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuXHRcdGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXG5cdFx0aWYgKEwuQnJvd3Nlci5yZXRpbmEpIHtcblx0XHRcdHRoaXMuX2N0eC5zY2FsZSgyLCAyKTtcblx0XHR9XG5cblx0XHQvLyB0cmFuc2xhdGUgc28gd2UgdXNlIHRoZSBzYW1lIHBhdGggY29vcmRpbmF0ZXMgYWZ0ZXIgY2FudmFzIGVsZW1lbnQgbW92ZXNcblx0XHR0aGlzLl9jdHgudHJhbnNsYXRlKC1iLm1pbi54LCAtYi5taW4ueSk7XG5cblx0XHQvLyBUZWxsIHBhdGhzIHRvIHJlZHJhdyB0aGVtc2VsdmVzXG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW0wuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBMLlV0aWwuZmFsc2VGbixcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0bGF5ZXIuX3JlbW92ZWQgPSB0cnVlO1xuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBsYXllci5fcHhCb3VuZHM7XG5cdFx0dGhpcy5fZHJhdyh0cnVlKTtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0XHR0aGlzLl9kcmF3KCk7XG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZURhc2hBcnJheTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHR2YXIgcGFydHMgPSBsYXllci5vcHRpb25zLmRhc2hBcnJheS5zcGxpdCgnLCcpLFxuXHRcdFx0ICAgIGRhc2hBcnJheSA9IFtdLFxuXHRcdFx0ICAgIGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGFzaEFycmF5LnB1c2goTnVtYmVyKHBhcnRzW2ldKSk7XG5cdFx0XHR9XG5cdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXF1ZXN0UmVkcmF3OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBwYWRkaW5nID0gKGxheWVyLm9wdGlvbnMud2VpZ2h0IHx8IDApICsgMTtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHMgfHwgbmV3IEwuQm91bmRzKCk7XG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWluLnN1YnRyYWN0KFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1heC5hZGQoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG5cblx0XHR0aGlzLl9yZWRyYXdSZXF1ZXN0ID0gdGhpcy5fcmVkcmF3UmVxdWVzdCB8fCBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9yZWRyYXcsIHRoaXMpO1xuXHR9LFxuXG5cdF9yZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZWRyYXdSZXF1ZXN0ID0gbnVsbDtcblxuXHRcdHRoaXMuX2RyYXcodHJ1ZSk7IC8vIGNsZWFyIGxheWVycyBpbiByZWRyYXcgYm91bmRzXG5cdFx0dGhpcy5fZHJhdygpOyAvLyBkcmF3IGxheWVyc1xuXG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24gKGNsZWFyKSB7XG5cdFx0dGhpcy5fY2xlYXIgPSBjbGVhcjtcblx0XHR2YXIgbGF5ZXIsIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcblx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcblx0XHRcdHRoaXMuX2N0eC5yZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBib3VuZHMubWF4LnggLSBib3VuZHMubWluLngsIGJvdW5kcy5tYXgueSAtIGJvdW5kcy5taW4ueSk7XG5cdFx0XHR0aGlzLl9jdHguY2xpcCgpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0aWYgKCFib3VuZHMgfHwgKGxheWVyLl9weEJvdW5kcyAmJiBsYXllci5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSkge1xuXHRcdFx0XHRsYXllci5fdXBkYXRlUGF0aCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNsZWFyICYmIGxheWVyLl9yZW1vdmVkKSB7XG5cdFx0XHRcdGRlbGV0ZSBsYXllci5fcmVtb3ZlZDtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7ICAvLyBSZXN0b3JlIHN0YXRlIGJlZm9yZSBjbGlwcGluZy5cblx0fSxcblxuXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcblxuXHRcdHZhciBpLCBqLCBsZW4yLCBwLFxuXHRcdCAgICBwYXJ0cyA9IGxheWVyLl9wYXJ0cyxcblx0XHQgICAgbGVuID0gcGFydHMubGVuZ3RoLFxuXHRcdCAgICBjdHggPSB0aGlzLl9jdHg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2RyYXduTGF5ZXJzW2xheWVyLl9sZWFmbGV0X2lkXSA9IGxheWVyO1xuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0Y3R4LnNldExpbmVEYXNoKGxheWVyLm9wdGlvbnMgJiYgbGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5IHx8IFtdKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0c1tpXS5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdFx0cCA9IHBhcnRzW2ldW2pdO1xuXHRcdFx0XHRjdHhbaiA/ICdsaW5lVG8nIDogJ21vdmVUbyddKHAueCwgcC55KTtcblx0XHRcdH1cblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cblx0XHQvLyBUT0RPIG9wdGltaXphdGlvbjogMSBmaWxsL3N0cm9rZSBmb3IgYWxsIGZlYXR1cmVzIHdpdGggZXF1YWwgc3R5bGUgaW5zdGVhZCBvZiAxIGZvciBlYWNoIGZlYXR1cmVcblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblxuXHRcdGlmIChsYXllci5fZW1wdHkoKSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuXHRcdCAgICBjdHggPSB0aGlzLl9jdHgsXG5cdFx0ICAgIHIgPSBsYXllci5fcmFkaXVzLFxuXHRcdCAgICBzID0gKGxheWVyLl9yYWRpdXNZIHx8IHIpIC8gcjtcblxuXHRcdHRoaXMuX2RyYXduTGF5ZXJzW2xheWVyLl9sZWFmbGV0X2lkXSA9IGxheWVyO1xuXG5cdFx0aWYgKHMgIT09IDEpIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHguc2NhbGUoMSwgcyk7XG5cdFx0fVxuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5hcmMocC54LCBwLnkgLyBzLCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuXG5cdFx0aWYgKHMgIT09IDEpIHtcblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblx0fSxcblxuXHRfZmlsbFN0cm9rZTogZnVuY3Rpb24gKGN0eCwgbGF5ZXIpIHtcblx0XHR2YXIgY2xlYXIgPSB0aGlzLl9jbGVhcixcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cblx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gY2xlYXIgPyAnZGVzdGluYXRpb24tb3V0JyA6ICdzb3VyY2Utb3Zlcic7XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBjbGVhciA/IDEgOiBvcHRpb25zLmZpbGxPcGFjaXR5O1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRjdHguZmlsbChvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlICYmIG9wdGlvbnMud2VpZ2h0ICE9PSAwKSB7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBjbGVhciA/IDEgOiBvcHRpb25zLm9wYWNpdHk7XG5cblx0XHRcdC8vIGlmIGNsZWFyaW5nIHNoYXBlLCBkbyBpdCB3aXRoIHRoZSBwcmV2aW91c2x5IGRyYXduIGxpbmUgd2lkdGhcblx0XHRcdGxheWVyLl9wcmV2V2VpZ2h0ID0gY3R4LmxpbmVXaWR0aCA9IGNsZWFyID8gbGF5ZXIuX3ByZXZXZWlnaHQgKyAxIDogb3B0aW9ucy53ZWlnaHQ7XG5cblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRjdHgubGluZUNhcCA9IG9wdGlvbnMubGluZUNhcDtcblx0XHRcdGN0eC5saW5lSm9pbiA9IG9wdGlvbnMubGluZUpvaW47XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENhbnZhcyBvYnZpb3VzbHkgZG9lc24ndCBoYXZlIG1vdXNlIGV2ZW50cyBmb3IgaW5kaXZpZHVhbCBkcmF3biBvYmplY3RzLFxuXHQvLyBzbyB3ZSBlbXVsYXRlIHRoYXQgYnkgY2FsY3VsYXRpbmcgd2hhdCdzIHVuZGVyIHRoZSBtb3VzZSBvbiBtb3VzZW1vdmUvY2xpY2sgbWFudWFsbHlcblxuXHRfb25DbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSwgbGF5ZXJzID0gW10sIGxheWVyO1xuXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkgJiYgIXRoaXMuX21hcC5fZHJhZ2dhYmxlTW92ZWQobGF5ZXIpKSB7XG5cdFx0XHRcdEwuRG9tRXZlbnQuX2Zha2VTdG9wKGUpO1xuXHRcdFx0XHRsYXllcnMucHVzaChsYXllcik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChsYXllcnMubGVuZ3RoKSAge1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KGxheWVycywgZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCkgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSk7XG5cdFx0dGhpcy5faGFuZGxlTW91c2VPdXQoZSwgcG9pbnQpO1xuXHRcdHRoaXMuX2hhbmRsZU1vdXNlSG92ZXIoZSwgcG9pbnQpO1xuXHR9LFxuXG5cblx0X2hhbmRsZU1vdXNlT3V0OiBmdW5jdGlvbiAoZSwgcG9pbnQpIHtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9ob3ZlcmVkTGF5ZXI7XG5cdFx0aWYgKGxheWVyICYmIChlLnR5cGUgPT09ICdtb3VzZW91dCcgfHwgIWxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSkpIHtcblx0XHRcdC8vIGlmIHdlJ3JlIGxlYXZpbmcgdGhlIGxheWVyLCBmaXJlIG1vdXNlb3V0XG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtsYXllcl0sIGUsICdtb3VzZW91dCcpO1xuXHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZU1vdXNlSG92ZXI6IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuXHRcdHZhciBpZCwgbGF5ZXI7XG5cblx0XHRmb3IgKGlkIGluIHRoaXMuX2RyYXduTGF5ZXJzKSB7XG5cdFx0XHRsYXllciA9IHRoaXMuX2RyYXduTGF5ZXJzW2lkXTtcblx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSkge1xuXHRcdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpOyAvLyBjaGFuZ2UgY3Vyc29yXG5cdFx0XHRcdHRoaXMuX2ZpcmVFdmVudChbbGF5ZXJdLCBlLCAnbW91c2VvdmVyJyk7XG5cdFx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IGxheWVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9ob3ZlcmVkTGF5ZXIpIHtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbdGhpcy5faG92ZXJlZExheWVyXSwgZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9maXJlRXZlbnQ6IGZ1bmN0aW9uIChsYXllcnMsIGUsIHR5cGUpIHtcblx0XHR0aGlzLl9tYXAuX2ZpcmVET01FdmVudChlLCB0eXBlIHx8IGUudHlwZSwgbGF5ZXJzKTtcblx0fSxcblxuXHQvLyBUT0RPIF9icmluZ1RvRnJvbnQgJiBfYnJpbmdUb0JhY2ssIHByZXR0eSB0cmlja3lcblxuXHRfYnJpbmdUb0Zyb250OiBMLlV0aWwuZmFsc2VGbixcblx0X2JyaW5nVG9CYWNrOiBMLlV0aWwuZmFsc2VGblxufSk7XG5cbi8vIEBuYW1lc3BhY2UgQnJvd3NlcjsgQHByb3BlcnR5IGNhbnZhczogQm9vbGVhblxuLy8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cbkwuQnJvd3Nlci5jYW52YXMgPSAoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0O1xufSgpKTtcblxuLy8gQG5hbWVzcGFjZSBDYW52YXNcbi8vIEBmYWN0b3J5IEwuY2FudmFzKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIENhbnZhcyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuTC5jYW52YXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gTC5Ccm93c2VyLmNhbnZhcyA/IG5ldyBMLkNhbnZhcyhvcHRpb25zKSA6IG51bGw7XG59O1xuXG5MLlBvbHlsaW5lLnByb3RvdHlwZS5fY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIChwLCBjbG9zZWQpIHtcblx0dmFyIGksIGosIGssIGxlbiwgbGVuMiwgcGFydCxcblx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXG5cdGlmICghdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gaGl0IGRldGVjdGlvbiBmb3IgcG9seWxpbmVzXG5cdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG5cdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRpZiAoIWNsb3NlZCAmJiAoaiA9PT0gMCkpIHsgY29udGludWU7IH1cblxuXHRcdFx0aWYgKEwuTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwYXJ0W2tdLCBwYXJ0W2pdKSA8PSB3KSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5MLlBvbHlnb24ucHJvdG90eXBlLl9jb250YWluc1BvaW50ID0gZnVuY3Rpb24gKHApIHtcblx0dmFyIGluc2lkZSA9IGZhbHNlLFxuXHQgICAgcGFydCwgcDEsIHAyLCBpLCBqLCBrLCBsZW4sIGxlbjI7XG5cblx0aWYgKCF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyByYXkgY2FzdGluZyBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBpZiBwb2ludCBpcyBpbiBwb2x5Z29uXG5cdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG5cdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRwMSA9IHBhcnRbal07XG5cdFx0XHRwMiA9IHBhcnRba107XG5cblx0XHRcdGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmIChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XG5cdFx0XHRcdGluc2lkZSA9ICFpbnNpZGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gYWxzbyBjaGVjayBpZiBpdCdzIG9uIHBvbHlnb24gc3Ryb2tlXG5cdHJldHVybiBpbnNpZGUgfHwgTC5Qb2x5bGluZS5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQuY2FsbCh0aGlzLCBwLCB0cnVlKTtcbn07XG5cbkwuQ2lyY2xlTWFya2VyLnByb3RvdHlwZS5fY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIChwKSB7XG5cdHJldHVybiBwLmRpc3RhbmNlVG8odGhpcy5fcG9pbnQpIDw9IHRoaXMuX3JhZGl1cyArIHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG59O1xuXG4vKlxyXG4gKiBAY2xhc3MgR2VvSlNPTlxyXG4gKiBAYWthIEwuR2VvSlNPTlxyXG4gKiBAaW5oZXJpdHMgRmVhdHVyZUdyb3VwXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBHZW9KU09OIG9iamVjdCBvciBhbiBhcnJheSBvZiBHZW9KU09OIG9iamVjdHMuIEFsbG93cyB5b3UgdG8gcGFyc2VcclxuICogR2VvSlNPTiBkYXRhIGFuZCBkaXNwbGF5IGl0IG9uIHRoZSBtYXAuIEV4dGVuZHMgYEZlYXR1cmVHcm91cGAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwuZ2VvSlNPTihkYXRhLCB7XHJcbiAqIFx0c3R5bGU6IGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcbiAqIFx0XHRyZXR1cm4ge2NvbG9yOiBmZWF0dXJlLnByb3BlcnRpZXMuY29sb3J9O1xyXG4gKiBcdH1cclxuICogfSkuYmluZFBvcHVwKGZ1bmN0aW9uIChsYXllcikge1xyXG4gKiBcdHJldHVybiBsYXllci5mZWF0dXJlLnByb3BlcnRpZXMuZGVzY3JpcHRpb247XHJcbiAqIH0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuR2VvSlNPTiA9IEwuRmVhdHVyZUdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQGFrYSBHZW9KU09OIG9wdGlvbnNcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gcG9pbnRUb0xheWVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgaG93IEdlb0pTT04gcG9pbnRzIHNwYXduIExlYWZsZXQgbGF5ZXJzLiBJdCBpcyBpbnRlcm5hbGx5XHJcblx0ICogY2FsbGVkIHdoZW4gZGF0YSBpcyBhZGRlZCwgcGFzc2luZyB0aGUgR2VvSlNPTiBwb2ludCBmZWF0dXJlIGFuZCBpdHMgYExhdExuZ2AuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gc3Bhd24gYSBkZWZhdWx0IGBNYXJrZXJgOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24oZ2VvSnNvblBvaW50LCBsYXRsbmcpIHtcclxuXHQgKiBcdHJldHVybiBMLm1hcmtlcihsYXRsbmcpO1xyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc3R5bGU6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyB0aGUgYFBhdGggb3B0aW9uc2AgZm9yIHN0eWxpbmcgR2VvSlNPTiBsaW5lcyBhbmQgcG9seWdvbnMsXHJcblx0ICogY2FsbGVkIGludGVybmFsbHkgd2hlbiBkYXRhIGlzIGFkZGVkLlxyXG5cdCAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRvIG5vdCBvdmVycmlkZSBhbnkgZGVmYXVsdHM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuXHQgKiBcdHJldHVybiB7fVxyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gb25FYWNoRmVhdHVyZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZWFjaCBjcmVhdGVkIGBGZWF0dXJlYCwgYWZ0ZXIgaXQgaGFzXHJcblx0ICogYmVlbiBjcmVhdGVkIGFuZCBzdHlsZWQuIFVzZWZ1bCBmb3IgYXR0YWNoaW5nIGV2ZW50cyBhbmQgcG9wdXBzIHRvIGZlYXR1cmVzLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGRvIG5vdGhpbmcgd2l0aCB0aGUgbmV3bHkgY3JlYXRlZCBsYXllcnM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZmVhdHVyZSwgbGF5ZXIpIHt9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGZpbHRlcjogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRlY2lkZSB3aGV0aGVyIHRvIGluY2x1ZGUgYSBmZWF0dXJlIG9yIG5vdC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBpbmNsdWRlIGFsbCBmZWF0dXJlczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHRydWU7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqIE5vdGU6IGR5bmFtaWNhbGx5IGNoYW5naW5nIHRoZSBgZmlsdGVyYCBvcHRpb24gd2lsbCBoYXZlIGVmZmVjdCBvbmx5IG9uIG5ld2x5XHJcblx0ICogYWRkZWQgZGF0YS4gSXQgd2lsbCBfbm90XyByZS1ldmFsdWF0ZSBhbHJlYWR5IGluY2x1ZGVkIGZlYXR1cmVzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBjb29yZHNUb0xhdExuZzogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBjb252ZXJ0aW5nIEdlb0pTT04gY29vcmRpbmF0ZXMgdG8gYExhdExuZ2BzLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRoZSBgY29vcmRzVG9MYXRMbmdgIHN0YXRpYyBtZXRob2QuXHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0aWYgKGdlb2pzb24pIHtcclxuXHRcdFx0dGhpcy5hZGREYXRhKGdlb2pzb24pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkRGF0YSggPEdlb0pTT04+IGRhdGEgKTogTGF5ZXJcclxuXHQvLyBBZGRzIGEgR2VvSlNPTiBvYmplY3QgdG8gdGhlIGxheWVyLlxyXG5cdGFkZERhdGE6IGZ1bmN0aW9uIChnZW9qc29uKSB7XHJcblx0XHR2YXIgZmVhdHVyZXMgPSBMLlV0aWwuaXNBcnJheShnZW9qc29uKSA/IGdlb2pzb24gOiBnZW9qc29uLmZlYXR1cmVzLFxyXG5cdFx0ICAgIGksIGxlbiwgZmVhdHVyZTtcclxuXHJcblx0XHRpZiAoZmVhdHVyZXMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHQvLyBvbmx5IGFkZCB0aGlzIGlmIGdlb21ldHJ5IG9yIGdlb21ldHJpZXMgYXJlIHNldCBhbmQgbm90IG51bGxcclxuXHRcdFx0XHRmZWF0dXJlID0gZmVhdHVyZXNbaV07XHJcblx0XHRcdFx0aWYgKGZlYXR1cmUuZ2VvbWV0cmllcyB8fCBmZWF0dXJlLmdlb21ldHJ5IHx8IGZlYXR1cmUuZmVhdHVyZXMgfHwgZmVhdHVyZS5jb29yZGluYXRlcykge1xyXG5cdFx0XHRcdFx0dGhpcy5hZGREYXRhKGZlYXR1cmUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0aW9ucy5maWx0ZXIgJiYgIW9wdGlvbnMuZmlsdGVyKGdlb2pzb24pKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGxheWVyID0gTC5HZW9KU09OLmdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKTtcclxuXHRcdGlmICghbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRsYXllci5mZWF0dXJlID0gTC5HZW9KU09OLmFzRmVhdHVyZShnZW9qc29uKTtcclxuXHJcblx0XHRsYXllci5kZWZhdWx0T3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XHJcblx0XHR0aGlzLnJlc2V0U3R5bGUobGF5ZXIpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLm9uRWFjaEZlYXR1cmUpIHtcclxuXHRcdFx0b3B0aW9ucy5vbkVhY2hGZWF0dXJlKGdlb2pzb24sIGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihsYXllcik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZXNldFN0eWxlKCA8UGF0aD4gbGF5ZXIgKTogTGF5ZXJcclxuXHQvLyBSZXNldHMgdGhlIGdpdmVuIHZlY3RvciBsYXllcidzIHN0eWxlIHRvIHRoZSBvcmlnaW5hbCBHZW9KU09OIHN0eWxlLCB1c2VmdWwgZm9yIHJlc2V0dGluZyBzdHlsZSBhZnRlciBob3ZlciBldmVudHMuXHJcblx0cmVzZXRTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHQvLyByZXNldCBhbnkgY3VzdG9tIHN0eWxlc1xyXG5cdFx0bGF5ZXIub3B0aW9ucyA9IEwuVXRpbC5leHRlbmQoe30sIGxheWVyLmRlZmF1bHRPcHRpb25zKTtcclxuXHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHRoaXMub3B0aW9ucy5zdHlsZSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKCA8RnVuY3Rpb24+IHN0eWxlICk6IExheWVyXHJcblx0Ly8gQ2hhbmdlcyBzdHlsZXMgb2YgR2VvSlNPTiB2ZWN0b3IgbGF5ZXJzIHdpdGggdGhlIGdpdmVuIHN0eWxlIGZ1bmN0aW9uLlxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgc3R5bGUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X3NldExheWVyU3R5bGU6IGZ1bmN0aW9uIChsYXllciwgc3R5bGUpIHtcclxuXHRcdGlmICh0eXBlb2Ygc3R5bGUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0c3R5bGUgPSBzdHlsZShsYXllci5mZWF0dXJlKTtcclxuXHRcdH1cclxuXHRcdGlmIChsYXllci5zZXRTdHlsZSkge1xyXG5cdFx0XHRsYXllci5zZXRTdHlsZShzdHlsZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBzZWN0aW9uXHJcbi8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5HZW9KU09OOlxyXG5MLmV4dGVuZChMLkdlb0pTT04sIHtcclxuXHQvLyBAZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGZlYXR1cmVEYXRhOiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpOiBMYXllclxyXG5cdC8vIENyZWF0ZXMgYSBgTGF5ZXJgIGZyb20gYSBnaXZlbiBHZW9KU09OIGZlYXR1cmUuIENhbiB1c2UgYSBjdXN0b21cclxuXHQvLyBbYHBvaW50VG9MYXllcmBdKCNnZW9qc29uLXBvaW50dG9sYXllcikgYW5kL29yIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuXHQvLyBmdW5jdGlvbnMgaWYgcHJvdmlkZWQgYXMgb3B0aW9ucy5cclxuXHRnZW9tZXRyeVRvTGF5ZXI6IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgPyBnZW9qc29uLmdlb21ldHJ5IDogZ2VvanNvbixcclxuXHRcdCAgICBjb29yZHMgPSBnZW9tZXRyeSA/IGdlb21ldHJ5LmNvb3JkaW5hdGVzIDogbnVsbCxcclxuXHRcdCAgICBsYXllcnMgPSBbXSxcclxuXHRcdCAgICBwb2ludFRvTGF5ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMucG9pbnRUb0xheWVyLFxyXG5cdFx0ICAgIGNvb3Jkc1RvTGF0TG5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvb3Jkc1RvTGF0TG5nIHx8IHRoaXMuY29vcmRzVG9MYXRMbmcsXHJcblx0XHQgICAgbGF0bG5nLCBsYXRsbmdzLCBpLCBsZW47XHJcblxyXG5cdFx0aWYgKCFjb29yZHMgJiYgIWdlb21ldHJ5KSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xyXG5cdFx0Y2FzZSAnUG9pbnQnOlxyXG5cdFx0XHRsYXRsbmcgPSBjb29yZHNUb0xhdExuZyhjb29yZHMpO1xyXG5cdFx0XHRyZXR1cm4gcG9pbnRUb0xheWVyID8gcG9pbnRUb0xheWVyKGdlb2pzb24sIGxhdGxuZykgOiBuZXcgTC5NYXJrZXIobGF0bG5nKTtcclxuXHJcblx0XHRjYXNlICdNdWx0aVBvaW50JzpcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0bGF0bG5nID0gY29vcmRzVG9MYXRMbmcoY29vcmRzW2ldKTtcclxuXHRcdFx0XHRsYXllcnMucHVzaChwb2ludFRvTGF5ZXIgPyBwb2ludFRvTGF5ZXIoZ2VvanNvbiwgbGF0bG5nKSA6IG5ldyBMLk1hcmtlcihsYXRsbmcpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbmV3IEwuRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG5cdFx0Y2FzZSAnTGluZVN0cmluZyc6XHJcblx0XHRjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxyXG5cdFx0XHRsYXRsbmdzID0gdGhpcy5jb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgPyAwIDogMSwgY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdFx0Y2FzZSAnUG9seWdvbic6XHJcblx0XHRjYXNlICdNdWx0aVBvbHlnb24nOlxyXG5cdFx0XHRsYXRsbmdzID0gdGhpcy5jb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgPyAxIDogMiwgY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcblx0XHRjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGxheWVyID0gdGhpcy5nZW9tZXRyeVRvTGF5ZXIoe1xyXG5cdFx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5Lmdlb21ldHJpZXNbaV0sXHJcblx0XHRcdFx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRcdFx0XHRwcm9wZXJ0aWVzOiBnZW9qc29uLnByb3BlcnRpZXNcclxuXHRcdFx0XHR9LCBvcHRpb25zKTtcclxuXHJcblx0XHRcdFx0aWYgKGxheWVyKSB7XHJcblx0XHRcdFx0XHRsYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBuZXcgTC5GZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgR2VvSlNPTiBvYmplY3QuJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuXHQvLyBDcmVhdGVzIGEgYExhdExuZ2Agb2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgMiBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlKVxyXG5cdC8vIG9yIDMgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSwgYWx0aXR1ZGUpIHVzZWQgaW4gR2VvSlNPTiBmb3IgcG9pbnRzLlxyXG5cdGNvb3Jkc1RvTGF0TG5nOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKGNvb3Jkc1sxXSwgY29vcmRzWzBdLCBjb29yZHNbMl0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY29vcmRzVG9MYXRMbmc/OiBGdW5jdGlvbik6IEFycmF5XHJcblx0Ly8gQ3JlYXRlcyBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXkgb2YgYExhdExuZ2BzIGZyb20gYSBHZW9KU09OIGNvb3JkaW5hdGVzIGFycmF5LlxyXG5cdC8vIGBsZXZlbHNEZWVwYCBzcGVjaWZpZXMgdGhlIG5lc3RpbmcgbGV2ZWwgKDAgaXMgZm9yIGFuIGFycmF5IG9mIHBvaW50cywgMSBmb3IgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHBvaW50cywgZXRjLiwgMCBieSBkZWZhdWx0KS5cclxuXHQvLyBDYW4gdXNlIGEgY3VzdG9tIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZykgZnVuY3Rpb24uXHJcblx0Y29vcmRzVG9MYXRMbmdzOiBmdW5jdGlvbiAoY29vcmRzLCBsZXZlbHNEZWVwLCBjb29yZHNUb0xhdExuZykge1xyXG5cdFx0dmFyIGxhdGxuZ3MgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aCwgbGF0bG5nOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0bGF0bG5nID0gbGV2ZWxzRGVlcCA/XHJcblx0XHRcdCAgICAgICAgdGhpcy5jb29yZHNUb0xhdExuZ3MoY29vcmRzW2ldLCBsZXZlbHNEZWVwIC0gMSwgY29vcmRzVG9MYXRMbmcpIDpcclxuXHRcdFx0ICAgICAgICAoY29vcmRzVG9MYXRMbmcgfHwgdGhpcy5jb29yZHNUb0xhdExuZykoY29vcmRzW2ldKTtcclxuXHJcblx0XHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBsYXRsbmdzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmc6IExhdExuZyk6IEFycmF5XHJcblx0Ly8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcblx0bGF0TG5nVG9Db29yZHM6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiBsYXRsbmcuYWx0ICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0XHRcdFtsYXRsbmcubG5nLCBsYXRsbmcubGF0LCBsYXRsbmcuYWx0XSA6XHJcblx0XHRcdFx0W2xhdGxuZy5sbmcsIGxhdGxuZy5sYXRdO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5nczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNsb3NlZD86IEJvb2xlYW4pOiBBcnJheVxyXG5cdC8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ3NgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZ3MpXHJcblx0Ly8gYGNsb3NlZGAgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmaXJzdCBwb2ludCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkgdG8gY2xvc2UgdGhlIGZlYXR1cmUsIG9ubHkgdXNlZCB3aGVuIGBsZXZlbHNEZWVwYCBpcyAwLiBGYWxzZSBieSBkZWZhdWx0LlxyXG5cdGxhdExuZ3NUb0Nvb3JkczogZnVuY3Rpb24gKGxhdGxuZ3MsIGxldmVsc0RlZXAsIGNsb3NlZCkge1xyXG5cdFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKGxldmVsc0RlZXAgP1xyXG5cdFx0XHRcdEwuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHMobGF0bG5nc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIGNsb3NlZCkgOlxyXG5cdFx0XHRcdEwuR2VvSlNPTi5sYXRMbmdUb0Nvb3JkcyhsYXRsbmdzW2ldKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFsZXZlbHNEZWVwICYmIGNsb3NlZCkge1xyXG5cdFx0XHRjb29yZHMucHVzaChjb29yZHNbMF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb29yZHM7XHJcblx0fSxcclxuXHJcblx0Z2V0RmVhdHVyZTogZnVuY3Rpb24gKGxheWVyLCBuZXdHZW9tZXRyeSkge1xyXG5cdFx0cmV0dXJuIGxheWVyLmZlYXR1cmUgP1xyXG5cdFx0XHRcdEwuZXh0ZW5kKHt9LCBsYXllci5mZWF0dXJlLCB7Z2VvbWV0cnk6IG5ld0dlb21ldHJ5fSkgOlxyXG5cdFx0XHRcdEwuR2VvSlNPTi5hc0ZlYXR1cmUobmV3R2VvbWV0cnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbjogT2JqZWN0KTogT2JqZWN0XHJcblx0Ly8gTm9ybWFsaXplIEdlb0pTT04gZ2VvbWV0cmllcy9mZWF0dXJlcyBpbnRvIEdlb0pTT04gZmVhdHVyZXMuXHJcblx0YXNGZWF0dXJlOiBmdW5jdGlvbiAoZ2VvanNvbikge1xyXG5cdFx0aWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XHJcblx0XHRcdHJldHVybiBnZW9qc29uO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdFx0cHJvcGVydGllczoge30sXHJcblx0XHRcdGdlb21ldHJ5OiBnZW9qc29uXHJcblx0XHR9O1xyXG5cdH1cclxufSk7XHJcblxyXG52YXIgUG9pbnRUb0dlb0pTT04gPSB7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gTC5HZW9KU09OLmdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogTC5HZW9KU09OLmxhdExuZ1RvQ29vcmRzKHRoaXMuZ2V0TGF0TG5nKCkpXHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG5MLk1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ2lyY2xlTWFya2VyXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKCk6IE9iamVjdFxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbkwuQ2lyY2xlLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5MLkNpcmNsZU1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlsaW5lXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKCk6IE9iamVjdFxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWxpbmUgKGFzIGEgR2VvSlNPTiBgTGluZVN0cmluZ2Agb3IgYE11bHRpTGluZVN0cmluZ2AgRmVhdHVyZSkuXHJcbkwuUG9seWxpbmUucHJvdG90eXBlLnRvR2VvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgbXVsdGkgPSAhTC5Qb2x5bGluZS5fZmxhdCh0aGlzLl9sYXRsbmdzKTtcclxuXHJcblx0dmFyIGNvb3JkcyA9IEwuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAxIDogMCk7XHJcblxyXG5cdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ0xpbmVTdHJpbmcnLFxyXG5cdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdH0pO1xyXG59O1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb2x5Z29uXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKCk6IE9iamVjdFxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWdvbiAoYXMgYSBHZW9KU09OIGBQb2x5Z29uYCBvciBgTXVsdGlQb2x5Z29uYCBGZWF0dXJlKS5cclxuTC5Qb2x5Z29uLnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIGhvbGVzID0gIUwuUG9seWxpbmUuX2ZsYXQodGhpcy5fbGF0bG5ncyksXHJcblx0ICAgIG11bHRpID0gaG9sZXMgJiYgIUwuUG9seWxpbmUuX2ZsYXQodGhpcy5fbGF0bG5nc1swXSk7XHJcblxyXG5cdHZhciBjb29yZHMgPSBMLkdlb0pTT04ubGF0TG5nc1RvQ29vcmRzKHRoaXMuX2xhdGxuZ3MsIG11bHRpID8gMiA6IGhvbGVzID8gMSA6IDAsIHRydWUpO1xyXG5cclxuXHRpZiAoIWhvbGVzKSB7XHJcblx0XHRjb29yZHMgPSBbY29vcmRzXTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ1BvbHlnb24nLFxyXG5cdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdH0pO1xyXG59O1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTGF5ZXJHcm91cFxyXG5MLkxheWVyR3JvdXAuaW5jbHVkZSh7XHJcblx0dG9NdWx0aVBvaW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKGxheWVyLnRvR2VvSlNPTigpLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdNdWx0aVBvaW50JyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XHJcblx0Ly8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyIGdyb3VwIChhcyBhIEdlb0pTT04gYEdlb21ldHJ5Q29sbGVjdGlvbmApLlxyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0eXBlID0gdGhpcy5mZWF0dXJlICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRvTXVsdGlQb2ludCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxyXG5cdFx0ICAgIGpzb25zID0gW107XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGlmIChsYXllci50b0dlb0pTT04pIHtcclxuXHRcdFx0XHR2YXIganNvbiA9IGxheWVyLnRvR2VvSlNPTigpO1xyXG5cdFx0XHRcdGpzb25zLnB1c2goaXNHZW9tZXRyeUNvbGxlY3Rpb24gPyBqc29uLmdlb21ldHJ5IDogTC5HZW9KU09OLmFzRmVhdHVyZShqc29uKSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG5cdFx0XHRyZXR1cm4gTC5HZW9KU09OLmdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHRcdGdlb21ldHJpZXM6IGpzb25zLFxyXG5cdFx0XHRcdHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcblx0XHRcdGZlYXR1cmVzOiBqc29uc1xyXG5cdFx0fTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBHZW9KU09OXHJcbi8vIEBmYWN0b3J5IEwuZ2VvSlNPTihnZW9qc29uPzogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgR2VvSlNPTiBsYXllci4gT3B0aW9uYWxseSBhY2NlcHRzIGFuIG9iamVjdCBpblxyXG4vLyBbR2VvSlNPTiBmb3JtYXRdKGh0dHA6Ly9nZW9qc29uLm9yZy9nZW9qc29uLXNwZWMuaHRtbCkgdG8gZGlzcGxheSBvbiB0aGUgbWFwXHJcbi8vICh5b3UgY2FuIGFsdGVybmF0aXZlbHkgYWRkIGl0IGxhdGVyIHdpdGggYGFkZERhdGFgIG1ldGhvZCkgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbkwuZ2VvSlNPTiA9IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucyk7XHJcbn07XHJcbi8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXHJcbkwuZ2VvSnNvbiA9IEwuZ2VvSlNPTjtcclxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbUV2ZW50XHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTSBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudCksIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbi8vIEluc3BpcmVkIGJ5IEpvaG4gUmVzaWcsIERlYW4gRWR3YXJkcyBhbmQgWVVJIGFkZEV2ZW50IGltcGxlbWVudGF0aW9ucy5cclxuXHJcblxyXG5cclxudmFyIGV2ZW50c0tleSA9ICdfbGVhZmxldF9ldmVudHMnO1xyXG5cclxuTC5Eb21FdmVudCA9IHtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIERPTSBldmVudCB0eXBlIG9mIHRoZVxyXG5cdC8vIGVsZW1lbnQgYGVsYC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyXHJcblx0Ly8gKG9iamVjdCB0aGUgYHRoaXNgIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWxcclxuXHQvLyBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcblx0b246IGZ1bmN0aW9uIChvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLl9vbihvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHR5cGVzID0gTC5VdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb24ob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi4gSWYgbm8gZnVuY3Rpb24gaXMgc3BlY2lmaWVkLFxyXG5cdC8vIGl0IHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoYXQgcGFydGljdWxhciBET00gZXZlbnQgZnJvbSB0aGUgZWxlbWVudC5cclxuXHQvLyBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIG9uLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lXHJcblx0Ly8gY29udGV4dCB0byBgb2ZmYCBpbiBvcmRlciB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcblx0b2ZmOiBmdW5jdGlvbiAob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHlwZXMgPSBMLlV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X29uOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIGlkID0gdHlwZSArIEwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBMLnN0YW1wKGNvbnRleHQpIDogJycpO1xyXG5cclxuXHRcdGlmIChvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF0pIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdHJldHVybiBmbi5jYWxsKGNvbnRleHQgfHwgb2JqLCBlIHx8IHdpbmRvdy5ldmVudCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdFx0dGhpcy5hZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCk7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChMLkJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpICYmIHRoaXMuYWRkRG91YmxlVGFwTGlzdGVuZXIpIHtcclxuXHRcdFx0dGhpcy5hZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIsIGlkKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcblx0XHRcdGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuXHRcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcignb253aGVlbCcgaW4gb2JqID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICgodHlwZSA9PT0gJ21vdXNlZW50ZXInKSB8fCAodHlwZSA9PT0gJ21vdXNlbGVhdmUnKSkge1xyXG5cdFx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdFx0XHRcdFx0aWYgKEwuRG9tRXZlbnQuX2lzRXh0ZXJuYWxUYXJnZXQob2JqLCBlKSkge1xyXG5cdFx0XHRcdFx0XHRvcmlnaW5hbEhhbmRsZXIoZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlID09PSAnbW91c2VlbnRlcicgPyAnbW91c2VvdmVyJyA6ICdtb3VzZW91dCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdjbGljaycgJiYgTC5Ccm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gTC5Eb21FdmVudC5fZmlsdGVyQ2xpY2soZSwgb3JpZ2luYWxIYW5kbGVyKTtcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoJ2F0dGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdFx0b2JqLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRvYmpbZXZlbnRzS2V5XSA9IG9ialtldmVudHNLZXldIHx8IHt9O1xyXG5cdFx0b2JqW2V2ZW50c0tleV1baWRdID0gaGFuZGxlcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb2ZmOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdHZhciBpZCA9IHR5cGUgKyBMLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgTC5zdGFtcChjb250ZXh0KSA6ICcnKSxcclxuXHRcdCAgICBoYW5kbGVyID0gb2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdO1xyXG5cclxuXHRcdGlmICghaGFuZGxlcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCk7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChMLkJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpICYmIHRoaXMucmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIpIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGlkKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcblx0XHRcdGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuXHRcdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignb253aGVlbCcgaW4gb2JqID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcclxuXHRcdFx0XHRcdHR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdtb3VzZW92ZXInIDpcclxuXHRcdFx0XHRcdHR5cGUgPT09ICdtb3VzZWxlYXZlJyA/ICdtb3VzZW91dCcgOiB0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCdkZXRhY2hFdmVudCcgaW4gb2JqKSB7XHJcblx0XHRcdG9iai5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0b2JqW2V2ZW50c0tleV1baWRdID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2OiBET01FdmVudCk6IHRoaXNcclxuXHQvLyBTdG9wIHRoZSBnaXZlbiBldmVudCBmcm9tIHByb3BhZ2F0aW9uIHRvIHBhcmVudCBlbGVtZW50cy4gVXNlZCBpbnNpZGUgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uczpcclxuXHQvLyBgYGBqc1xyXG5cdC8vIEwuRG9tRXZlbnQub24oZGl2LCAnY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuXHQvLyBcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGV2KTtcclxuXHQvLyB9KTtcclxuXHQvLyBgYGBcclxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uIChlKSB7XHJcblxyXG5cdFx0aWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XHJcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHR9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudCkgeyAgLy8gSW4gY2FzZSBvZiBMZWFmbGV0IGV2ZW50LlxyXG5cdFx0XHRlLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgPSB0cnVlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0TC5Eb21FdmVudC5fc2tpcHBlZChlKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuXHQvLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdtb3VzZXdoZWVsJ2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG5cdGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbjogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudC5vbihlbCwgJ21vdXNld2hlZWwnLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuXHQvLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdjbGljaydgLCBgJ2RvdWJsZWNsaWNrJ2AsXHJcblx0Ly8gYCdtb3VzZWRvd24nYCBhbmQgYCd0b3VjaHN0YXJ0J2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG5cdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHZhciBzdG9wID0gTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb247XHJcblxyXG5cdFx0TC5Eb21FdmVudC5vbihlbCwgTC5EcmFnZ2FibGUuU1RBUlQuam9pbignICcpLCBzdG9wKTtcclxuXHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudC5vbihlbCwge1xyXG5cdFx0XHRjbGljazogTC5Eb21FdmVudC5fZmFrZVN0b3AsXHJcblx0XHRcdGRibGNsaWNrOiBzdG9wXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXY6IERPTUV2ZW50KTogdGhpc1xyXG5cdC8vIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgRE9NIEV2ZW50IGBldmAgZnJvbSBoYXBwZW5pbmcgKHN1Y2ggYXNcclxuXHQvLyBmb2xsb3dpbmcgYSBsaW5rIGluIHRoZSBocmVmIG9mIHRoZSBhIGVsZW1lbnQsIG9yIGRvaW5nIGEgUE9TVCByZXF1ZXN0XHJcblx0Ly8gd2l0aCBwYWdlIHJlbG9hZCB3aGVuIGEgYDxmb3JtPmAgaXMgc3VibWl0dGVkKS5cclxuXHQvLyBVc2UgaXQgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKGUpIHtcclxuXHJcblx0XHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xyXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc3RvcChldik6IHRoaXNcclxuXHQvLyBEb2VzIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIGF0IHRoZSBzYW1lIHRpbWUuXHJcblx0c3RvcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBMLkRvbUV2ZW50XHJcblx0XHRcdC5wcmV2ZW50RGVmYXVsdChlKVxyXG5cdFx0XHQuc3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGV2OiBET01FdmVudCwgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG5cdC8vIEdldHMgbm9ybWFsaXplZCBtb3VzZSBwb3NpdGlvbiBmcm9tIGEgRE9NIGV2ZW50IHJlbGF0aXZlIHRvIHRoZVxyXG5cdC8vIGBjb250YWluZXJgIG9yIHRvIHRoZSB3aG9sZSBwYWdlIGlmIG5vdCBzcGVjaWZpZWQuXHJcblx0Z2V0TW91c2VQb3NpdGlvbjogZnVuY3Rpb24gKGUsIGNvbnRhaW5lcikge1xyXG5cdFx0aWYgKCFjb250YWluZXIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLlBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoXHJcblx0XHRcdGUuY2xpZW50WCAtIHJlY3QubGVmdCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LFxyXG5cdFx0XHRlLmNsaWVudFkgLSByZWN0LnRvcCAtIGNvbnRhaW5lci5jbGllbnRUb3ApO1xyXG5cdH0sXHJcblxyXG5cdC8vIENocm9tZSBvbiBXaW4gc2Nyb2xscyBkb3VibGUgdGhlIHBpeGVscyBhcyBpbiBvdGhlciBwbGF0Zm9ybXMgKHNlZSAjNDUzOCksXHJcblx0Ly8gYW5kIEZpcmVmb3ggc2Nyb2xscyBkZXZpY2UgcGl4ZWxzLCBub3QgQ1NTIHBpeGVsc1xyXG5cdF93aGVlbFB4RmFjdG9yOiAoTC5Ccm93c2VyLndpbiAmJiBMLkJyb3dzZXIuY2hyb21lKSA/IDIgOlxyXG5cdCAgICAgICAgICAgICAgICBMLkJyb3dzZXIuZ2Vja28gPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6XHJcblx0ICAgICAgICAgICAgICAgIDEsXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGV2OiBET01FdmVudCk6IE51bWJlclxyXG5cdC8vIEdldHMgbm9ybWFsaXplZCB3aGVlbCBkZWx0YSBmcm9tIGEgbW91c2V3aGVlbCBET00gZXZlbnQsIGluIHZlcnRpY2FsXHJcblx0Ly8gcGl4ZWxzIHNjcm9sbGVkIChuZWdhdGl2ZSBpZiBzY3JvbGxpbmcgZG93bikuXHJcblx0Ly8gRXZlbnRzIGZyb20gcG9pbnRpbmcgZGV2aWNlcyB3aXRob3V0IHByZWNpc2Ugc2Nyb2xsaW5nIGFyZSBtYXBwZWQgdG9cclxuXHQvLyBhIGJlc3QgZ3Vlc3Mgb2YgNjAgcGl4ZWxzLlxyXG5cdGdldFdoZWVsRGVsdGE6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gKEwuQnJvd3Nlci5lZGdlKSA/IGUud2hlZWxEZWx0YVkgLyAyIDogLy8gRG9uJ3QgdHJ1c3Qgd2luZG93LWdlb21ldHJ5LWJhc2VkIGRlbHRhXHJcblx0XHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAwKSA/IC1lLmRlbHRhWSAvIEwuRG9tRXZlbnQuX3doZWVsUHhGYWN0b3IgOiAvLyBQaXhlbHNcclxuXHRcdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDEpID8gLWUuZGVsdGFZICogMjAgOiAvLyBMaW5lc1xyXG5cdFx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMikgPyAtZS5kZWx0YVkgKiA2MCA6IC8vIFBhZ2VzXHJcblx0XHQgICAgICAgKGUuZGVsdGFYIHx8IGUuZGVsdGFaKSA/IDAgOlx0Ly8gU2tpcCBob3Jpem9udGFsL2RlcHRoIHdoZWVsIGV2ZW50c1xyXG5cdFx0ICAgICAgIGUud2hlZWxEZWx0YSA/IChlLndoZWVsRGVsdGFZIHx8IGUud2hlZWxEZWx0YSkgLyAyIDogLy8gTGVnYWN5IElFIHBpeGVsc1xyXG5cdFx0ICAgICAgIChlLmRldGFpbCAmJiBNYXRoLmFicyhlLmRldGFpbCkgPCAzMjc2NSkgPyAtZS5kZXRhaWwgKiAyMCA6IC8vIExlZ2FjeSBNb3ogbGluZXNcclxuXHRcdCAgICAgICBlLmRldGFpbCA/IGUuZGV0YWlsIC8gLTMyNzY1ICogNjAgOiAvLyBMZWdhY3kgTW96IHBhZ2VzXHJcblx0XHQgICAgICAgMDtcclxuXHR9LFxyXG5cclxuXHRfc2tpcEV2ZW50czoge30sXHJcblxyXG5cdF9mYWtlU3RvcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIGZha2VzIHN0b3BQcm9wYWdhdGlvbiBieSBzZXR0aW5nIGEgc3BlY2lhbCBldmVudCBmbGFnLCBjaGVja2VkL3Jlc2V0IHdpdGggTC5Eb21FdmVudC5fc2tpcHBlZChlKVxyXG5cdFx0TC5Eb21FdmVudC5fc2tpcEV2ZW50c1tlLnR5cGVdID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfc2tpcHBlZDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBza2lwcGVkID0gdGhpcy5fc2tpcEV2ZW50c1tlLnR5cGVdO1xyXG5cdFx0Ly8gcmVzZXQgd2hlbiBjaGVja2luZywgYXMgaXQncyBvbmx5IHVzZWQgaW4gbWFwIGNvbnRhaW5lciBhbmQgcHJvcGFnYXRlcyBvdXRzaWRlIG9mIHRoZSBtYXBcclxuXHRcdHRoaXMuX3NraXBFdmVudHNbZS50eXBlXSA9IGZhbHNlO1xyXG5cdFx0cmV0dXJuIHNraXBwZWQ7XHJcblx0fSxcclxuXHJcblx0Ly8gY2hlY2sgaWYgZWxlbWVudCByZWFsbHkgbGVmdC9lbnRlcmVkIHRoZSBldmVudCB0YXJnZXQgKGZvciBtb3VzZWVudGVyL21vdXNlbGVhdmUpXHJcblx0X2lzRXh0ZXJuYWxUYXJnZXQ6IGZ1bmN0aW9uIChlbCwgZSkge1xyXG5cclxuXHRcdHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuXHRcdGlmICghcmVsYXRlZCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdHdoaWxlIChyZWxhdGVkICYmIChyZWxhdGVkICE9PSBlbCkpIHtcclxuXHRcdFx0XHRyZWxhdGVkID0gcmVsYXRlZC5wYXJlbnROb2RlO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XHJcblx0fSxcclxuXHJcblx0Ly8gdGhpcyBpcyBhIGhvcnJpYmxlIHdvcmthcm91bmQgZm9yIGEgYnVnIGluIEFuZHJvaWQgd2hlcmUgYSBzaW5nbGUgdG91Y2ggdHJpZ2dlcnMgdHdvIGNsaWNrIGV2ZW50c1xyXG5cdF9maWx0ZXJDbGljazogZnVuY3Rpb24gKGUsIGhhbmRsZXIpIHtcclxuXHRcdHZhciB0aW1lU3RhbXAgPSAoZS50aW1lU3RhbXAgfHwgKGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQudGltZVN0YW1wKSksXHJcblx0XHQgICAgZWxhcHNlZCA9IEwuRG9tRXZlbnQuX2xhc3RDbGljayAmJiAodGltZVN0YW1wIC0gTC5Eb21FdmVudC5fbGFzdENsaWNrKTtcclxuXHJcblx0XHQvLyBhcmUgdGhleSBjbG9zZXIgdG9nZXRoZXIgdGhhbiA1MDBtcyB5ZXQgbW9yZSB0aGFuIDEwMG1zP1xyXG5cdFx0Ly8gQW5kcm9pZCB0eXBpY2FsbHkgdHJpZ2dlcnMgdGhlbSB+MzAwbXMgYXBhcnQgd2hpbGUgbXVsdGlwbGUgbGlzdGVuZXJzXHJcblx0XHQvLyBvbiB0aGUgc2FtZSBldmVudCBzaG91bGQgYmUgdHJpZ2dlcmVkIGZhciBmYXN0ZXI7XHJcblx0XHQvLyBvciBjaGVjayBpZiBjbGljayBpcyBzaW11bGF0ZWQgb24gdGhlIGVsZW1lbnQsIGFuZCBpZiBpdCBpcywgcmVqZWN0IGFueSBub24tc2ltdWxhdGVkIGV2ZW50c1xyXG5cclxuXHRcdGlmICgoZWxhcHNlZCAmJiBlbGFwc2VkID4gMTAwICYmIGVsYXBzZWQgPCA1MDApIHx8IChlLnRhcmdldC5fc2ltdWxhdGVkQ2xpY2sgJiYgIWUuX3NpbXVsYXRlZCkpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5zdG9wKGUpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRMLkRvbUV2ZW50Ll9sYXN0Q2xpY2sgPSB0aW1lU3RhbXA7XHJcblxyXG5cdFx0aGFuZGxlcihlKTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkTGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYEwuRG9tRXZlbnQub25gXSgjZG9tZXZlbnQtb24pXHJcbkwuRG9tRXZlbnQuYWRkTGlzdGVuZXIgPSBMLkRvbUV2ZW50Lm9uO1xyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BMLkRvbUV2ZW50Lm9mZmBdKCNkb21ldmVudC1vZmYpXHJcbkwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIgPSBMLkRvbUV2ZW50Lm9mZjtcclxuXG4vKlxyXG4gKiBAY2xhc3MgRHJhZ2dhYmxlXHJcbiAqIEBha2EgTC5EcmFnZ2FibGVcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogQSBjbGFzcyBmb3IgbWFraW5nIERPTSBlbGVtZW50cyBkcmFnZ2FibGUgKGluY2x1ZGluZyB0b3VjaCBzdXBwb3J0KS5cclxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBtYXAgYW5kIG1hcmtlciBkcmFnZ2luZy4gT25seSB3b3JrcyBmb3IgZWxlbWVudHNcclxuICogdGhhdCB3ZXJlIHBvc2l0aW9uZWQgd2l0aCBbYEwuRG9tVXRpbC5zZXRQb3NpdGlvbmBdKCNkb211dGlsLXNldHBvc2l0aW9uKS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogdmFyIGRyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShlbGVtZW50VG9EcmFnKTtcclxuICogZHJhZ2dhYmxlLmVuYWJsZSgpO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLkRyYWdnYWJsZSA9IEwuRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGNsaWNrVG9sZXJhbmNlOiBOdW1iZXIgPSAzXHJcblx0XHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCB0aGUgbW91c2UgcG9pbnRlciBkdXJpbmcgYSBjbGlja1xyXG5cdFx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCBjbGljayAoYXMgb3Bwb3NlZCB0byBhIG1vdXNlIGRyYWcpLlxyXG5cdFx0Y2xpY2tUb2xlcmFuY2U6IDNcclxuXHR9LFxyXG5cclxuXHRzdGF0aWNzOiB7XHJcblx0XHRTVEFSVDogTC5Ccm93c2VyLnRvdWNoID8gWyd0b3VjaHN0YXJ0JywgJ21vdXNlZG93biddIDogWydtb3VzZWRvd24nXSxcclxuXHRcdEVORDoge1xyXG5cdFx0XHRtb3VzZWRvd246ICdtb3VzZXVwJyxcclxuXHRcdFx0dG91Y2hzdGFydDogJ3RvdWNoZW5kJyxcclxuXHRcdFx0cG9pbnRlcmRvd246ICd0b3VjaGVuZCcsXHJcblx0XHRcdE1TUG9pbnRlckRvd246ICd0b3VjaGVuZCdcclxuXHRcdH0sXHJcblx0XHRNT1ZFOiB7XHJcblx0XHRcdG1vdXNlZG93bjogJ21vdXNlbW92ZScsXHJcblx0XHRcdHRvdWNoc3RhcnQ6ICd0b3VjaG1vdmUnLFxyXG5cdFx0XHRwb2ludGVyZG93bjogJ3RvdWNobW92ZScsXHJcblx0XHRcdE1TUG9pbnRlckRvd246ICd0b3VjaG1vdmUnXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQGNvbnN0cnVjdG9yIEwuRHJhZ2dhYmxlKGVsOiBIVE1MRWxlbWVudCwgZHJhZ0hhbmRsZT86IEhUTUxFbGVtZW50LCBwcmV2ZW50T3V0bGluZTogQm9vbGVhbilcclxuXHQvLyBDcmVhdGVzIGEgYERyYWdnYWJsZWAgb2JqZWN0IGZvciBtb3ZpbmcgYGVsYCB3aGVuIHlvdSBzdGFydCBkcmFnZ2luZyB0aGUgYGRyYWdIYW5kbGVgIGVsZW1lbnQgKGVxdWFscyBgZWxgIGl0c2VsZiBieSBkZWZhdWx0KS5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZWxlbWVudCwgZHJhZ1N0YXJ0VGFyZ2V0LCBwcmV2ZW50T3V0bGluZSkge1xyXG5cdFx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9kcmFnU3RhcnRUYXJnZXQgPSBkcmFnU3RhcnRUYXJnZXQgfHwgZWxlbWVudDtcclxuXHRcdHRoaXMuX3ByZXZlbnRPdXRsaW5lID0gcHJldmVudE91dGxpbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlbmFibGUoKVxyXG5cdC8vIEVuYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdEwuRG9tRXZlbnQub24odGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBMLkRyYWdnYWJsZS5TVEFSVC5qb2luKCcgJyksIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXNhYmxlKClcclxuXHQvLyBEaXNhYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIEwuRHJhZ2dhYmxlLlNUQVJULmpvaW4oJyAnKSwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKEwuRG9tVXRpbC5oYXNDbGFzcyh0aGlzLl9lbGVtZW50LCAnbGVhZmxldC16b29tLWFuaW0nKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoTC5EcmFnZ2FibGUuX2RyYWdnaW5nIHx8IGUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpICYmICFlLnRvdWNoZXMpIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cdFx0TC5EcmFnZ2FibGUuX2RyYWdnaW5nID0gdHJ1ZTsgIC8vIFByZXZlbnQgZHJhZ2dpbmcgbXVsdGlwbGUgb2JqZWN0cyBhdCBvbmNlLlxyXG5cclxuXHRcdGlmICh0aGlzLl9wcmV2ZW50T3V0bGluZSkge1xyXG5cdFx0XHRMLkRvbVV0aWwucHJldmVudE91dGxpbmUodGhpcy5fZWxlbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0TC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcclxuXHRcdEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tb3ZpbmcpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGRvd246IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBpcyBhYm91dCB0byBzdGFydC5cclxuXHRcdHRoaXMuZmlyZSgnZG93bicpO1xyXG5cclxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XHJcblxyXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IG5ldyBMLlBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0Lm9uKGRvY3VtZW50LCBMLkRyYWdnYWJsZS5NT1ZFW2UudHlwZV0sIHRoaXMuX29uTW92ZSwgdGhpcylcclxuXHRcdFx0Lm9uKGRvY3VtZW50LCBMLkRyYWdnYWJsZS5FTkRbZS50eXBlXSwgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSBzaW11bGF0ZWQgZXZlbnRzLCBzaW5jZSB3ZSBoYW5kbGUgYm90aCB0b3VjaCBhbmRcclxuXHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxyXG5cdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXHJcblx0XHQvLyBBbHNvIGlnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmlyc3QgPSAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPT09IDEgPyBlLnRvdWNoZXNbMF0gOiBlKSxcclxuXHRcdCAgICBuZXdQb2ludCA9IG5ldyBMLlBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG5ld1BvaW50LnN1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybjsgfVxyXG5cdFx0aWYgKE1hdGguYWJzKG9mZnNldC54KSArIE1hdGguYWJzKG9mZnNldC55KSA8IHRoaXMub3B0aW9ucy5jbGlja1RvbGVyYW5jZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cclxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcclxuXHRcdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgc3RhcnRzXHJcblx0XHRcdHRoaXMuZmlyZSgnZHJhZ3N0YXJ0Jyk7XHJcblxyXG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblx0XHRcdHRoaXMuX3N0YXJ0UG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQpLnN1YnRyYWN0KG9mZnNldCk7XHJcblxyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcblx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XHJcblx0XHRcdC8vIElFIGFuZCBFZGdlIGRvIG5vdCBnaXZlIHRoZSA8dXNlPiBlbGVtZW50LCBzbyBmZXRjaCBpdFxyXG5cdFx0XHQvLyBpZiBuZWNlc3NhcnlcclxuXHRcdFx0aWYgKCh3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlKSAmJiAodGhpcy5fbGFzdFRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnRJbnN0YW5jZSkpIHtcclxuXHRcdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gdGhpcy5fbGFzdFRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcclxuXHRcdFx0fVxyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9uZXdQb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcclxuXHRcdHRoaXMuX21vdmluZyA9IHRydWU7XHJcblxyXG5cdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XHJcblx0XHR0aGlzLl9sYXN0RXZlbnQgPSBlO1xyXG5cdFx0dGhpcy5fYW5pbVJlcXVlc3QgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVQb3NpdGlvbiwgdGhpcywgdHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZSA9IHtvcmlnaW5hbEV2ZW50OiB0aGlzLl9sYXN0RXZlbnR9O1xyXG5cclxuXHRcdC8vIEBldmVudCBwcmVkcmFnOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZyAqYmVmb3JlKiBlYWNoIGNvcnJlc3BvbmRpbmdcclxuXHRcdC8vIHVwZGF0ZSBvZiB0aGUgZWxlbWVudCdzIHBvc2l0aW9uLlxyXG5cdFx0dGhpcy5maXJlKCdwcmVkcmFnJywgZSk7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCwgdGhpcy5fbmV3UG9zKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcuXHJcblx0XHR0aGlzLmZpcmUoJ2RyYWcnLCBlKTtcclxuXHR9LFxyXG5cclxuXHRfb25VcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSBzaW11bGF0ZWQgZXZlbnRzLCBzaW5jZSB3ZSBoYW5kbGUgYm90aCB0b3VjaCBhbmRcclxuXHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxyXG5cdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXHJcblx0XHQvLyBBbHNvIGlnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RUYXJnZXQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gTC5EcmFnZ2FibGUuTU9WRSkge1xyXG5cdFx0XHRMLkRvbUV2ZW50XHJcblx0XHRcdFx0Lm9mZihkb2N1bWVudCwgTC5EcmFnZ2FibGUuTU9WRVtpXSwgdGhpcy5fb25Nb3ZlLCB0aGlzKVxyXG5cdFx0XHRcdC5vZmYoZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLkVORFtpXSwgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0TC5Eb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0TC5Eb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92ZWQgJiYgdGhpcy5fbW92aW5nKSB7XHJcblx0XHRcdC8vIGVuc3VyZSBkcmFnIGlzIG5vdCBmaXJlZCBhZnRlciBkcmFnZW5kXHJcblx0XHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cclxuXHRcdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBkcmFnIGVuZHMuXHJcblx0XHRcdHRoaXMuZmlyZSgnZHJhZ2VuZCcsIHtcclxuXHRcdFx0XHRkaXN0YW5jZTogdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21vdmluZyA9IGZhbHNlO1xyXG5cdFx0TC5EcmFnZ2FibGUuX2RyYWdnaW5nID0gZmFsc2U7XHJcblx0fVxyXG59KTtcclxuXG4vKlxuXHRMLkhhbmRsZXIgaXMgYSBiYXNlIGNsYXNzIGZvciBoYW5kbGVyIGNsYXNzZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5IHRvIGluamVjdFxuXHRpbnRlcmFjdGlvbiBmZWF0dXJlcyBsaWtlIGRyYWdnaW5nIHRvIGNsYXNzZXMgbGlrZSBNYXAgYW5kIE1hcmtlci5cbiovXG5cbi8vIEBjbGFzcyBIYW5kbGVyXG4vLyBAYWthIEwuSGFuZGxlclxuLy8gQWJzdHJhY3QgY2xhc3MgZm9yIG1hcCBpbnRlcmFjdGlvbiBoYW5kbGVyc1xuXG5MLkhhbmRsZXIgPSBMLkNsYXNzLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGUoKTogdGhpc1xuXHQvLyBFbmFibGVzIHRoZSBoYW5kbGVyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcblx0XHR0aGlzLmFkZEhvb2tzKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBkaXNhYmxlKCk6IHRoaXNcblx0Ly8gRGlzYWJsZXMgdGhlIGhhbmRsZXJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuXHRcdHRoaXMucmVtb3ZlSG9va3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZWQoKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaGFuZGxlciBpcyBlbmFibGVkXG5cdGVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9lbmFibGVkO1xuXHR9XG5cblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcblx0Ly8gQ2xhc3NlcyBpbmhlcml0aW5nIGZyb20gYEhhbmRsZXJgIG11c3QgaW1wbGVtZW50IHRoZSB0d28gZm9sbG93aW5nIG1ldGhvZHM6XG5cdC8vIEBtZXRob2QgYWRkSG9va3MoKVxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBlbmFibGVkLCBzaG91bGQgYWRkIGV2ZW50IGhvb2tzLlxuXHQvLyBAbWV0aG9kIHJlbW92ZUhvb2tzKClcblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZGlzYWJsZWQsIHNob3VsZCByZW1vdmUgdGhlIGV2ZW50IGhvb2tzIGFkZGVkIHByZXZpb3VzbHkuXG59KTtcblxuLypcbiAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZHJhZ2dpbmc6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBiZSBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXG5cdGRyYWdnaW5nOiB0cnVlLFxuXG5cdC8vIEBzZWN0aW9uIFBhbm5pbmcgSW5lcnRpYSBPcHRpb25zXG5cdC8vIEBvcHRpb24gaW5lcnRpYTogQm9vbGVhbiA9ICpcblx0Ly8gSWYgZW5hYmxlZCwgcGFubmluZyBvZiB0aGUgbWFwIHdpbGwgaGF2ZSBhbiBpbmVydGlhIGVmZmVjdCB3aGVyZVxuXHQvLyB0aGUgbWFwIGJ1aWxkcyBtb21lbnR1bSB3aGlsZSBkcmFnZ2luZyBhbmQgY29udGludWVzIG1vdmluZyBpblxuXHQvLyB0aGUgc2FtZSBkaXJlY3Rpb24gZm9yIHNvbWUgdGltZS4gRmVlbHMgZXNwZWNpYWxseSBuaWNlIG9uIHRvdWNoXG5cdC8vIGRldmljZXMuIEVuYWJsZWQgYnkgZGVmYXVsdCB1bmxlc3MgcnVubmluZyBvbiBvbGQgQW5kcm9pZCBkZXZpY2VzLlxuXHRpbmVydGlhOiAhTC5Ccm93c2VyLmFuZHJvaWQyMyxcblxuXHQvLyBAb3B0aW9uIGluZXJ0aWFEZWNlbGVyYXRpb246IE51bWJlciA9IDMwMDBcblx0Ly8gVGhlIHJhdGUgd2l0aCB3aGljaCB0aGUgaW5lcnRpYWwgbW92ZW1lbnQgc2xvd3MgZG93biwgaW4gcGl4ZWxzL3NlY29uZMKyLlxuXHRpbmVydGlhRGVjZWxlcmF0aW9uOiAzNDAwLCAvLyBweC9zXjJcblxuXHQvLyBAb3B0aW9uIGluZXJ0aWFNYXhTcGVlZDogTnVtYmVyID0gSW5maW5pdHlcblx0Ly8gTWF4IHNwZWVkIG9mIHRoZSBpbmVydGlhbCBtb3ZlbWVudCwgaW4gcGl4ZWxzL3NlY29uZC5cblx0aW5lcnRpYU1heFNwZWVkOiBJbmZpbml0eSwgLy8gcHgvc1xuXG5cdC8vIEBvcHRpb24gZWFzZUxpbmVhcml0eTogTnVtYmVyID0gMC4yXG5cdGVhc2VMaW5lYXJpdHk6IDAuMixcblxuXHQvLyBUT0RPIHJlZmFjdG9yLCBtb3ZlIHRvIENSU1xuXHQvLyBAb3B0aW9uIHdvcmxkQ29weUp1bXA6IEJvb2xlYW4gPSBmYWxzZVxuXHQvLyBXaXRoIHRoaXMgb3B0aW9uIGVuYWJsZWQsIHRoZSBtYXAgdHJhY2tzIHdoZW4geW91IHBhbiB0byBhbm90aGVyIFwiY29weVwiXG5cdC8vIG9mIHRoZSB3b3JsZCBhbmQgc2VhbWxlc3NseSBqdW1wcyB0byB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgYWxsIG92ZXJsYXlzXG5cdC8vIGxpa2UgbWFya2VycyBhbmQgdmVjdG9yIGxheWVycyBhcmUgc3RpbGwgdmlzaWJsZS5cblx0d29ybGRDb3B5SnVtcDogZmFsc2UsXG5cblx0Ly8gQG9wdGlvbiBtYXhCb3VuZHNWaXNjb3NpdHk6IE51bWJlciA9IDAuMFxuXHQvLyBJZiBgbWF4Qm91bmRzYCBpcyBzZXQsIHRoaXMgb3B0aW9uIHdpbGwgY29udHJvbCBob3cgc29saWQgdGhlIGJvdW5kc1xuXHQvLyBhcmUgd2hlbiBkcmFnZ2luZyB0aGUgbWFwIGFyb3VuZC4gVGhlIGRlZmF1bHQgdmFsdWUgb2YgYDAuMGAgYWxsb3dzIHRoZVxuXHQvLyB1c2VyIHRvIGRyYWcgb3V0c2lkZSB0aGUgYm91bmRzIGF0IG5vcm1hbCBzcGVlZCwgaGlnaGVyIHZhbHVlcyB3aWxsXG5cdC8vIHNsb3cgZG93biBtYXAgZHJhZ2dpbmcgb3V0c2lkZSBib3VuZHMsIGFuZCBgMS4wYCBtYWtlcyB0aGUgYm91bmRzIGZ1bGx5XG5cdC8vIHNvbGlkLCBwcmV2ZW50aW5nIHRoZSB1c2VyIGZyb20gZHJhZ2dpbmcgb3V0c2lkZSB0aGUgYm91bmRzLlxuXHRtYXhCb3VuZHNWaXNjb3NpdHk6IDAuMFxufSk7XG5cbkwuTWFwLkRyYWcgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuXHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IEwuRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0XHRkb3duOiB0aGlzLl9vbkRvd24sXG5cdFx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnTGltaXQsIHRoaXMpO1xuXHRcdFx0aWYgKG1hcC5vcHRpb25zLndvcmxkQ29weUp1bXApIHtcblx0XHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnV3JhcCwgdGhpcyk7XG5cdFx0XHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cblx0XHRcdFx0bWFwLndoZW5SZWFkeSh0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWIgbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmVuYWJsZSgpO1xuXHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdHRoaXMuX3RpbWVzID0gW107XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWInKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLWRyYWcnKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZGlzYWJsZSgpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdG1vdmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3Zpbmc7XG5cdH0sXG5cblx0X29uRG93bjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcC5fc3RvcCgpO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzICYmIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gTC5ib3VuZHMoXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXROb3J0aFdlc3QoKSkubXVsdGlwbHlCeSgtMSksXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSkubXVsdGlwbHlCeSgtMSlcblx0XHRcdFx0XHQuYWRkKHRoaXMuX21hcC5nZXRTaXplKCkpKTtcblxuXHRcdFx0dGhpcy5fdmlzY29zaXR5ID0gTWF0aC5taW4oMS4wLCBNYXRoLm1heCgwLjAsIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0bWFwXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXG5cdFx0XHQgICAgcG9zID0gdGhpcy5fbGFzdFBvcyA9IHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zIHx8IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zO1xuXG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuXHRcdFx0dGhpcy5fdGltZXMucHVzaCh0aW1lKTtcblxuXHRcdFx0aWYgKHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDUwKSB7XG5cdFx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5zaGlmdCgpO1xuXHRcdFx0XHR0aGlzLl90aW1lcy5zaGlmdCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX21hcFxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X29uWm9vbUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBweENlbnRlciA9IHRoaXMuX21hcC5nZXRTaXplKCkuZGl2aWRlQnkoMiksXG5cdFx0ICAgIHB4V29ybGRDZW50ZXIgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFswLCAwXSk7XG5cblx0XHR0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQgPSBweFdvcmxkQ2VudGVyLnN1YnRyYWN0KHB4Q2VudGVyKS54O1xuXHRcdHRoaXMuX3dvcmxkV2lkdGggPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcygpLmdldFNpemUoKS54O1xuXHR9LFxuXG5cdF92aXNjb3VzTGltaXQ6IGZ1bmN0aW9uICh2YWx1ZSwgdGhyZXNob2xkKSB7XG5cdFx0cmV0dXJuIHZhbHVlIC0gKHZhbHVlIC0gdGhyZXNob2xkKSAqIHRoaXMuX3Zpc2Nvc2l0eTtcblx0fSxcblxuXHRfb25QcmVEcmFnTGltaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX3Zpc2Nvc2l0eSB8fCAhdGhpcy5fb2Zmc2V0TGltaXQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3Muc3VidHJhY3QodGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcyk7XG5cblx0XHR2YXIgbGltaXQgPSB0aGlzLl9vZmZzZXRMaW1pdDtcblx0XHRpZiAob2Zmc2V0LnggPCBsaW1pdC5taW4ueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWluLngpOyB9XG5cdFx0aWYgKG9mZnNldC55IDwgbGltaXQubWluLnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1pbi55KTsgfVxuXHRcdGlmIChvZmZzZXQueCA+IGxpbWl0Lm1heC54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5tYXgueCk7IH1cblx0XHRpZiAob2Zmc2V0LnkgPiBsaW1pdC5tYXgueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWF4LnkpOyB9XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XG5cdH0sXG5cblx0X29uUHJlRHJhZ1dyYXA6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUT0RPIHJlZmFjdG9yIHRvIGJlIGFibGUgdG8gYWRqdXN0IG1hcCBwYW5lIHBvc2l0aW9uIGFmdGVyIHpvb21cblx0XHR2YXIgd29ybGRXaWR0aCA9IHRoaXMuX3dvcmxkV2lkdGgsXG5cdFx0ICAgIGhhbGZXaWR0aCA9IE1hdGgucm91bmQod29ybGRXaWR0aCAvIDIpLFxuXHRcdCAgICBkeCA9IHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCxcblx0XHQgICAgeCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLngsXG5cdFx0ICAgIG5ld1gxID0gKHggLSBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoICsgaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1gyID0gKHggKyBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoIC0gaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1ggPSBNYXRoLmFicyhuZXdYMSArIGR4KSA8IE1hdGguYWJzKG5ld1gyICsgZHgpID8gbmV3WDEgOiBuZXdYMjtcblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuY2xvbmUoKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54ID0gbmV3WDtcblx0fSxcblxuXHRfb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9wdGlvbnMgPSBtYXAub3B0aW9ucyxcblxuXHRcdCAgICBub0luZXJ0aWEgPSAhb3B0aW9ucy5pbmVydGlhIHx8IHRoaXMuX3RpbWVzLmxlbmd0aCA8IDI7XG5cblx0XHRtYXAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXG5cdFx0aWYgKG5vSW5lcnRpYSkge1xuXHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHZhciBkaXJlY3Rpb24gPSB0aGlzLl9sYXN0UG9zLnN1YnRyYWN0KHRoaXMuX3Bvc2l0aW9uc1swXSksXG5cdFx0XHQgICAgZHVyYXRpb24gPSAodGhpcy5fbGFzdFRpbWUgLSB0aGlzLl90aW1lc1swXSkgLyAxMDAwLFxuXHRcdFx0ICAgIGVhc2UgPSBvcHRpb25zLmVhc2VMaW5lYXJpdHksXG5cblx0XHRcdCAgICBzcGVlZFZlY3RvciA9IGRpcmVjdGlvbi5tdWx0aXBseUJ5KGVhc2UgLyBkdXJhdGlvbiksXG5cdFx0XHQgICAgc3BlZWQgPSBzcGVlZFZlY3Rvci5kaXN0YW5jZVRvKFswLCAwXSksXG5cblx0XHRcdCAgICBsaW1pdGVkU3BlZWQgPSBNYXRoLm1pbihvcHRpb25zLmluZXJ0aWFNYXhTcGVlZCwgc3BlZWQpLFxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZFZlY3RvciA9IHNwZWVkVmVjdG9yLm11bHRpcGx5QnkobGltaXRlZFNwZWVkIC8gc3BlZWQpLFxuXG5cdFx0XHQgICAgZGVjZWxlcmF0aW9uRHVyYXRpb24gPSBsaW1pdGVkU3BlZWQgLyAob3B0aW9ucy5pbmVydGlhRGVjZWxlcmF0aW9uICogZWFzZSksXG5cdFx0XHQgICAgb2Zmc2V0ID0gbGltaXRlZFNwZWVkVmVjdG9yLm11bHRpcGx5QnkoLWRlY2VsZXJhdGlvbkR1cmF0aW9uIC8gMikucm91bmQoKTtcblxuXHRcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcblx0XHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldChvZmZzZXQsIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdFx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQsIHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkZWNlbGVyYXRpb25EdXJhdGlvbixcblx0XHRcdFx0XHRcdGVhc2VMaW5lYXJpdHk6IGVhc2UsXG5cdFx0XHRcdFx0XHRub01vdmVTdGFydDogdHJ1ZSxcblx0XHRcdFx0XHRcdGFuaW1hdGU6IHRydWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuLy8gTWFwIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RyYWdnaW5nJywgTC5NYXAuRHJhZyk7XG5cbi8qXG4gKiBMLkhhbmRsZXIuRG91YmxlQ2xpY2tab29tIGlzIHVzZWQgdG8gaGFuZGxlIGRvdWJsZS1jbGljayB6b29tIG9uIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRvdWJsZUNsaWNrWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGluIGJ5IGRvdWJsZSBjbGlja2luZyBvbiBpdCBhbmRcblx0Ly8gem9vbWVkIG91dCBieSBkb3VibGUgY2xpY2tpbmcgd2hpbGUgaG9sZGluZyBzaGlmdC4gSWYgcGFzc2VkXG5cdC8vIGAnY2VudGVyJ2AsIGRvdWJsZS1jbGljayB6b29tIHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZVxuXHQvLyAgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG5cdGRvdWJsZUNsaWNrWm9vbTogdHJ1ZVxufSk7XG5cbkwuTWFwLkRvdWJsZUNsaWNrWm9vbSA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcC5vbignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcC5vZmYoJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG5cdH0sXG5cblx0X29uRG91YmxlQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb2xkWm9vbSA9IG1hcC5nZXRab29tKCksXG5cdFx0ICAgIGRlbHRhID0gbWFwLm9wdGlvbnMuem9vbURlbHRhLFxuXHRcdCAgICB6b29tID0gZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5ID8gb2xkWm9vbSAtIGRlbHRhIDogb2xkWm9vbSArIGRlbHRhO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmRvdWJsZUNsaWNrWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdG1hcC5zZXRab29tKHpvb20pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZChlLmNvbnRhaW5lclBvaW50LCB6b29tKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy9cbi8vIE1hcCBwcm9wZXJ0aWVzIGluY2x1ZGUgaW50ZXJhY3Rpb24gaGFuZGxlcnMgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbFxuLy8gaW50ZXJhY3Rpb24gYmVoYXZpb3IgaW4gcnVudGltZSwgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIGNlcnRhaW4gZmVhdHVyZXMgc3VjaFxuLy8gYXMgZHJhZ2dpbmcgb3IgdG91Y2ggem9vbSAoc2VlIGBIYW5kbGVyYCBtZXRob2RzKS4gRm9yIGV4YW1wbGU6XG4vL1xuLy8gYGBganNcbi8vIG1hcC5kb3VibGVDbGlja1pvb20uZGlzYWJsZSgpO1xuLy8gYGBgXG4vL1xuLy8gQHByb3BlcnR5IGRvdWJsZUNsaWNrWm9vbTogSGFuZGxlclxuLy8gRG91YmxlIGNsaWNrIHpvb20gaGFuZGxlci5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RvdWJsZUNsaWNrWm9vbScsIEwuTWFwLkRvdWJsZUNsaWNrWm9vbSk7XG5cbi8qXG4gKiBMLkhhbmRsZXIuU2Nyb2xsV2hlZWxab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gZW5hYmxlIG1vdXNlIHNjcm9sbCB3aGVlbCB6b29tIG9uIHRoZSBtYXAuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIE1vdXNld2hlZWwgb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHNjcm9sbFdoZWVsWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHVzaW5nIHRoZSBtb3VzZSB3aGVlbC4gSWYgcGFzc2VkIGAnY2VudGVyJ2AsXG5cdC8vIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0c2Nyb2xsV2hlZWxab29tOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxEZWJvdW5jZVRpbWU6IE51bWJlciA9IDQwXG5cdC8vIExpbWl0cyB0aGUgcmF0ZSBhdCB3aGljaCBhIHdoZWVsIGNhbiBmaXJlIChpbiBtaWxsaXNlY29uZHMpLiBCeSBkZWZhdWx0XG5cdC8vIHVzZXIgY2FuJ3Qgem9vbSB2aWEgd2hlZWwgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIDQwIG1zLlxuXHR3aGVlbERlYm91bmNlVGltZTogNDAsXG5cblx0Ly8gQG9wdGlvbiB3aGVlbFB4UGVyWm9vbUxldmVsOiBOdW1iZXIgPSA2MFxuXHQvLyBIb3cgbWFueSBzY3JvbGwgcGl4ZWxzIChhcyByZXBvcnRlZCBieSBbTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhXSgjZG9tZXZlbnQtZ2V0d2hlZWxkZWx0YSkpXG5cdC8vIG1lYW4gYSBjaGFuZ2Ugb2Ygb25lIGZ1bGwgem9vbSBsZXZlbC4gU21hbGxlciB2YWx1ZXMgd2lsbCBtYWtlIHdoZWVsLXpvb21pbmdcblx0Ly8gZmFzdGVyIChhbmQgdmljZSB2ZXJzYSkuXG5cdHdoZWVsUHhQZXJab29tTGV2ZWw6IDYwXG59KTtcblxuTC5NYXAuU2Nyb2xsV2hlZWxab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ21vdXNld2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXHR9LFxuXG5cdF9vbldoZWVsU2Nyb2xsOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBkZWx0YSA9IEwuRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YShlKTtcblxuXHRcdHZhciBkZWJvdW5jZSA9IHRoaXMuX21hcC5vcHRpb25zLndoZWVsRGVib3VuY2VUaW1lO1xuXG5cdFx0dGhpcy5fZGVsdGEgKz0gZGVsdGE7XG5cdFx0dGhpcy5fbGFzdE1vdXNlUG9zID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0aWYgKCF0aGlzLl9zdGFydFRpbWUpIHtcblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXHRcdH1cblxuXHRcdHZhciBsZWZ0ID0gTWF0aC5tYXgoZGVib3VuY2UgLSAoK25ldyBEYXRlKCkgLSB0aGlzLl9zdGFydFRpbWUpLCAwKTtcblxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG5cdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9wZXJmb3JtWm9vbSwgdGhpcyksIGxlZnQpO1xuXG5cdFx0TC5Eb21FdmVudC5zdG9wKGUpO1xuXHR9LFxuXG5cdF9wZXJmb3JtWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzbmFwID0gdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXAgfHwgMDtcblxuXHRcdG1hcC5fc3RvcCgpOyAvLyBzdG9wIHBhbm5pbmcgYW5kIGZseSBhbmltYXRpb25zIGlmIGFueVxuXG5cdFx0Ly8gbWFwIHRoZSBkZWx0YSB3aXRoIGEgc2lnbW9pZCBmdW5jdGlvbiB0byAtNC4uNCByYW5nZSBsZWFuaW5nIG9uIC0xLi4xXG5cdFx0dmFyIGQyID0gdGhpcy5fZGVsdGEgLyAodGhpcy5fbWFwLm9wdGlvbnMud2hlZWxQeFBlclpvb21MZXZlbCAqIDQpLFxuXHRcdCAgICBkMyA9IDQgKiBNYXRoLmxvZygyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZDIpKSkpIC8gTWF0aC5MTjIsXG5cdFx0ICAgIGQ0ID0gc25hcCA/IE1hdGguY2VpbChkMyAvIHNuYXApICogc25hcCA6IGQzLFxuXHRcdCAgICBkZWx0YSA9IG1hcC5fbGltaXRab29tKHpvb20gKyAodGhpcy5fZGVsdGEgPiAwID8gZDQgOiAtZDQpKSAtIHpvb207XG5cblx0XHR0aGlzLl9kZWx0YSA9IDA7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblxuXHRcdGlmICghZGVsdGEpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuc2Nyb2xsV2hlZWxab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSArIGRlbHRhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwLnNldFpvb21Bcm91bmQodGhpcy5fbGFzdE1vdXNlUG9zLCB6b29tICsgZGVsdGEpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgc2Nyb2xsV2hlZWxab29tOiBIYW5kbGVyXG4vLyBTY3JvbGwgd2hlZWwgem9vbSBoYW5kbGVyLlxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnc2Nyb2xsV2hlZWxab29tJywgTC5NYXAuU2Nyb2xsV2hlZWxab29tKTtcblxuLypcbiAqIEBjbGFzcyBQb3NBbmltYXRpb25cbiAqIEBha2EgTC5Qb3NBbmltYXRpb25cbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBVc2VkIGludGVybmFsbHkgZm9yIHBhbm5pbmcgYW5pbWF0aW9ucywgdXRpbGl6aW5nIENTUzMgVHJhbnNpdGlvbnMgZm9yIG1vZGVybiBicm93c2VycyBhbmQgYSB0aW1lciBmYWxsYmFjayBmb3IgSUU2LTkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiB2YXIgZnggPSBuZXcgTC5Qb3NBbmltYXRpb24oKTtcbiAqIGZ4LnJ1bihlbCwgWzMwMCwgNTAwXSwgMC41KTtcbiAqIGBgYFxuICpcbiAqIEBjb25zdHJ1Y3RvciBMLlBvc0FuaW1hdGlvbigpXG4gKiBDcmVhdGVzIGEgYFBvc0FuaW1hdGlvbmAgb2JqZWN0LlxuICpcbiAqL1xuXG5MLlBvc0FuaW1hdGlvbiA9IEwuRXZlbnRlZC5leHRlbmQoe1xuXG5cdC8vIEBtZXRob2QgcnVuKGVsOiBIVE1MRWxlbWVudCwgbmV3UG9zOiBQb2ludCwgZHVyYXRpb24/OiBOdW1iZXIsIGVhc2VMaW5lYXJpdHk/OiBOdW1iZXIpXG5cdC8vIFJ1biBhbiBhbmltYXRpb24gb2YgYSBnaXZlbiBlbGVtZW50IHRvIGEgbmV3IHBvc2l0aW9uLCBvcHRpb25hbGx5IHNldHRpbmdcblx0Ly8gZHVyYXRpb24gaW4gc2Vjb25kcyAoYDAuMjVgIGJ5IGRlZmF1bHQpIGFuZCBlYXNpbmcgbGluZWFyaXR5IGZhY3RvciAoM3JkXG5cdC8vIGFyZ3VtZW50IG9mIHRoZSBbY3ViaWMgYmV6aWVyIGN1cnZlXShodHRwOi8vY3ViaWMtYmV6aWVyLmNvbS8jMCwwLC41LDEpLFxuXHQvLyBgMC41YCBieSBkZWZhdWx0KS5cblx0cnVuOiBmdW5jdGlvbiAoZWwsIG5ld1BvcywgZHVyYXRpb24sIGVhc2VMaW5lYXJpdHkpIHtcblx0XHR0aGlzLnN0b3AoKTtcblxuXHRcdHRoaXMuX2VsID0gZWw7XG5cdFx0dGhpcy5faW5Qcm9ncmVzcyA9IHRydWU7XG5cdFx0dGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbiB8fCAwLjI1O1xuXHRcdHRoaXMuX2Vhc2VPdXRQb3dlciA9IDEgLyBNYXRoLm1heChlYXNlTGluZWFyaXR5IHx8IDAuNSwgMC4yKTtcblxuXHRcdHRoaXMuX3N0YXJ0UG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKGVsKTtcblx0XHR0aGlzLl9vZmZzZXQgPSBuZXdQb3Muc3VidHJhY3QodGhpcy5fc3RhcnRQb3MpO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydHNcblx0XHR0aGlzLmZpcmUoJ3N0YXJ0Jyk7XG5cblx0XHR0aGlzLl9hbmltYXRlKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzdG9wKClcblx0Ly8gU3RvcHMgdGhlIGFuaW1hdGlvbiAoaWYgY3VycmVudGx5IHJ1bm5pbmcpLlxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fc3RlcCh0cnVlKTtcblx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHR9LFxuXG5cdF9hbmltYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gYW5pbWF0aW9uIGxvb3Bcblx0XHR0aGlzLl9hbmltSWQgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlLCB0aGlzKTtcblx0XHR0aGlzLl9zdGVwKCk7XG5cdH0sXG5cblx0X3N0ZXA6IGZ1bmN0aW9uIChyb3VuZCkge1xuXHRcdHZhciBlbGFwc2VkID0gKCtuZXcgRGF0ZSgpKSAtIHRoaXMuX3N0YXJ0VGltZSxcblx0XHQgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbiAqIDEwMDA7XG5cblx0XHRpZiAoZWxhcHNlZCA8IGR1cmF0aW9uKSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSh0aGlzLl9lYXNlT3V0KGVsYXBzZWQgLyBkdXJhdGlvbiksIHJvdW5kKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUoMSk7XG5cdFx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfcnVuRnJhbWU6IGZ1bmN0aW9uIChwcm9ncmVzcywgcm91bmQpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKHRoaXMuX29mZnNldC5tdWx0aXBseUJ5KHByb2dyZXNzKSk7XG5cdFx0aWYgKHJvdW5kKSB7XG5cdFx0XHRwb3MuX3JvdW5kKCk7XG5cdFx0fVxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbCwgcG9zKTtcblxuXHRcdC8vIEBldmVudCBzdGVwOiBFdmVudFxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgdGhlIGFuaW1hdGlvbi5cblx0XHR0aGlzLmZpcmUoJ3N0ZXAnKTtcblx0fSxcblxuXHRfY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1JZCk7XG5cblx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XG5cdFx0Ly8gQGV2ZW50IGVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gZW5kcy5cblx0XHR0aGlzLmZpcmUoJ2VuZCcpO1xuXHR9LFxuXG5cdF9lYXNlT3V0OiBmdW5jdGlvbiAodCkge1xuXHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIHRoaXMuX2Vhc2VPdXRQb3dlcik7XG5cdH1cbn0pO1xuXG4vKlxuICogRXh0ZW5kcyBMLk1hcCB0byBoYW5kbGUgcGFubmluZyBhbmltYXRpb25zLlxuICovXG5cbkwuTWFwLmluY2x1ZGUoe1xuXG5cdHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcblxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xuXHRcdGNlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKEwubGF0TG5nKGNlbnRlciksIHpvb20sIHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dGhpcy5fc3RvcCgpO1xuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiAhb3B0aW9ucy5yZXNldCAmJiBvcHRpb25zICE9PSB0cnVlKSB7XG5cblx0XHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRvcHRpb25zLnpvb20gPSBMLmV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlfSwgb3B0aW9ucy56b29tKTtcblx0XHRcdFx0b3B0aW9ucy5wYW4gPSBMLmV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlLCBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbn0sIG9wdGlvbnMucGFuKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdHJ5IGFuaW1hdGluZyBwYW4gb3Igem9vbVxuXHRcdFx0dmFyIG1vdmVkID0gKHRoaXMuX3pvb20gIT09IHpvb20pID9cblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRab29tICYmIHRoaXMuX3RyeUFuaW1hdGVkWm9vbShjZW50ZXIsIHpvb20sIG9wdGlvbnMuem9vbSkgOlxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFBhbihjZW50ZXIsIG9wdGlvbnMucGFuKTtcblxuXHRcdFx0aWYgKG1vdmVkKSB7XG5cdFx0XHRcdC8vIHByZXZlbnQgcmVzaXplIGhhbmRsZXIgY2FsbCwgdGhlIHZpZXcgd2lsbCByZWZyZXNoIGFmdGVyIGFuaW1hdGlvbiBhbnl3YXlcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XG5cdFx0dGhpcy5fcmVzZXRWaWV3KGNlbnRlciwgem9vbSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRwYW5CeTogZnVuY3Rpb24gKG9mZnNldCwgb3B0aW9ucykge1xuXHRcdG9mZnNldCA9IEwucG9pbnQob2Zmc2V0KS5yb3VuZCgpO1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcblx0XHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcblx0XHR9XG5cdFx0Ly8gSWYgd2UgcGFuIHRvbyBmYXIsIENocm9tZSBnZXRzIGlzc3VlcyB3aXRoIHRpbGVzXG5cdFx0Ly8gYW5kIG1ha2VzIHRoZW0gZGlzYXBwZWFyIG9yIGFwcGVhciBpbiB0aGUgd3JvbmcgcGxhY2UgKHNsaWdodGx5IG9mZnNldCkgIzI2MDJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7XG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy51bnByb2plY3QodGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLmFkZChvZmZzZXQpKSwgdGhpcy5nZXRab29tKCkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9wYW5BbmltKSB7XG5cdFx0XHR0aGlzLl9wYW5BbmltID0gbmV3IEwuUG9zQW5pbWF0aW9uKCk7XG5cblx0XHRcdHRoaXMuX3BhbkFuaW0ub24oe1xuXHRcdFx0XHQnc3RlcCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvblN0ZXAsXG5cdFx0XHRcdCdlbmQnOiB0aGlzLl9vblBhblRyYW5zaXRpb25FbmRcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH1cblxuXHRcdC8vIGRvbid0IGZpcmUgbW92ZXN0YXJ0IGlmIGFuaW1hdGluZyBpbmVydGlhXG5cdFx0aWYgKCFvcHRpb25zLm5vTW92ZVN0YXJ0KSB7XG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xuXHRcdH1cblxuXHRcdC8vIGFuaW1hdGUgcGFuIHVubGVzcyBhbmltYXRlOiBmYWxzZSBzcGVjaWZpZWRcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSBmYWxzZSkge1xuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XG5cblx0XHRcdHZhciBuZXdQb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KS5yb3VuZCgpO1xuXHRcdFx0dGhpcy5fcGFuQW5pbS5ydW4odGhpcy5fbWFwUGFuZSwgbmV3UG9zLCBvcHRpb25zLmR1cmF0aW9uIHx8IDAuMjUsIG9wdGlvbnMuZWFzZUxpbmVhcml0eSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKS5maXJlKCdtb3ZlZW5kJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X29uUGFuVHJhbnNpdGlvblN0ZXA6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcblx0fSxcblxuXHRfb25QYW5UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XG5cdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XG5cdH0sXG5cblx0X3RyeUFuaW1hdGVkUGFuOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7XG5cdFx0Ly8gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBuZXcgYW5kIGN1cnJlbnQgY2VudGVycyBpbiBwaXhlbHNcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX2Zsb29yKCk7XG5cblx0XHQvLyBkb24ndCBhbmltYXRlIHRvbyBmYXIgdW5sZXNzIGFuaW1hdGU6IHRydWUgc3BlY2lmaWVkIGluIG9wdGlvbnNcblx0XHRpZiAoKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRlKSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdHRoaXMucGFuQnkob2Zmc2V0LCBvcHRpb25zKTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxuLypcbiAqIEV4dGVuZHMgTC5NYXAgdG8gaGFuZGxlIHpvb20gYW5pbWF0aW9ucy5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gQW5pbWF0aW9uIE9wdGlvbnNcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIHpvb20gYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXG5cdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cblx0em9vbUFuaW1hdGlvbjogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IE51bWJlciA9IDRcblx0Ly8gV29uJ3QgYW5pbWF0ZSB6b29tIGlmIHRoZSB6b29tIGRpZmZlcmVuY2UgZXhjZWVkcyB0aGlzIHZhbHVlLlxuXHR6b29tQW5pbWF0aW9uVGhyZXNob2xkOiA0XG59KTtcblxudmFyIHpvb21BbmltYXRlZCA9IEwuRG9tVXRpbC5UUkFOU0lUSU9OICYmIEwuQnJvd3Nlci5hbnkzZCAmJiAhTC5Ccm93c2VyLm1vYmlsZU9wZXJhO1xuXG5pZiAoem9vbUFuaW1hdGVkKSB7XG5cblx0TC5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xuXHRcdC8vIGRvbid0IGFuaW1hdGUgb24gYnJvd3NlcnMgd2l0aG91dCBoYXJkd2FyZS1hY2NlbGVyYXRlZCB0cmFuc2l0aW9ucyBvciBvbGQgQW5kcm9pZC9PcGVyYVxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uO1xuXG5cdFx0Ly8gem9vbSB0cmFuc2l0aW9ucyBydW4gd2l0aCB0aGUgc2FtZSBkdXJhdGlvbiBmb3IgYWxsIGxheWVycywgc28gaWYgb25lIG9mIHRyYW5zaXRpb25lbmQgZXZlbnRzXG5cdFx0Ly8gaGFwcGVucyBhZnRlciBzdGFydGluZyB6b29tIGFuaW1hdGlvbiAocHJvcGFnYXRpbmcgdG8gdGhlIG1hcCBwYW5lKSwgd2Uga25vdyB0aGF0IGl0IGVuZGVkIGdsb2JhbGx5XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXG5cdFx0XHR0aGlzLl9jcmVhdGVBbmltUHJveHkoKTtcblxuXHRcdFx0TC5Eb21FdmVudC5vbih0aGlzLl9wcm94eSwgTC5Eb21VdGlsLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9jYXRjaFRyYW5zaXRpb25FbmQsIHRoaXMpO1xuXHRcdH1cblx0fSk7XG59XG5cbkwuTWFwLmluY2x1ZGUoIXpvb21BbmltYXRlZCA/IHt9IDoge1xuXG5cdF9jcmVhdGVBbmltUHJveHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwcm94eSA9IHRoaXMuX3Byb3h5ID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtcHJveHkgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG5cdFx0dGhpcy5fcGFuZXMubWFwUGFuZS5hcHBlbmRDaGlsZChwcm94eSk7XG5cblx0XHR0aGlzLm9uKCd6b29tYW5pbScsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR2YXIgcHJvcCA9IEwuRG9tVXRpbC5UUkFOU0ZPUk0sXG5cdFx0XHQgICAgdHJhbnNmb3JtID0gcHJveHkuc3R5bGVbcHJvcF07XG5cblx0XHRcdEwuRG9tVXRpbC5zZXRUcmFuc2Zvcm0ocHJveHksIHRoaXMucHJvamVjdChlLmNlbnRlciwgZS56b29tKSwgdGhpcy5nZXRab29tU2NhbGUoZS56b29tLCAxKSk7XG5cblx0XHRcdC8vIHdvcmthcm91bmQgZm9yIGNhc2Ugd2hlbiB0cmFuc2Zvcm0gaXMgdGhlIHNhbWUgYW5kIHNvIHRyYW5zaXRpb25lbmQgZXZlbnQgaXMgbm90IGZpcmVkXG5cdFx0XHRpZiAodHJhbnNmb3JtID09PSBwcm94eS5zdHlsZVtwcm9wXSAmJiB0aGlzLl9hbmltYXRpbmdab29tKSB7XG5cdFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcblx0XHRcdH1cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMub24oJ2xvYWQgbW92ZWVuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjID0gdGhpcy5nZXRDZW50ZXIoKSxcblx0XHRcdCAgICB6ID0gdGhpcy5nZXRab29tKCk7XG5cdFx0XHRMLkRvbVV0aWwuc2V0VHJhbnNmb3JtKHByb3h5LCB0aGlzLnByb2plY3QoYywgeiksIHRoaXMuZ2V0Wm9vbVNjYWxlKHosIDEpKTtcblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfY2F0Y2hUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tICYmIGUucHJvcGVydHlOYW1lLmluZGV4T2YoJ3RyYW5zZm9ybScpID49IDApIHtcblx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcblx0XHR9XG5cdH0sXG5cblx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKS5sZW5ndGg7XG5cdH0sXG5cblx0X3RyeUFuaW1hdGVkWm9vbTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xuXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiBkaXNhYmxlZCwgbm90IHN1cHBvcnRlZCBvciB6b29tIGRpZmZlcmVuY2UgaXMgdG9vIGxhcmdlXG5cdFx0aWYgKCF0aGlzLl96b29tQW5pbWF0ZWQgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCB0aGlzLl9ub3RoaW5nVG9BbmltYXRlKCkgfHxcblx0XHQgICAgICAgIE1hdGguYWJzKHpvb20gLSB0aGlzLl96b29tKSA+IHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uVGhyZXNob2xkKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gb2Zmc2V0IGlzIHRoZSBwaXhlbCBjb29yZHMgb2YgdGhlIHpvb20gb3JpZ2luIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IGNlbnRlclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZGl2aWRlQnkoMSAtIDEgLyBzY2FsZSk7XG5cblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHRMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzXG5cdFx0XHQgICAgLl9tb3ZlU3RhcnQodHJ1ZSlcblx0XHRcdCAgICAuX2FuaW1hdGVab29tKGNlbnRlciwgem9vbSwgdHJ1ZSk7XG5cdFx0fSwgdGhpcyk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIHN0YXJ0QW5pbSwgbm9VcGRhdGUpIHtcblx0XHRpZiAoc3RhcnRBbmltKSB7XG5cdFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gdHJ1ZTtcblxuXHRcdFx0Ly8gcmVtZW1iZXIgd2hhdCBjZW50ZXIvem9vbSB0byBzZXQgYWZ0ZXIgYW5pbWF0aW9uXG5cdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XG5cdFx0XHR0aGlzLl9hbmltYXRlVG9ab29tID0gem9vbTtcblxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xuXHRcdH1cblxuXHRcdC8vIEBldmVudCB6b29tYW5pbTogWm9vbUFuaW1FdmVudFxuXHRcdC8vIEZpcmVkIG9uIGV2ZXJ5IGZyYW1lIG9mIGEgem9vbSBhbmltYXRpb25cblx0XHR0aGlzLmZpcmUoJ3pvb21hbmltJywge1xuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXG5cdFx0XHR6b29tOiB6b29tLFxuXHRcdFx0bm9VcGRhdGU6IG5vVXBkYXRlXG5cdFx0fSk7XG5cblx0XHQvLyBXb3JrIGFyb3VuZCB3ZWJraXQgbm90IGZpcmluZyAndHJhbnNpdGlvbmVuZCcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zNjg5LCAyNjkzXG5cdFx0c2V0VGltZW91dChMLmJpbmQodGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCwgdGhpcyksIDI1MCk7XG5cdH0sXG5cblx0X29uWm9vbVRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XG5cblx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gZmFsc2U7XG5cblx0XHR0aGlzLl9tb3ZlKHRoaXMuX2FuaW1hdGVUb0NlbnRlciwgdGhpcy5fYW5pbWF0ZVRvWm9vbSk7XG5cblx0XHQvLyBUaGlzIGFuaW0gZnJhbWUgc2hvdWxkIHByZXZlbnQgYW4gb2JzY3VyZSBpT1Mgd2Via2l0IHRpbGUgbG9hZGluZyByYWNlIGNvbmRpdGlvbi5cblx0XHRMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9tb3ZlRW5kKHRydWUpO1xuXHRcdH0sIHRoaXMpO1xuXHR9XG59KTtcblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcbkwuTWFwLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2QgZmx5VG8obGF0bG5nOiBMYXRMbmcsIHpvb20/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHBlcmZvcm1pbmcgYSBzbW9vdGhcblx0Ly8gcGFuLXpvb20gYW5pbWF0aW9uLlxuXHRmbHlUbzogZnVuY3Rpb24gKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucykge1xuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgIUwuQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N0b3AoKTtcblxuXHRcdHZhciBmcm9tID0gdGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLFxuXHRcdCAgICB0byA9IHRoaXMucHJvamVjdCh0YXJnZXRDZW50ZXIpLFxuXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCksXG5cdFx0ICAgIHN0YXJ0Wm9vbSA9IHRoaXMuX3pvb207XG5cblx0XHR0YXJnZXRDZW50ZXIgPSBMLmxhdExuZyh0YXJnZXRDZW50ZXIpO1xuXHRcdHRhcmdldFpvb20gPSB0YXJnZXRab29tID09PSB1bmRlZmluZWQgPyBzdGFydFpvb20gOiB0YXJnZXRab29tO1xuXG5cdFx0dmFyIHcwID0gTWF0aC5tYXgoc2l6ZS54LCBzaXplLnkpLFxuXHRcdCAgICB3MSA9IHcwICogdGhpcy5nZXRab29tU2NhbGUoc3RhcnRab29tLCB0YXJnZXRab29tKSxcblx0XHQgICAgdTEgPSAodG8uZGlzdGFuY2VUbyhmcm9tKSkgfHwgMSxcblx0XHQgICAgcmhvID0gMS40Mixcblx0XHQgICAgcmhvMiA9IHJobyAqIHJobztcblxuXHRcdGZ1bmN0aW9uIHIoaSkge1xuXHRcdFx0dmFyIHMxID0gaSA/IC0xIDogMSxcblx0XHRcdCAgICBzMiA9IGkgPyB3MSA6IHcwLFxuXHRcdFx0ICAgIHQxID0gdzEgKiB3MSAtIHcwICogdzAgKyBzMSAqIHJobzIgKiByaG8yICogdTEgKiB1MSxcblx0XHRcdCAgICBiMSA9IDIgKiBzMiAqIHJobzIgKiB1MSxcblx0XHRcdCAgICBiID0gdDEgLyBiMSxcblx0XHRcdCAgICBzcSA9IE1hdGguc3FydChiICogYiArIDEpIC0gYjtcblxuXHRcdFx0ICAgIC8vIHdvcmthcm91bmQgZm9yIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBidWcgd2hlbiBzcSA9IDAsIGxvZyA9IC1JbmZpbml0ZSxcblx0XHRcdCAgICAvLyB0aHVzIHRyaWdnZXJpbmcgYW4gaW5maW5pdGUgbG9vcCBpbiBmbHlUb1xuXHRcdFx0ICAgIHZhciBsb2cgPSBzcSA8IDAuMDAwMDAwMDAxID8gLTE4IDogTWF0aC5sb2coc3EpO1xuXG5cdFx0XHRyZXR1cm4gbG9nO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNpbmgobikgeyByZXR1cm4gKE1hdGguZXhwKG4pIC0gTWF0aC5leHAoLW4pKSAvIDI7IH1cblx0XHRmdW5jdGlvbiBjb3NoKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSArIE1hdGguZXhwKC1uKSkgLyAyOyB9XG5cdFx0ZnVuY3Rpb24gdGFuaChuKSB7IHJldHVybiBzaW5oKG4pIC8gY29zaChuKTsgfVxuXG5cdFx0dmFyIHIwID0gcigwKTtcblxuXHRcdGZ1bmN0aW9uIHcocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgLyBjb3NoKHIwICsgcmhvICogcykpOyB9XG5cdFx0ZnVuY3Rpb24gdShzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAqIHRhbmgocjAgKyByaG8gKiBzKSAtIHNpbmgocjApKSAvIHJobzI7IH1cblxuXHRcdGZ1bmN0aW9uIGVhc2VPdXQodCkgeyByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCAxLjUpOyB9XG5cblx0XHR2YXIgc3RhcnQgPSBEYXRlLm5vdygpLFxuXHRcdCAgICBTID0gKHIoMSkgLSByMCkgLyByaG8sXG5cdFx0ICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiA/IDEwMDAgKiBvcHRpb25zLmR1cmF0aW9uIDogMTAwMCAqIFMgKiAwLjg7XG5cblx0XHRmdW5jdGlvbiBmcmFtZSgpIHtcblx0XHRcdHZhciB0ID0gKERhdGUubm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbixcblx0XHRcdCAgICBzID0gZWFzZU91dCh0KSAqIFM7XG5cblx0XHRcdGlmICh0IDw9IDEpIHtcblx0XHRcdFx0dGhpcy5fZmx5VG9GcmFtZSA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZyYW1lLCB0aGlzKTtcblxuXHRcdFx0XHR0aGlzLl9tb3ZlKFxuXHRcdFx0XHRcdHRoaXMudW5wcm9qZWN0KGZyb20uYWRkKHRvLnN1YnRyYWN0KGZyb20pLm11bHRpcGx5QnkodShzKSAvIHUxKSksIHN0YXJ0Wm9vbSksXG5cdFx0XHRcdFx0dGhpcy5nZXRTY2FsZVpvb20odzAgLyB3KHMpLCBzdGFydFpvb20pLFxuXHRcdFx0XHRcdHtmbHlUbzogdHJ1ZX0pO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzXG5cdFx0XHRcdFx0Ll9tb3ZlKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSlcblx0XHRcdFx0XHQuX21vdmVFbmQodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fbW92ZVN0YXJ0KHRydWUpO1xuXG5cdFx0ZnJhbWUuY2FsbCh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGZseVRvQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCB3aXRoIGEgc21vb3RoIGFuaW1hdGlvbiBsaWtlIFtgZmx5VG9gXSgjbWFwLWZseXRvKSxcblx0Ly8gYnV0IHRha2VzIGEgYm91bmRzIHBhcmFtZXRlciBsaWtlIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxuXHRmbHlUb0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XG5cdFx0cmV0dXJuIHRoaXMuZmx5VG8odGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xuXHR9XG59KTtcblxuLypcclxuICogRXh0ZW5kcyB0aGUgZXZlbnQgaGFuZGxpbmcgY29kZSB3aXRoIGRvdWJsZSB0YXAgc3VwcG9ydCBmb3IgbW9iaWxlIGJyb3dzZXJzLlxyXG4gKi9cclxuXHJcbkwuZXh0ZW5kKEwuRG9tRXZlbnQsIHtcclxuXHJcblx0X3RvdWNoc3RhcnQ6IEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgOiBMLkJyb3dzZXIucG9pbnRlciA/ICdwb2ludGVyZG93bicgOiAndG91Y2hzdGFydCcsXHJcblx0X3RvdWNoZW5kOiBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyA6IEwuQnJvd3Nlci5wb2ludGVyID8gJ3BvaW50ZXJ1cCcgOiAndG91Y2hlbmQnLFxyXG5cclxuXHQvLyBpbnNwaXJlZCBieSBaZXB0byB0b3VjaCBjb2RlIGJ5IFRob21hcyBGdWNoc1xyXG5cdGFkZERvdWJsZVRhcExpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCBoYW5kbGVyLCBpZCkge1xyXG5cdFx0dmFyIGxhc3QsIHRvdWNoLFxyXG5cdFx0ICAgIGRvdWJsZVRhcCA9IGZhbHNlLFxyXG5cdFx0ICAgIGRlbGF5ID0gMjUwO1xyXG5cclxuXHRcdGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XHJcblx0XHRcdHZhciBjb3VudDtcclxuXHJcblx0XHRcdGlmIChMLkJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRcdGNvdW50ID0gTC5Eb21FdmVudC5fcG9pbnRlcnNDb3VudDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb3VudCA9IGUudG91Y2hlcy5sZW5ndGg7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChjb3VudCA+IDEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKSxcclxuXHRcdFx0ICAgIGRlbHRhID0gbm93IC0gKGxhc3QgfHwgbm93KTtcclxuXHJcblx0XHRcdHRvdWNoID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcclxuXHRcdFx0ZG91YmxlVGFwID0gKGRlbHRhID4gMCAmJiBkZWx0YSA8PSBkZWxheSk7XHJcblx0XHRcdGxhc3QgPSBub3c7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25Ub3VjaEVuZCgpIHtcclxuXHRcdFx0aWYgKGRvdWJsZVRhcCAmJiAhdG91Y2guY2FuY2VsQnViYmxlKSB7XHJcblx0XHRcdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRcdFx0XHQvLyB3b3JrIGFyb3VuZCAudHlwZSBiZWluZyByZWFkb25seSB3aXRoIE1TUG9pbnRlciogZXZlbnRzXHJcblx0XHRcdFx0XHR2YXIgbmV3VG91Y2ggPSB7fSxcclxuXHRcdFx0XHRcdCAgICBwcm9wLCBpO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoaSBpbiB0b3VjaCkge1xyXG5cdFx0XHRcdFx0XHRwcm9wID0gdG91Y2hbaV07XHJcblx0XHRcdFx0XHRcdG5ld1RvdWNoW2ldID0gcHJvcCAmJiBwcm9wLmJpbmQgPyBwcm9wLmJpbmQodG91Y2gpIDogcHJvcDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRvdWNoID0gbmV3VG91Y2g7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRvdWNoLnR5cGUgPSAnZGJsY2xpY2snO1xyXG5cdFx0XHRcdGhhbmRsZXIodG91Y2gpO1xyXG5cdFx0XHRcdGxhc3QgPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHByZSA9ICdfbGVhZmxldF8nLFxyXG5cdFx0ICAgIHRvdWNoc3RhcnQgPSB0aGlzLl90b3VjaHN0YXJ0LFxyXG5cdFx0ICAgIHRvdWNoZW5kID0gdGhpcy5fdG91Y2hlbmQ7XHJcblxyXG5cdFx0b2JqW3ByZSArIHRvdWNoc3RhcnQgKyBpZF0gPSBvblRvdWNoU3RhcnQ7XHJcblx0XHRvYmpbcHJlICsgdG91Y2hlbmQgKyBpZF0gPSBvblRvdWNoRW5kO1xyXG5cdFx0b2JqW3ByZSArICdkYmxjbGljaycgKyBpZF0gPSBoYW5kbGVyO1xyXG5cclxuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRvdWNoc3RhcnQsIG9uVG91Y2hTdGFydCwgZmFsc2UpO1xyXG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodG91Y2hlbmQsIG9uVG91Y2hFbmQsIGZhbHNlKTtcclxuXHJcblx0XHQvLyBPbiBzb21lIHBsYXRmb3JtcyAobm90YWJseSwgY2hyb21lIG9uIHdpbjEwICsgdG91Y2hzY3JlZW4gKyBtb3VzZSksXHJcblx0XHQvLyB0aGUgYnJvd3NlciBkb2Vzbid0IGZpcmUgdG91Y2hlbmQvcG9pbnRlcnVwIGV2ZW50cyBidXQgZG9lcyBmaXJlXHJcblx0XHQvLyBuYXRpdmUgZGJsY2xpY2tzLiBTZWUgIzQxMjcuXHJcblx0XHRpZiAoIUwuQnJvd3Nlci5lZGdlKSB7XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVEb3VibGVUYXBMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgaWQpIHtcclxuXHRcdHZhciBwcmUgPSAnX2xlYWZsZXRfJyxcclxuXHRcdCAgICB0b3VjaHN0YXJ0ID0gb2JqW3ByZSArIHRoaXMuX3RvdWNoc3RhcnQgKyBpZF0sXHJcblx0XHQgICAgdG91Y2hlbmQgPSBvYmpbcHJlICsgdGhpcy5fdG91Y2hlbmQgKyBpZF0sXHJcblx0XHQgICAgZGJsY2xpY2sgPSBvYmpbcHJlICsgJ2RibGNsaWNrJyArIGlkXTtcclxuXHJcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl90b3VjaHN0YXJ0LCB0b3VjaHN0YXJ0LCBmYWxzZSk7XHJcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl90b3VjaGVuZCwgdG91Y2hlbmQsIGZhbHNlKTtcclxuXHRcdGlmICghTC5Ccm93c2VyLmVkZ2UpIHtcclxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZGJsY2xpY2ssIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cbi8qXG4gKiBFeHRlbmRzIEwuRG9tRXZlbnQgdG8gcHJvdmlkZSB0b3VjaCBzdXBwb3J0IGZvciBJbnRlcm5ldCBFeHBsb3JlciBhbmQgV2luZG93cy1iYXNlZCBkZXZpY2VzLlxuICovXG5cbkwuZXh0ZW5kKEwuRG9tRXZlbnQsIHtcblxuXHRQT0lOVEVSX0RPV046ICAgTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJEb3duJyAgIDogJ3BvaW50ZXJkb3duJyxcblx0UE9JTlRFUl9NT1ZFOiAgIEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyTW92ZScgICA6ICdwb2ludGVybW92ZScsXG5cdFBPSU5URVJfVVA6ICAgICBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyAgICAgOiAncG9pbnRlcnVwJyxcblx0UE9JTlRFUl9DQU5DRUw6IEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyQ2FuY2VsJyA6ICdwb2ludGVyY2FuY2VsJyxcblx0VEFHX1dISVRFX0xJU1Q6IFsnSU5QVVQnLCAnU0VMRUNUJywgJ09QVElPTiddLFxuXG5cdF9wb2ludGVyczoge30sXG5cdF9wb2ludGVyc0NvdW50OiAwLFxuXG5cdC8vIFByb3ZpZGVzIGEgdG91Y2ggZXZlbnRzIHdyYXBwZXIgZm9yIChtcylwb2ludGVyIGV2ZW50cy5cblx0Ly8gcmVmIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvIGh0dHBzOi8vd3d3LnczLm9yZy9CdWdzL1B1YmxpYy9zaG93X2J1Zy5jZ2k/aWQ9MjI4OTBcblxuXHRhZGRQb2ludGVyTGlzdGVuZXI6IGZ1bmN0aW9uIChvYmosIHR5cGUsIGhhbmRsZXIsIGlkKSB7XG5cblx0XHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG5cdFx0XHR0aGlzLl9hZGRQb2ludGVyU3RhcnQob2JqLCBoYW5kbGVyLCBpZCk7XG5cblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG5cdFx0XHR0aGlzLl9hZGRQb2ludGVyTW92ZShvYmosIGhhbmRsZXIsIGlkKTtcblxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuXHRcdFx0dGhpcy5fYWRkUG9pbnRlckVuZChvYmosIGhhbmRsZXIsIGlkKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVQb2ludGVyTGlzdGVuZXI6IGZ1bmN0aW9uIChvYmosIHR5cGUsIGlkKSB7XG5cdFx0dmFyIGhhbmRsZXIgPSBvYmpbJ19sZWFmbGV0XycgKyB0eXBlICsgaWRdO1xuXG5cdFx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX0RPV04sIGhhbmRsZXIsIGZhbHNlKTtcblxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcblx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9NT1ZFLCBoYW5kbGVyLCBmYWxzZSk7XG5cblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcblx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9VUCwgaGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX0NBTkNFTCwgaGFuZGxlciwgZmFsc2UpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9hZGRQb2ludGVyU3RhcnQ6IGZ1bmN0aW9uIChvYmosIGhhbmRsZXIsIGlkKSB7XG5cdFx0dmFyIG9uRG93biA9IEwuYmluZChmdW5jdGlvbiAoZSkge1xuXHRcdFx0aWYgKGUucG9pbnRlclR5cGUgIT09ICdtb3VzZScgJiYgZS5wb2ludGVyVHlwZSAhPT0gZS5NU1BPSU5URVJfVFlQRV9NT1VTRSkge1xuXHRcdFx0XHQvLyBJbiBJRTExLCBzb21lIHRvdWNoIGV2ZW50cyBuZWVkcyB0byBmaXJlIGZvciBmb3JtIGNvbnRyb2xzLCBvclxuXHRcdFx0XHQvLyB0aGUgY29udHJvbHMgd2lsbCBzdG9wIHdvcmtpbmcuIFdlIGtlZXAgYSB3aGl0ZWxpc3Qgb2YgdGFnIG5hbWVzIHRoYXRcblx0XHRcdFx0Ly8gbmVlZCB0aGVzZSBldmVudHMuIEZvciBvdGhlciB0YXJnZXQgdGFncywgd2UgcHJldmVudCBkZWZhdWx0IG9uIHRoZSBldmVudC5cblx0XHRcdFx0aWYgKHRoaXMuVEFHX1dISVRFX0xJU1QuaW5kZXhPZihlLnRhcmdldC50YWdOYW1lKSA8IDApIHtcblx0XHRcdFx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpO1xuXHRcdH0sIHRoaXMpO1xuXG5cdFx0b2JqWydfbGVhZmxldF90b3VjaHN0YXJ0JyArIGlkXSA9IG9uRG93bjtcblx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfRE9XTiwgb25Eb3duLCBmYWxzZSk7XG5cblx0XHQvLyBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygd2hhdCBwb2ludGVycyBhbmQgaG93IG1hbnkgYXJlIGFjdGl2ZSB0byBwcm92aWRlIGUudG91Y2hlcyBlbXVsYXRpb25cblx0XHRpZiAoIXRoaXMuX3BvaW50ZXJEb2NMaXN0ZW5lcikge1xuXHRcdFx0dmFyIHBvaW50ZXJVcCA9IEwuYmluZCh0aGlzLl9nbG9iYWxQb2ludGVyVXAsIHRoaXMpO1xuXG5cdFx0XHQvLyB3ZSBsaXN0ZW4gZG9jdW1lbnRFbGVtZW50IGFzIGFueSBkcmFncyB0aGF0IGVuZCBieSBtb3ZpbmcgdGhlIHRvdWNoIG9mZiB0aGUgc2NyZWVuIGdldCBmaXJlZCB0aGVyZVxuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX0RPV04sIEwuYmluZCh0aGlzLl9nbG9iYWxQb2ludGVyRG93biwgdGhpcyksIHRydWUpO1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX01PVkUsIEwuYmluZCh0aGlzLl9nbG9iYWxQb2ludGVyTW92ZSwgdGhpcyksIHRydWUpO1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX1VQLCBwb2ludGVyVXAsIHRydWUpO1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX0NBTkNFTCwgcG9pbnRlclVwLCB0cnVlKTtcblxuXHRcdFx0dGhpcy5fcG9pbnRlckRvY0xpc3RlbmVyID0gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0X2dsb2JhbFBvaW50ZXJEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMuX3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG5cdFx0dGhpcy5fcG9pbnRlcnNDb3VudCsrO1xuXHR9LFxuXG5cdF9nbG9iYWxQb2ludGVyTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fcG9pbnRlcnNbZS5wb2ludGVySWRdKSB7XG5cdFx0XHR0aGlzLl9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuXHRcdH1cblx0fSxcblxuXHRfZ2xvYmFsUG9pbnRlclVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGRlbGV0ZSB0aGlzLl9wb2ludGVyc1tlLnBvaW50ZXJJZF07XG5cdFx0dGhpcy5fcG9pbnRlcnNDb3VudC0tO1xuXHR9LFxuXG5cdF9oYW5kbGVQb2ludGVyOiBmdW5jdGlvbiAoZSwgaGFuZGxlcikge1xuXHRcdGUudG91Y2hlcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fcG9pbnRlcnMpIHtcblx0XHRcdGUudG91Y2hlcy5wdXNoKHRoaXMuX3BvaW50ZXJzW2ldKTtcblx0XHR9XG5cdFx0ZS5jaGFuZ2VkVG91Y2hlcyA9IFtlXTtcblxuXHRcdGhhbmRsZXIoZSk7XG5cdH0sXG5cblx0X2FkZFBvaW50ZXJNb3ZlOiBmdW5jdGlvbiAob2JqLCBoYW5kbGVyLCBpZCkge1xuXHRcdHZhciBvbk1vdmUgPSBMLmJpbmQoZnVuY3Rpb24gKGUpIHtcblx0XHRcdC8vIGRvbid0IGZpcmUgdG91Y2ggbW92ZXMgd2hlbiBtb3VzZSBpc24ndCBkb3duXG5cdFx0XHRpZiAoKGUucG9pbnRlclR5cGUgPT09IGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgJiYgZS5idXR0b25zID09PSAwKSB7IHJldHVybjsgfVxuXG5cdFx0XHR0aGlzLl9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpO1xuXHRcdH0sIHRoaXMpO1xuXG5cdFx0b2JqWydfbGVhZmxldF90b3VjaG1vdmUnICsgaWRdID0gb25Nb3ZlO1xuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9NT1ZFLCBvbk1vdmUsIGZhbHNlKTtcblx0fSxcblxuXHRfYWRkUG9pbnRlckVuZDogZnVuY3Rpb24gKG9iaiwgaGFuZGxlciwgaWQpIHtcblx0XHR2YXIgb25VcCA9IEwuYmluZChmdW5jdGlvbiAoZSkge1xuXHRcdFx0dGhpcy5faGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0XHR9LCB0aGlzKTtcblxuXHRcdG9ialsnX2xlYWZsZXRfdG91Y2hlbmQnICsgaWRdID0gb25VcDtcblx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfVVAsIG9uVXAsIGZhbHNlKTtcblx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfQ0FOQ0VMLCBvblVwLCBmYWxzZSk7XG5cdH1cbn0pO1xuXG4vKlxuICogTC5IYW5kbGVyLlRvdWNoWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGFkZCBwaW5jaCB6b29tIG9uIHN1cHBvcnRlZCBtb2JpbGUgYnJvd3NlcnMuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0b3VjaFpvb206IEJvb2xlYW58U3RyaW5nID0gKlxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB0b3VjaC1kcmFnZ2luZyB3aXRoIHR3byBmaW5nZXJzLiBJZlxuXHQvLyBwYXNzZWQgYCdjZW50ZXInYCwgaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZlxuXHQvLyB3aGVyZSB0aGUgdG91Y2ggZXZlbnRzIChmaW5nZXJzKSB3ZXJlLiBFbmFibGVkIGZvciB0b3VjaC1jYXBhYmxlIHdlYlxuXHQvLyBicm93c2VycyBleGNlcHQgZm9yIG9sZCBBbmRyb2lkcy5cblx0dG91Y2hab29tOiBMLkJyb3dzZXIudG91Y2ggJiYgIUwuQnJvd3Nlci5hbmRyb2lkMjMsXG5cblx0Ly8gQG9wdGlvbiBib3VuY2VBdFpvb21MaW1pdHM6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFNldCBpdCB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIHpvb20gYmV5b25kIG1pbi9tYXggem9vbVxuXHQvLyBhbmQgdGhlbiBib3VuY2UgYmFjayB3aGVuIHBpbmNoLXpvb21pbmcuXG5cdGJvdW5jZUF0Wm9vbUxpbWl0czogdHJ1ZVxufSk7XG5cbkwuTWFwLlRvdWNoWm9vbSA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdEwuRG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0X29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgbWFwLl9hbmltYXRpbmdab29tIHx8IHRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKTtcblxuXHRcdHRoaXMuX2NlbnRlclBvaW50ID0gbWFwLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XG5cdFx0dGhpcy5fc3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSAhPT0gJ2NlbnRlcicpIHtcblx0XHRcdHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhwMS5hZGQocDIpLl9kaXZpZGVCeSgyKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3RhcnREaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG5cdFx0dGhpcy5fc3RhcnRab29tID0gbWFwLmdldFpvb20oKTtcblxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdFx0dGhpcy5fem9vbWluZyA9IHRydWU7XG5cblx0XHRtYXAuX3N0b3AoKTtcblxuXHRcdEwuRG9tRXZlbnRcblx0XHQgICAgLm9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpXG5cdFx0ICAgIC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cblx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8ICF0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKSxcblx0XHQgICAgc2NhbGUgPSBwMS5kaXN0YW5jZVRvKHAyKSAvIHRoaXMuX3N0YXJ0RGlzdDtcblxuXG5cdFx0dGhpcy5fem9vbSA9IG1hcC5nZXRTY2FsZVpvb20oc2NhbGUsIHRoaXMuX3N0YXJ0Wm9vbSk7XG5cblx0XHRpZiAoIW1hcC5vcHRpb25zLmJvdW5jZUF0Wm9vbUxpbWl0cyAmJiAoXG5cdFx0XHQodGhpcy5fem9vbSA8IG1hcC5nZXRNaW5ab29tKCkgJiYgc2NhbGUgPCAxKSB8fFxuXHRcdFx0KHRoaXMuX3pvb20gPiBtYXAuZ2V0TWF4Wm9vbSgpICYmIHNjYWxlID4gMSkpKSB7XG5cdFx0XHR0aGlzLl96b29tID0gbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSk7XG5cdFx0fVxuXG5cdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX3N0YXJ0TGF0TG5nO1xuXHRcdFx0aWYgKHNjYWxlID09PSAxKSB7IHJldHVybjsgfVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBHZXQgZGVsdGEgZnJvbSBwaW5jaCB0byBjZW50ZXIsIHNvIGNlbnRlckxhdExuZyBpcyBkZWx0YSBhcHBsaWVkIHRvIGluaXRpYWwgcGluY2hMYXRMbmdcblx0XHRcdHZhciBkZWx0YSA9IHAxLl9hZGQocDIpLl9kaXZpZGVCeSgyKS5fc3VidHJhY3QodGhpcy5fY2VudGVyUG9pbnQpO1xuXHRcdFx0aWYgKHNjYWxlID09PSAxICYmIGRlbHRhLnggPT09IDAgJiYgZGVsdGEueSA9PT0gMCkgeyByZXR1cm47IH1cblx0XHRcdHRoaXMuX2NlbnRlciA9IG1hcC51bnByb2plY3QobWFwLnByb2plY3QodGhpcy5fcGluY2hTdGFydExhdExuZywgdGhpcy5fem9vbSkuc3VidHJhY3QoZGVsdGEpLCB0aGlzLl96b29tKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHRtYXAuX21vdmVTdGFydCh0cnVlKTtcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuXHRcdHZhciBtb3ZlRm4gPSBMLmJpbmQobWFwLl9tb3ZlLCBtYXAsIHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSwge3BpbmNoOiB0cnVlLCByb3VuZDogZmFsc2V9KTtcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKG1vdmVGbiwgdGhpcywgdHJ1ZSk7XG5cblx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCB8fCAhdGhpcy5fem9vbWluZykge1xuXHRcdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuXHRcdEwuRG9tRXZlbnRcblx0XHQgICAgLm9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKVxuXHRcdCAgICAub2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kKTtcblxuXHRcdC8vIFBpbmNoIHVwZGF0ZXMgR3JpZExheWVycycgbGV2ZWxzIG9ubHkgd2hlbiB6b29tU25hcCBpcyBvZmYsIHNvIHpvb21TbmFwIGJlY29tZXMgbm9VcGRhdGUuXG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcblx0XHRcdHRoaXMuX21hcC5fYW5pbWF0ZVpvb20odGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSwgdHJ1ZSwgdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9tYXAuX3Jlc2V0Vmlldyh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRvdWNoWm9vbTogSGFuZGxlclxuLy8gVG91Y2ggem9vbSBoYW5kbGVyLlxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndG91Y2hab29tJywgTC5NYXAuVG91Y2hab29tKTtcblxuLypcbiAqIEwuTWFwLlRhcCBpcyB1c2VkIHRvIGVuYWJsZSBtb2JpbGUgaGFja3MgbGlrZSBxdWljayB0YXBzIGFuZCBsb25nIGhvbGQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0YXA6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIEVuYWJsZXMgbW9iaWxlIGhhY2tzIGZvciBzdXBwb3J0aW5nIGluc3RhbnQgdGFwcyAoZml4aW5nIDIwMG1zIGNsaWNrXG5cdC8vIGRlbGF5IG9uIGlPUy9BbmRyb2lkKSBhbmQgdG91Y2ggaG9sZHMgKGZpcmVkIGFzIGBjb250ZXh0bWVudWAgZXZlbnRzKS5cblx0dGFwOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gdGFwVG9sZXJhbmNlOiBOdW1iZXIgPSAxNVxuXHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCBoaXMgZmluZ2VyIGR1cmluZyB0b3VjaFxuXHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIHRhcC5cblx0dGFwVG9sZXJhbmNlOiAxNVxufSk7XG5cbkwuTWFwLlRhcCA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUudG91Y2hlcykgeyByZXR1cm47IH1cblxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cblx0XHR0aGlzLl9maXJlQ2xpY2sgPSB0cnVlO1xuXG5cdFx0Ly8gZG9uJ3Qgc2ltdWxhdGUgY2xpY2sgb3IgdHJhY2sgbG9uZ3ByZXNzIGlmIG1vcmUgdGhhbiAxIHRvdWNoXG5cdFx0aWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHR0aGlzLl9maXJlQ2xpY2sgPSBmYWxzZTtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdLFxuXHRcdCAgICBlbCA9IGZpcnN0LnRhcmdldDtcblxuXHRcdHRoaXMuX3N0YXJ0UG9zID0gdGhpcy5fbmV3UG9zID0gbmV3IEwuUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cblx0XHQvLyBpZiB0b3VjaGluZyBhIGxpbmssIGhpZ2hsaWdodCBpdFxuXHRcdGlmIChlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LWFjdGl2ZScpO1xuXHRcdH1cblxuXHRcdC8vIHNpbXVsYXRlIGxvbmcgaG9sZCBidXQgc2V0dGluZyBhIHRpbWVvdXRcblx0XHR0aGlzLl9ob2xkVGltZW91dCA9IHNldFRpbWVvdXQoTC5iaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9pc1RhcFZhbGlkKCkpIHtcblx0XHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX29uVXAoKTtcblx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY29udGV4dG1lbnUnLCBmaXJzdCk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyksIDEwMDApO1xuXG5cdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vkb3duJywgZmlyc3QpO1xuXG5cdFx0TC5Eb21FdmVudC5vbihkb2N1bWVudCwge1xuXHRcdFx0dG91Y2htb3ZlOiB0aGlzLl9vbk1vdmUsXG5cdFx0XHR0b3VjaGVuZDogdGhpcy5fb25VcFxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vblVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG5cblx0XHRMLkRvbUV2ZW50Lm9mZihkb2N1bWVudCwge1xuXHRcdFx0dG91Y2htb3ZlOiB0aGlzLl9vbk1vdmUsXG5cdFx0XHR0b3VjaGVuZDogdGhpcy5fb25VcFxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX2ZpcmVDbGljayAmJiBlICYmIGUuY2hhbmdlZFRvdWNoZXMpIHtcblxuXHRcdFx0dmFyIGZpcnN0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXSxcblx0XHRcdCAgICBlbCA9IGZpcnN0LnRhcmdldDtcblxuXHRcdFx0aWYgKGVsICYmIGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcblx0XHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2V1cCcsIGZpcnN0KTtcblxuXHRcdFx0Ly8gc2ltdWxhdGUgY2xpY2sgaWYgdGhlIHRvdWNoIGRpZG4ndCBtb3ZlIHRvbyBtdWNoXG5cdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XG5cdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NsaWNrJywgZmlyc3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfaXNUYXBWYWxpZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcykgPD0gdGhpcy5fbWFwLm9wdGlvbnMudGFwVG9sZXJhbmNlO1xuXHR9LFxuXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdO1xuXHRcdHRoaXMuX25ld1BvcyA9IG5ldyBMLlBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuXHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNlbW92ZScsIGZpcnN0KTtcblx0fSxcblxuXHRfc2ltdWxhdGVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcblx0XHR2YXIgc2ltdWxhdGVkRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlO1xuXHRcdGUudGFyZ2V0Ll9zaW11bGF0ZWRDbGljayA9IHRydWU7XG5cblx0XHRzaW11bGF0ZWRFdmVudC5pbml0TW91c2VFdmVudChcblx0XHQgICAgICAgIHR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgMSxcblx0XHQgICAgICAgIGUuc2NyZWVuWCwgZS5zY3JlZW5ZLFxuXHRcdCAgICAgICAgZS5jbGllbnRYLCBlLmNsaWVudFksXG5cdFx0ICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG5cblx0XHRlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgdGFwOiBIYW5kbGVyXG4vLyBNb2JpbGUgdG91Y2ggaGFja3MgKHF1aWNrIHRhcCBhbmQgdG91Y2ggaG9sZCkgaGFuZGxlci5cbmlmIChMLkJyb3dzZXIudG91Y2ggJiYgIUwuQnJvd3Nlci5wb2ludGVyKSB7XG5cdEwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RhcCcsIEwuTWFwLlRhcCk7XG59XG5cbi8qXG4gKiBMLkhhbmRsZXIuQm94Wm9vbSBpcyB1c2VkIHRvIGFkZCBzaGlmdC1kcmFnIHpvb20gaW50ZXJhY3Rpb24gdG8gdGhlIG1hcFxuICogKHpvb20gdG8gYSBzZWxlY3RlZCBib3VuZGluZyBib3gpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gYm94Wm9vbTogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgdG8gYSByZWN0YW5ndWxhciBhcmVhIHNwZWNpZmllZCBieVxuXHQvLyBkcmFnZ2luZyB0aGUgbW91c2Ugd2hpbGUgcHJlc3NpbmcgdGhlIHNoaWZ0IGtleS5cblx0Ym94Wm9vbTogdHJ1ZVxufSk7XG5cbkwuTWFwLkJveFpvb20gPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl9jb250YWluZXIgPSBtYXAuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9wYW5lID0gbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21vdmVkO1xuXHR9LFxuXG5cdF9yZXNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHR0aGlzLl9yZXNldFN0YXRlKCk7XG5cblx0XHRMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcblx0XHRMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdEwuRG9tRXZlbnQub24oZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBMLkRvbUV2ZW50LnN0b3AsXG5cdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblxuXHRcdFx0dGhpcy5fYm94ID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtem9vbS1ib3gnLCB0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY3Jvc3NoYWlyJyk7XG5cblx0XHRcdHRoaXMuX21hcC5maXJlKCdib3h6b29tc3RhcnQnKTtcblx0XHR9XG5cblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdHZhciBib3VuZHMgPSBuZXcgTC5Cb3VuZHModGhpcy5fcG9pbnQsIHRoaXMuX3N0YXJ0UG9pbnQpLFxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9ib3gsIGJvdW5kcy5taW4pO1xuXG5cdFx0dGhpcy5fYm94LnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XG5cdFx0dGhpcy5fYm94LnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG5cdH0sXG5cblx0X2ZpbmlzaDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tb3ZlZCkge1xuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9ib3gpO1xuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY3Jvc3NoYWlyJyk7XG5cdFx0fVxuXG5cdFx0TC5Eb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcblx0XHRMLkRvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHRMLkRvbUV2ZW50Lm9mZihkb2N1bWVudCwge1xuXHRcdFx0Y29udGV4dG1lbnU6IEwuRG9tRXZlbnQuc3RvcCxcblx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2ZpbmlzaCgpO1xuXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkgeyByZXR1cm47IH1cblx0XHQvLyBQb3N0cG9uZSB0byBuZXh0IEpTIHRpY2sgc28gaW50ZXJuYWwgY2xpY2sgZXZlbnQgaGFuZGxpbmdcblx0XHQvLyBzdGlsbCBzZWUgaXQgYXMgXCJtb3ZlZFwiLlxuXHRcdHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX3Jlc2V0U3RhdGUsIHRoaXMpLCAwKTtcblxuXHRcdHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoXG5cdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9zdGFydFBvaW50KSxcblx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50KSk7XG5cblx0XHR0aGlzLl9tYXBcblx0XHRcdC5maXRCb3VuZHMoYm91bmRzKVxuXHRcdFx0LmZpcmUoJ2JveHpvb21lbmQnLCB7Ym94Wm9vbUJvdW5kczogYm91bmRzfSk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5rZXlDb2RlID09PSAyNykge1xuXHRcdFx0dGhpcy5fZmluaXNoKCk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBib3hab29tOiBIYW5kbGVyXG4vLyBCb3ggKHNoaWZ0LWRyYWcgd2l0aCBtb3VzZSkgem9vbSBoYW5kbGVyLlxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnYm94Wm9vbScsIEwuTWFwLkJveFpvb20pO1xuXG4vKlxuICogTC5NYXAuS2V5Ym9hcmQgaXMgaGFuZGxpbmcga2V5Ym9hcmQgaW50ZXJhY3Rpb24gd2l0aCB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEtleWJvYXJkIE5hdmlnYXRpb24gT3B0aW9uc1xuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcblx0Ly8gTWFrZXMgdGhlIG1hcCBmb2N1c2FibGUgYW5kIGFsbG93cyB1c2VycyB0byBuYXZpZ2F0ZSB0aGUgbWFwIHdpdGgga2V5Ym9hcmRcblx0Ly8gYXJyb3dzIGFuZCBgK2AvYC1gIGtleXMuXG5cdGtleWJvYXJkOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24ga2V5Ym9hcmRQYW5EZWx0YTogTnVtYmVyID0gODBcblx0Ly8gQW1vdW50IG9mIHBpeGVscyB0byBwYW4gd2hlbiBwcmVzc2luZyBhbiBhcnJvdyBrZXkuXG5cdGtleWJvYXJkUGFuRGVsdGE6IDgwXG59KTtcblxuTC5NYXAuS2V5Ym9hcmQgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblxuXHRrZXlDb2Rlczoge1xuXHRcdGxlZnQ6ICAgIFszN10sXG5cdFx0cmlnaHQ6ICAgWzM5XSxcblx0XHRkb3duOiAgICBbNDBdLFxuXHRcdHVwOiAgICAgIFszOF0sXG5cdFx0em9vbUluOiAgWzE4NywgMTA3LCA2MSwgMTcxXSxcblx0XHR6b29tT3V0OiBbMTg5LCAxMDksIDU0LCAxNzNdXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblxuXHRcdHRoaXMuX3NldFBhbkRlbHRhKG1hcC5vcHRpb25zLmtleWJvYXJkUGFuRGVsdGEpO1xuXHRcdHRoaXMuX3NldFpvb21EZWx0YShtYXAub3B0aW9ucy56b29tRGVsdGEpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX21hcC5fY29udGFpbmVyO1xuXG5cdFx0Ly8gbWFrZSB0aGUgY29udGFpbmVyIGZvY3VzYWJsZSBieSB0YWJiaW5nXG5cdFx0aWYgKGNvbnRhaW5lci50YWJJbmRleCA8PSAwKSB7XG5cdFx0XHRjb250YWluZXIudGFiSW5kZXggPSAnMCc7XG5cdFx0fVxuXG5cdFx0TC5Eb21FdmVudC5vbihjb250YWluZXIsIHtcblx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLm9uKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW1vdmVIb29rcygpO1xuXG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsIHtcblx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLm9mZih7XG5cdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG5cdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9mb2N1c2VkKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuXHRcdCAgICBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHQgICAgdG9wID0gYm9keS5zY3JvbGxUb3AgfHwgZG9jRWwuc2Nyb2xsVG9wLFxuXHRcdCAgICBsZWZ0ID0gYm9keS5zY3JvbGxMZWZ0IHx8IGRvY0VsLnNjcm9sbExlZnQ7XG5cblx0XHR0aGlzLl9tYXAuX2NvbnRhaW5lci5mb2N1cygpO1xuXG5cdFx0d2luZG93LnNjcm9sbFRvKGxlZnQsIHRvcCk7XG5cdH0sXG5cblx0X29uRm9jdXM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcblx0XHR0aGlzLl9tYXAuZmlyZSgnZm9jdXMnKTtcblx0fSxcblxuXHRfb25CbHVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZm9jdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdibHVyJyk7XG5cdH0sXG5cblx0X3NldFBhbkRlbHRhOiBmdW5jdGlvbiAocGFuRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3BhbktleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5sZWZ0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmxlZnRbaV1dID0gWy0xICogcGFuRGVsdGEsIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5yaWdodC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5yaWdodFtpXV0gPSBbcGFuRGVsdGEsIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5kb3duLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmRvd25baV1dID0gWzAsIHBhbkRlbHRhXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMudXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMudXBbaV1dID0gWzAsIC0xICogcGFuRGVsdGFdO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbURlbHRhOiBmdW5jdGlvbiAoem9vbURlbHRhKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl96b29tS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21Jbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy56b29tSW5baV1dID0gem9vbURlbHRhO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tT3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21PdXRbaV1dID0gLXpvb21EZWx0YTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9yZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBrZXkgPSBlLmtleUNvZGUsXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb2Zmc2V0O1xuXG5cdFx0aWYgKGtleSBpbiB0aGlzLl9wYW5LZXlzKSB7XG5cblx0XHRcdGlmIChtYXAuX3BhbkFuaW0gJiYgbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXG5cdFx0XHRvZmZzZXQgPSB0aGlzLl9wYW5LZXlzW2tleV07XG5cdFx0XHRpZiAoZS5zaGlmdEtleSkge1xuXHRcdFx0XHRvZmZzZXQgPSBMLnBvaW50KG9mZnNldCkubXVsdGlwbHlCeSgzKTtcblx0XHRcdH1cblxuXHRcdFx0bWFwLnBhbkJ5KG9mZnNldCk7XG5cblx0XHRcdGlmIChtYXAub3B0aW9ucy5tYXhCb3VuZHMpIHtcblx0XHRcdFx0bWFwLnBhbkluc2lkZUJvdW5kcyhtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmIChrZXkgaW4gdGhpcy5fem9vbUtleXMpIHtcblx0XHRcdG1hcC5zZXRab29tKG1hcC5nZXRab29tKCkgKyAoZS5zaGlmdEtleSA/IDMgOiAxKSAqIHRoaXMuX3pvb21LZXlzW2tleV0pO1xuXG5cdFx0fSBlbHNlIGlmIChrZXkgPT09IDI3KSB7XG5cdFx0XHRtYXAuY2xvc2VQb3B1cCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRMLkRvbUV2ZW50LnN0b3AoZSk7XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBrZXlib2FyZDogSGFuZGxlclxuLy8gS2V5Ym9hcmQgbmF2aWdhdGlvbiBoYW5kbGVyLlxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAna2V5Ym9hcmQnLCBMLk1hcC5LZXlib2FyZCk7XG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFya2VyRHJhZyBpcyB1c2VkIGludGVybmFsbHkgYnkgTC5NYXJrZXIgdG8gbWFrZSB0aGUgbWFya2VycyBkcmFnZ2FibGUuXG4gKi9cblxuXG4vKiBAbmFtZXNwYWNlIE1hcmtlclxuICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gaGFuZGxlcnNcbiAqXG4gKiBJbnRlcmFjdGlvbiBoYW5kbGVycyBhcmUgcHJvcGVydGllcyBvZiBhIG1hcmtlciBpbnN0YW5jZSB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2ggYXMgZHJhZ2dpbmcgKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIG1hcmtlci5kcmFnZ2luZy5kaXNhYmxlKCk7XG4gKiBgYGBcbiAqXG4gKiBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbiAqIE1hcmtlciBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuXG4gKi9cblxuTC5IYW5kbGVyLk1hcmtlckRyYWcgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcmtlcikge1xuXHRcdHRoaXMuX21hcmtlciA9IG1hcmtlcjtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpY29uID0gdGhpcy5fbWFya2VyLl9pY29uO1xuXG5cdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShpY29uLCBpY29uLCB0cnVlKTtcblx0XHR9XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmVuYWJsZSgpO1xuXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5vZmYoe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmRpc2FibGUoKTtcblxuXHRcdGlmICh0aGlzLl9tYXJrZXIuX2ljb24pIHtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXJrZXIuX2ljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0XHR9XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG5cdH0sXG5cblx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQHNlY3Rpb24gRHJhZ2dpbmcgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RhcnRzIG1vdmluZyAoYmVjYXVzZSBvZiBkcmFnZ2luZykuXG5cblx0XHR0aGlzLl9vbGRMYXRMbmcgPSB0aGlzLl9tYXJrZXIuZ2V0TGF0TG5nKCk7XG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5jbG9zZVBvcHVwKClcblx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnc3RhcnQnKTtcblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0ICAgIHNoYWRvdyA9IG1hcmtlci5fc2hhZG93LFxuXHRcdCAgICBpY29uUG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGxhdGxuZyA9IG1hcmtlci5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhpY29uUG9zKTtcblxuXHRcdC8vIHVwZGF0ZSBzaGFkb3cgcG9zaXRpb25cblx0XHRpZiAoc2hhZG93KSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oc2hhZG93LCBpY29uUG9zKTtcblx0XHR9XG5cblx0XHRtYXJrZXIuX2xhdGxuZyA9IGxhdGxuZztcblx0XHRlLmxhdGxuZyA9IGxhdGxuZztcblx0XHRlLm9sZExhdExuZyA9IHRoaXMuX29sZExhdExuZztcblxuXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIG1hcmtlci5cblx0XHRtYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdG9wcyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXHRcdGRlbGV0ZSB0aGlzLl9vbGRMYXRMbmc7XG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5maXJlKCdtb3ZlZW5kJylcblx0XHQgICAgLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblx0fVxufSk7XG5cbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sXHJcbiAqIEBha2EgTC5Db250cm9sXHJcbiAqXHJcbiAqIEwuQ29udHJvbCBpcyBhIGJhc2UgY2xhc3MgZm9yIGltcGxlbWVudGluZyBtYXAgY29udHJvbHMuIEhhbmRsZXMgcG9zaXRpb25pbmcuXHJcbiAqIEFsbCBvdGhlciBjb250cm9scyBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxyXG4gKi9cclxuXHJcbkwuQ29udHJvbCA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbCBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBwb3NpdGlvbjogU3RyaW5nID0gJ3RvcHJpZ2h0J1xyXG5cdFx0Ly8gVGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIChvbmUgb2YgdGhlIG1hcCBjb3JuZXJzKS4gUG9zc2libGUgdmFsdWVzIGFyZSBgJ3RvcGxlZnQnYCxcclxuXHRcdC8vIGAndG9wcmlnaHQnYCwgYCdib3R0b21sZWZ0J2Agb3IgYCdib3R0b21yaWdodCdgXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBMLkNvbnRyb2wgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgZ2V0UG9zaXRpb246IHN0cmluZ1xyXG5cdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG5cdCAqL1xyXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLnJlbW92ZUNvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAuYWRkQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MRWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBjb250cm9sLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZFRvKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGNvbnRyb2wgdG8gdGhlIGdpdmVuIG1hcC5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5yZW1vdmUoKTtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApLFxyXG5cdFx0ICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcclxuXHRcdCAgICBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XHJcblxyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbCcpO1xyXG5cclxuXHRcdGlmIChwb3MuaW5kZXhPZignYm90dG9tJykgIT09IC0xKSB7XHJcblx0XHRcdGNvcm5lci5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBjb3JuZXIuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb3JuZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGNvbnRyb2wgZnJvbSB0aGUgbWFwIGl0IGlzIGN1cnJlbnRseSBhY3RpdmUgb24uXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub25SZW1vdmUpIHtcclxuXHRcdFx0dGhpcy5vblJlbW92ZSh0aGlzLl9tYXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3JlZm9jdXNPbk1hcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIGlmIG1hcCBleGlzdHMgYW5kIGV2ZW50IGlzIG5vdCBhIGtleWJvYXJkIGV2ZW50XHJcblx0XHRpZiAodGhpcy5fbWFwICYmIGUgJiYgZS5zY3JlZW5YID4gMCAmJiBlLnNjcmVlblkgPiAwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5mb2N1cygpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5MLmNvbnRyb2wgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5Db250cm9sKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuICogQHVuaW5oZXJpdGFibGVcclxuICpcclxuICogRXZlcnkgY29udHJvbCBzaG91bGQgZXh0ZW5kIGZyb20gYEwuQ29udHJvbGAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cclxuICpcclxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IEhUTUxFbGVtZW50XHJcbiAqIFNob3VsZCByZXR1cm4gdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgYW5kIGFkZCBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgY29udHJvbC5hZGRUbyhtYXApYF0oI2NvbnRyb2wtYWRkVG8pLlxyXG4gKlxyXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKVxyXG4gKiBPcHRpb25hbCBtZXRob2QuIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNjb250cm9sLW9uYWRkKS4gQ2FsbGVkIG9uIFtgY29udHJvbC5yZW1vdmUoKWBdKCNjb250cm9sLXJlbW92ZSkuXHJcbiAqL1xyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG4gKi9cclxuTC5NYXAuaW5jbHVkZSh7XHJcblx0Ly8gQG1ldGhvZCBhZGRDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gY29udHJvbCB0byB0aGUgbWFwXHJcblx0YWRkQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuXHRcdGNvbnRyb2wuYWRkVG8odGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUNvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBjb250cm9sIGZyb20gdGhlIG1hcFxyXG5cdHJlbW92ZUNvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLnJlbW92ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29ybmVycyA9IHRoaXMuX2NvbnRyb2xDb3JuZXJzID0ge30sXHJcblx0XHQgICAgbCA9ICdsZWFmbGV0LScsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udHJvbENvbnRhaW5lciA9XHJcblx0XHQgICAgICAgICAgICBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBsICsgJ2NvbnRyb2wtY29udGFpbmVyJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRmdW5jdGlvbiBjcmVhdGVDb3JuZXIodlNpZGUsIGhTaWRlKSB7XHJcblx0XHRcdHZhciBjbGFzc05hbWUgPSBsICsgdlNpZGUgKyAnICcgKyBsICsgaFNpZGU7XHJcblxyXG5cdFx0XHRjb3JuZXJzW3ZTaWRlICsgaFNpZGVdID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ3JpZ2h0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdyaWdodCcpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckNvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fY29udHJvbENvbnRhaW5lcik7XHJcblx0fVxyXG59KTtcclxuXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5ab29tXHJcbiAqIEBha2EgTC5Db250cm9sLlpvb21cclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogQSBiYXNpYyB6b29tIGNvbnRyb2wgd2l0aCB0d28gYnV0dG9ucyAoem9vbSBpbiBhbmQgem9vbSBvdXQpLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYHpvb21Db250cm9sYCBvcHRpb25dKCNtYXAtem9vbWNvbnRyb2wpIHRvIGBmYWxzZWAuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gKi9cclxuXHJcbkwuQ29udHJvbC5ab29tID0gTC5Db250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuWm9vbSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICd0b3BsZWZ0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21JblRleHQ6IFN0cmluZyA9ICcrJ1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG5cdFx0em9vbUluVGV4dDogJysnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGl0bGU6IFN0cmluZyA9ICdab29tIGluJ1xyXG5cdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuXHRcdHpvb21JblRpdGxlOiAnWm9vbSBpbicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGV4dDogU3RyaW5nID0gJy0nXHJcblx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG5cdFx0em9vbU91dFRleHQ6ICctJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PdXRUaXRsZTogU3RyaW5nID0gJ1pvb20gb3V0J1xyXG5cdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcblx0XHR6b29tT3V0VGl0bGU6ICdab29tIG91dCdcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dmFyIHpvb21OYW1lID0gJ2xlYWZsZXQtY29udHJvbC16b29tJyxcclxuXHRcdCAgICBjb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCB6b29tTmFtZSArICcgbGVhZmxldC1iYXInKSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdHRoaXMuX3pvb21JbkJ1dHRvbiAgPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tSW5UZXh0LCBvcHRpb25zLnpvb21JblRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctaW4nLCAgY29udGFpbmVyLCB0aGlzLl96b29tSW4pO1xyXG5cdFx0dGhpcy5fem9vbU91dEJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21PdXRUZXh0LCBvcHRpb25zLnpvb21PdXRUaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLW91dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCk7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdG1hcC5vbignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBjb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vZmYoJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IHRydWU7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF96b29tSW46IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA8IHRoaXMuX21hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21Jbih0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3pvb21PdXQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA+IHRoaXMuX21hcC5nZXRNaW5ab29tKCkpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21PdXQodGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uIChodG1sLCB0aXRsZSwgY2xhc3NOYW1lLCBjb250YWluZXIsIGZuKSB7XHJcblx0XHR2YXIgbGluayA9IEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHRsaW5rLmlubmVySFRNTCA9IGh0bWw7XHJcblx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRsaW5rLnRpdGxlID0gdGl0bGU7XHJcblxyXG5cdFx0TC5Eb21FdmVudFxyXG5cdFx0ICAgIC5vbihsaW5rLCAnbW91c2Vkb3duIGRibGNsaWNrJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pXHJcblx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIEwuRG9tRXZlbnQuc3RvcClcclxuXHRcdCAgICAub24obGluaywgJ2NsaWNrJywgZm4sIHRoaXMpXHJcblx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIHRoaXMuX3JlZm9jdXNPbk1hcCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGxpbms7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZURpc2FibGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWRpc2FibGVkJztcclxuXHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbi8vIEBvcHRpb24gem9vbUNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbi8vIFdoZXRoZXIgYSBbem9vbSBjb250cm9sXSgjY29udHJvbC16b29tKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0em9vbUNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5MLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy56b29tQ29udHJvbCkge1xyXG5cdFx0dGhpcy56b29tQ29udHJvbCA9IG5ldyBMLkNvbnRyb2wuWm9vbSgpO1xyXG5cdFx0dGhpcy5hZGRDb250cm9sKHRoaXMuem9vbUNvbnRyb2wpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuWm9vbVxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuem9vbShvcHRpb25zOiBDb250cm9sLlpvb20gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIHpvb20gY29udHJvbFxyXG5MLmNvbnRyb2wuem9vbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkNvbnRyb2wuWm9vbShvcHRpb25zKTtcclxufTtcclxuXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAYWthIEwuQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgYXR0cmlidXRpb24gY29udHJvbCBhbGxvd3MgeW91IHRvIGRpc3BsYXkgYXR0cmlidXRpb24gZGF0YSBpbiBhIHNtYWxsIHRleHQgYm94IG9uIGEgbWFwLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYGF0dHJpYnV0aW9uQ29udHJvbGAgb3B0aW9uXSgjbWFwLWF0dHJpYnV0aW9uY29udHJvbCkgdG8gYGZhbHNlYCwgYW5kIGl0IGZldGNoZXMgYXR0cmlidXRpb24gdGV4dHMgZnJvbSBsYXllcnMgd2l0aCB0aGUgW2BnZXRBdHRyaWJ1dGlvbmAgbWV0aG9kXSgjbGF5ZXItZ2V0YXR0cmlidXRpb24pIGF1dG9tYXRpY2FsbHkuIEV4dGVuZHMgQ29udHJvbC5cclxuICovXHJcblxyXG5MLkNvbnRyb2wuQXR0cmlidXRpb24gPSBMLkNvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICdib3R0b21yaWdodCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwcmVmaXg6IFN0cmluZyA9ICdMZWFmbGV0J1xyXG5cdFx0Ly8gVGhlIEhUTUwgdGV4dCBzaG93biBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy4gUGFzcyBgZmFsc2VgIHRvIGRpc2FibGUuXHJcblx0XHRwcmVmaXg6ICc8YSBocmVmPVwiaHR0cDovL2xlYWZsZXRqcy5jb21cIiB0aXRsZT1cIkEgSlMgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwc1wiPkxlYWZsZXQ8L2E+J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fYXR0cmlidXRpb25zID0ge307XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wgPSB0aGlzO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbicpO1xyXG5cdFx0aWYgKEwuRG9tRXZlbnQpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRPRE8gdWdseSwgcmVmYWN0b3JcclxuXHRcdGZvciAodmFyIGkgaW4gbWFwLl9sYXllcnMpIHtcclxuXHRcdFx0aWYgKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQcmVmaXgocHJlZml4OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdGV4dCBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy5cclxuXHRzZXRQcmVmaXg6IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5wcmVmaXggPSBwcmVmaXg7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gYXR0cmlidXRpb24gdGV4dCAoZS5nLiBgJ1ZlY3RvciBkYXRhICZjb3B5OyBNYXBib3gnYCkuXHJcblx0YWRkQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0gPSAwO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdKys7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0LlxyXG5cdHJlbW92ZUF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0tLTtcclxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGF0dHJpYnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2F0dHJpYnV0aW9ucykge1xyXG5cdFx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW2ldKSB7XHJcblx0XHRcdFx0YXR0cmlicy5wdXNoKGkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHByZWZpeEFuZEF0dHJpYnMgPSBbXTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnByZWZpeCkge1xyXG5cdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2godGhpcy5vcHRpb25zLnByZWZpeCk7XHJcblx0XHR9XHJcblx0XHRpZiAoYXR0cmlicy5sZW5ndGgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKGF0dHJpYnMuam9pbignLCAnKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IHByZWZpeEFuZEF0dHJpYnMuam9pbignIHwgJyk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4vLyBAb3B0aW9uIGF0dHJpYnV0aW9uQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFthdHRyaWJ1dGlvbiBjb250cm9sXSgjY29udHJvbC1hdHRyaWJ1dGlvbikgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbkwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkge1xyXG5cdFx0bmV3IEwuQ29udHJvbC5BdHRyaWJ1dGlvbigpLmFkZFRvKHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuQXR0cmlidXRpb25cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmF0dHJpYnV0aW9uKG9wdGlvbnM6IENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sLlxyXG5MLmNvbnRyb2wuYXR0cmlidXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5Db250cm9sLkF0dHJpYnV0aW9uKG9wdGlvbnMpO1xyXG59O1xyXG5cbi8qXG4gKiBAY2xhc3MgQ29udHJvbC5TY2FsZVxuICogQGFrYSBMLkNvbnRyb2wuU2NhbGVcbiAqIEBpbmhlcml0cyBDb250cm9sXG4gKlxuICogQSBzaW1wbGUgc2NhbGUgY29udHJvbCB0aGF0IHNob3dzIHRoZSBzY2FsZSBvZiB0aGUgY3VycmVudCBjZW50ZXIgb2Ygc2NyZWVuIGluIG1ldHJpYyAobS9rbSkgYW5kIGltcGVyaWFsIChtaS9mdCkgc3lzdGVtcy4gRXh0ZW5kcyBgQ29udHJvbGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogTC5jb250cm9sLnNjYWxlKCkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbkwuQ29udHJvbC5TY2FsZSA9IEwuQ29udHJvbC5leHRlbmQoe1xuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENvbnRyb2wuU2NhbGUgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0cG9zaXRpb246ICdib3R0b21sZWZ0JyxcblxuXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDEwMFxuXHRcdC8vIE1heGltdW0gd2lkdGggb2YgdGhlIGNvbnRyb2wgaW4gcGl4ZWxzLiBUaGUgd2lkdGggaXMgc2V0IGR5bmFtaWNhbGx5IHRvIHNob3cgcm91bmQgdmFsdWVzIChlLmcuIDEwMCwgMjAwLCA1MDApLlxuXHRcdG1heFdpZHRoOiAxMDAsXG5cblx0XHQvLyBAb3B0aW9uIG1ldHJpYzogQm9vbGVhbiA9IFRydWVcblx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIG1ldHJpYyBzY2FsZSBsaW5lIChtL2ttKS5cblx0XHRtZXRyaWM6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGltcGVyaWFsOiBCb29sZWFuID0gVHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgaW1wZXJpYWwgc2NhbGUgbGluZSAobWkvZnQpLlxuXHRcdGltcGVyaWFsOiB0cnVlXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIGlzIHVwZGF0ZWQgb24gW2Btb3ZlZW5kYF0oI21hcC1tb3ZlZW5kKSwgb3RoZXJ3aXNlIGl0J3MgYWx3YXlzIHVwLXRvLWRhdGUgKHVwZGF0ZWQgb24gW2Btb3ZlYF0oI21hcC1tb3ZlKSkuXG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1zY2FsZScsXG5cdFx0ICAgIGNvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLl9hZGRTY2FsZXMob3B0aW9ucywgY2xhc3NOYW1lICsgJy1saW5lJywgY29udGFpbmVyKTtcblxuXHRcdG1hcC5vbihvcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHRcdG1hcC53aGVuUmVhZHkodGhpcy5fdXBkYXRlLCB0aGlzKTtcblxuXHRcdHJldHVybiBjb250YWluZXI7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAub2ZmKHRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0fSxcblxuXHRfYWRkU2NhbGVzOiBmdW5jdGlvbiAob3B0aW9ucywgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcblx0XHRpZiAob3B0aW9ucy5tZXRyaWMpIHtcblx0XHRcdHRoaXMuX21TY2FsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMuaW1wZXJpYWwpIHtcblx0XHRcdHRoaXMuX2lTY2FsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHkgPSBtYXAuZ2V0U2l6ZSgpLnkgLyAyO1xuXG5cdFx0dmFyIG1heE1ldGVycyA9IG1hcC5kaXN0YW5jZShcblx0XHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoWzAsIHldKSxcblx0XHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoW3RoaXMub3B0aW9ucy5tYXhXaWR0aCwgeV0pKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlcyhtYXhNZXRlcnMpO1xuXHR9LFxuXG5cdF91cGRhdGVTY2FsZXM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHRpZiAodGhpcy5vcHRpb25zLm1ldHJpYyAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU1ldHJpYyhtYXhNZXRlcnMpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmltcGVyaWFsICYmIG1heE1ldGVycykge1xuXHRcdFx0dGhpcy5fdXBkYXRlSW1wZXJpYWwobWF4TWV0ZXJzKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZU1ldHJpYzogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdHZhciBtZXRlcnMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNZXRlcnMpLFxuXHRcdCAgICBsYWJlbCA9IG1ldGVycyA8IDEwMDAgPyBtZXRlcnMgKyAnIG0nIDogKG1ldGVycyAvIDEwMDApICsgJyBrbSc7XG5cblx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9tU2NhbGUsIGxhYmVsLCBtZXRlcnMgLyBtYXhNZXRlcnMpO1xuXHR9LFxuXG5cdF91cGRhdGVJbXBlcmlhbDogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdHZhciBtYXhGZWV0ID0gbWF4TWV0ZXJzICogMy4yODA4Mzk5LFxuXHRcdCAgICBtYXhNaWxlcywgbWlsZXMsIGZlZXQ7XG5cblx0XHRpZiAobWF4RmVldCA+IDUyODApIHtcblx0XHRcdG1heE1pbGVzID0gbWF4RmVldCAvIDUyODA7XG5cdFx0XHRtaWxlcyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1pbGVzKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgbWlsZXMgKyAnIG1pJywgbWlsZXMgLyBtYXhNaWxlcyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZmVldCA9IHRoaXMuX2dldFJvdW5kTnVtKG1heEZlZXQpO1xuXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBmZWV0ICsgJyBmdCcsIGZlZXQgLyBtYXhGZWV0KTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVNjYWxlOiBmdW5jdGlvbiAoc2NhbGUsIHRleHQsIHJhdGlvKSB7XG5cdFx0c2NhbGUuc3R5bGUud2lkdGggPSBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5tYXhXaWR0aCAqIHJhdGlvKSArICdweCc7XG5cdFx0c2NhbGUuaW5uZXJIVE1MID0gdGV4dDtcblx0fSxcblxuXHRfZ2V0Um91bmROdW06IGZ1bmN0aW9uIChudW0pIHtcblx0XHR2YXIgcG93MTAgPSBNYXRoLnBvdygxMCwgKE1hdGguZmxvb3IobnVtKSArICcnKS5sZW5ndGggLSAxKSxcblx0XHQgICAgZCA9IG51bSAvIHBvdzEwO1xuXG5cdFx0ZCA9IGQgPj0gMTAgPyAxMCA6XG5cdFx0ICAgIGQgPj0gNSA/IDUgOlxuXHRcdCAgICBkID49IDMgPyAzIDpcblx0XHQgICAgZCA+PSAyID8gMiA6IDE7XG5cblx0XHRyZXR1cm4gcG93MTAgKiBkO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuc2NhbGUob3B0aW9ucz86IENvbnRyb2wuU2NhbGUgb3B0aW9ucylcbi8vIENyZWF0ZXMgYW4gc2NhbGUgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuTC5jb250cm9sLnNjYWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLkNvbnRyb2wuU2NhbGUob3B0aW9ucyk7XG59O1xuXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5MYXllcnNcclxuICogQGFrYSBMLkNvbnRyb2wuTGF5ZXJzXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBsYXllcnMgY29udHJvbCBnaXZlcyB1c2VycyB0aGUgYWJpbGl0eSB0byBzd2l0Y2ggYmV0d2VlbiBkaWZmZXJlbnQgYmFzZSBsYXllcnMgYW5kIHN3aXRjaCBvdmVybGF5cyBvbi9vZmYgKGNoZWNrIG91dCB0aGUgW2RldGFpbGVkIGV4YW1wbGVdKGh0dHA6Ly9sZWFmbGV0anMuY29tL2V4YW1wbGVzL2xheWVycy1jb250cm9sLmh0bWwpKS4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBiYXNlTGF5ZXJzID0ge1xyXG4gKiBcdFwiTWFwYm94XCI6IG1hcGJveCxcclxuICogXHRcIk9wZW5TdHJlZXRNYXBcIjogb3NtXHJcbiAqIH07XHJcbiAqXHJcbiAqIHZhciBvdmVybGF5cyA9IHtcclxuICogXHRcIk1hcmtlclwiOiBtYXJrZXIsXHJcbiAqIFx0XCJSb2Fkc1wiOiByb2Fkc0xheWVyXHJcbiAqIH07XHJcbiAqXHJcbiAqIEwuY29udHJvbC5sYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMpLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgYGJhc2VMYXllcnNgIGFuZCBgb3ZlcmxheXNgIHBhcmFtZXRlcnMgYXJlIG9iamVjdCBsaXRlcmFscyB3aXRoIGxheWVyIG5hbWVzIGFzIGtleXMgYW5kIGBMYXllcmAgb2JqZWN0cyBhcyB2YWx1ZXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHtcclxuICogICAgIFwiPHNvbWVOYW1lMT5cIjogbGF5ZXIxLFxyXG4gKiAgICAgXCI8c29tZU5hbWUyPlwiOiBsYXllcjJcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhlIGxheWVyIG5hbWVzIGNhbiBjb250YWluIEhUTUwsIHdoaWNoIGFsbG93cyB5b3UgdG8gYWRkIGFkZGl0aW9uYWwgc3R5bGluZyB0byB0aGUgaXRlbXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHtcIjxpbWcgc3JjPSdteS1sYXllci1pY29uJyAvPiA8c3BhbiBjbGFzcz0nbXktbGF5ZXItaXRlbSc+TXkgTGF5ZXI8L3NwYW4+XCI6IG15TGF5ZXJ9XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG5MLkNvbnRyb2wuTGF5ZXJzID0gTC5Db250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuTGF5ZXJzIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGNvbGxhcHNlZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBiZSBjb2xsYXBzZWQgaW50byBhbiBpY29uIGFuZCBleHBhbmRlZCBvbiBtb3VzZSBob3ZlciBvciB0b3VjaC5cclxuXHRcdGNvbGxhcHNlZDogdHJ1ZSxcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1pJbmRleDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBhc3NpZ24gekluZGV4ZXMgaW4gaW5jcmVhc2luZyBvcmRlciB0byBhbGwgb2YgaXRzIGxheWVycyBzbyB0aGF0IHRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQgd2hlbiBzd2l0Y2hpbmcgdGhlbSBvbi9vZmYuXHJcblx0XHRhdXRvWkluZGV4OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaGlkZVNpbmdsZUJhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgYmFzZSBsYXllcnMgaW4gdGhlIGNvbnRyb2wgd2lsbCBiZSBoaWRkZW4gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZS5cclxuXHRcdGhpZGVTaW5nbGVCYXNlOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5fbGFzdFpJbmRleCA9IDA7XHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBiYXNlTGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKGJhc2VMYXllcnNbaV0sIGkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSBpbiBvdmVybGF5cykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihvdmVybGF5c1tpXSwgaSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRCYXNlTGF5ZXIobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhIGJhc2UgbGF5ZXIgKHJhZGlvIGJ1dHRvbiBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuXHRhZGRCYXNlTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUpO1xyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkT3ZlcmxheShsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIG92ZXJsYXkgKGNoZWNrYm94IGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG5cdGFkZE92ZXJsYXk6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUsIHRydWUpO1xyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZSB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgY29udHJvbC5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRsYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoTC5zdGFtcChsYXllcikpO1xyXG5cdFx0aWYgKG9iaikge1xyXG5cdFx0XHR0aGlzLl9sYXllcnMuc3BsaWNlKHRoaXMuX2xheWVycy5pbmRleE9mKG9iaiksIDEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXhwYW5kKCk6IHRoaXNcclxuXHQvLyBFeHBhbmQgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGNvbGxhcHNlZC5cclxuXHRleHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0XHR0aGlzLl9mb3JtLnN0eWxlLmhlaWdodCA9IG51bGw7XHJcblx0XHR2YXIgYWNjZXB0YWJsZUhlaWdodCA9IHRoaXMuX21hcC5nZXRTaXplKCkueSAtICh0aGlzLl9jb250YWluZXIub2Zmc2V0VG9wICsgNTApO1xyXG5cdFx0aWYgKGFjY2VwdGFibGVIZWlnaHQgPCB0aGlzLl9mb3JtLmNsaWVudEhlaWdodCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fZm9ybSwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcblx0XHRcdHRoaXMuX2Zvcm0uc3R5bGUuaGVpZ2h0ID0gYWNjZXB0YWJsZUhlaWdodCArICdweCc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fZm9ybSwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbGxhcHNlKCk6IHRoaXNcclxuXHQvLyBDb2xsYXBzZSB0aGUgY29udHJvbCBjb250YWluZXIgaWYgZXhwYW5kZWQuXHJcblx0Y29sbGFwc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpO1xyXG5cclxuXHRcdC8vIG1ha2VzIHRoaXMgd29yayBvbiBJRSB0b3VjaCBkZXZpY2VzIGJ5IHN0b3BwaW5nIGl0IGZyb20gZmlyaW5nIGEgbW91c2VvdXQgZXZlbnQgd2hlbiB0aGUgdG91Y2ggaXMgcmVsZWFzZWRcclxuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcclxuXHJcblx0XHRMLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblx0XHRpZiAoIUwuQnJvd3Nlci50b3VjaCkge1xyXG5cdFx0XHRMLkRvbUV2ZW50LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmb3JtID0gdGhpcy5fZm9ybSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2Zvcm0nLCBjbGFzc05hbWUgKyAnLWxpc3QnKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNvbGxhcHNlZCkge1xyXG5cdFx0XHRpZiAoIUwuQnJvd3Nlci5hbmRyb2lkKSB7XHJcblx0XHRcdFx0TC5Eb21FdmVudC5vbihjb250YWluZXIsIHtcclxuXHRcdFx0XHRcdG1vdXNlZW50ZXI6IHRoaXMuZXhwYW5kLFxyXG5cdFx0XHRcdFx0bW91c2VsZWF2ZTogdGhpcy5jb2xsYXBzZVxyXG5cdFx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbGluayA9IHRoaXMuX2xheWVyc0xpbmsgPSBMLkRvbVV0aWwuY3JlYXRlKCdhJywgY2xhc3NOYW1lICsgJy10b2dnbGUnLCBjb250YWluZXIpO1xyXG5cdFx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRcdGxpbmsudGl0bGUgPSAnTGF5ZXJzJztcclxuXHJcblx0XHRcdGlmIChMLkJyb3dzZXIudG91Y2gpIHtcclxuXHRcdFx0XHRMLkRvbUV2ZW50XHJcblx0XHRcdFx0ICAgIC5vbihsaW5rLCAnY2xpY2snLCBMLkRvbUV2ZW50LnN0b3ApXHJcblx0XHRcdFx0ICAgIC5vbihsaW5rLCAnY2xpY2snLCB0aGlzLmV4cGFuZCwgdGhpcyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0TC5Eb21FdmVudC5vbihsaW5rLCAnZm9jdXMnLCB0aGlzLmV4cGFuZCwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHdvcmsgYXJvdW5kIGZvciBGaXJlZm94IEFuZHJvaWQgaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjAzM1xyXG5cdFx0XHRMLkRvbUV2ZW50Lm9uKGZvcm0sICdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9vbklucHV0Q2xpY2ssIHRoaXMpLCAwKTtcclxuXHRcdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5jb2xsYXBzZSwgdGhpcyk7XHJcblx0XHRcdC8vIFRPRE8ga2V5Ym9hcmQgYWNjZXNzaWJpbGl0eVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctYmFzZScsIGZvcm0pO1xyXG5cdFx0dGhpcy5fc2VwYXJhdG9yID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1zZXBhcmF0b3InLCBmb3JtKTtcclxuXHRcdHRoaXMuX292ZXJsYXlzTGlzdCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBmb3JtKTtcclxuXHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZm9ybSk7XHJcblx0fSxcclxuXHJcblx0X2dldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5fbGF5ZXJzW2ldICYmIEwuc3RhbXAodGhpcy5fbGF5ZXJzW2ldLmxheWVyKSA9PT0gaWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuXHRcdGxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzLnB1c2goe1xyXG5cdFx0XHRsYXllcjogbGF5ZXIsXHJcblx0XHRcdG5hbWU6IG5hbWUsXHJcblx0XHRcdG92ZXJsYXk6IG92ZXJsYXlcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1pJbmRleCAmJiBsYXllci5zZXRaSW5kZXgpIHtcclxuXHRcdFx0dGhpcy5fbGFzdFpJbmRleCsrO1xyXG5cdFx0XHRsYXllci5zZXRaSW5kZXgodGhpcy5fbGFzdFpJbmRleCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRMLkRvbVV0aWwuZW1wdHkodGhpcy5fYmFzZUxheWVyc0xpc3QpO1xyXG5cdFx0TC5Eb21VdGlsLmVtcHR5KHRoaXMuX292ZXJsYXlzTGlzdCk7XHJcblxyXG5cdFx0dmFyIGJhc2VMYXllcnNQcmVzZW50LCBvdmVybGF5c1ByZXNlbnQsIGksIG9iaiwgYmFzZUxheWVyc0NvdW50ID0gMDtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHRcdFx0dGhpcy5fYWRkSXRlbShvYmopO1xyXG5cdFx0XHRvdmVybGF5c1ByZXNlbnQgPSBvdmVybGF5c1ByZXNlbnQgfHwgb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgfHwgIW9iai5vdmVybGF5O1xyXG5cdFx0XHRiYXNlTGF5ZXJzQ291bnQgKz0gIW9iai5vdmVybGF5ID8gMSA6IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSGlkZSBiYXNlIGxheWVycyBzZWN0aW9uIGlmIHRoZXJlJ3Mgb25seSBvbmUgbGF5ZXIuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmhpZGVTaW5nbGVCYXNlKSB7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgJiYgYmFzZUxheWVyc0NvdW50ID4gMTtcclxuXHRcdFx0dGhpcy5fYmFzZUxheWVyc0xpc3Quc3R5bGUuZGlzcGxheSA9IGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc2VwYXJhdG9yLnN0eWxlLmRpc3BsYXkgPSBvdmVybGF5c1ByZXNlbnQgJiYgYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb25MYXllckNoYW5nZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5faGFuZGxpbmdDbGljaykge1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoTC5zdGFtcChlLnRhcmdldCkpO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBMYXllciBldmVudHNcclxuXHRcdC8vIEBldmVudCBiYXNlbGF5ZXJjaGFuZ2U6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYmFzZSBsYXllciBpcyBjaGFuZ2VkIHRocm91Z2ggdGhlIFtsYXllciBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQGV2ZW50IG92ZXJsYXlhZGQ6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIHNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllciBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQGV2ZW50IG92ZXJsYXlyZW1vdmU6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIGRlc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAbmFtZXNwYWNlIENvbnRyb2wuTGF5ZXJzXHJcblx0XHR2YXIgdHlwZSA9IG9iai5vdmVybGF5ID9cclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnb3ZlcmxheWFkZCcgOiAnb3ZlcmxheXJlbW92ZScpIDpcclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnYmFzZWxheWVyY2hhbmdlJyA6IG51bGwpO1xyXG5cclxuXHRcdGlmICh0eXBlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5maXJlKHR5cGUsIG9iaik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gSUU3IGJ1Z3Mgb3V0IGlmIHlvdSBjcmVhdGUgYSByYWRpbyBkeW5hbWljYWxseSwgc28geW91IGhhdmUgdG8gZG8gaXQgdGhpcyBoYWNreSB3YXkgKHNlZSBodHRwOi8vYml0Lmx5L1BxWUxCZSlcclxuXHRfY3JlYXRlUmFkaW9FbGVtZW50OiBmdW5jdGlvbiAobmFtZSwgY2hlY2tlZCkge1xyXG5cclxuXHRcdHZhciByYWRpb0h0bWwgPSAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwibGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvclwiIG5hbWU9XCInICtcclxuXHRcdFx0XHRuYW1lICsgJ1wiJyArIChjaGVja2VkID8gJyBjaGVja2VkPVwiY2hlY2tlZFwiJyA6ICcnKSArICcvPic7XHJcblxyXG5cdFx0dmFyIHJhZGlvRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdHJhZGlvRnJhZ21lbnQuaW5uZXJIVE1MID0gcmFkaW9IdG1sO1xyXG5cclxuXHRcdHJldHVybiByYWRpb0ZyYWdtZW50LmZpcnN0Q2hpbGQ7XHJcblx0fSxcclxuXHJcblx0X2FkZEl0ZW06IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyksXHJcblx0XHQgICAgY2hlY2tlZCA9IHRoaXMuX21hcC5oYXNMYXllcihvYmoubGF5ZXIpLFxyXG5cdFx0ICAgIGlucHV0O1xyXG5cclxuXHRcdGlmIChvYmoub3ZlcmxheSkge1xyXG5cdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcblx0XHRcdGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xyXG5cdFx0XHRpbnB1dC5jbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3Rvcic7XHJcblx0XHRcdGlucHV0LmRlZmF1bHRDaGVja2VkID0gY2hlY2tlZDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlucHV0ID0gdGhpcy5fY3JlYXRlUmFkaW9FbGVtZW50KCdsZWFmbGV0LWJhc2UtbGF5ZXJzJywgY2hlY2tlZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aW5wdXQubGF5ZXJJZCA9IEwuc3RhbXAob2JqLmxheWVyKTtcclxuXHJcblx0XHRMLkRvbUV2ZW50Lm9uKGlucHV0LCAnY2xpY2snLCB0aGlzLl9vbklucHV0Q2xpY2ssIHRoaXMpO1xyXG5cclxuXHRcdHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG5cdFx0bmFtZS5pbm5lckhUTUwgPSAnICcgKyBvYmoubmFtZTtcclxuXHJcblx0XHQvLyBIZWxwcyBmcm9tIHByZXZlbnRpbmcgbGF5ZXIgY29udHJvbCBmbGlja2VyIHdoZW4gY2hlY2tib3hlcyBhcmUgZGlzYWJsZWRcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzI3NzFcclxuXHRcdHZhciBob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHJcblx0XHRsYWJlbC5hcHBlbmRDaGlsZChob2xkZXIpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKGlucHV0KTtcclxuXHRcdGhvbGRlci5hcHBlbmRDaGlsZChuYW1lKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIGxhYmVsO1xyXG5cdH0sXHJcblxyXG5cdF9vbklucHV0Q2xpY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9mb3JtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpLFxyXG5cdFx0ICAgIGlucHV0LCBsYXllciwgaGFzTGF5ZXI7XHJcblx0XHR2YXIgYWRkZWRMYXllcnMgPSBbXSxcclxuXHRcdCAgICByZW1vdmVkTGF5ZXJzID0gW107XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHRcdFx0aGFzTGF5ZXIgPSB0aGlzLl9tYXAuaGFzTGF5ZXIobGF5ZXIpO1xyXG5cclxuXHRcdFx0aWYgKGlucHV0LmNoZWNrZWQgJiYgIWhhc0xheWVyKSB7XHJcblx0XHRcdFx0YWRkZWRMYXllcnMucHVzaChsYXllcik7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCFpbnB1dC5jaGVja2VkICYmIGhhc0xheWVyKSB7XHJcblx0XHRcdFx0cmVtb3ZlZExheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJ1Z2ZpeCBpc3N1ZSAyMzE4OiBTaG91bGQgcmVtb3ZlIGFsbCBvbGQgbGF5ZXJzIGJlZm9yZSByZWFkZGluZyBuZXcgb25lc1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHJlbW92ZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHJlbW92ZWRMYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGFkZGVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihhZGRlZExheWVyc1tpXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX3JlZm9jdXNPbk1hcCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jaGVja0Rpc2FibGVkTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW5wdXRzID0gdGhpcy5fZm9ybS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKSxcclxuXHRcdCAgICBpbnB1dCxcclxuXHRcdCAgICBsYXllcixcclxuXHRcdCAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cdFx0XHRpbnB1dC5kaXNhYmxlZCA9IChsYXllci5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tIDwgbGF5ZXIub3B0aW9ucy5taW5ab29tKSB8fFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgIChsYXllci5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tID4gbGF5ZXIub3B0aW9ucy5tYXhab29tKTtcclxuXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2V4cGFuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgcmVtb3ZlIG1lIGluIDEuMS5cclxuXHRcdHJldHVybiB0aGlzLmV4cGFuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgcmVtb3ZlIG1lIGluIDEuMS5cclxuXHRcdHJldHVybiB0aGlzLmNvbGxhcHNlKCk7XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmxheWVycyhiYXNlbGF5ZXJzPzogT2JqZWN0LCBvdmVybGF5cz86IE9iamVjdCwgb3B0aW9ucz86IENvbnRyb2wuTGF5ZXJzIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gYXR0cmlidXRpb24gY29udHJvbCB3aXRoIHRoZSBnaXZlbiBsYXllcnMuIEJhc2UgbGF5ZXJzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCByYWRpbyBidXR0b25zLCB3aGlsZSBvdmVybGF5cyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggY2hlY2tib3hlcy4gTm90ZSB0aGF0IGFsbCBiYXNlIGxheWVycyBzaG91bGQgYmUgcGFzc2VkIGluIHRoZSBiYXNlIGxheWVycyBvYmplY3QsIGJ1dCBvbmx5IG9uZSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG1hcCBkdXJpbmcgbWFwIGluc3RhbnRpYXRpb24uXHJcbkwuY29udHJvbC5sYXllcnMgPSBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ29udHJvbC5MYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpO1xyXG59O1xyXG5cbi8qXHJcbiAqIFByb3ZpZGVzIEwuTWFwIHdpdGggY29udmVuaWVudCBzaG9ydGN1dHMgZm9yIHVzaW5nIGJyb3dzZXIgZ2VvbG9jYXRpb24gZmVhdHVyZXMuXHJcbiAqL1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuXHJcbkwuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBzZWN0aW9uIEdlb2xvY2F0aW9uIG1ldGhvZHNcclxuXHRfZGVmYXVsdExvY2F0ZU9wdGlvbnM6IHtcclxuXHRcdHRpbWVvdXQ6IDEwMDAwLFxyXG5cdFx0d2F0Y2g6IGZhbHNlXHJcblx0XHQvLyBzZXRWaWV3OiBmYWxzZVxyXG5cdFx0Ly8gbWF4Wm9vbTogPE51bWJlcj5cclxuXHRcdC8vIG1heGltdW1BZ2U6IDBcclxuXHRcdC8vIGVuYWJsZUhpZ2hBY2N1cmFjeTogZmFsc2VcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxvY2F0ZShvcHRpb25zPzogTG9jYXRlIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gVHJpZXMgdG8gbG9jYXRlIHRoZSB1c2VyIHVzaW5nIHRoZSBHZW9sb2NhdGlvbiBBUEksIGZpcmluZyBhIFtgbG9jYXRpb25mb3VuZGBdKCNtYXAtbG9jYXRpb25mb3VuZClcclxuXHQvLyBldmVudCB3aXRoIGxvY2F0aW9uIGRhdGEgb24gc3VjY2VzcyBvciBhIFtgbG9jYXRpb25lcnJvcmBdKCNtYXAtbG9jYXRpb25lcnJvcikgZXZlbnQgb24gZmFpbHVyZSxcclxuXHQvLyBhbmQgb3B0aW9uYWxseSBzZXRzIHRoZSBtYXAgdmlldyB0byB0aGUgdXNlcidzIGxvY2F0aW9uIHdpdGggcmVzcGVjdCB0b1xyXG5cdC8vIGRldGVjdGlvbiBhY2N1cmFjeSAob3IgdG8gdGhlIHdvcmxkIHZpZXcgaWYgZ2VvbG9jYXRpb24gZmFpbGVkKS5cclxuXHQvLyBOb3RlIHRoYXQsIGlmIHlvdXIgcGFnZSBkb2Vzbid0IHVzZSBIVFRQUywgdGhpcyBtZXRob2Qgd2lsbCBmYWlsIGluXHJcblx0Ly8gbW9kZXJuIGJyb3dzZXJzIChbQ2hyb21lIDUwIGFuZCBuZXdlcl0oaHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2Rldi9Ib21lL2Nocm9taXVtLXNlY3VyaXR5L2RlcHJlY2F0aW5nLXBvd2VyZnVsLWZlYXR1cmVzLW9uLWluc2VjdXJlLW9yaWdpbnMpKVxyXG5cdC8vIFNlZSBgTG9jYXRlIG9wdGlvbnNgIGZvciBtb3JlIGRldGFpbHMuXHJcblx0bG9jYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zID0gTC5leHRlbmQoe30sIHRoaXMuX2RlZmF1bHRMb2NhdGVPcHRpb25zLCBvcHRpb25zKTtcclxuXHJcblx0XHRpZiAoISgnZ2VvbG9jYXRpb24nIGluIG5hdmlnYXRvcikpIHtcclxuXHRcdFx0dGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvcih7XHJcblx0XHRcdFx0Y29kZTogMCxcclxuXHRcdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gbm90IHN1cHBvcnRlZC4nXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb25SZXNwb25zZSA9IEwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlLCB0aGlzKSxcclxuXHRcdCAgICBvbkVycm9yID0gTC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3IsIHRoaXMpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLndhdGNoKSB7XHJcblx0XHRcdHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCA9XHJcblx0XHRcdCAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLndhdGNoUG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzdG9wTG9jYXRlKCk6IHRoaXNcclxuXHQvLyBTdG9wcyB3YXRjaGluZyBsb2NhdGlvbiBwcmV2aW91c2x5IGluaXRpYXRlZCBieSBgbWFwLmxvY2F0ZSh7d2F0Y2g6IHRydWV9KWBcclxuXHQvLyBhbmQgYWJvcnRzIHJlc2V0dGluZyB0aGUgbWFwIHZpZXcgaWYgbWFwLmxvY2F0ZSB3YXMgY2FsbGVkIHdpdGhcclxuXHQvLyBge3NldFZpZXc6IHRydWV9YC5cclxuXHRzdG9wTG9jYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAobmF2aWdhdG9yLmdlb2xvY2F0aW9uICYmIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKSB7XHJcblx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucykge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXcgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVHZW9sb2NhdGlvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuXHRcdHZhciBjID0gZXJyb3IuY29kZSxcclxuXHRcdCAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fFxyXG5cdFx0ICAgICAgICAgICAgKGMgPT09IDEgPyAncGVybWlzc2lvbiBkZW5pZWQnIDpcclxuXHRcdCAgICAgICAgICAgIChjID09PSAyID8gJ3Bvc2l0aW9uIHVuYXZhaWxhYmxlJyA6ICd0aW1lb3V0JykpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXcgJiYgIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLmZpdFdvcmxkKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gTG9jYXRpb24gZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgbG9jYXRpb25lcnJvcjogRXJyb3JFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZCkgZmFpbGVkLlxyXG5cdFx0dGhpcy5maXJlKCdsb2NhdGlvbmVycm9yJywge1xyXG5cdFx0XHRjb2RlOiBjLFxyXG5cdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gZXJyb3I6ICcgKyBtZXNzYWdlICsgJy4nXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZTogZnVuY3Rpb24gKHBvcykge1xyXG5cdFx0dmFyIGxhdCA9IHBvcy5jb29yZHMubGF0aXR1ZGUsXHJcblx0XHQgICAgbG5nID0gcG9zLmNvb3Jkcy5sb25naXR1ZGUsXHJcblx0XHQgICAgbGF0bG5nID0gbmV3IEwuTGF0TG5nKGxhdCwgbG5nKSxcclxuXHRcdCAgICBib3VuZHMgPSBsYXRsbmcudG9Cb3VuZHMocG9zLmNvb3Jkcy5hY2N1cmFjeSksXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuc2V0Vmlldykge1xyXG5cdFx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMpO1xyXG5cdFx0XHR0aGlzLnNldFZpZXcobGF0bG5nLCBvcHRpb25zLm1heFpvb20gPyBNYXRoLm1pbih6b29tLCBvcHRpb25zLm1heFpvb20pIDogem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG5cdFx0XHRib3VuZHM6IGJvdW5kcyxcclxuXHRcdFx0dGltZXN0YW1wOiBwb3MudGltZXN0YW1wXHJcblx0XHR9O1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gcG9zLmNvb3Jkcykge1xyXG5cdFx0XHRpZiAodHlwZW9mIHBvcy5jb29yZHNbaV0gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdFx0ZGF0YVtpXSA9IHBvcy5jb29yZHNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbG9jYXRpb25mb3VuZDogTG9jYXRpb25FdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZClcclxuXHRcdC8vIHdlbnQgc3VjY2Vzc2Z1bGx5LlxyXG5cdFx0dGhpcy5maXJlKCdsb2NhdGlvbmZvdW5kJywgZGF0YSk7XHJcblx0fVxyXG59KTtcclxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIihmdW5jdGlvbih3aW5kb3csIHVuZGVmaW5lZCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICghd2luZG93KSByZXR1cm47IC8vIFNlcnZlciBzaWRlXG5cbnZhclxuICAgIF9iYXJvbiA9IHdpbmRvdy5iYXJvbiwgLy8gU3RvcmVkIGJhcm9uIHZhbHVlIGZvciBub0NvbmZsaWN0IHVzYWdlXG4gICAgJCA9IHdpbmRvdy5qUXVlcnksIC8vIFRyeWluZyB0byB1c2UgalF1ZXJ5XG4gICAgb3JpZ2luID0ge1xuICAgICAgICB2OiB7IC8vIFZlcnRpY2FsXG4gICAgICAgICAgICB4OiAnWScsIHBvczogJ3RvcCcsIGNyb3NzUG9zOiAnbGVmdCcsIHNpemU6ICdoZWlnaHQnLCBjcm9zc1NpemU6ICd3aWR0aCcsXG4gICAgICAgICAgICBjbGllbnQ6ICdjbGllbnRIZWlnaHQnLCBjcm9zc0NsaWVudDogJ2NsaWVudFdpZHRoJywgb2Zmc2V0OiAnb2Zmc2V0SGVpZ2h0JywgY3Jvc3NPZmZzZXQ6ICdvZmZzZXRXaWR0aCcsIG9mZnNldFBvczogJ29mZnNldFRvcCcsXG4gICAgICAgICAgICBzY3JvbGw6ICdzY3JvbGxUb3AnLCBzY3JvbGxTaXplOiAnc2Nyb2xsSGVpZ2h0J1xuICAgICAgICB9LFxuICAgICAgICBoOiB7IC8vIEhvcml6b250YWxcbiAgICAgICAgICAgIHg6ICdYJywgcG9zOiAnbGVmdCcsIGNyb3NzUG9zOiAndG9wJywgc2l6ZTogJ3dpZHRoJywgY3Jvc3NTaXplOiAnaGVpZ2h0JyxcbiAgICAgICAgICAgIGNsaWVudDogJ2NsaWVudFdpZHRoJywgY3Jvc3NDbGllbnQ6ICdjbGllbnRIZWlnaHQnLCBvZmZzZXQ6ICdvZmZzZXRXaWR0aCcsIGNyb3NzT2Zmc2V0OiAnb2Zmc2V0SGVpZ2h0Jywgb2Zmc2V0UG9zOiAnb2Zmc2V0TGVmdCcsXG4gICAgICAgICAgICBzY3JvbGw6ICdzY3JvbGxMZWZ0Jywgc2Nyb2xsU2l6ZTogJ3Njcm9sbFdpZHRoJ1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yKSB7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICBpZiAob2JqLmxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gd2luZG93KSBvYmogPSBbb2JqXTtcblxuICAgICAgICB3aGlsZSAob2JqW2ldKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKHRoaXMsIG9ialtpXSwgaSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYmFyb24gPSBmdW5jdGlvbihwYXJhbXMpIHsgLy8gdGhpcyAtIHdpbmRvdyBvciBqUXVlcnkgaW5zdGFuY2VcbiAgICAgICAgdmFyIGpRdWVyeU1vZGUgPSBmYWxzZSwvLyh0aGlzICYmIHRoaXNbMF0gJiYgdGhpc1swXS5ub2RlVHlwZSksXG4gICAgICAgICAgICByb290cyxcbiAgICAgICAgICAgICQ7XG5cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICAkID0gcGFyYW1zLiQgfHwgd2luZG93LmpRdWVyeTtcblxuICAgICAgICBpZiAoalF1ZXJ5TW9kZSkge1xuICAgICAgICAgICAgcGFyYW1zLnJvb3QgPSByb290cyA9IHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb290cyA9ICQocGFyYW1zLnJvb3QgfHwgcGFyYW1zLnNjcm9sbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgYmFyb24uZm4uY29uc3RydWN0b3Iocm9vdHMsIHBhcmFtcywgJCk7XG4gICAgfTtcblxuICAgIGJhcm9uLmZuID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24ocm9vdHMsIGlucHV0LCAkKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gdmFsaWRhdGUoaW5wdXQpO1xuXG4gICAgICAgICAgICBwYXJhbXMuJCA9ICQ7XG4gICAgICAgICAgICBlYWNoLmNhbGwodGhpcywgcm9vdHMsIGZ1bmN0aW9uKHJvb3QsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxQYXJhbXMgPSBjbG9uZShwYXJhbXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5yb290ICYmIHBhcmFtcy5zY3JvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFBhcmFtcy5zY3JvbGxlciA9IHBhcmFtcy4kKHBhcmFtcy5zY3JvbGxlciwgcm9vdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9jYWxQYXJhbXMuc2Nyb2xsZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFBhcmFtcy5zY3JvbGxlciA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFBhcmFtcy5zY3JvbGxlciA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbG9jYWxQYXJhbXMucm9vdCA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IGluaXQobG9jYWxQYXJhbXMpO1xuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gaSArIDE7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG5cbiAgICAgICAgICAgIGVhY2godGhpcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uZGlzcG9zZShwYXJhbXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICAgICAgd2hpbGUgKHRoaXNbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldLnVwZGF0ZS5hcHBseSh0aGlzW2ldLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBiYXJvbjogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMucm9vdCA9IFtdO1xuICAgICAgICAgICAgcGFyYW1zLnNjcm9sbGVyID0gdGhpcy5wYXJhbXMuc2Nyb2xsZXI7XG5cbiAgICAgICAgICAgIGVhY2guY2FsbCh0aGlzLCB0aGlzLCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnJvb3QucHVzaChlbGVtLnJvb3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJhbXMuZGlyZWN0aW9uID0gKHRoaXMucGFyYW1zLmRpcmVjdGlvbiA9PSAndicpID8gJ2gnIDogJ3YnO1xuICAgICAgICAgICAgcGFyYW1zLl9jaGFpbiA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybiBiYXJvbihwYXJhbXMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1hbmFnZUV2ZW50cyhpdGVtLCBldmVudE1hbmFnZXIsIG1vZGUpIHtcbiAgICAgICAgaXRlbS5fZXZlbnRIYW5kbGVycyA9IGl0ZW0uX2V2ZW50SGFuZGxlcnMgfHwgWyAvLyBDcmVhdGluZyBuZXcgZnVuY3Rpb25zIGZvciBvbmUgYmFyb24gaXRlbSBvbmx5IG9uZSB0aW1lXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gb25TY3JvbGw6XG4gICAgICAgICAgICAgICAgZWxlbWVudDogaXRlbS5zY3JvbGxlcixcblxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zY3JvbGwoZSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHR5cGU6ICdzY3JvbGwnXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgLy8gb25Nb3VzZURvd246XG4gICAgICAgICAgICAgICAgZWxlbWVudDogaXRlbS5iYXIsXG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQgPyBlLnByZXZlbnREZWZhdWx0KCkgOiBlLnJldHVyblZhbHVlID0gZmFsc2U7IC8vIFRleHQgc2VsZWN0aW9uIGRpc2FibGluZyBpbiBPcGVyYS4uLiBhbmQgYWxsIG90aGVyIGJyb3dzZXJzP1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnNlbGVjdGlvbigpOyAvLyBEaXNhYmxlIHRleHQgc2VsZWN0aW9uIGluIGllOFxuICAgICAgICAgICAgICAgICAgICBpdGVtLmRyYWcubm93ID0gMTsgLy8gU2F2ZSBwcml2YXRlIGJ5dGVcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgdHlwZTogJ3RvdWNoc3RhcnQgbW91c2Vkb3duJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIC8vIG9uTW91c2VVcDpcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBkb2N1bWVudCxcblxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnNlbGVjdGlvbigxKTsgLy8gRW5hYmxlIHRleHQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZHJhZy5ub3cgPSAwO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICB0eXBlOiAnbW91c2V1cCBibHVyIHRvdWNoZW5kJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIC8vIG9uQ29vcmRpbmF0ZVJlc2V0OlxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGl0ZW0uYmFyLFxuXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5idXR0b24gIT0gMikgeyAvLyBOb3QgUk1cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uX3BvczAoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgdHlwZTogJ3RvdWNoc3RhcnQgbW91c2Vkb3duJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIC8vIG9uTW91c2VNb3ZlOlxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LFxuXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5kcmFnLm5vdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5kcmFnKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHR5cGU6ICdtb3VzZW1vdmUgdG91Y2htb3ZlJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIC8vIG9uUmVzaXplOlxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcblxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICB0eXBlOiAncmVzaXplJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIC8vIHNpemVDaGFuZ2U6XG4gICAgICAgICAgICAgICAgZWxlbWVudDogaXRlbS5yb290LFxuXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHR5cGU6ICdzaXplQ2hhbmdlJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuXG4gICAgICAgIGVhY2goaXRlbS5fZXZlbnRIYW5kbGVycywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnRNYW5hZ2VyKGV2ZW50LmVsZW1lbnQsIGV2ZW50LnR5cGUsIGV2ZW50LmhhbmRsZXIsIG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpZiAoaXRlbS5zY3JvbGxlcikge1xuICAgICAgICAvLyAgICAgZXZlbnQoaXRlbS5zY3JvbGxlciwgJ3Njcm9sbCcsIGl0ZW0uX2V2ZW50SGFuZGxlcnMub25TY3JvbGwsIG1vZGUpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmIChpdGVtLmJhcikge1xuICAgICAgICAvLyAgICAgZXZlbnQoaXRlbS5iYXIsICd0b3VjaHN0YXJ0IG1vdXNlZG93bicsIGl0ZW0uX2V2ZW50SGFuZGxlcnMub25Nb3VzZURvd24sIG1vZGUpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGV2ZW50KGRvY3VtZW50LCAnbW91c2V1cCBibHVyIHRvdWNoZW5kJywgaXRlbS5fZXZlbnRIYW5kbGVycy5vbk1vdXNlVXAsIG1vZGUpO1xuICAgICAgICAvLyBldmVudChkb2N1bWVudCwgJ3RvdWNoc3RhcnQgbW91c2Vkb3duJywgaXRlbS5fZXZlbnRIYW5kbGVycy5vbkNvb3JkaW5hdGVSZXNldCwgbW9kZSk7XG4gICAgICAgIC8vIGV2ZW50KGRvY3VtZW50LCAnbW91c2Vtb3ZlIHRvdWNobW92ZScsIGl0ZW0uX2V2ZW50SGFuZGxlcnMub25Nb3VzZU1vdmUsIG1vZGUpO1xuICAgICAgICAvLyBldmVudCh3aW5kb3csICdyZXNpemUnLCBpdGVtLl9ldmVudEhhbmRsZXJzLm9uUmVzaXplLCBtb2RlKTtcbiAgICAgICAgLy8gaWYgKGl0ZW0ucm9vdCkge1xuICAgICAgICAvLyAgICAgZXZlbnQoaXRlbS5yb290LCAnc2l6ZUNoYW5nZScsIGl0ZW0uX2V2ZW50SGFuZGxlcnMub25SZXNpemUsIG1vZGUpOyAvLyBDdXN0b24gZXZlbnQgZm9yIGFsdGVybmF0ZSBiYXJvbiB1cGRhdGUgbWVjaGFuaXNtXG4gICAgICAgIC8vIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYW5hZ2VBdHRyKG5vZGUsIGRpcmVjdGlvbiwgbW9kZSkge1xuICAgICAgICB2YXIgYXR0ck5hbWUgPSAnZGF0YS1iYXJvbi0nICsgZGlyZWN0aW9uO1xuXG4gICAgICAgIGlmIChtb2RlID09ICdvbicpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCAnaW5pdGVkJyk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSAnb2ZmJykge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXQocGFyYW1zKSB7XG4gICAgICAgIGlmIChtYW5hZ2VBdHRyKHBhcmFtcy5yb290LCBwYXJhbXMuZGlyZWN0aW9uKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBvdXQgPSBuZXcgaXRlbS5wcm90b3R5cGUuY29uc3RydWN0b3IocGFyYW1zKTsgLy8gX19wcm90b19fIG9mIHJldHVybmluZyBvYmplY3QgaXMgYmFyb24ucHJvdG90eXBlXG5cbiAgICAgICAgbWFuYWdlRXZlbnRzKG91dCwgcGFyYW1zLmV2ZW50LCAnb24nKTtcblxuICAgICAgICBtYW5hZ2VBdHRyKG91dC5yb290LCBwYXJhbXMuZGlyZWN0aW9uLCAnb24nKTtcblxuICAgICAgICBvdXQudXBkYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZShpbnB1dCkge1xuICAgICAgICB2YXIgb3V0cHV0ID0ge307XG5cbiAgICAgICAgaW5wdXQgPSBpbnB1dCB8fCB7fTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShpbnB1dCkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gY2xvbmUoaW5wdXQpO1xuXG4gICAgICAgIG91dHB1dC5kaXJlY3Rpb24gPSBvdXRwdXQuZGlyZWN0aW9uIHx8ICd2JztcblxuICAgICAgICB2YXIgZXZlbnQgPSBpbnB1dC5ldmVudCB8fCBmdW5jdGlvbihlbGVtLCBldmVudCwgZnVuYywgbW9kZSkge1xuICAgICAgICAgICAgb3V0cHV0LiQoZWxlbSlbbW9kZSB8fCAnb24nXShldmVudCwgZnVuYyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb3V0cHV0LmV2ZW50ID0gZnVuY3Rpb24oZWxlbXMsIGUsIGZ1bmMsIG1vZGUpIHtcbiAgICAgICAgICAgIGVhY2goZWxlbXMsIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICBldmVudChlbGVtLCBlLCBmdW5jLCBtb2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlyZShldmVudE5hbWUpIHtcbiAgICAgICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIGlmICh0aGlzLmV2ZW50cyAmJiB0aGlzLmV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCB0aGlzLmV2ZW50c1tldmVudE5hbWVdLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXVtpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpdGVtID0ge307XG5cbiAgICBpdGVtLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAgICAgdmFyICQsXG4gICAgICAgICAgICAgICAgYmFyUG9zLFxuICAgICAgICAgICAgICAgIHNjcm9sbGVyUG9zMCxcbiAgICAgICAgICAgICAgICB0cmFjayxcbiAgICAgICAgICAgICAgICByZXNpemVQYXVzZVRpbWVyLFxuICAgICAgICAgICAgICAgIHNjcm9sbFBhdXNlVGltZXIsXG4gICAgICAgICAgICAgICAgcGF1c2UsXG4gICAgICAgICAgICAgICAgc2Nyb2xsTGFzdEZpcmUsXG4gICAgICAgICAgICAgICAgcmVzaXplTGFzdEZpcmU7XG5cbiAgICAgICAgICAgIHJlc2l6ZUxhc3RGaXJlID0gc2Nyb2xsTGFzdEZpcmUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICAgICAgJCA9IHRoaXMuJCA9IHBhcmFtcy4kO1xuICAgICAgICAgICAgdGhpcy5ldmVudCA9IHBhcmFtcy5ldmVudDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0ge307XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldE5vZGUoc2VsLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQoc2VsLCBjb250ZXh0KVswXTsgLy8gQ2FuIGJlIHVuZGVmaW5lZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBET00gZWxlbWVudHNcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHBhcmFtcy5yb290OyAvLyBBbHdheXMgaHRtbCBub2RlLCBub3QganVzdCBzZWxlY3RvclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlciA9IGdldE5vZGUocGFyYW1zLnNjcm9sbGVyKTsgLy8gKHBhcmFtcy5zY3JvbGxlcikgPyBnZXROb2RlKHBhcmFtcy5zY3JvbGxlciwgdGhpcy5yb290KSA6IHRoaXMucm9vdDtcbiAgICAgICAgICAgIHRoaXMuYmFyID0gZ2V0Tm9kZShwYXJhbXMuYmFyLCB0aGlzLnJvb3QpO1xuICAgICAgICAgICAgdHJhY2sgPSB0aGlzLnRyYWNrID0gZ2V0Tm9kZShwYXJhbXMudHJhY2ssIHRoaXMucm9vdCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHJhY2sgJiYgdGhpcy5iYXIpIHtcbiAgICAgICAgICAgICAgICB0cmFjayA9IHRoaXMuYmFyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsaXBwZXIgPSB0aGlzLnNjcm9sbGVyLnBhcmVudE5vZGU7XG5cbiAgICAgICAgICAgIC8vIFBhcmFtZXRlcnNcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gcGFyYW1zLmRpcmVjdGlvbjtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luID0gb3JpZ2luW3RoaXMuZGlyZWN0aW9uXTtcbiAgICAgICAgICAgIHRoaXMuYmFyT25DbHMgPSBwYXJhbXMuYmFyT25DbHM7XG4gICAgICAgICAgICB0aGlzLmJhclRvcExpbWl0ID0gMDtcbiAgICAgICAgICAgIHBhdXNlID0gcGFyYW1zLnBhdXNlICogMTAwMCB8fCAwO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGluZyBoZWlnaHQgb3Igd2lkdGggb2YgYmFyXG4gICAgICAgICAgICBmdW5jdGlvbiBzZXRCYXJTaXplKHNpemUpIHtcbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgICAgICAgICB2YXIgYmFyTWluU2l6ZSA9IHRoaXMuYmFyTWluU2l6ZSB8fCAyMDtcblxuICAgICAgICAgICAgICAgIGlmIChzaXplID4gMCAmJiBzaXplIDwgYmFyTWluU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gYmFyTWluU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmJhcikuY3NzKHRoaXMub3JpZ2luLnNpemUsIHBhcnNlSW50KHNpemUsIDEwKSArICdweCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRpbmcgdG9wIG9yIGxlZnQgYmFyIHBvc2l0aW9uXG4gICAgICAgICAgICBmdW5jdGlvbiBwb3NCYXIocG9zKSB7XG4gICAgICAgICAgICAgICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmFyKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5iYXIpLmNzcyh0aGlzLm9yaWdpbi5wb3MsICtwb3MgKyAncHgnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZyZWUgcGF0aCBmb3IgYmFyXG4gICAgICAgICAgICBmdW5jdGlvbiBrKCkge1xuICAgICAgICAgICAgICAgIC8qIGpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFja1t0aGlzLm9yaWdpbi5jbGllbnRdIC0gdGhpcy5iYXJUb3BMaW1pdCAtIHRoaXMuYmFyW3RoaXMub3JpZ2luLm9mZnNldF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbGF0aXZlIGNvbnRlbnQgdG9wIHBvc2l0aW9uIHRvIGJhciB0b3AgcG9zaXRpb25cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbFRvUG9zKHIpIHtcbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gciAqIGsuY2FsbCh0aGlzKSArIHRoaXMuYmFyVG9wTGltaXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEJhciBwb3NpdGlvbiB0byByZWxhdGl2ZSBjb250ZW50IHBvc2l0aW9uXG4gICAgICAgICAgICBmdW5jdGlvbiBwb3NUb1JlbCh0KSB7XG4gICAgICAgICAgICAgICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0IC0gdGhpcy5iYXJUb3BMaW1pdCkgLyBrLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEN1cnNvciBwb3NpdGlvbiBpbiBtYWluIGRpcmVjdGlvbiBpbiBweCAvLyBOb3cgd2l0aCBpT3Mgc3VwcG9ydFxuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVbJ2NsaWVudCcgKyB0aGlzLm9yaWdpbi54XSB8fCAoKChlLm9yaWdpbmFsRXZlbnQgfHwgZSkudG91Y2hlcyB8fCB7fSlbMF0gfHwge30pWydwYWdlJyArIHRoaXMub3JpZ2luLnhdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gVGV4dCBzZWxlY3Rpb24gcG9zIHByZXZlbnRpbmdcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRvbnRQb3NTZWxlY3QoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBvcyA9IGZ1bmN0aW9uKHgpIHsgLy8gQWJzb2x1dGUgc2Nyb2xsZXIgcG9zaXRpb24gaW4gcHhcbiAgICAgICAgICAgICAgICB2YXIgaWUgPSAncGFnZScgKyB0aGlzLm9yaWdpbi54ICsgJ09mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgIGtleSA9ICh0aGlzLnNjcm9sbGVyW2llXSkgPyBpZSA6IHRoaXMub3JpZ2luLnNjcm9sbDtcblxuICAgICAgICAgICAgICAgIGlmICh4ICE9PSB1bmRlZmluZWQpIHRoaXMuc2Nyb2xsZXJba2V5XSA9IHg7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxlcltrZXldO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5ycG9zID0gZnVuY3Rpb24ocikgeyAvLyBSZWxhdGl2ZSBzY3JvbGxlciBwb3NpdGlvbiAoMC4uMSlcbiAgICAgICAgICAgICAgICB2YXIgZnJlZSA9IHRoaXMuc2Nyb2xsZXJbdGhpcy5vcmlnaW4uc2Nyb2xsU2l6ZV0gLSB0aGlzLnNjcm9sbGVyW3RoaXMub3JpZ2luLmNsaWVudF0sXG4gICAgICAgICAgICAgICAgICAgIHg7XG5cbiAgICAgICAgICAgICAgICBpZiAocikgeCA9IHRoaXMucG9zKHIgKiBmcmVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIHggPSB0aGlzLnBvcygpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHggLyAoZnJlZSB8fCAxKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFN3aXRjaCBvbiB0aGUgYmFyIGJ5IGFkZGluZyB1c2VyLWRlZmluZWQgQ1NTIGNsYXNzbmFtZSB0byBzY3JvbGxlclxuICAgICAgICAgICAgdGhpcy5iYXJPbiA9IGZ1bmN0aW9uKGRpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iYXJPbkNscykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzcG9zZSB8fCB0aGlzLnNjcm9sbGVyW3RoaXMub3JpZ2luLmNsaWVudF0gPj0gdGhpcy5zY3JvbGxlclt0aGlzLm9yaWdpbi5zY3JvbGxTaXplXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzLnJvb3QpLnJlbW92ZUNsYXNzKHRoaXMuYmFyT25DbHMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzLnJvb3QpLmFkZENsYXNzKHRoaXMuYmFyT25DbHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fcG9zMCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxlclBvczAgPSB0aGlzLmN1cnNvcihlKSAtIGJhclBvcztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuZHJhZyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVyW3RoaXMub3JpZ2luLnNjcm9sbF0gPSBwb3NUb1JlbC5jYWxsKHRoaXMsIHRoaXMuY3Vyc29yKGUpIC0gc2Nyb2xsZXJQb3MwKSAqICh0aGlzLnNjcm9sbGVyW3RoaXMub3JpZ2luLnNjcm9sbFNpemVdIC0gdGhpcy5zY3JvbGxlclt0aGlzLm9yaWdpbi5jbGllbnRdKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFRleHQgc2VsZWN0aW9uIHByZXZlbnRpbmcgb24gZHJhZ1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBmdW5jdGlvbihlbmFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50KGRvY3VtZW50LCAnc2VsZWN0cG9zIHNlbGVjdHN0YXJ0JywgZG9udFBvc1NlbGVjdCwgZW5hYmxlID8gJ29mZicgOiAnb24nKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIG9uUmVzaXplICYgRE9NIG1vZGlmaWVkIGhhbmRsZXJcbiAgICAgICAgICAgIHRoaXMucmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBkZWxheSA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSByZXNpemVMYXN0RmlyZSA8IHBhdXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXNpemVQYXVzZVRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBwYXVzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IHNlbGYuc2Nyb2xsZXJbc2VsZi5vcmlnaW4uY3Jvc3NPZmZzZXRdIC0gc2VsZi5zY3JvbGxlcltzZWxmLm9yaWdpbi5jcm9zc0NsaWVudF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5mcmVlemUgJiYgIXNlbGYuY2xpcHBlci5zdHlsZVtzZWxmLm9yaWdpbi5jcm9zc1NpemVdKSB7IC8vIFNvdWxkIGZpcmUgb25seSBvbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAkKHNlbGYuY2xpcHBlcikuY3NzKHNlbGYub3JpZ2luLmNyb3NzU2l6ZSwgc2VsZi5jbGlwcGVyW3NlbGYub3JpZ2luLmNyb3NzQ2xpZW50XSAtIGRlbHRhICsgJ3B4Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJChzZWxmLnNjcm9sbGVyKS5jc3Moc2VsZi5vcmlnaW4uY3Jvc3NTaXplLCBzZWxmLmNsaXBwZXJbc2VsZi5vcmlnaW4uY3Jvc3NDbGllbnRdICsgZGVsdGEgKyAncHgnKTtcblxuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5jYWxsKGFyZ3VtZW50cywgJ3Jlc2l6ZScpO1xuICAgICAgICAgICAgICAgICAgICBmaXJlLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzaXplTGFzdEZpcmUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplUGF1c2VUaW1lciA9IHNldFRpbWVvdXQodXBkLCBkZWxheSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gb25TY3JvbGwgaGFuZGxlclxuICAgICAgICAgICAgdGhpcy5zY3JvbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkQmFyU2l6ZSwgbmV3QmFyU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSAwLFxuICAgICAgICAgICAgICAgICAgICBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHNjcm9sbExhc3RGaXJlIDwgcGF1c2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbFBhdXNlVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICBkZWxheSA9IHBhdXNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYmFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdCYXJTaXplID0gKHRyYWNrW3NlbGYub3JpZ2luLmNsaWVudF0gLSBzZWxmLmJhclRvcExpbWl0KSAqIHNlbGYuc2Nyb2xsZXJbc2VsZi5vcmlnaW4uY2xpZW50XSAvIHNlbGYuc2Nyb2xsZXJbc2VsZi5vcmlnaW4uc2Nyb2xsU2l6ZV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvc2l0aW9uaW5nIGJhclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZEJhclNpemUgIT0gbmV3QmFyU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJhclNpemUuY2FsbChzZWxmLCBuZXdCYXJTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRCYXJTaXplID0gbmV3QmFyU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyUG9zID0gcmVsVG9Qb3MuY2FsbChzZWxmLCBzZWxmLnJwb3MoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc0Jhci5jYWxsKHNlbGYsIGJhclBvcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5jYWxsKCBhcmd1bWVudHMsICdzY3JvbGwnICk7XG4gICAgICAgICAgICAgICAgICAgIGZpcmUuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxMYXN0RmlyZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxQYXVzZVRpbWVyID0gc2V0VGltZW91dCh1cGQsIGRlbGF5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cGQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgICAgICBmaXJlLmNhbGwodGhpcywgJ3VwZCcsIHBhcmFtcyk7IC8vINCe0LHQvdC+0LLQu9GP0LXQvCDQv9Cw0YDQsNC80LXRgtGA0Ysg0LLRgdC10YUg0L/Qu9Cw0LPQuNC90L7QslxuXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgxKTtcbiAgICAgICAgICAgIHRoaXMuYmFyT24oKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAgICAgbWFuYWdlRXZlbnRzKHRoaXMsIHRoaXMuZXZlbnQsICdvZmYnKTtcbiAgICAgICAgICAgIG1hbmFnZUF0dHIodGhpcy5yb290LCBwYXJhbXMuZGlyZWN0aW9uLCAnb2ZmJyk7XG4gICAgICAgICAgICAkKHRoaXMuc2Nyb2xsZXIpLmNzcyh0aGlzLm9yaWdpbi5jcm9zc1NpemUsICcnKTtcbiAgICAgICAgICAgIHRoaXMuYmFyT24odHJ1ZSk7XG4gICAgICAgICAgICBmaXJlLmNhbGwodGhpcywgJ2Rpc3Bvc2UnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbjogZnVuY3Rpb24oZXZlbnROYW1lLCBmdW5jLCBhcmcpIHtcbiAgICAgICAgICAgIHZhciBuYW1lcyA9IGV2ZW50TmFtZS5zcGxpdCgnICcpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBuYW1lcy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXNbaV0gPT0gJ2luaXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmMuY2FsbCh0aGlzLCBhcmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzW25hbWVzW2ldXSA9IHRoaXMuZXZlbnRzW25hbWVzW2ldXSB8fCBbXTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50c1tuYW1lc1tpXV0ucHVzaChmdW5jdGlvbih1c2VyQXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jLmNhbGwodGhpcywgdXNlckFyZyB8fCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYmFyb24uZm4uY29uc3RydWN0b3IucHJvdG90eXBlID0gYmFyb24uZm47XG4gICAgaXRlbS5wcm90b3R5cGUuY29uc3RydWN0b3IucHJvdG90eXBlID0gaXRlbS5wcm90b3R5cGU7XG5cbiAgICAvLyBVc2Ugd2hlbiB5b3UgbmVlZCBcImJhcm9uXCIgZ2xvYmFsIHZhciBmb3IgYW5vdGhlciBwdXJwb3Nlc1xuICAgIGJhcm9uLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LmJhcm9uID0gX2Jhcm9uOyAvLyBSZXN0b3Jpbmcgb3JpZ2luYWwgdmFsdWUgb2YgXCJiYXJvblwiIGdsb2JhbCB2YXJcbiAgICAgICAgcmV0dXJuIGJhcm9uO1xuICAgIH07XG5cbiAgICBiYXJvbi52ZXJzaW9uID0gJzAuNi42JztcblxuICAgIGlmICgkICYmICQuZm4pIHsgLy8gQWRkaW5nIGJhcm9uIHRvIGpRdWVyeSBhcyBwbHVnaW5cbiAgICAgICAgJC5mbi5iYXJvbiA9IGJhcm9uO1xuICAgIH1cbiAgICB3aW5kb3cuYmFyb24gPSBiYXJvbjsgLy8gVXNlIG5vQ29uZmxpY3QgbWV0aG9kIGlmIHlvdSBuZWVkIHdpbmRvdy5iYXJvbiB2YXIgZm9yIGFub3RoZXIgcHVycG9zZXNcblxuICAgIHZhciBmaXggPSBmdW5jdGlvbih1c2VyUGFyYW1zKSB7XG4gICAgICAgIHZhciBlbGVtZW50cywgdmlld1BvcnRTaXplLFxuICAgICAgICAgICAgcGFyYW1zID0geyAvLyBEZWZhdWx0IHBhcmFtc1xuICAgICAgICAgICAgICAgIG91dHNpZGU6ICcnLFxuICAgICAgICAgICAgICAgIGJlZm9yZTogJycsXG4gICAgICAgICAgICAgICAgYWZ0ZXI6ICcnLFxuICAgICAgICAgICAgICAgIHBhc3Q6ICcnLFxuICAgICAgICAgICAgICAgIGZ1dHVyZTogJycsXG4gICAgICAgICAgICAgICAgcmFkaXVzOiAwLFxuICAgICAgICAgICAgICAgIG1pblZpZXc6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b3BGaXhIZWlnaHRzID0gW10sIC8vIGlubGluZSBzdHlsZSBmb3IgZWxlbWVudFxuICAgICAgICAgICAgdG9wUmVhbEhlaWdodHMgPSBbXSwgLy8gcmVhbCBvZmZzZXQgcG9zaXRpb24gd2hlbiBub3QgZml4ZWRcbiAgICAgICAgICAgIGhlYWRlclRvcHMgPSBbXSxcbiAgICAgICAgICAgIHNjcm9sbGVyID0gdGhpcy5zY3JvbGxlcixcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlciA9IHRoaXMuZXZlbnQsXG4gICAgICAgICAgICAkID0gdGhpcy4kLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgZnVuY3Rpb24gZml4RWxlbWVudChpLCBwb3MpIHtcbiAgICAgICAgICAgIGlmICh2aWV3UG9ydFNpemUgPCAocGFyYW1zLm1pblZpZXcgfHwgMCkpIHsgLy8gTm8gaGVhZGVycyBmaXhpbmcgd2hlbiBubyBlbm91Z2h0IHNwYWNlIGZvciB2aWV3cG9ydFxuICAgICAgICAgICAgICAgIHBvcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcG9zICs9ICdweCc7XG4gICAgICAgICAgICAgICAgdGhpcy4kKGVsZW1lbnRzW2ldKS5jc3ModGhpcy5vcmlnaW4ucG9zLCBwb3MpLmFkZENsYXNzKHBhcmFtcy5vdXRzaWRlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kKGVsZW1lbnRzW2ldKS5jc3ModGhpcy5vcmlnaW4ucG9zLCAnJykucmVtb3ZlQ2xhc3MocGFyYW1zLm91dHNpZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYnViYmxlV2hlZWwoZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ1doZWVsRXZlbnQnKTsgLy8gaSAtIGZvciBleHRyYSBieXRlXG4gICAgICAgICAgICAgICAgLy8gZXZ0LmluaXRXZWJLaXRXaGVlbEV2ZW50KGRlbHRhWCwgZGVsdGFZLCB3aW5kb3csIHNjcmVlblgsIHNjcmVlblksIGNsaWVudFgsIGNsaWVudFksIGN0cmxLZXksIGFsdEtleSwgc2hpZnRLZXksIG1ldGFLZXkpO1xuICAgICAgICAgICAgICAgIGkuaW5pdFdlYktpdFdoZWVsRXZlbnQoZS5vcmlnaW5hbEV2ZW50LndoZWVsRGVsdGFYLCBlLm9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YVkpO1xuICAgICAgICAgICAgICAgIHNjcm9sbGVyLmRpc3BhdGNoRXZlbnQoaSk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXQoX3BhcmFtcykge1xuICAgICAgICAgICAgdmFyIHBvcztcblxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIF9wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5XSA9IF9wYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbWVudHMgPSB0aGlzLiQocGFyYW1zLmVsZW1lbnRzLCB0aGlzLnNjcm9sbGVyKTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgdmlld1BvcnRTaXplID0gdGhpcy5zY3JvbGxlclt0aGlzLm9yaWdpbi5jbGllbnRdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGVsZW1lbnRzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBWYXJpYWJsZSBoZWFkZXIgaGVpZ2h0c1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgcG9zW3RoaXMub3JpZ2luLnNpemVdID0gZWxlbWVudHNbaV1bdGhpcy5vcmlnaW4ub2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzW2ldLnBhcmVudE5vZGUgIT09IHRoaXMuc2Nyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJChlbGVtZW50c1tpXS5wYXJlbnROb2RlKS5jc3MocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb3MgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgcG9zW3RoaXMub3JpZ2luLmNyb3NzU2l6ZV0gPSBlbGVtZW50c1tpXS5wYXJlbnROb2RlW3RoaXMub3JpZ2luLmNyb3NzQ2xpZW50XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kKGVsZW1lbnRzW2ldKS5jc3MocG9zKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBCZXR3ZWVuIGZpeGVkIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgdmlld1BvcnRTaXplIC09IGVsZW1lbnRzW2ldW3RoaXMub3JpZ2luLm9mZnNldF07XG5cbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyVG9wc1tpXSA9IGVsZW1lbnRzW2ldLnBhcmVudE5vZGVbdGhpcy5vcmlnaW4ub2Zmc2V0UG9zXTsgLy8gTm8gcGFkZGluZ3MgZm9yIHBhcmVudE5vZGVcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdW1tYXJ5IGVsZW1lbnRzIGhlaWdodCBhYm92ZSBjdXJyZW50XG4gICAgICAgICAgICAgICAgICAgIHRvcEZpeEhlaWdodHNbaV0gPSAodG9wRml4SGVpZ2h0c1tpIC0gMV0gfHwgMCk7IC8vIE5vdCB6ZXJvIGJlY2F1c2Ugb2YgbmVnYXRpdmUgbWFyZ2luc1xuICAgICAgICAgICAgICAgICAgICB0b3BSZWFsSGVpZ2h0c1tpXSA9ICh0b3BSZWFsSGVpZ2h0c1tpIC0gMV0gfHwgTWF0aC5taW4oaGVhZGVyVG9wc1tpXSwgMCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50c1tpIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcEZpeEhlaWdodHNbaV0gKz0gZWxlbWVudHNbaSAtIDFdW3RoaXMub3JpZ2luLm9mZnNldF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BSZWFsSGVpZ2h0c1tpXSArPSBlbGVtZW50c1tpIC0gMV1bdGhpcy5vcmlnaW4ub2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIShpID09IDAgJiYgaGVhZGVyVG9wc1tpXSA9PSAwKS8qICYmIGZvcmNlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50KGVsZW1lbnRzW2ldLCAnbW91c2V3aGVlbCcsIGJ1YmJsZVdoZWVsLCAnb2ZmJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50KGVsZW1lbnRzW2ldLCAnbW91c2V3aGVlbCcsIGJ1YmJsZVdoZWVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGltaXRlciAmJiBlbGVtZW50c1swXSkgeyAvLyBCb3R0b20gZWRnZSBvZiBmaXJzdCBoZWFkZXIgYXMgdG9wIGxpbWl0IGZvciB0cmFja1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFjayAmJiB0aGlzLnRyYWNrICE9IHRoaXMuc2Nyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zW3RoaXMub3JpZ2luLnBvc10gPSBlbGVtZW50c1swXS5wYXJlbnROb2RlW3RoaXMub3JpZ2luLm9mZnNldF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiQodGhpcy50cmFjaykuY3NzKHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJhclRvcExpbWl0ID0gZWxlbWVudHNbMF0ucGFyZW50Tm9kZVt0aGlzLm9yaWdpbi5vZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuYmFyVG9wTGltaXQgPSBlbGVtZW50c1swXS5wYXJlbnROb2RlW3RoaXMub3JpZ2luLm9mZnNldF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5saW1pdGVyID09PSBmYWxzZSkgeyAvLyB1bmRlZmluZWQgKGluIHNlY29uZCBmaXggaW5zdGFuY2UpIHNob3VsZCBoYXZlIG5vIGluZmx1ZW5jZSBvbiBiYXIgbGltaXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXJUb3BMaW1pdCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudHMsXG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICQodGhpcylbMF0ucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IHBhcmVudC5vZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBudW07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZGluZyBudW0gLT4gZWxlbWVudHNbbnVtXSA9PT0gdGhpc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBlbGVtZW50cy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHNbaV0gPT09IHRoaXMpIG51bSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gdG9wIC0gdG9wRml4SGVpZ2h0c1tudW1dO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuc2Nyb2xsKSB7IC8vIFVzZXIgZGVmaW5lZCBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnNjcm9sbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDE6IHNlbGYuc2Nyb2xsZXIuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyOiBwb3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxlci5zY3JvbGxUb3AgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NsaWNrJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtcy5jbGlja2FibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXJzLnB1c2goZXZlbnQpOyAvLyBGb3IgYXV0by1kaXNwb3NlXG4gICAgICAgICAgICAgICAgZXZlbnRNYW5hZ2VyKGV2ZW50LmVsZW1lbnQsIGV2ZW50LnR5cGUsIGV2ZW50LmhhbmRsZXIsICdvZmYnKTtcbiAgICAgICAgICAgICAgICBldmVudE1hbmFnZXIoZXZlbnQuZWxlbWVudCwgZXZlbnQudHlwZSwgZXZlbnQuaGFuZGxlciwgJ29uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uKCdpbml0JywgaW5pdCwgdXNlclBhcmFtcyk7XG5cbiAgICAgICAgdGhpcy5vbignaW5pdCBzY3JvbGwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmaXhTdGF0ZSwgaFRvcCxcbiAgICAgICAgICAgICAgICBmaXhGbGFnID0gW107IC8vIDEgLSBwYXN0LCAyIC0gZnV0dXJlLCAzIC0gY3VycmVudCAobm90IGZpeGVkKVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlO1xuXG4gICAgICAgICAgICAgICAgLy8gZml4RmxhZyB1cGRhdGVcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBlbGVtZW50cy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZml4U3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyVG9wc1tpXSAtIHRoaXMucG9zKCkgPCB0b3BSZWFsSGVpZ2h0c1tpXSArIHBhcmFtcy5yYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhlYWRlciB0cnlpbmcgdG8gZ28gdXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpeFN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhUb3AgPSB0b3BGaXhIZWlnaHRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhlYWRlclRvcHNbaV0gLSB0aGlzLnBvcygpID4gdG9wUmVhbEhlaWdodHNbaV0gKyB2aWV3UG9ydFNpemUgLSBwYXJhbXMucmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIZWFkZXIgdHJ5aW5nIHRvIGdvIGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpeFN0YXRlID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhUb3AgPSB0b3BGaXhIZWlnaHRzW2ldICsgdmlld1BvcnRTaXplO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGVhZGVyIGluIHZpZXdwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXhTdGF0ZSA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICBoVG9wID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXhTdGF0ZSAhPSBmaXhGbGFnW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXhFbGVtZW50LmNhbGwodGhpcywgaSwgaFRvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXhGbGFnW2ldID0gZml4U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkaW5nIHBvc2l0aW9uaW5nIGNsYXNzZXMgKG9uIGxhc3QgdG9wIGFuZCBmaXJzdCBib3R0b20gaGVhZGVyKVxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UpIHsgLy8gQXQgbGVhdHMgb25lIGNoYW5nZSBpbiBlbGVtZW50cyBmbGFnIHN0cnVjdHVyZSBvY2N1cmVkXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAgOyBpIDwgZWxlbWVudHMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZml4RmxhZ1tpXSA9PSAxICYmIHBhcmFtcy5wYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kKGVsZW1lbnRzW2ldKS5hZGRDbGFzcyhwYXJhbXMucGFzdCkucmVtb3ZlQ2xhc3MocGFyYW1zLmZ1dHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXhGbGFnW2ldID09IDIgJiYgcGFyYW1zLmZ1dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJChlbGVtZW50c1tpXSkuYWRkQ2xhc3MocGFyYW1zLmZ1dHVyZSkucmVtb3ZlQ2xhc3MocGFyYW1zLnBhc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZml4RmxhZ1tpXSA9PSAzICYmIChwYXJhbXMuZnV0dXJlIHx8IHBhcmFtcy5wYXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJChlbGVtZW50c1tpXSkucmVtb3ZlQ2xhc3MocGFyYW1zLnBhc3QpLnJlbW92ZUNsYXNzKHBhcmFtcy5mdXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZml4RmxhZ1tpXSAhPSBmaXhGbGFnW2kgKyAxXSAmJiBmaXhGbGFnW2ldID09IDEgJiYgcGFyYW1zLmJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJChlbGVtZW50c1tpXSkuYWRkQ2xhc3MocGFyYW1zLmJlZm9yZSkucmVtb3ZlQ2xhc3MocGFyYW1zLmFmdGVyKTsgLy8gTGFzdCB0b3AgZml4ZWQgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpeEZsYWdbaV0gIT0gZml4RmxhZ1tpIC0gMV0gJiYgZml4RmxhZ1tpXSA9PSAyICYmIHBhcmFtcy5hZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJChlbGVtZW50c1tpXSkuYWRkQ2xhc3MocGFyYW1zLmFmdGVyKS5yZW1vdmVDbGFzcyhwYXJhbXMuYmVmb3JlKTsgLy8gRmlyc3QgYm90dG9tIGZpeGVkIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiQoZWxlbWVudHNbaV0pLnJlbW92ZUNsYXNzKHBhcmFtcy5iZWZvcmUpLnJlbW92ZUNsYXNzKHBhcmFtcy5hZnRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMub24oJ3Jlc2l6ZSB1cGQnLCBmdW5jdGlvbih1cGRQYXJhbXMpIHtcbiAgICAgICAgICAgIGluaXQuY2FsbCh0aGlzLCB1cGRQYXJhbXMgJiYgdXBkUGFyYW1zLmZpeCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBiYXJvbi5mbi5maXggPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIHdoaWxlICh0aGlzW2ldKSB7XG4gICAgICAgICAgICBmaXguY2FsbCh0aGlzW2ldLCBwYXJhbXMpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBjb250cm9scyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgZm9yd2FyZCwgYmFja3dhcmQsIHRyYWNrLCBzY3JlZW4sXG4gICAgICAgICAgICBzZWxmID0gdGhpczsgLy8gQUFBQUFBISEhISExMVxuXG4gICAgICAgIHNjcmVlbiA9IHBhcmFtcy5zY3JlZW4gfHwgMC45O1xuXG4gICAgICAgIGlmIChwYXJhbXMuZm9yd2FyZCkge1xuICAgICAgICAgICAgZm9yd2FyZCA9IHRoaXMuJChwYXJhbXMuZm9yd2FyZCwgdGhpcy5jbGlwcGVyKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudChmb3J3YXJkLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHNlbGYucG9zKCkgLSBwYXJhbXMuZGVsdGEgfHwgMzA7XG5cbiAgICAgICAgICAgICAgICBzZWxmLnBvcyh5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5iYWNrd2FyZCkge1xuICAgICAgICAgICAgYmFja3dhcmQgPSB0aGlzLiQocGFyYW1zLmJhY2t3YXJkLCB0aGlzLmNsaXBwZXIpO1xuXG4gICAgICAgICAgICB0aGlzLmV2ZW50KGJhY2t3YXJkLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHNlbGYucG9zKCkgKyBwYXJhbXMuZGVsdGEgfHwgMzA7XG5cbiAgICAgICAgICAgICAgICBzZWxmLnBvcyh5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy50cmFjaykge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy50cmFjayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRyYWNrID0gdGhpcy50cmFjaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhY2sgPSB0aGlzLiQocGFyYW1zLnRyYWNrLCB0aGlzLmNsaXBwZXIpWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50KHRyYWNrLCAnbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGVbJ29mZnNldCcgKyBzZWxmLm9yaWdpbi54XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhCYXIgPSBzZWxmLmJhcltzZWxmLm9yaWdpbi5vZmZzZXRQb3NdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbiA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPCB4QmFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeCA+IHhCYXIgKyBzZWxmLmJhcltzZWxmLm9yaWdpbi5vZmZzZXRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gc2VsZi5wb3MoKSArIHNpZ24gKiBzY3JlZW4gKiBzZWxmLnNjcm9sbGVyW3NlbGYub3JpZ2luLmNsaWVudF07XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucG9zKHkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgYmFyb24uZm4uY29udHJvbHMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIHdoaWxlICh0aGlzW2ldKSB7XG4gICAgICAgICAgICBjb250cm9scy5jYWxsKHRoaXNbaV0sIHBhcmFtcyk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdmFyIHB1bGwgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGJsb2NrID0gdGhpcy4kKHBhcmFtcy5ibG9jayksXG4gICAgICAgICAgICBzaXplID0gcGFyYW1zLnNpemUgfHwgdGhpcy5vcmlnaW4uc2l6ZSxcbiAgICAgICAgICAgIGxpbWl0ID0gcGFyYW1zLmxpbWl0IHx8IDgwLFxuICAgICAgICAgICAgb25FeHBhbmQgPSBwYXJhbXMub25FeHBhbmQsXG4gICAgICAgICAgICBlbGVtZW50cyA9IHBhcmFtcy5lbGVtZW50cyB8fCBbXSxcbiAgICAgICAgICAgIGluUHJvZ3Jlc3MgPSBwYXJhbXMuaW5Qcm9ncmVzcyB8fCAnJyxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgX2luc2lzdGVuY2UgPSAwLFxuICAgICAgICAgICAgX3plcm9YQ291bnQgPSAwLFxuICAgICAgICAgICAgX2ludGVydmFsLFxuICAgICAgICAgICAgX3RpbWVyLFxuICAgICAgICAgICAgX3ggPSAwLFxuICAgICAgICAgICAgX29uRXhwYW5kQ2FsbGVkLFxuICAgICAgICAgICAgX3dhaXRpbmcgPSBwYXJhbXMud2FpdGluZyB8fCA1MDAsXG4gICAgICAgICAgICBfb247XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0U2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnNjcm9sbGVyW3NlbGYub3JpZ2luLnNjcm9sbF0gKyBzZWxmLnNjcm9sbGVyW3NlbGYub3JpZ2luLm9mZnNldF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTY3JvbGxlciBjb250ZW50IGhlaWdodFxuICAgICAgICBmdW5jdGlvbiBnZXRDb250ZW50U2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnNjcm9sbGVyW3NlbGYub3JpZ2luLnNjcm9sbFNpemVdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2Nyb2xsZXIgaGVpZ2h0XG4gICAgICAgIGZ1bmN0aW9uIGdldFNjcm9sbGVyU2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnNjcm9sbGVyW3NlbGYub3JpZ2luLmNsaWVudF07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzdGVwKHgsIGZvcmNlKSB7XG4gICAgICAgICAgICB2YXIgayA9IHggKiAwLjAwMDU7XG5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKGZvcmNlIC0gayAqICh4ICsgNTUwKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0b2dnbGUob24pIHtcbiAgICAgICAgICAgIF9vbiA9IG9uO1xuXG4gICAgICAgICAgICBpZiAob24pIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUoKTsgLy8gRmlyc3QgdGltZSB3aXRoIG5vIGRlbGF5XG4gICAgICAgICAgICAgICAgX2ludGVydmFsID0gc2V0SW50ZXJ2YWwodXBkYXRlLCAyMDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKF9pbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0ge30sXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gZ2V0U2l6ZSgpLFxuICAgICAgICAgICAgICAgIHNjcm9sbEhlaWdodCA9IGdldENvbnRlbnRTaXplKCksXG4gICAgICAgICAgICAgICAgZHgsXG4gICAgICAgICAgICAgICAgb3A0LFxuICAgICAgICAgICAgICAgIHNjcm9sbEluUHJvZ3Jlc3MgPSBfaW5zaXN0ZW5jZSA9PSAxO1xuXG4gICAgICAgICAgICBvcDQgPSAwOyAvLyDQktC+0LfQstGA0LDRidCw0Y7RidCw0Y8g0YHQuNC70LBcbiAgICAgICAgICAgIGlmIChfaW5zaXN0ZW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICBvcDQgPSA0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaWYgKF9pbnNpc3RlbmNlID4gLTEpIHtcbiAgICAgICAgICAgICAgICBkeCA9IHN0ZXAoX3gsIG9wNCk7XG4gICAgICAgICAgICAgICAgaWYgKGhlaWdodCA+PSBzY3JvbGxIZWlnaHQgLSBfeCAmJiBfaW5zaXN0ZW5jZSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfeCArPSBkeDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF94ID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX3ggPCAwKSBfeCA9IDA7XG5cbiAgICAgICAgICAgICAgICBwb3Nbc2l6ZV0gPSBfeCArICdweCc7XG4gICAgICAgICAgICAgICAgaWYgKGdldFNjcm9sbGVyU2l6ZSgpIDw9IGdldENvbnRlbnRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi4kKGJsb2NrKS5jc3MocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgZWxlbWVudHMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLiQoZWxlbWVudHNbaV0uc2VsZikuY3NzKGVsZW1lbnRzW2ldLnByb3BlcnR5LCBNYXRoLm1pbihfeCAvIGxpbWl0ICogMTAwLCAxMDApICsgJyUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpblByb2dyZXNzICYmIF94KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuJChzZWxmLnJvb3QpLmFkZENsYXNzKGluUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfeCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMub25Db2xsYXBzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLm9uQ29sbGFwc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9pbnNpc3RlbmNlID0gMDtcbiAgICAgICAgICAgICAgICBfdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBfaW5zaXN0ZW5jZSA9IC0xO1xuICAgICAgICAgICAgICAgIH0sIF93YWl0aW5nKTtcbiAgICAgICAgICAgIC8vfVxuXG4gICAgICAgICAgICBpZiAob25FeHBhbmQgJiYgX3ggPiBsaW1pdCAmJiAhX29uRXhwYW5kQ2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgb25FeHBhbmQoKTtcbiAgICAgICAgICAgICAgICBfb25FeHBhbmRDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoX3ggPT0gMCkge1xuICAgICAgICAgICAgICAgIF96ZXJvWENvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF96ZXJvWENvdW50ID0gMDtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF96ZXJvWENvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgIHRvZ2dsZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgX29uRXhwYW5kQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi4kKHNlbGYucm9vdCkucmVtb3ZlQ2xhc3MoaW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbignaW5pdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdG9nZ2xlKHRydWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0b2dnbGUoZmFsc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmV2ZW50KHRoaXMuc2Nyb2xsZXIsICdtb3VzZXdoZWVsIERPTU1vdXNlU2Nyb2xsJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIGRvd24gPSBlLndoZWVsRGVsdGEgPCAwIHx8IChlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LndoZWVsRGVsdGEgPCAwKSB8fCBlLmRldGFpbCA+IDA7XG5cbiAgICAgICAgICAgIGlmIChkb3duKSB7XG4gICAgICAgICAgICAgICAgX2luc2lzdGVuY2UgPSAxO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGltZXIpO1xuICAgICAgICAgICAgICAgIGlmICghX29uICYmIGdldFNpemUoKSA+PSBnZXRDb250ZW50U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAgZWxzZSB7XG4gICAgICAgICAgICAvLyAgICAgdG9nZ2xlKGZhbHNlKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGJhcm9uLmZuLnB1bGwgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIHdoaWxlICh0aGlzW2ldKSB7XG4gICAgICAgICAgICBwdWxsLmNhbGwodGhpc1tpXSwgcGFyYW1zKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59KSh3aW5kb3cpO1xuIl19
},{"process":"C:\\Users\\Алексей\\AppData\\Roaming\\npm\\node_modules\\parcel-bundler\\node_modules\\process\\browser.js"}],"js\\main.js":[function(require,module,exports) {
var DG = require('2gis-maps');

var controlPanelLoadingText = document.querySelector('.control-panel-box__loading-text');
var controlPanelSwitcherButton = document.querySelector('.control-panel-box__switcher-button');
var controlPanelSelect = document.querySelector('.control-panel-box__form-select');
var controlPanelLogo = document.querySelector('.control-panel-box__logo');
var mapBoxYandex = document.getElementById('map-1');
var mapBox2gis = document.getElementById('map-2');

var dataM24 = void 0;
var displaySwitcher = false;

controlPanelSwitcherButton.addEventListener('click', function () {
    if (!displaySwitcher) {
        mapBox2gis.style.visibility = 'visible';
        controlPanelSelect.setAttribute('disabled', true);
        controlPanelSelect.style.cursor = 'not-allowed';
        mapBoxYandex.style.display = 'none';
        mapBox2gis.style.display = 'block';
        controlPanelLogo.src = 'https://upload.wikimedia.org/wikipedia/commons/c/c1/2GIS_logo.svg';
        displaySwitcher = true;
        return;
    } else if (displaySwitcher) {
        mapBox2gis.style.visibility = 'hidden';
        controlPanelSelect.removeAttribute('disabled');
        controlPanelSelect.style.cursor = '';
        mapBoxYandex.style.display = 'block';
        mapBox2gis.style.display = 'none';
        controlPanelLogo.src = 'https://upload.wikimedia.org/wikipedia/commons/9/91/Yandex_logo_en.svg';
        displaySwitcher = false;
    }
});

ymaps.ready(init);

function init() {

    var myMap = new ymaps.Map("map-1", {
        center: [55.76, 37.64],
        zoom: 12
    });

    fetch('https://raw.githubusercontent.com/ProUnebit/Reminder_ToMe_Reminder/master/src/data.json').then(function (res) {
        controlPanelLoadingText.textContent = 'Обработка данных... ⏳';
        return res.json();
    }).then(function (data) {
        dataM24 = data;
        showMapPointsYandex(data, 'orange');
        return data;
    }).then(function (data) {
        controlPanelLoadingText.textContent = 'Yandex карта загружена ✔️';
        showMapPoints2gis(data);
    }).catch(function (err) {
        return console.error(err);
    });

    var showMapPointsYandex = function showMapPointsYandex(dataM24, color) {

        var myGeoObjects = new ymaps.GeoObjectCollection({}, {
            preset: 'islands#' + color + 'CircleIcon',
            strokeWidth: 4,
            geodesic: true
        });

        dataM24.map(function (district) {
            return district.points.map(function (point) {
                myGeoObjects.add(new ymaps.Placemark([point.address.lon, point.address.lat], {
                    hintContent: '<div class="hintContent">\n                <span>' + district.header + '</span>\n                </div>',
                    balloonContent: '<div class="balloonContent">\n                <p>' + district.header + '</p>\n                <p>' + point.address.address + '</p>\n                </div>'
                }));
            });
        });

        myMap.geoObjects.add(myGeoObjects);
    };

    var showMapPoints2gis = function showMapPoints2gis(dataM24) {

        DG.then(function () {

            var map = void 0,
                markers = DG.featureGroup(),
                coordinates = [],
                myIcon = DG.icon({
                iconUrl: 'https://mbtskoudsalg.com/images/map-marker-icons-png-3.png',
                iconSize: [26, 30]
            });

            map = DG.map('map-2', {
                center: [55.76, 37.64],
                zoom: 12,
                skin: 'light'
            });

            dataM24.map(function (district) {
                for (var i = 0; i < district.points.length; i++) {
                    coordinates[0] = district.points[i].address.lon;
                    coordinates[1] = district.points[i].address.lat;
                    DG.marker(coordinates, {
                        icon: myIcon,
                        label: '\n                     <div class="hintContent">\n                        <span style="font-size: 17px">' + district.header + '</span>\n                     </div>'
                    }).addTo(markers).bindPopup('\n                        <di class="balloonContent">\n                        <p style="margin-bottom: 5px;">' + district.header + '</p>\n                        <p style="color: rgba(248, 194, 85, 1)">' + district.points[i].address.address + '</p>\n                        </di>');
                }
            });

            markers.addTo(map);

            setTimeout(function () {
                return controlPanelLoadingText.textContent = '2GIS карта загружена ✔️';
            }, 1200);
            setTimeout(function () {
                return controlPanelLoadingText.textContent = 'Карты готовы 👌';
            }, 1800);
        });
    };

    controlPanelSelect.addEventListener('change', function (e) {
        if (e.target.value === 'Все') {
            myMap.geoObjects.removeAll();
            showMapPointsYandex(dataM24, 'orange');
        } else {
            var separatedTargetDistrict = dataM24.filter(function (district) {
                return district.header === e.target.value;
            });
            myMap.geoObjects.removeAll();
            showMapPointsYandex(separatedTargetDistrict, 'violet');
        }
    });
}
},{"2gis-maps":"node_modules\\2gis-maps\\dist\\js\\script.full.js"}],"C:\\Users\\Алексей\\AppData\\Roaming\\npm\\node_modules\\parcel-bundler\\src\\builtins\\hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';

var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };

  module.bundle.hotData = null;
}

module.bundle.Module = Module;

var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = '' || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + '17326' + '/');
  ws.onmessage = function (event) {
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      console.clear();

      data.assets.forEach(function (asset) {
        hmrApply(global.parcelRequire, asset);
      });

      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          hmrAccept(global.parcelRequire, asset.id);
        }
      });
    }

    if (data.type === 'reload') {
      ws.close();
      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');

      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);

      removeErrorOverlay();

      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;

  // html encode message and stack trace
  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;

  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';

  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAccept(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAccept(bundle.parent, id);
  }

  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);

  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAccept(global.parcelRequire, id);
  });
}
},{}]},{},["C:\\Users\\Алексей\\AppData\\Roaming\\npm\\node_modules\\parcel-bundler\\src\\builtins\\hmr-runtime.js","js\\main.js"], null)
//# sourceMappingURL=/main.ee847ad5.map